{
  "name": "serde::__private::de::content::__private::de::content::EnumDeserializer<'de, E>::new",
  "name_with_impl": "serde::__private::de::content::{impl#18}::new",
  "mod_info": {
    "name": "__private::de::content",
    "loc": "serde/src/private/de.rs:198:1:2358:2"
  },
  "visible": true,
  "loc": "serde/src/private/de.rs:1537:9:1543:10",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: EnumDeserializer {\n                variant,\n                value,\n                err: PhantomData,\n            }\n"
      ],
      "input_infer": "variant: {Bool(true), U8(0-255), U16(0-65535), U32(0-4294967295), U64(0-18446744073709551615), I8(-128 to 127), I16(-32768 to 32767), I32(-2147483648 to 2147483647), I64(-9223372036854775808 to 9223372036854775807), F32(-3.40282347E+38 to 3.40282347E+38), F64(-1.7976931348623157E+308 to 1.7976931348623157E+308), Char('\\u{0}' to '\\u{10FFFF}'), String(length 0 to 65535), None, Some(Box<Content>), Unit, UnitStruct({'static str}), NewtypeStruct({'static str'}, Box<Content>), NewtypeVariant({'static str'}, u32, {'static str'}, Box<Content>), Seq(Vec<Content>), Tuple(Vec<Content>), TupleStruct({'static str'}, Vec<Content>), TupleVariant({'static str'}, u32, {'static str'}, Vec<Content>), Map(Vec<(Content, Content)>), Struct({'static str'}, Vec<(&'static str, Content)>), StructVariant({'static str'}, u32, {'static str'}, Vec<(&'static str, Content)>)}, value: {None, Some(Bool(true)), Some(U8(0-255)), Some(U16(0-65535)), Some(U32(0-4294967295)), Some(U64(0-18446744073709551615)), Some(I8(-128 to 127)), Some(I16(-32768 to 32767)), Some(I32(-2147483648 to 2147483647)), Some(I64(-9223372036854775808 to 9223372036854775807)), Some(F32(-3.40282347E+38 to 3.40282347E+38)), Some(F64(-1.7976931348623157E+308 to 1.7976931348623157E+308)), Some(Char('\\u{0}' to '\\u{10FFFF}')), Some(String(length 0 to 65535)), Some(Seq(Vec<Content>)), Some(Tuple(Vec<Content>)), Some(Map(Vec<(Content, Content)>)), Some(Struct({'static str'}, Vec<(&'static str, Content)>))}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::Bool(true);",
                "    let value = Some(Content::Bool(false));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Bool(true));"
                ],
                [
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Bool(false)));"
                ],
                [
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::ptr::eq(&deserializer.err, &PhantomData));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Bool(true));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Bool(false)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Bool(true);",
                  "    let value = Some(Content::Bool(false));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::ptr::eq(&deserializer.err, &PhantomData));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::Bool(true));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::Bool(false)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0283]: type annotations needed for `__private::de::content::EnumDeserializer<'_, _>`\n    --> serde/src/private/de.rs:2371:9\n     |\n2371 |     let deserializer = EnumDeserializer::new(variant, value);\n     |         ^^^^^^^^^^^^   ------------------------------------- type must be known at this point\n     |\n     = note: cannot satisfy `_: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer::<'de, E>::new`\n    --> serde/src/private/de.rs:1535:12\n     |\n1535 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer::<'de, E>::new`\n1536 |     {\n1537 |         pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n     |                --- required by a bound in this associated function\nhelp: consider giving `deserializer` an explicit type, where the type for type parameter `E` is specified\n     |\n2371 |     let deserializer: __private::de::content::EnumDeserializer<'_, E> = EnumDeserializer::new(variant, value);\n     |                     +++++++++++++++++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::U8(255);",
                "    let value = Some(Content::U8(128));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::U8(255));"
                ],
                [
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::U8(128)));"
                ],
                [
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of_val(&deserializer) > 0);"
                ],
                [
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::ptr::addr_of!(deserializer) != std::ptr::null());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::U8(255));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::U8(128)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of_val(&deserializer) > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U8(255);",
                  "    let value = Some(Content::U8(128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::ptr::addr_of!(deserializer) != std::ptr::null());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::U8(255));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::U8(128)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0283]: type annotations needed for `__private::de::content::EnumDeserializer<'_, _>`\n    --> serde/src/private/de.rs:2371:9\n     |\n2371 |     let deserializer = EnumDeserializer::new(variant, value);\n     |         ^^^^^^^^^^^^   ------------------------------------- type must be known at this point\n     |\n     = note: cannot satisfy `_: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer::<'de, E>::new`\n    --> serde/src/private/de.rs:1535:12\n     |\n1535 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer::<'de, E>::new`\n1536 |     {\n1537 |         pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n     |                --- required by a bound in this associated function\nhelp: consider giving `deserializer` an explicit type, where the type for type parameter `E` is specified\n     |\n2371 |     let deserializer: __private::de::content::EnumDeserializer<'_, E> = EnumDeserializer::new(variant, value);\n     |                     +++++++++++++++++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0283]: type annotations needed for `__private::de::content::EnumDeserializer<'_, _>`\n    --> serde/src/private/de.rs:2371:9\n     |\n2371 |     let deserializer = EnumDeserializer::new(variant, value);\n     |         ^^^^^^^^^^^^   ------------------------------------- type must be known at this point\n     |\n     = note: cannot satisfy `_: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer::<'de, E>::new`\n    --> serde/src/private/de.rs:1535:12\n     |\n1535 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer::<'de, E>::new`\n1536 |     {\n1537 |         pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n     |                --- required by a bound in this associated function\nhelp: consider giving `deserializer` an explicit type, where the type for type parameter `E` is specified\n     |\n2371 |     let deserializer: __private::de::content::EnumDeserializer<'_, E> = EnumDeserializer::new(variant, value);\n     |                     +++++++++++++++++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::U16(65535);",
                "    let value = Some(Content::U16(32768));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::U16(65535));"
                ],
                [
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::U16(32768)));"
                ],
                [
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<_>>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::U16(65535));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::U16(32768)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U16(65535);",
                  "    let value = Some(Content::U16(32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<_>>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::U16(65535));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::U16(32768)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no method named `is` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<_>>());\n     |                              ^^ method not found in `PhantomData<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::U32(4294967295);",
                "    let value = Some(Content::U32(2147483647));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);"
                ],
                [
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);"
                ],
                [
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U32(4294967295);",
                  "    let value = Some(Content::U32(2147483647));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, variant);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0412]: cannot find type `E` in this scope\n    --> serde/src/private/de.rs:2375:47\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                                               ^ help: a trait with a similar name exists: `Eq`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:328:1\n     |\n     = note: similarly named trait `Eq` defined here\n\nerror[E0599]: no method named `is` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                              ^^ method not found in `PhantomData<_>`\n\nSome errors have detailed explanations: E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `serde` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::U64(18446744073709551615);",
                "    let value = Some(Content::U64(9223372036854775807));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::U64(18446744073709551615));"
                ],
                [
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::U64(9223372036854775807)));"
                ],
                [
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of::<EnumDeserializer<()>>() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::U64(18446744073709551615));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::U64(9223372036854775807)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::U64(18446744073709551615);",
                  "    let value = Some(Content::U64(9223372036854775807));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of::<EnumDeserializer<()>>() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::U64(18446744073709551615));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::U64(9223372036854775807)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0277]: the trait bound `(): de::Error` is not satisfied\n    --> serde/src/private/de.rs:2375:33\n     |\n2375 |     assert!(std::mem::size_of::<EnumDeserializer<()>>() > 0);\n     |                                 ^^^^^^^^^^^^^^^^^^^^ the trait `de::Error` is not implemented for `()`\n     |\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer`\n    --> serde/src/private/de.rs:1526:12\n     |\n1524 |     pub struct EnumDeserializer<'de, E>\n     |                ---------------- required by a bound in this struct\n1525 |     where\n1526 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::I8(127);",
                "    let value = Some(Content::I8(-128));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::I8(127));"
                ],
                [
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::I8(-128)));"
                ],
                [
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of::<PhantomData<()>>() > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::I8(127));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::I8(-128)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I8(127);",
                  "    let value = Some(Content::I8(-128));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of::<PhantomData<()>>() > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::I8(127));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::I8(-128)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0283]: type annotations needed for `__private::de::content::EnumDeserializer<'_, _>`\n    --> serde/src/private/de.rs:2371:9\n     |\n2371 |     let deserializer = EnumDeserializer::new(variant, value);\n     |         ^^^^^^^^^^^^   ------------------------------------- type must be known at this point\n     |\n     = note: cannot satisfy `_: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer::<'de, E>::new`\n    --> serde/src/private/de.rs:1535:12\n     |\n1535 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer::<'de, E>::new`\n1536 |     {\n1537 |         pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n     |                --- required by a bound in this associated function\nhelp: consider giving `deserializer` an explicit type, where the type for type parameter `E` is specified\n     |\n2371 |     let deserializer: __private::de::content::EnumDeserializer<'_, E> = EnumDeserializer::new(variant, value);\n     |                     +++++++++++++++++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::I16(32767);",
                "    let value = Some(Content::I16(-32768));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::I16(32767));"
                ],
                [
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::I16(-32768)));"
                ],
                [
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::I16(32767));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::I16(-32768)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I16(32767);",
                  "    let value = Some(Content::I16(-32768));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::I16(32767));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::I16(-32768)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no method named `is_err` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is_err());\n     |                              ^^^^^^ method not found in `PhantomData<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::I32(2147483647);",
                "    let value = Some(Content::I32(-2147483648));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::I32(2147483647));"
                ],
                [
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::I32(-2147483648)));"
                ],
                [
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of_val(&deserializer.err) > 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::I32(2147483647));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::I32(-2147483648)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I32(2147483647);",
                  "    let value = Some(Content::I32(-2147483648));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::mem::size_of_val(&deserializer.err) > 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::I32(2147483647));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::I32(-2147483648)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0283]: type annotations needed for `__private::de::content::EnumDeserializer<'_, _>`\n    --> serde/src/private/de.rs:2371:9\n     |\n2371 |     let deserializer = EnumDeserializer::new(variant, value);\n     |         ^^^^^^^^^^^^   ------------------------------------- type must be known at this point\n     |\n     = note: cannot satisfy `_: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer::<'de, E>::new`\n    --> serde/src/private/de.rs:1535:12\n     |\n1535 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer::<'de, E>::new`\n1536 |     {\n1537 |         pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n     |                --- required by a bound in this associated function\nhelp: consider giving `deserializer` an explicit type, where the type for type parameter `E` is specified\n     |\n2371 |     let deserializer: __private::de::content::EnumDeserializer<'_, E> = EnumDeserializer::new(variant, value);\n     |                     +++++++++++++++++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::I64(9223372036854775807);",
                "    let value = Some(Content::I64(-9223372036854775808));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);"
                ],
                [
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);"
                ],
                [
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::I64(9223372036854775807);",
                  "    let value = Some(Content::I64(-9223372036854775808));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, variant);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0412]: cannot find type `E` in this scope\n    --> serde/src/private/de.rs:2375:47\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                                               ^ help: a trait with a similar name exists: `Eq`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:328:1\n     |\n     = note: similarly named trait `Eq` defined here\n\nerror[E0599]: no method named `is` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                              ^^ method not found in `PhantomData<_>`\n\nSome errors have detailed explanations: E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `serde` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::F32(3.40282347E+38);",
                "    let value = Some(Content::F32(-3.40282347E+38));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::F32(3.40282347E+38));"
                ],
                [
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::F32(-3.40282347E+38)));"
                ],
                [
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::F32(3.40282347E+38));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::F32(-3.40282347E+38)));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::F32(3.40282347E+38);",
                  "    let value = Some(Content::F32(-3.40282347E+38));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::F32(3.40282347E+38));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::F32(-3.40282347E+38)));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no method named `is_err` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is_err());\n     |                              ^^^^^^ method not found in `PhantomData<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::F64(1.7976931348623157E+308);",
                "    let value = Some(Content::F64(-1.7976931348623157E+308));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_variant = Content::F64(1.7976931348623157E+308);",
                  "    let expected_value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let expected_err_type = PhantomData::<E>;",
                  "    assert_eq!(deserializer.variant, expected_variant);"
                ],
                [
                  "    let expected_variant = Content::F64(1.7976931348623157E+308);",
                  "    let expected_value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let expected_err_type = PhantomData::<E>;",
                  "    assert_eq!(deserializer.value, expected_value);"
                ],
                [
                  "    let expected_variant = Content::F64(1.7976931348623157E+308);",
                  "    let expected_value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let expected_err_type = PhantomData::<E>;",
                  "    assert_eq!(deserializer.err, expected_err_type);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::F64(1.7976931348623157E+308);",
                  "    let value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let expected_variant = Content::F64(1.7976931348623157E+308);",
                  "    let expected_value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let expected_err_type = PhantomData::<E>;",
                  "    assert_eq!(deserializer.variant, expected_variant);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::F64(1.7976931348623157E+308);",
                  "    let value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let expected_variant = Content::F64(1.7976931348623157E+308);",
                  "    let expected_value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let expected_err_type = PhantomData::<E>;",
                  "    assert_eq!(deserializer.value, expected_value);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::F64(1.7976931348623157E+308);",
                  "    let value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let expected_variant = Content::F64(1.7976931348623157E+308);",
                  "    let expected_value = Some(Content::F64(-1.7976931348623157E+308));",
                  "    let expected_err_type = PhantomData::<E>;",
                  "    assert_eq!(deserializer.err, expected_err_type);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0412]: cannot find type `E` in this scope\n    --> serde/src/private/de.rs:2374:43\n     |\n2374 |     let expected_err_type = PhantomData::<E>;\n     |                                           ^ help: a trait with a similar name exists: `Eq`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:328:1\n     |\n     = note: similarly named trait `Eq` defined here\n\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, expected_variant);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nSome errors have detailed explanations: E0369, E0412.\nFor more information about an error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0412]: cannot find type `E` in this scope\n    --> serde/src/private/de.rs:2374:43\n     |\n2374 |     let expected_err_type = PhantomData::<E>;\n     |                                           ^ help: a trait with a similar name exists: `Eq`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:328:1\n     |\n     = note: similarly named trait `Eq` defined here\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, expected_value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nSome errors have detailed explanations: E0369, E0412.\nFor more information about an error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0412]: cannot find type `E` in this scope\n    --> serde/src/private/de.rs:2374:43\n     |\n2374 |     let expected_err_type = PhantomData::<E>;\n     |                                           ^ help: a trait with a similar name exists: `Eq`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:328:1\n     |\n     = note: similarly named trait `Eq` defined here\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::Char('\\u{10FFFF}');",
                "    let value = Some(Content::Char('\\u{0}'));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Char('\\u{10FFFF}'));"
                ],
                [
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Char('\\u{0}')));"
                ],
                [
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::ptr::eq(&deserializer.err, &PhantomData));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Char('\\u{10FFFF}'));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Char('\\u{0}')));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Char('\\u{10FFFF}');",
                  "    let value = Some(Content::Char('\\u{0}'));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(std::ptr::eq(&deserializer.err, &PhantomData));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::Char('\\u{10FFFF}'));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::Char('\\u{0}')));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0283]: type annotations needed for `__private::de::content::EnumDeserializer<'_, _>`\n    --> serde/src/private/de.rs:2371:9\n     |\n2371 |     let deserializer = EnumDeserializer::new(variant, value);\n     |         ^^^^^^^^^^^^   ------------------------------------- type must be known at this point\n     |\n     = note: cannot satisfy `_: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer::<'de, E>::new`\n    --> serde/src/private/de.rs:1535:12\n     |\n1535 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer::<'de, E>::new`\n1536 |     {\n1537 |         pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n     |                --- required by a bound in this associated function\nhelp: consider giving `deserializer` an explicit type, where the type for type parameter `E` is specified\n     |\n2371 |     let deserializer: __private::de::content::EnumDeserializer<'_, E> = EnumDeserializer::new(variant, value);\n     |                     +++++++++++++++++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::String(\"test\".to_string());",
                "    let value = Some(Content::String(\"value\".to_string()));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant.clone(), value.clone());",
                  "    assert_eq!(deserializer.variant, variant);"
                ],
                [
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant.clone(), value.clone());",
                  "    assert_eq!(deserializer.value, value);"
                ],
                [
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant.clone(), value.clone());",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant.clone(), value.clone());",
                  "    assert_eq!(deserializer.variant, variant);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant.clone(), value.clone());",
                  "    assert_eq!(deserializer.value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::String(\"test\".to_string());",
                  "    let value = Some(Content::String(\"value\".to_string()));",
                  "    let deserializer = EnumDeserializer::new(variant.clone(), value.clone());",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, variant);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0412]: cannot find type `E` in this scope\n    --> serde/src/private/de.rs:2375:47\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                                               ^ help: a trait with a similar name exists: `Eq`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:328:1\n     |\n     = note: similarly named trait `Eq` defined here\n\nerror[E0599]: no method named `is` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                              ^^ method not found in `PhantomData<_>`\n\nSome errors have detailed explanations: E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `serde` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::None;",
                "    let value = None;",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::None);"
                ],
                [
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, None);"
                ],
                [
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_some());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::None);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, None);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::None;",
                  "    let value = None;",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_some());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::None);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, None);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no method named `is_some` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is_some());\n     |                              ^^^^^^^ method not found in `PhantomData<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Some(Box::new(Content::Bool(true))));"
                ],
                [
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Some(Box::new(Content::U8(0)))));"
                ],
                [
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Some(Box::new(Content::Bool(true))));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Some(Box::new(Content::U8(0)))));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Some(Box::new(Content::Bool(true)));",
                  "    let value = Some(Content::Some(Box::new(Content::U8(0))));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<E>>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::Some(Box::new(Content::Bool(true))));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::Some(Box::new(Content::U8(0)))));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0412]: cannot find type `E` in this scope\n    --> serde/src/private/de.rs:2375:47\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                                               ^ help: a trait with a similar name exists: `Eq`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:328:1\n     |\n     = note: similarly named trait `Eq` defined here\n\nerror[E0599]: no method named `is` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<E>>());\n     |                              ^^ method not found in `PhantomData<_>`\n\nSome errors have detailed explanations: E0412, E0599.\nFor more information about an error, try `rustc --explain E0412`.\nerror: could not compile `serde` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::Unit;",
                "    let value = Some(Content::Unit);",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);"
                ],
                [
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);"
                ],
                [
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<>()>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Unit;",
                  "    let value = Some(Content::Unit);",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is::<PhantomData<>()>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, variant);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror: expected one of `,` or `>`, found `(`\n    --> serde/src/private/de.rs:2375:48\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<>()>());\n     |                                                ^ expected one of `,` or `>`\n     |\nhelp: expressions must be enclosed in braces to be used as const generic arguments\n     |\n2375 |     assert!(deserializer.err.is::<{ PhantomData<>() }>());\n     |                                   +                 +\n\nerror[E0599]: no method named `is` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is::<PhantomData<>()>());\n     |                              ^^ method not found in `PhantomData<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Seq(vec![Content::U8(1), Content::U8(2)]));"
                ],
                [
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Seq(vec![Content::U8(3)])));"
                ],
                [
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_phantom());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, Content::Seq(vec![Content::U8(1), Content::U8(2)]));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, Some(Content::Seq(vec![Content::U8(3)])));",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Seq(vec![Content::U8(1), Content::U8(2)]);",
                  "    let value = Some(Content::Seq(vec![Content::U8(3)]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(deserializer.err.is_phantom());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, Content::Seq(vec![Content::U8(1), Content::U8(2)]));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, Some(Content::Seq(vec![Content::U8(3)])));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no method named `is_phantom` found for struct `std::marker::PhantomData` in the current scope\n    --> serde/src/private/de.rs:2375:30\n     |\n2375 |     assert!(deserializer.err.is_phantom());\n     |                              ^^^^^^^^^^ method not found in `PhantomData<_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);"
                ],
                [
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);"
                ],
                [
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(matches!(deserializer.err, PhantomData));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.variant, variant);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert_eq!(deserializer.value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Map(vec![(Content::String(\"key\".to_string()), Content::U8(1))]);",
                  "    let value = Some(Content::Map(vec![(Content::String(\"another_key\".to_string()), Content::U8(2))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    assert!(matches!(deserializer.err, PhantomData));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.variant, variant);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     __private::de::content::Content<'_>\n     |     __private::de::content::Content<'_>\n     |\nnote: an implementation of `PartialEq<__private::de::content::Content<'_>>` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<__private::de::content::Content<'_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `std::option::Option<__private::de::content::Content<'_>>`\n    --> serde/src/private/de.rs:2375:5\n     |\n2375 |     assert_eq!(deserializer.value, value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |     std::option::Option<__private::de::content::Content<'_>>\n     |\nnote: an implementation of `PartialEq` might be missing for `__private::de::content::Content<'_>`\n    --> serde/src/private/de.rs:223:5\n     |\n223  |     pub enum Content<'de> {\n     |     ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `__private::de::content::Content<'_>` with `#[derive(PartialEq)]`\n     |\n223  +     #[derive(PartialEq)]\n224  |     pub enum Content<'de> {\n     |\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0283]: type annotations needed for `__private::de::content::EnumDeserializer<'_, _>`\n    --> serde/src/private/de.rs:2371:9\n     |\n2371 |     let deserializer = EnumDeserializer::new(variant, value);\n     |         ^^^^^^^^^^^^   ------------------------------------- type must be known at this point\n     |\n     = note: cannot satisfy `_: de::Error`\n     = help: the trait `de::Error` is implemented for `value::Error`\nnote: required by a bound in `__private::de::content::EnumDeserializer::<'de, E>::new`\n    --> serde/src/private/de.rs:1535:12\n     |\n1535 |         E: de::Error,\n     |            ^^^^^^^^^ required by this bound in `EnumDeserializer::<'de, E>::new`\n1536 |     {\n1537 |         pub fn new(variant: Content<'de>, value: Option<Content<'de>>) -> EnumDeserializer<'de, E> {\n     |                --- required by a bound in this associated function\nhelp: consider giving `deserializer` an explicit type, where the type for type parameter `E` is specified\n     |\n2371 |     let deserializer: __private::de::content::EnumDeserializer<'_, E> = EnumDeserializer::new(variant, value);\n     |                     +++++++++++++++++++++++++++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0283`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                "    let deserializer = EnumDeserializer::new(variant, value);",
                "}"
              ],
              "oracles": [
                [
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    assert_eq!(deserializer.variant, variant);"
                ],
                [
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    assert_eq!(deserializer.value, value);"
                ],
                [
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    assert!(std::mem::discriminant(&deserializer.err) == std::mem::discriminant(&PhantomData));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    assert_eq!(deserializer.variant, variant);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    assert_eq!(deserializer.value, value);",
                  "}"
                ],
                [
                  "{",
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    let deserializer = EnumDeserializer::new(variant, value);",
                  "    let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);",
                  "    let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));",
                  "    assert!(std::mem::discriminant(&deserializer.err) == std::mem::discriminant(&PhantomData));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2369:28\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2369 |     let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);\n     |                            ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2370:31\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2370 |     let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));\n     |                               ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2372:28\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2372 |     let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);\n     |                            ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2373:31\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2373 |     let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));\n     |                               ^^^^^^ variant or associated item not found in `Content<'_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 4 previous errors\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2369:28\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2369 |     let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);\n     |                            ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2370:31\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2370 |     let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));\n     |                               ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2372:28\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2372 |     let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);\n     |                            ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2373:31\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2373 |     let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));\n     |                               ^^^^^^ variant or associated item not found in `Content<'_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 4 previous errors\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2369:28\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2369 |     let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);\n     |                            ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2370:31\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2370 |     let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));\n     |                               ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2372:28\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2372 |     let variant = Content::Struct(\"TestStruct\", vec![(\"field\", Content::U16(5))]);\n     |                            ^^^^^^ variant or associated item not found in `Content<'_>`\n\nerror[E0599]: no variant or associated item named `Struct` found for enum `__private::de::content::Content` in the current scope\n    --> serde/src/private/de.rs:2373:31\n     |\n223  |     pub enum Content<'de> {\n     |     --------------------- variant or associated item `Struct` not found for this enum\n...\n2373 |     let value = Some(Content::Struct(\"AnotherStruct\", vec![(\"another_field\", Content::U32(10))]));\n     |                               ^^^^^^ variant or associated item not found in `Content<'_>`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 4 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}