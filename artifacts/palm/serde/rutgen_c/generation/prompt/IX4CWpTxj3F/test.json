{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/de/mod.rs\n// crate name is serde\nuse crate::lib::*;\npub use self::ignored_any::IgnoredAny;\n#[cfg(all(not(feature = \"std\"), no_core_error))]\npub use crate::std_error::Error as StdError;\n#[cfg(not(any(feature = \"std\", no_core_error)))]\npub use core::error::Error as StdError;\n#[cfg(feature = \"std\")]\npub use std::error::Error as StdError;\nmacro_rules! declare_error_trait {\n    (Error : Sized $(+ $($supertrait:ident)::+)*) => {\n        #[doc =\n        \" The `Error` trait allows `Deserialize` implementations to create descriptive\"]\n        #[doc = \" error messages belonging to the `Deserializer` against which they are\"]\n        #[doc = \" currently running.\"] #[doc = \"\"] #[doc =\n        \" Every `Deserializer` declares an `Error` type that encompasses both\"] #[doc =\n        \" general-purpose deserialization errors as well as errors specific to the\"]\n        #[doc = \" particular deserialization format. For example the `Error` type of\"]\n        #[doc =\n        \" `serde_json` can represent errors like an invalid JSON escape sequence or an\"]\n        #[doc =\n        \" unterminated string literal, in addition to the error cases that are part of\"]\n        #[doc = \" this trait.\"] #[doc = \"\"] #[doc =\n        \" Most deserializers should only need to provide the `Error::custom` method\"]\n        #[doc = \" and inherit the default behavior for the other methods.\"] #[doc = \"\"]\n        #[doc = \" # Example implementation\"] #[doc = \"\"] #[doc =\n        \" The [example data format] presented on the website shows an error\"] #[doc =\n        \" type appropriate for a basic JSON data format.\"] #[doc = \"\"] #[doc =\n        \" [example data format]: https://serde.rs/data-format.html\"] pub trait Error :\n        Sized $(+ $($supertrait)::+)* { #[doc =\n        \" Raised when there is general error when deserializing a type.\"] #[doc = \"\"]\n        #[doc =\n        \" The message should not be capitalized and should not end with a period.\"] #[doc\n        = \"\"] #[doc = \" ```edition2021\"] #[doc = \" # use std::str::FromStr;\"] #[doc =\n        \" #\"] #[doc = \" # struct IpAddr;\"] #[doc = \" #\"] #[doc =\n        \" # impl FromStr for IpAddr {\"] #[doc = \" #     type Err = String;\"] #[doc =\n        \" #\"] #[doc = \" #     fn from_str(_: &str) -> Result<Self, String> {\"] #[doc =\n        \" #         unimplemented!()\"] #[doc = \" #     }\"] #[doc = \" # }\"] #[doc = \" #\"]\n        #[doc = \" use serde::de::{self, Deserialize, Deserializer};\"] #[doc = \"\"] #[doc =\n        \" impl<'de> Deserialize<'de> for IpAddr {\"] #[doc =\n        \"     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\"] #[doc =\n        \"     where\"] #[doc = \"         D: Deserializer<'de>,\"] #[doc = \"     {\"] #[doc =\n        \"         let s = String::deserialize(deserializer)?;\"] #[doc =\n        \"         s.parse().map_err(de::Error::custom)\"] #[doc = \"     }\"] #[doc = \" }\"]\n        #[doc = \" ```\"] fn custom < T > (msg : T) -> Self where T : Display; #[doc =\n        \" Raised when a `Deserialize` receives a type different from what it was\"] #[doc\n        = \" expecting.\"] #[doc = \"\"] #[doc =\n        \" The `unexp` argument provides information about what type was received.\"] #[doc\n        = \" This is the type that was present in the input file or other source data\"]\n        #[doc = \" of the Deserializer.\"] #[doc = \"\"] #[doc =\n        \" The `exp` argument provides information about what type was being\"] #[doc =\n        \" expected. This is the type that is written in the program.\"] #[doc = \"\"] #[doc\n        = \" For example if we try to deserialize a String out of a JSON file\"] #[doc =\n        \" containing an integer, the unexpected type is the integer and the\"] #[doc =\n        \" expected type is the string.\"] #[cold] fn invalid_type(unexp : Unexpected, exp\n        : & dyn Expected) -> Self {\n        Error::custom(format_args!(\"invalid type: {}, expected {}\", unexp, exp)) } #[doc\n        = \" Raised when a `Deserialize` receives a value of the right type but that\"]\n        #[doc = \" is wrong for some other reason.\"] #[doc = \"\"] #[doc =\n        \" The `unexp` argument provides information about what value was received.\"]\n        #[doc = \" This is the value that was present in the input file or other source\"]\n        #[doc = \" data of the Deserializer.\"] #[doc = \"\"] #[doc =\n        \" The `exp` argument provides information about what value was being\"] #[doc =\n        \" expected. This is the type that is written in the program.\"] #[doc = \"\"] #[doc\n        = \" For example if we try to deserialize a String out of some binary data\"] #[doc\n        = \" that is not valid UTF-8, the unexpected value is the bytes and the\"] #[doc =\n        \" expected value is a string.\"] #[cold] fn invalid_value(unexp : Unexpected, exp\n        : & dyn Expected) -> Self {\n        Error::custom(format_args!(\"invalid value: {}, expected {}\", unexp, exp)) } #[doc\n        = \" Raised when deserializing a sequence or map and the input data contains\"]\n        #[doc = \" too many or too few elements.\"] #[doc = \"\"] #[doc =\n        \" The `len` argument is the number of elements encountered. The sequence\"] #[doc\n        = \" or map may have expected more arguments or fewer arguments.\"] #[doc = \"\"]\n        #[doc = \" The `exp` argument provides information about what data was being\"]\n        #[doc = \" expected. For example `exp` might say that a tuple of size 6 was\"]\n        #[doc = \" expected.\"] #[cold] fn invalid_length(len : usize, exp : & dyn\n        Expected) -> Self { Error::custom(format_args!(\"invalid length {}, expected {}\",\n        len, exp)) } #[doc =\n        \" Raised when a `Deserialize` enum type received a variant with an\"] #[doc =\n        \" unrecognized name.\"] #[cold] fn unknown_variant(variant : & str, expected :\n        &'static [&'static str]) -> Self { if expected.is_empty() {\n        Error::custom(format_args!(\"unknown variant `{}`, there are no variants\",\n        variant)) } else {\n        Error::custom(format_args!(\"unknown variant `{}`, expected {}\", variant, OneOf {\n        names : expected })) } } #[doc =\n        \" Raised when a `Deserialize` struct type received a field with an\"] #[doc =\n        \" unrecognized name.\"] #[cold] fn unknown_field(field : & str, expected :\n        &'static [&'static str]) -> Self { if expected.is_empty() {\n        Error::custom(format_args!(\"unknown field `{}`, there are no fields\", field)) }\n        else { Error::custom(format_args!(\"unknown field `{}`, expected {}\", field, OneOf\n        { names : expected })) } } #[doc =\n        \" Raised when a `Deserialize` struct type expected to receive a required\"] #[doc\n        = \" field with a particular name but that field was not present in the\"] #[doc =\n        \" input.\"] #[cold] fn missing_field(field : &'static str) -> Self {\n        Error::custom(format_args!(\"missing field `{}`\", field)) } #[doc =\n        \" Raised when a `Deserialize` struct type received more than one of the\"] #[doc =\n        \" same field.\"] #[cold] fn duplicate_field(field : &'static str) -> Self {\n        Error::custom(format_args!(\"duplicate field `{}`\", field)) } }\n    };\n}\n#[cfg(feature = \"std\")]\ndeclare_error_trait!(Error : Sized + StdError);\n#[cfg(not(feature = \"std\"))]\ndeclare_error_trait!(Error : Sized + Debug + Display);\nstruct WithDecimalPoint(f64);\n#[derive(Copy, Clone, PartialEq, Debug)]\npub enum Unexpected<'a> {\n    /// The input contained a boolean value that was not expected.\n    Bool(bool),\n    /// The input contained an unsigned integer `u8`, `u16`, `u32` or `u64` that\n    /// was not expected.\n    Unsigned(u64),\n    /// The input contained a signed integer `i8`, `i16`, `i32` or `i64` that\n    /// was not expected.\n    Signed(i64),\n    /// The input contained a floating point `f32` or `f64` that was not\n    /// expected.\n    Float(f64),\n    /// The input contained a `char` that was not expected.\n    Char(char),\n    /// The input contained a `&str` or `String` that was not expected.\n    Str(&'a str),\n    /// The input contained a `&[u8]` or `Vec<u8>` that was not expected.\n    Bytes(&'a [u8]),\n    /// The input contained a unit `()` that was not expected.\n    Unit,\n    /// The input contained an `Option<T>` that was not expected.\n    Option,\n    /// The input contained a newtype struct that was not expected.\n    NewtypeStruct,\n    /// The input contained a sequence that was not expected.\n    Seq,\n    /// The input contained a map that was not expected.\n    Map,\n    /// The input contained an enum that was not expected.\n    Enum,\n    /// The input contained a unit variant that was not expected.\n    UnitVariant,\n    /// The input contained a newtype variant that was not expected.\n    NewtypeVariant,\n    /// The input contained a tuple variant that was not expected.\n    TupleVariant,\n    /// The input contained a struct variant that was not expected.\n    StructVariant,\n    /// A message stating what uncategorized thing the input contained that was\n    /// not expected.\n    ///\n    /// The message should be a noun or noun phrase, not capitalized and without\n    /// a period. An example message is \"unoriginal superhero\".\n    Other(&'a str),\n}\nimpl<'a> fmt::Display for Unexpected<'a> {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        use self::Unexpected::*;\n        match *self {\n            Bool(b) => write!(formatter, \"boolean `{}`\", b),\n            Unsigned(i) => write!(formatter, \"integer `{}`\", i),\n            Signed(i) => write!(formatter, \"integer `{}`\", i),\n            Float(f) => write!(formatter, \"floating point `{}`\", WithDecimalPoint(f)),\n            Char(c) => write!(formatter, \"character `{}`\", c),\n            Str(s) => write!(formatter, \"string {:?}\", s),\n            Bytes(_) => formatter.write_str(\"byte array\"),\n            Unit => formatter.write_str(\"unit value\"),\n            Option => formatter.write_str(\"Option value\"),\n            NewtypeStruct => formatter.write_str(\"newtype struct\"),\n            Seq => formatter.write_str(\"sequence\"),\n            Map => formatter.write_str(\"map\"),\n            Enum => formatter.write_str(\"enum\"),\n            UnitVariant => formatter.write_str(\"unit variant\"),\n            NewtypeVariant => formatter.write_str(\"newtype variant\"),\n            TupleVariant => formatter.write_str(\"tuple variant\"),\n            StructVariant => formatter.write_str(\"struct variant\"),\n            Other(other) => formatter.write_str(other),\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\nfn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n    use self::Unexpected::*;\n    match *self {\n        Bool(b) => write!(formatter, \"boolean `{}`\", b),\n        Unsigned(i) => write!(formatter, \"integer `{}`\", i),\n        Signed(i) => write!(formatter, \"integer `{}`\", i),\n        Float(f) => write!(formatter, \"floating point `{}`\", WithDecimalPoint(f)),\n        Char(c) => write!(formatter, \"character `{}`\", c),\n        Str(s) => write!(formatter, \"string {:?}\", s),\n        Bytes(_) => formatter.write_str(\"byte array\"),\n        Unit => formatter.write_str(\"unit value\"),\n        Option => formatter.write_str(\"Option value\"),\n        NewtypeStruct => formatter.write_str(\"newtype struct\"),\n        Seq => formatter.write_str(\"sequence\"),\n        Map => formatter.write_str(\"map\"),\n        Enum => formatter.write_str(\"enum\"),\n        UnitVariant => formatter.write_str(\"unit variant\"),\n        NewtypeVariant => formatter.write_str(\"newtype variant\"),\n        TupleVariant => formatter.write_str(\"tuple variant\"),\n        StructVariant => formatter.write_str(\"struct variant\"),\n        Other(other) => formatter.write_str(other),\n    }\n}\n",
  "depend_pt": ""
}