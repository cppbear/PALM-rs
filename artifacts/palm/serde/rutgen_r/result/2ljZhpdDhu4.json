{"function_name":"serde::format::<format::Buf<'a> as std::fmt::Write>::write_str","tests":5,"tests_lines":[9,10,9,30,30],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":5,"tests_passed":4,"tests_passed_rate":80.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[21,22,23,25,26,27,29],"codes_lines_covered":[[["{","    let mut writer = Writer {","        bytes: vec![0; 5], // create a writer with a byte buffer of size 5","        offset: 4, // set offset near the end of buffer","    };","    ","    let result = writer.write_str(\"test\"); // length is 4, offset is 4, total would be 8 which exceeds capacity","    assert!(result.is_err()); // Expecting an error","}"],[]],[["{","    let mut writer = Writer {","        bytes: vec![0; 5], // create a writer with a byte buffer of size 5","        offset: 0, // starting from the beginning","    };","    ","    let result = writer.write_str(\"hello\"); // length is 5, should fit exactly into the buffer","    assert!(result.is_ok()); // Expecting success","    assert_eq!(&writer.bytes[0..5], b\"hello\"); // Verify that the data is written correctly","}"],[]],[["{","    let mut writer = Writer {","        bytes: vec![0; 10], // create a writer with a byte buffer of size 10","        offset: 8, // set offset such that adding 3 will exceed","    };","    ","    let result = writer.write_str(\"123\"); // length is 3, offset is 8, total would be 11 which exceeds capacity","    assert!(result.is_err()); // Expecting an error","}"],[]],[["{","    struct TestWriter {","        bytes: Vec<u8>,","        offset: usize,","    }","    ","    impl TestWriter {","        fn new(size: usize) -> Self {","            TestWriter {","                bytes: vec![0u8; size],","                offset: 0,","            }","        }","        ","        fn write_str(&mut self, s: &str) -> std::fmt::Result {","            if self.offset + s.len() > self.bytes.len() {","                Err(std::fmt::Error)","            } else {","                self.bytes[self.offset..self.offset + s.len()].copy_from_slice(s.as_bytes());","                self.offset += s.len();","                Ok(())","            }","        }","    }","","    let mut writer = TestWriter::new(5);","    let result = writer.write_str(\"hello\");","    assert!(result.is_ok());","    assert_eq!(writer.bytes, b\"hello\");","}"],[]],[["{","    struct TestWriter {","        bytes: Vec<u8>,","        offset: usize,","    }","    ","    impl TestWriter {","        fn new(size: usize) -> Self {","            TestWriter {","                bytes: vec![0u8; size],","                offset: 0,","            }","        }","        ","        fn write_str(&mut self, s: &str) -> std::fmt::Result {","            if self.offset + s.len() > self.bytes.len() {","                Err(std::fmt::Error)","            } else {","                self.bytes[self.offset..self.offset + s.len()].copy_from_slice(s.as_bytes());","                self.offset += s.len();","                Ok(())","            }","        }","    }","","    let mut writer = TestWriter::new(5);","    let result = writer.write_str(\"\");","    assert!(result.is_ok());","    assert_eq!(writer.bytes, b\"\");","}"],[]]],"codes_branches":[{"start_line":22,"start_column":12,"end_line":22,"end_column":52,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut writer = Writer {","        bytes: vec![0; 5], // create a writer with a byte buffer of size 5","        offset: 4, // set offset near the end of buffer","    };","    ","    let result = writer.write_str(\"test\"); // length is 4, offset is 4, total would be 8 which exceeds capacity","    assert!(result.is_err()); // Expecting an error","}"],[{"start_line":22,"start_column":12,"end_line":22,"end_column":52,"positive":false,"negative":false}]],[["{","    let mut writer = Writer {","        bytes: vec![0; 5], // create a writer with a byte buffer of size 5","        offset: 0, // starting from the beginning","    };","    ","    let result = writer.write_str(\"hello\"); // length is 5, should fit exactly into the buffer","    assert!(result.is_ok()); // Expecting success","    assert_eq!(&writer.bytes[0..5], b\"hello\"); // Verify that the data is written correctly","}"],[{"start_line":22,"start_column":12,"end_line":22,"end_column":52,"positive":false,"negative":false}]],[["{","    let mut writer = Writer {","        bytes: vec![0; 10], // create a writer with a byte buffer of size 10","        offset: 8, // set offset such that adding 3 will exceed","    };","    ","    let result = writer.write_str(\"123\"); // length is 3, offset is 8, total would be 11 which exceeds capacity","    assert!(result.is_err()); // Expecting an error","}"],[{"start_line":22,"start_column":12,"end_line":22,"end_column":52,"positive":false,"negative":false}]],[["{","    struct TestWriter {","        bytes: Vec<u8>,","        offset: usize,","    }","    ","    impl TestWriter {","        fn new(size: usize) -> Self {","            TestWriter {","                bytes: vec![0u8; size],","                offset: 0,","            }","        }","        ","        fn write_str(&mut self, s: &str) -> std::fmt::Result {","            if self.offset + s.len() > self.bytes.len() {","                Err(std::fmt::Error)","            } else {","                self.bytes[self.offset..self.offset + s.len()].copy_from_slice(s.as_bytes());","                self.offset += s.len();","                Ok(())","            }","        }","    }","","    let mut writer = TestWriter::new(5);","    let result = writer.write_str(\"hello\");","    assert!(result.is_ok());","    assert_eq!(writer.bytes, b\"hello\");","}"],[{"start_line":22,"start_column":12,"end_line":22,"end_column":52,"positive":false,"negative":false}]],[["{","    struct TestWriter {","        bytes: Vec<u8>,","        offset: usize,","    }","    ","    impl TestWriter {","        fn new(size: usize) -> Self {","            TestWriter {","                bytes: vec![0u8; size],","                offset: 0,","            }","        }","        ","        fn write_str(&mut self, s: &str) -> std::fmt::Result {","            if self.offset + s.len() > self.bytes.len() {","                Err(std::fmt::Error)","            } else {","                self.bytes[self.offset..self.offset + s.len()].copy_from_slice(s.as_bytes());","                self.offset += s.len();","                Ok(())","            }","        }","    }","","    let mut writer = TestWriter::new(5);","    let result = writer.write_str(\"\");","    assert!(result.is_ok());","    assert_eq!(writer.bytes, b\"\");","}"],[{"start_line":22,"start_column":12,"end_line":22,"end_column":52,"positive":false,"negative":false}]]]}