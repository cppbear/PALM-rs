{"function_name":"serde::__private::ser::content::<__private::ser::content::SerializeTuple<E> as ser::SerializeTuple>::end","tests":2,"tests_lines":[33,33],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[810,811,812],"codes_lines_covered":[[["{","    struct TestStruct {","        elements: Vec<i32>,","    }","","    impl TestStruct {","        fn end(self) -> Result<Content, &'static str> {","            Ok(Content::Tuple(self.elements))","        }","    }","","    struct Content {","        elements: Vec<i32>,","    }","","    impl Content {","        fn Tuple(elements: Vec<i32>) -> Content {","            Content { elements }","        }","    }","","    let elements = vec![1, 2, 3];","    let test_struct = TestStruct { elements };","    ","    let result = test_struct.end();","    match result {","        Ok(content) => {","            assert_eq!(content.elements.len(), 3);","            assert_eq!(content.elements, vec![1, 2, 3]);","        },","        Err(_) => panic!(\"Expected Ok but got Err\"),","    }","}"],[]],[["{","    struct TestStruct {","        elements: Vec<i32>,","    }","","    impl TestStruct {","        fn end(self) -> Result<Content, &'static str> {","            Ok(Content::Tuple(self.elements))","        }","    }","","    struct Content {","        elements: Vec<i32>,","    }","","    impl Content {","        fn Tuple(elements: Vec<i32>) -> Content {","            Content { elements }","        }","    }","","    let elements: Vec<i32> = vec![];","    let test_struct = TestStruct { elements };","    ","    let result = test_struct.end();","    match result {","        Ok(content) => {","            assert_eq!(content.elements.len(), 0);","            assert_eq!(content.elements, vec![]);","        },","        Err(_) => panic!(\"Expected Ok but got Err\"),","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestStruct {","        elements: Vec<i32>,","    }","","    impl TestStruct {","        fn end(self) -> Result<Content, &'static str> {","            Ok(Content::Tuple(self.elements))","        }","    }","","    struct Content {","        elements: Vec<i32>,","    }","","    impl Content {","        fn Tuple(elements: Vec<i32>) -> Content {","            Content { elements }","        }","    }","","    let elements = vec![1, 2, 3];","    let test_struct = TestStruct { elements };","    ","    let result = test_struct.end();","    match result {","        Ok(content) => {","            assert_eq!(content.elements.len(), 3);","            assert_eq!(content.elements, vec![1, 2, 3]);","        },","        Err(_) => panic!(\"Expected Ok but got Err\"),","    }","}"],[]],[["{","    struct TestStruct {","        elements: Vec<i32>,","    }","","    impl TestStruct {","        fn end(self) -> Result<Content, &'static str> {","            Ok(Content::Tuple(self.elements))","        }","    }","","    struct Content {","        elements: Vec<i32>,","    }","","    impl Content {","        fn Tuple(elements: Vec<i32>) -> Content {","            Content { elements }","        }","    }","","    let elements: Vec<i32> = vec![];","    let test_struct = TestStruct { elements };","    ","    let result = test_struct.end();","    match result {","        Ok(content) => {","            assert_eq!(content.elements.len(), 0);","            assert_eq!(content.elements, vec![]);","        },","        Err(_) => panic!(\"Expected Ok but got Err\"),","    }","}"],[]]]}