{
  "name": "serde::ser::Serializer::is_human_readable",
  "name_with_impl": "serde::ser::Serializer::is_human_readable",
  "mod_info": {
    "name": "ser",
    "loc": "serde/src/lib.rs:312:1:312:13"
  },
  "visible": true,
  "loc": "serde/src/ser/mod.rs:1444:5:1446:6",
  "doc": "/// Determine whether `Serialize` implementations should serialize in\n/// human-readable form.\n///\n/// Some types have a human-readable form that may be somewhat expensive to\n/// construct, as well as a binary form that is compact and efficient.\n/// Generally text-based formats like JSON and YAML will prefer to use the\n/// human-readable one and binary formats like Postcard will prefer the\n/// compact one.\n///\n/// ```edition2021\n/// # use std::fmt::{self, Display};\n/// #\n/// # struct Timestamp;\n/// #\n/// # impl Timestamp {\n/// #     fn seconds_since_epoch(&self) -> u64 { unimplemented!() }\n/// # }\n/// #\n/// # impl Display for Timestamp {\n/// #     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::{Serialize, Serializer};\n///\n/// impl Serialize for Timestamp {\n///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n///     where\n///         S: Serializer,\n///     {\n///         if serializer.is_human_readable() {\n///             // Serialize to a human-readable string \"2015-05-15T17:01:00Z\".\n///             self.to_string().serialize(serializer)\n///         } else {\n///             // Serialize to a compact binary representation.\n///             self.seconds_since_epoch().serialize(serializer)\n///         }\n///     }\n/// }\n/// ```\n///\n/// The default implementation of this method returns `true`. Data formats\n/// may override this to `false` to request a compact form for types that\n/// support one. Note that modifying this method to change a format from\n/// human-readable to compact or vice versa should be regarded as a breaking\n/// change, as a value serialized in human-readable mode is not required to\n/// deserialize from the same data in compact mode.\n",
  "code": [
    "fn is_human_readable(&self) -> bool {",
    "    true",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "true",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}