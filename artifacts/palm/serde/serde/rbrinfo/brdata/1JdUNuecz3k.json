{
  "name": "serde::de::Deserializer::is_human_readable",
  "name_with_impl": "serde::de::Deserializer::is_human_readable",
  "mod_info": {
    "name": "de",
    "loc": "serde/src/lib.rs:311:1:311:12"
  },
  "visible": true,
  "loc": "serde/src/de/mod.rs:1222:5:1224:6",
  "doc": "/// Determine whether `Deserialize` implementations should expect to\n/// deserialize their human-readable form.\n///\n/// Some types have a human-readable form that may be somewhat expensive to\n/// construct, as well as a binary form that is compact and efficient.\n/// Generally text-based formats like JSON and YAML will prefer to use the\n/// human-readable one and binary formats like Postcard will prefer the\n/// compact one.\n///\n/// ```edition2021\n/// # use std::ops::Add;\n/// # use std::str::FromStr;\n/// #\n/// # struct Timestamp;\n/// #\n/// # impl Timestamp {\n/// #     const EPOCH: Timestamp = Timestamp;\n/// # }\n/// #\n/// # impl FromStr for Timestamp {\n/// #     type Err = String;\n/// #     fn from_str(_: &str) -> Result<Self, Self::Err> {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// # struct Duration;\n/// #\n/// # impl Duration {\n/// #     fn seconds(_: u64) -> Self { unimplemented!() }\n/// # }\n/// #\n/// # impl Add<Duration> for Timestamp {\n/// #     type Output = Timestamp;\n/// #     fn add(self, _: Duration) -> Self::Output {\n/// #         unimplemented!()\n/// #     }\n/// # }\n/// #\n/// use serde::de::{self, Deserialize, Deserializer};\n///\n/// impl<'de> Deserialize<'de> for Timestamp {\n///     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n///     where\n///         D: Deserializer<'de>,\n///     {\n///         if deserializer.is_human_readable() {\n///             // Deserialize from a human-readable string like \"2015-05-15T17:01:00Z\".\n///             let s = String::deserialize(deserializer)?;\n///             Timestamp::from_str(&s).map_err(de::Error::custom)\n///         } else {\n///             // Deserialize from a compact binary representation, seconds since\n///             // the Unix epoch.\n///             let n = u64::deserialize(deserializer)?;\n///             Ok(Timestamp::EPOCH + Duration::seconds(n))\n///         }\n///     }\n/// }\n/// ```\n///\n/// The default implementation of this method returns `true`. Data formats\n/// may override this to `false` to request a compact form for types that\n/// support one. Note that modifying this method to change a format from\n/// human-readable to compact or vice versa should be regarded as a breaking\n/// change, as a value serialized in human-readable mode is not required to\n/// deserialize from the same data in compact mode.\n",
  "code": [
    "fn is_human_readable(&self) -> bool {",
    "    true",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "true",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}