{"function_name":"thiserror::display::<&T as display::AsDisplay<'a>>::as_display","file_path":"/home/abezbm/rust-utgen-test-crates-new/thiserror/src/display.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/thiserror","tests":15,"tests_lines":[7,7,9,9,7,7,6,6,14,14,7,6,7,7,7],"oracles":8,"oracles_compiled":7,"oracles_compiled_rate":87.5,"tests_compiled":9,"tests_compiled_rate":60.0,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":9,"tests_passed":7,"tests_passed_rate":77.77777777777779,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[20,21,22],"codes_lines_covered":[[["{","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    assert_eq!(result, s);","}"],[20,21,22]],[["{","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    assert!(std::any::TypeId::of::<&str>() == std::any::TypeId::of::<&dyn Display>());","}"],[20,21,22]],[["{","    let s: String = String::from(\"Hello, Rust!\");","    let result: &String = &s;","    let display_result = result.as_display();","    let s: String = String::from(\"Hello, Rust!\");","    let result: &String = &s;","    let display_result = result.as_display();","    assert_eq!(display_result.to_string(), \"Hello, Rust!\");","}"],[20,21,22]],[["{","    let num: &i32 = &42;","    let display_result = num.as_display();","    let num: &i32 = &42;","    let display_result = num.as_display();","    assert_eq!(display_result, &42);","}"],[20,21,22]],[["{","    let float_num: &f64 = &3.14;","    let display_result = float_num.as_display();","    let float_num: &f64 = &3.14;","    assert_eq!(display_result, &3.14);","}"],[20,21,22]],[["{","    struct MyStruct;","    impl Display for MyStruct {","        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {","            write!(f, \"MyStruct\")","        }","    }","    ","    let my_struct_instance: &MyStruct = &MyStruct;","    let display_result = my_struct_instance.as_display();","    let my_struct_instance: &MyStruct = &MyStruct;","    let display_result = my_struct_instance.as_display();","    assert_eq!(format!(\"{}\", display_result), \"MyStruct\");","}"],[20,21,22]],[["{","    let empty_string: &str = \"\";","    let display_result = empty_string.as_display();","    let empty_string: &str = \"\";","    assert_eq!(display_result, empty_string);","}"],[20,21,22]],[["{","  let null_ref: Option<&str> = None;  ","  let _result = null_ref.as_ref().map(|s| s.as_display()); // handle None  ","  let null_ref: Option<&str> = None;  ","  let _result = null_ref.as_ref().map(|s| s.as_display());  ","  assert!(_result.is_none());  ","}"],[]],[["{","  let null_ref: Option<&str> = None;","  null_ref.as_ref().map(|s| s.as_display()); // correctly handle the Option type","  let null_ref: Option<&str> = None;","  null_ref.as_ref().map(|s| s.as_display()); // correctly handle the Option type","   assert!(std::any::type_name::<Option<&str>>() == \"Option<&str>\");","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    assert_eq!(result, s);","}"],[]],[["{","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    let s: &str = \"Hello, world!\";","    let result = s.as_display();","    assert!(std::any::TypeId::of::<&str>() == std::any::TypeId::of::<&dyn Display>());","}"],[]],[["{","    let s: String = String::from(\"Hello, Rust!\");","    let result: &String = &s;","    let display_result = result.as_display();","    let s: String = String::from(\"Hello, Rust!\");","    let result: &String = &s;","    let display_result = result.as_display();","    assert_eq!(display_result.to_string(), \"Hello, Rust!\");","}"],[]],[["{","    let num: &i32 = &42;","    let display_result = num.as_display();","    let num: &i32 = &42;","    let display_result = num.as_display();","    assert_eq!(display_result, &42);","}"],[]],[["{","    let float_num: &f64 = &3.14;","    let display_result = float_num.as_display();","    let float_num: &f64 = &3.14;","    assert_eq!(display_result, &3.14);","}"],[]],[["{","    struct MyStruct;","    impl Display for MyStruct {","        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {","            write!(f, \"MyStruct\")","        }","    }","    ","    let my_struct_instance: &MyStruct = &MyStruct;","    let display_result = my_struct_instance.as_display();","    let my_struct_instance: &MyStruct = &MyStruct;","    let display_result = my_struct_instance.as_display();","    assert_eq!(format!(\"{}\", display_result), \"MyStruct\");","}"],[]],[["{","    let empty_string: &str = \"\";","    let display_result = empty_string.as_display();","    let empty_string: &str = \"\";","    assert_eq!(display_result, empty_string);","}"],[]],[["{","  let null_ref: Option<&str> = None;  ","  let _result = null_ref.as_ref().map(|s| s.as_display()); // handle None  ","  let null_ref: Option<&str> = None;  ","  let _result = null_ref.as_ref().map(|s| s.as_display());  ","  assert!(_result.is_none());  ","}"],[]],[["{","  let null_ref: Option<&str> = None;","  null_ref.as_ref().map(|s| s.as_display()); // correctly handle the Option type","  let null_ref: Option<&str> = None;","  null_ref.as_ref().map(|s| s.as_display()); // correctly handle the Option type","   assert!(std::any::type_name::<Option<&str>>() == \"Option<&str>\");","}"],[]]]}