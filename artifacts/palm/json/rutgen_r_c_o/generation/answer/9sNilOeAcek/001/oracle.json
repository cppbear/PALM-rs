[
  {
    "uses": [
      "use std::collections::HashMap;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct EmptyStruct;",
          "",
          "    impl serde::ser::Serialize for EmptyStruct {",
          "        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>",
          "        where",
          "            S: serde::ser::Serializer,",
          "        {",
          "            serializer.serialize_unit()",
          "        }",
          "    }",
          "",
          "    let writer = Vec::new();",
          "    let value = EmptyStruct;",
          "    to_writer_pretty(writer, &value);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = Vec::new();",
            "    let value = EmptyStruct;",
            "    let result = to_writer_pretty(writer, &value);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let writer = Vec::new();",
            "    let value = EmptyStruct;",
            "    let result = to_writer_pretty(writer, &value);",
            "    assert_eq!(writer.len(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct EmptyStruct;",
            "",
            "    impl serde::ser::Serialize for EmptyStruct {",
            "        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>",
            "        where",
            "            S: serde::ser::Serializer,",
            "        {",
            "            serializer.serialize_unit()",
            "        }",
            "    }",
            "",
            "    let writer = Vec::new();",
            "    let value = EmptyStruct;",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = EmptyStruct;",
            "    let result = to_writer_pretty(writer, &value);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct EmptyStruct;",
            "",
            "    impl serde::ser::Serialize for EmptyStruct {",
            "        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>",
            "        where",
            "            S: serde::ser::Serializer,",
            "        {",
            "            serializer.serialize_unit()",
            "        }",
            "    }",
            "",
            "    let writer = Vec::new();",
            "    let value = EmptyStruct;",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = EmptyStruct;",
            "    let result = to_writer_pretty(writer, &value);",
            "    assert_eq!(writer.len(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::HashMap;",
          "",
          "    let writer = Vec::new();",
          "    let value: HashMap<String, String> = HashMap::new();",
          "    to_writer_pretty(writer, &value);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = Vec::new();",
            "    let value: HashMap<String, String> = HashMap::new();",
            "    let result = to_writer_pretty(writer, &value);",
            "    assert!(result.is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    use std::collections::HashMap;",
            "",
            "    let writer = Vec::new();",
            "    let value: HashMap<String, String> = HashMap::new();",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value: HashMap<String, String> = HashMap::new();",
            "    let result = to_writer_pretty(writer, &value);",
            "    assert!(result.is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let writer = Vec::new();",
          "    let value = \"hello world\";",
          "    to_writer_pretty(writer, &value);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = Vec::new();",
            "    let value = \"hello world\";",
            "    assert!(to_writer_pretty(writer, &value).is_ok());"
          ],
          [
            "    let writer = Vec::new();",
            "    let value = \"hello world\";",
            "    assert_eq!(String::from_utf8(writer).unwrap(), \"\\\"hello world\\\"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let writer = Vec::new();",
            "    let value = \"hello world\";",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = \"hello world\";",
            "    assert!(to_writer_pretty(writer, &value).is_ok());",
            "}"
          ],
          [
            "{",
            "    let writer = Vec::new();",
            "    let value = \"hello world\";",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = \"hello world\";",
            "    assert_eq!(String::from_utf8(writer).unwrap(), \"\\\"hello world\\\"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let writer = Vec::new();",
          "    let value = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
          "    to_writer_pretty(writer, &value);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = Vec::new();",
            "    let value = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "    assert_eq!(to_writer_pretty(writer, &value).is_ok(), true);"
          ],
          [
            "    let writer = Vec::new();",
            "    let value = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "    assert_eq!(writer.len(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let writer = Vec::new();",
            "    let value = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "    assert_eq!(to_writer_pretty(writer, &value).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let writer = Vec::new();",
            "    let value = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];",
            "    assert_eq!(writer.len(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    #[derive(Serialize)]",
          "    struct Nested {",
          "        value: String,",
          "        children: Vec<Nested>,",
          "    }",
          "",
          "    let writer = Vec::new();",
          "    let value = Nested {",
          "        value: \"root\".to_string(),",
          "        children: vec![",
          "            Nested {",
          "                value: \"child1\".to_string(),",
          "                children: vec![],",
          "            },",
          "            Nested {",
          "                value: \"child2\".to_string(),",
          "                children: vec![],",
          "            },",
          "        ],",
          "    };",
          "    to_writer_pretty(writer, &value);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(to_writer_pretty(writer, &value).is_ok());"
          ],
          [
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert_eq!(writer.len(), 0);"
          ],
          [
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(std::str::from_utf8(&writer).unwrap().contains(\"root\"));"
          ],
          [
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(std::str::from_utf8(&writer).unwrap().contains(\"child1\"));"
          ],
          [
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(std::str::from_utf8(&writer).unwrap().contains(\"child2\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    #[derive(Serialize)]",
            "    struct Nested {",
            "        value: String,",
            "        children: Vec<Nested>,",
            "    }",
            "",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "        value: \"root\".to_string(),",
            "        children: vec![",
            "            Nested {",
            "                value: \"child1\".to_string(),",
            "                children: vec![],",
            "            },",
            "            Nested {",
            "                value: \"child2\".to_string(),",
            "                children: vec![],",
            "            },",
            "        ],",
            "    };",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(to_writer_pretty(writer, &value).is_ok());",
            "}"
          ],
          [
            "{",
            "    #[derive(Serialize)]",
            "    struct Nested {",
            "        value: String,",
            "        children: Vec<Nested>,",
            "    }",
            "",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "        value: \"root\".to_string(),",
            "        children: vec![",
            "            Nested {",
            "                value: \"child1\".to_string(),",
            "                children: vec![],",
            "            },",
            "            Nested {",
            "                value: \"child2\".to_string(),",
            "                children: vec![],",
            "            },",
            "        ],",
            "    };",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert_eq!(writer.len(), 0);",
            "}"
          ],
          [
            "{",
            "    #[derive(Serialize)]",
            "    struct Nested {",
            "        value: String,",
            "        children: Vec<Nested>,",
            "    }",
            "",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "        value: \"root\".to_string(),",
            "        children: vec![",
            "            Nested {",
            "                value: \"child1\".to_string(),",
            "                children: vec![],",
            "            },",
            "            Nested {",
            "                value: \"child2\".to_string(),",
            "                children: vec![],",
            "            },",
            "        ],",
            "    };",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(std::str::from_utf8(&writer).unwrap().contains(\"root\"));",
            "}"
          ],
          [
            "{",
            "    #[derive(Serialize)]",
            "    struct Nested {",
            "        value: String,",
            "        children: Vec<Nested>,",
            "    }",
            "",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "        value: \"root\".to_string(),",
            "        children: vec![",
            "            Nested {",
            "                value: \"child1\".to_string(),",
            "                children: vec![],",
            "            },",
            "            Nested {",
            "                value: \"child2\".to_string(),",
            "                children: vec![],",
            "            },",
            "        ],",
            "    };",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(std::str::from_utf8(&writer).unwrap().contains(\"child1\"));",
            "}"
          ],
          [
            "{",
            "    #[derive(Serialize)]",
            "    struct Nested {",
            "        value: String,",
            "        children: Vec<Nested>,",
            "    }",
            "",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "        value: \"root\".to_string(),",
            "        children: vec![",
            "            Nested {",
            "                value: \"child1\".to_string(),",
            "                children: vec![],",
            "            },",
            "            Nested {",
            "                value: \"child2\".to_string(),",
            "                children: vec![],",
            "            },",
            "        ],",
            "    };",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value = Nested {",
            "    value: \"root\".to_string(),",
            "    children: vec![",
            "    Nested {",
            "    value: \"child1\".to_string(),",
            "    children: vec![],",
            "    },",
            "    Nested {",
            "    value: \"child2\".to_string(),",
            "    children: vec![],",
            "    },",
            "    ],",
            "    };",
            "    assert!(std::str::from_utf8(&writer).unwrap().contains(\"child2\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use std::collections::HashMap;",
          "",
          "    let writer = Vec::new();",
          "    let mut value = HashMap::new();",
          "    value.insert(\"key1\".to_string(), \"value1\".to_string());",
          "    value.insert(\"key2\".to_string(), \"value2\".to_string());",
          "    to_writer_pretty(writer, &value);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = Vec::new();",
            "    let mut value = HashMap::new();",
            "    value.insert(\"key1\".to_string(), \"value1\".to_string());",
            "    value.insert(\"key2\".to_string(), \"value2\".to_string());",
            "    assert_eq!(to_writer_pretty(writer, &value).is_ok(), true);"
          ],
          [
            "    let writer = Vec::new();",
            "    let mut value = HashMap::new();",
            "    value.insert(\"key1\".to_string(), \"value1\".to_string());",
            "    value.insert(\"key2\".to_string(), \"value2\".to_string());",
            "    assert_eq!(to_writer_pretty(writer, &value).unwrap_err().code(), ErrorCode::InvalidKey);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use std::collections::HashMap;",
            "",
            "    let writer = Vec::new();",
            "    let mut value = HashMap::new();",
            "    value.insert(\"key1\".to_string(), \"value1\".to_string());",
            "    value.insert(\"key2\".to_string(), \"value2\".to_string());",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let mut value = HashMap::new();",
            "    value.insert(\"key1\".to_string(), \"value1\".to_string());",
            "    value.insert(\"key2\".to_string(), \"value2\".to_string());",
            "    assert_eq!(to_writer_pretty(writer, &value).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    use std::collections::HashMap;",
            "",
            "    let writer = Vec::new();",
            "    let mut value = HashMap::new();",
            "    value.insert(\"key1\".to_string(), \"value1\".to_string());",
            "    value.insert(\"key2\".to_string(), \"value2\".to_string());",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let mut value = HashMap::new();",
            "    value.insert(\"key1\".to_string(), \"value1\".to_string());",
            "    value.insert(\"key2\".to_string(), \"value2\".to_string());",
            "    assert_eq!(to_writer_pretty(writer, &value).unwrap_err().code(), ErrorCode::InvalidKey);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    use std::collections::HashMap;",
          "",
          "    let writer = Vec::new();",
          "    let value: HashMap<i32, String> = [(1, \"value1\".to_string())].iter().cloned().collect();",
          "    to_writer_pretty(writer, &value);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = Vec::new();",
            "    let value: HashMap<i32, String> = [(1, \"value1\".to_string())].iter().cloned().collect();",
            "    assert!(std::panic::catch_unwind(|| to_writer_pretty(writer, &value)).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    use std::collections::HashMap;",
            "",
            "    let writer = Vec::new();",
            "    let value: HashMap<i32, String> = [(1, \"value1\".to_string())].iter().cloned().collect();",
            "    to_writer_pretty(writer, &value);",
            "    let writer = Vec::new();",
            "    let value: HashMap<i32, String> = [(1, \"value1\".to_string())].iter().cloned().collect();",
            "    assert!(std::panic::catch_unwind(|| to_writer_pretty(writer, &value)).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]