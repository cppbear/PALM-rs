[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"42\".as_bytes();",
          "    let result: Result<i32> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"42\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"42\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 42);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"42\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"42\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"42\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"42\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 42);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"3.14\".as_bytes();",
          "    let result: Result<f64> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"3.14\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"3.14\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 3.14);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"3.14\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"3.14\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"3.14\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"3.14\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 3.14);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"18446744073709551615\".as_bytes();",
          "    let result: Result<u128> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 18446744073709551615);"
          ],
          [
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    assert!(result.unwrap_err().is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 18446744073709551615);",
            "}"
          ],
          [
            "{",
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    let input = \"18446744073709551615\".as_bytes();",
            "    let result: Result<u128> = from_trait(StrRead::new(input));",
            "    assert!(result.unwrap_err().is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"-15\".as_bytes();",
          "    let result: Result<i32> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"-15\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"-15\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), -15);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"-15\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"-15\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"-15\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"-15\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), -15);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"0\".as_bytes();",
          "    let result: Result<i32> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"0\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"0\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"0\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"0\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"0\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"0\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert_eq!(result.unwrap(), 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"1e308\".as_bytes();",
          "    let result: Result<f64> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"1e308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    let deserialize_result = de::Deserialize::deserialize(&mut de);",
            "    assert!(deserialize_result.is_ok());"
          ],
          [
            "    let input = \"1e308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    let deserialize_result = de::Deserialize::deserialize(&mut de);",
            "    let value = deserialize_result.unwrap();",
            "    assert_eq!(value, 1e308);"
          ],
          [
            "    let input = \"1e308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    let deserialize_result = de::Deserialize::deserialize(&mut de);",
            "    let value = deserialize_result.unwrap();",
            "    let end_result = de.end();",
            "    assert!(end_result.is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"1e308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    let deserialize_result = de::Deserialize::deserialize(&mut de);",
            "    assert!(deserialize_result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"1e308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    let deserialize_result = de::Deserialize::deserialize(&mut de);",
            "    let value = deserialize_result.unwrap();",
            "    assert_eq!(value, 1e308);",
            "}"
          ],
          [
            "{",
            "    let input = \"1e308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    let deserialize_result = de::Deserialize::deserialize(&mut de);",
            "    let value = deserialize_result.unwrap();",
            "    let end_result = de.end();",
            "    assert!(end_result.is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"1e-308\".as_bytes();",
          "    let result: Result<f64> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.remaining_depth == 128);"
          ],
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.scratch.is_empty());"
          ],
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.peek().is_ok());"
          ],
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.parse_whitespace().is_ok());"
          ],
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de::Deserialize::deserialize(&mut de).is_ok());"
          ],
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.end().is_ok());"
          ],
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(result.unwrap() == 1e-308);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.remaining_depth == 128);",
            "}"
          ],
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.scratch.is_empty());",
            "}"
          ],
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.peek().is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.parse_whitespace().is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de::Deserialize::deserialize(&mut de).is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(de.end().is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"1e-308\".as_bytes();",
            "    let result: Result<f64> = from_trait(StrRead::new(input));",
            "    let input = \"1e-308\".as_bytes();",
            "    let de = Deserializer::new(StrRead::new(input));",
            "    assert!(result.unwrap() == 1e-308);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"  12345  \".as_bytes();",
          "    let result: Result<i32> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"  12345  \".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"  12345  \".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let value = result.unwrap();",
            "    assert_eq!(value, 12345);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"  12345  \".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"  12345  \".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"  12345  \".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"  12345  \".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let value = result.unwrap();",
            "    assert_eq!(value, 12345);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input = \"\".as_bytes();",
          "    let result: Result<i32> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"\".as_bytes();",
            "    let deserializer = Deserializer::new(StrRead::new(input));",
            "    let result = deserializer.deserialize_number(visitor);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input = \"\".as_bytes();",
            "    let deserializer = Deserializer::new(StrRead::new(input));",
            "    let result = deserializer.deserialize_number(visitor);",
            "    let end_result = deserializer.end();",
            "    assert!(end_result.is_ok());"
          ],
          [
            "    let input = \"\".as_bytes();",
            "    let deserializer = Deserializer::new(StrRead::new(input));",
            "    let result = deserializer.deserialize_number(visitor);",
            "    let end_result = deserializer.end();",
            "    assert_eq!(result.unwrap(), expected_value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"\".as_bytes();",
            "    let deserializer = Deserializer::new(StrRead::new(input));",
            "    let result = deserializer.deserialize_number(visitor);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"\".as_bytes();",
            "    let deserializer = Deserializer::new(StrRead::new(input));",
            "    let result = deserializer.deserialize_number(visitor);",
            "    let end_result = deserializer.end();",
            "    assert!(end_result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input = \"\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"\".as_bytes();",
            "    let deserializer = Deserializer::new(StrRead::new(input));",
            "    let result = deserializer.deserialize_number(visitor);",
            "    let end_result = deserializer.end();",
            "    assert_eq!(result.unwrap(), expected_value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let input = \"12a34\".as_bytes();",
          "    let result: Result<i32> = from_trait(StrRead::new(input));",
          "}"
        ],
        "oracles": [
          [
            "    let input = \"12a34\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input = \"12a34\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    let input = \"12a34\".as_bytes();",
            "    let result: Result<i32> = from_trait(StrRead::new(input));",
            "    assert!(result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]