[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'0'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_err());"
          ],
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert_eq!(result.unwrap_err().code(), ErrorCode::InvalidNumber);"
          ],
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    assert_eq!(value, 123);"
          ],
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_err());"
          ],
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert_eq!(result.unwrap_err().code(), ErrorCode::InvalidNumber);"
          ],
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'3', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'3', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    assert_eq!(value, 235);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert_eq!(result.unwrap_err().code(), ErrorCode::InvalidNumber);",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    assert_eq!(value, 123);",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert_eq!(result.unwrap_err().code(), ErrorCode::InvalidNumber);",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'3', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    } else {",
            "    panic!(\"Expected a U64, but got something else.\");",
            "    }",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'3', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    if let ParserNumber::U64(value) = result.unwrap() {",
            "    assert_eq!(value, 235);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'5'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let read = vec![b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let value = result.unwrap();",
            "    assert!(matches!(value, ParserNumber::U64(5)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let value = result.unwrap();",
            "    assert!(matches!(value, ParserNumber::U64(5)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'1', b'2'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.read.next(), Ok(Some(b'1')));"
          ],
          [
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.peek_or_null(), Ok(b'2'));"
          ],
          [
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.parse_number(true, 1), Ok(ParserNumber::U64(12)));"
          ],
          [
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.next_char(), Ok(Some(b'2')));"
          ],
          [
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.next_char(), Ok(None));"
          ],
          [
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.read.position().byte_offset(), 2);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'1', b'2'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.read.next(), Ok(Some(b'1')));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'2'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.peek_or_null(), Ok(b'2'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'2'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.parse_number(true, 1), Ok(ParserNumber::U64(12)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'2'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.next_char(), Ok(Some(b'2')));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'2'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.next_char(), Ok(None));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'2'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'2'];",
            "    assert_eq!(deserializer.read.position().byte_offset(), 2);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'1', b'0', b'0'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_ok());"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'1'));"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.peek_or_null().unwrap(), b'0');"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_long_integer(true).is_ok());"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_number(true, 100).is_ok());"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_ok());"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'0'));"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_ok());"
          ],
          [
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'0'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'1'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.peek_or_null().unwrap(), b'0');",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_long_integer(true).is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_number(true, 100).is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'0'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'0'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'2', b'5', b'3', b'1'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_integer(true).is_ok());"
          ],
          [
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    assert_eq!(value, 2531);"
          ],
          [
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'5'));"
          ],
          [
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert!(deserializer.next_char().is_some());"
          ],
          [
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert_eq!(deserializer.peek_or_null().unwrap(), Some(b'5'));"
          ],
          [
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert!(deserializer.parse_number(true, 253).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_integer(true).is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    assert_eq!(value, 2531);",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert_eq!(deserializer.next_char().unwrap(), Some(b'5'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert!(deserializer.next_char().is_some());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert_eq!(deserializer.peek_or_null().unwrap(), Some(b'5'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'2', b'5', b'3', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    if let Ok(ParserNumber::U64(value)) = deserializer.parse_integer(true) {",
            "    }",
            "    assert!(deserializer.parse_number(true, 253).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    assert!(result_invalid.is_err());"
          ],
          [
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    assert_eq!(result_invalid.unwrap_err().code(), ErrorCode::InvalidNumber);"
          ],
          [
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    let mut deserializer_eof = Deserializer { read: SliceRead::new(&[]), scratch: vec![], remaining_depth: 0 };",
            "    let result_eof = deserializer_eof.parse_integer(true);",
            "    assert!(result_eof.is_err());"
          ],
          [
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    let mut deserializer_eof = Deserializer { read: SliceRead::new(&[]), scratch: vec![], remaining_depth: 0 };",
            "    let result_eof = deserializer_eof.parse_integer(true);",
            "    assert_eq!(result_eof.unwrap_err().code(), ErrorCode::EofWhileParsingValue);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    assert!(result_invalid.is_err());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    assert_eq!(result_invalid.unwrap_err().code(), ErrorCode::InvalidNumber);",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    let mut deserializer_eof = Deserializer { read: SliceRead::new(&[]), scratch: vec![], remaining_depth: 0 };",
            "    let result_eof = deserializer_eof.parse_integer(true);",
            "    assert!(result_eof.is_err());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'1', b'8', b'4', b'4', b'6', b'7', b'4', b'0', b'7', b'3', b'7', b'0', b'9', b'5', b'5', b'1', b'6', b'1', b'5'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let result = deserializer.parse_integer(true);",
            "    let number = result.unwrap();",
            "    match number {",
            "    ParserNumber::U64(value) => assert_eq!(value, 18446744073709551615),",
            "    _ => panic!(\"Expected a u64 value\"),",
            "    }",
            "    let mut deserializer_invalid = Deserializer { read: SliceRead::new(&[b'0', b'0']), scratch: vec![], remaining_depth: 0 };",
            "    let result_invalid = deserializer_invalid.parse_integer(true);",
            "    let mut deserializer_eof = Deserializer { read: SliceRead::new(&[]), scratch: vec![], remaining_depth: 0 };",
            "    let result_eof = deserializer_eof.parse_integer(true);",
            "    assert_eq!(result_eof.unwrap_err().code(), ErrorCode::EofWhileParsingValue);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'0', b'0'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Err(Error::syntax(ErrorCode::InvalidNumber, position.line, position.column)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_integer(true).is_ok());"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(0)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(123)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(1)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(234)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(1e12)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(1e7)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(1e7 + 1)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(2e7 + 1)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Err(Error::syntax(ErrorCode::InvalidNumber, position.line, position.column)));"
          ],
          [
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'9', b'8', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Err(Error::syntax(ErrorCode::InvalidNumber, position.line, position.column)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Err(Error::syntax(ErrorCode::InvalidNumber, position.line, position.column)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_integer(true).is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(0)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(123)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(1)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(234)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(1e12)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(1e7)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(1e7 + 1)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::F64(2e7 + 1)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Err(Error::syntax(ErrorCode::InvalidNumber, position.line, position.column)));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'2', b'3'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'3', b'4'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'1', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'2', b'0', b'0', b'0', b'0', b'0', b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'9', b'9', b'9', b'9'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let read = vec![b'9', b'8', b'0', b'0'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Err(Error::syntax(ErrorCode::InvalidNumber, position.line, position.column)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![b'0', b'1'];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char(), Ok(Some(b'0')));"
          ],
          [
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.peek_or_null(), Ok(b'1'));"
          ],
          [
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_long_integer(true, 0), Ok(ParserNumber::U64(1))); // assuming parse_long_integer returns this"
          ],
          [
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_number(true, 0), Ok(ParserNumber::U64(0))); // adjust based on expected behavior"
          ],
          [
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(0)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.next_char(), Ok(Some(b'0')));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.peek_or_null(), Ok(b'1'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_long_integer(true, 0), Ok(ParserNumber::U64(1))); // assuming parse_long_integer returns this",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_number(true, 0), Ok(ParserNumber::U64(0))); // adjust based on expected behavior",
            "}"
          ],
          [
            "{",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![b'0', b'1'];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert_eq!(deserializer.parse_integer(true), Ok(ParserNumber::U64(0)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let read = vec![];",
          "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
          "    let _ = deserializer.parse_integer(true);",
          "}"
        ],
        "oracles": [
          [
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_err());"
          ],
          [
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_long_integer(true, 0).is_err());"
          ],
          [
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.next_char(), Ok(b'0')));"
          ],
          [
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.next_char(), Ok(c) if c >= b'1' && c <= b'9'));"
          ],
          [
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.peek_or_null(), Ok(c) if c >= b'0' && c <= b'9'));"
          ],
          [
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_long_integer(true, 0).is_ok());"
          ],
          [
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.peek_or_null(), Ok(c) if !(c >= b'0' && c <= b'9')));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.next_char().is_err());",
            "}"
          ],
          [
            "{",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_long_integer(true, 0).is_err());",
            "}"
          ],
          [
            "{",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.next_char(), Ok(b'0')));",
            "}"
          ],
          [
            "{",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.next_char(), Ok(c) if c >= b'1' && c <= b'9'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.peek_or_null(), Ok(c) if c >= b'0' && c <= b'9'));",
            "}"
          ],
          [
            "{",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(deserializer.parse_long_integer(true, 0).is_ok());",
            "}"
          ],
          [
            "{",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    let _ = deserializer.parse_integer(true);",
            "    let read = vec![];",
            "    let mut deserializer = Deserializer { read: SliceRead::new(&read), scratch: vec![], remaining_depth: 0 };",
            "    assert!(matches!(deserializer.peek_or_null(), Ok(c) if !(c >= b'0' && c <= b'9')));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]