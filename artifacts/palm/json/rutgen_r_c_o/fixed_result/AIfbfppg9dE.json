{"function_name":"serde_json::de::de::MapAccess<'a, R>::new","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/de.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":8,"tests_lines":[11,11,11,11,11,11,11,11],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":7,"tests_compiled_rate":87.5,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":7,"tests_passed":6,"tests_passed_rate":85.71428571428571,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1976,1977,1978],"codes_lines_covered":[[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: Vec::new(),","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 0, };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.first, true);","}"],[1976,1977,1978]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: Vec::new(),","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 0, };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.de as *const _, &deserializer as *const _);","}"],[1976,1977,1978]],[["{","   let mut deserializer = Deserializer {  ","       read: Vec::<u8>::new(),  ","       scratch: vec![1, 2, 3],  ","       remaining_depth: 0,  ","   };  ","   let _map_access = MapAccess::new(&mut deserializer);  ","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![1, 2, 3], remaining_depth: 0 };  ","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.first, true);","}"],[1976,1977,1978]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","        scratch: vec![1, 2, 3],","        remaining_depth: 0,","    };","    let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![1, 2, 3], remaining_depth: 0 };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.de as *const _, &deserializer as *const _);","}"],[1976,1977,1978]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: vec![0; 256],","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![0; 256], remaining_depth: 0 };","   let map_access = MapAccess::new(&mut deserializer);","   assert_eq!(map_access.first, true);","}"],[1976,1977,1978]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: vec![0; 256],","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![0; 256], remaining_depth: 0 };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.de as *const _, &deserializer as *const _);","}"],[1976,1977,1978]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: Vec::new(),","       remaining_depth: 1,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 1 };","   let _map_access = MapAccess::new(&mut deserializer);","    assert_eq!(_map_access.first, true);","}"],[1976,1977,1978]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: Vec::new(),","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 0, };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.first, true);","}"],[]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: Vec::new(),","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 0, };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.de as *const _, &deserializer as *const _);","}"],[]],[["{","   let mut deserializer = Deserializer {  ","       read: Vec::<u8>::new(),  ","       scratch: vec![1, 2, 3],  ","       remaining_depth: 0,  ","   };  ","   let _map_access = MapAccess::new(&mut deserializer);  ","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![1, 2, 3], remaining_depth: 0 };  ","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.first, true);","}"],[]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","        scratch: vec![1, 2, 3],","        remaining_depth: 0,","    };","    let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![1, 2, 3], remaining_depth: 0 };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.de as *const _, &deserializer as *const _);","}"],[]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: vec![0; 256],","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![0; 256], remaining_depth: 0 };","   let map_access = MapAccess::new(&mut deserializer);","   assert_eq!(map_access.first, true);","}"],[]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: vec![0; 256],","       remaining_depth: 0,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: vec![0; 256], remaining_depth: 0 };","    let map_access = MapAccess::new(&mut deserializer);","    assert_eq!(map_access.de as *const _, &deserializer as *const _);","}"],[]],[["{","   let mut deserializer = Deserializer {","       read: Vec::<u8>::new(),","       scratch: Vec::new(),","       remaining_depth: 1,","   };","   let _map_access = MapAccess::new(&mut deserializer);","   let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 1 };","   let _map_access = MapAccess::new(&mut deserializer);","    assert_eq!(_map_access.first, true);","}"],[]]]}