{"function_name":"serde_json::number::number::Number::from_u128","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/number.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":22,"tests_lines":[7,7,7,7,6,8,13,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"oracles":7,"oracles_compiled":6,"oracles_compiled_rate":85.71428571428571,"tests_compiled":19,"tests_compiled_rate":86.36363636363636,"oracles_run":6,"oracles_passed":4,"oracles_passed_rate":66.66666666666666,"tests_run":19,"tests_passed":9,"tests_passed_rate":47.368421052631575,"lines":9,"lines_covered":9,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[264,265,266,267,268,269,271,279,280],"codes_lines_covered":[[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert!(result.is_some());","}"],[264,265,266,267,268,269,279,280]],[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert_eq!(result.unwrap().as_u64(), Some(0));","}"],[264,265,266,267,268,269,279,280]],[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert_eq!(result.unwrap().as_i64(), Some(0));","}"],[264,265,266,267,268,269,279,280]],[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert_eq!(result.unwrap().as_f64(), Some(0.0));","}"],[264,265,266,267,268,269,279,280]],[["{","    let input: u128 = 18_446_744_073_709_551_615; // edge case upper bound","    Number::from_u128(input);","    let n = Number::from_u128(input);","    assert!(n.is_none());","}"],[264,265,266,267,268,269,279,280]],[["{","    let input: u128 = 18_446_744_073_709_551_616; // test input greater than u64::MAX","    let result = Number::from_u128(input);","    assert!(result.is_none()); // excepted to evaluate to None if not under arbitrary precision","    let input: u128 = 18_446_744_073_709_551_616;","    let result = Number::from_u128(input);","    assert!(result.is_none());","}"],[264,268,271,280]],[["{","    let result = Number::from_u128(1 << 64); // 2^64","    let result = Number::from_u128(1 << 64); // 2^64","    assert!(result.is_some());","}"],[264,268,271,280]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   let result = result.unwrap(); // Unwrap to get the Number","   assert!(result.as_u64().is_none());","}"],[264,268,271,280]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   let result = result.as_ref(); // Moved from Number to Option<Number>","   assert!(result.is_none());","}"],[264,268,271,280]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   let result = result.as_ref(); // Use as_ref to get a reference to the Option","   assert!(result.is_none());","}"],[264,268,271,280]],[["{","   let result = Number::from_u128(1 << 64).unwrap(); // 2^64","   assert!(result.as_i128().is_some());","   ","}"],[264,268,271,280]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   assert!(result.is_some()); ","   assert!(result.unwrap().as_u128().is_some());","}"],[264,268,271,280]],[["{","    let result = Number::from_u128(u128::MAX); // maximum value for u128","    let n = Number::from_u128(u128::MAX);","    assert!(n.is_some());","}"],[264,268,271,280]],[["{","   let n = Number::from_u128(u128::MAX).unwrap();  ","   assert!(n.as_u64().is_none());  "," ","}"],[264,268,271,280]],[["{","   let result = Number::from_u128(u128::MAX); // maximum value for u128  ","   let n = result.unwrap();  ","   assert!(n.as_f64().is_none());  ","}"],[264,268,271,280]],[["{","   let n = Number::from_u128(u128::MAX); // maximum value for u128","   assert!(n.is_some()); // Check if the Number is Some","   assert!(n.unwrap().as_u128().is_some()); // Now unwrap to access the underlying Number and assert as u128","}"],[264,268,271,280]],[["{","   let result = Number::from_u128(u128::MAX); // maximum value for u128  ","   let n = result.unwrap();  ","   assert!(n.as_i128().is_none());  ","}"],[264,268,271,280]],[["{","    let result = Number::from_u128(10_000_000_000_000_000_000); // A value greater than u64::MAX","    let result = Number::from_u128(10_000_000_000_000_000_000);","    assert!(result.is_some());","}"],[264,265,266,267,268,269,279,280]],[["{","    let result = Number::from_u128(10_000_000_000_000_000_000); // A value greater than u64::MAX","    let result = Number::from_u128(10_000_000_000_000_000_000);","    assert!(matches!(result.as_ref().unwrap().n, N::PosInt(_)));","}"],[264,265,266,267,268,269,279,280]]],"codes_branches":[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert!(result.is_some());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":false}]],[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert_eq!(result.unwrap().as_u64(), Some(0));","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":false}]],[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert_eq!(result.unwrap().as_i64(), Some(0));","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":false}]],[["{","    let input: u128 = 0; // edge case lower bound","    Number::from_u128(input);","    let input: u128 = 0;","    let result = Number::from_u128(input);","    assert_eq!(result.unwrap().as_f64(), Some(0.0));","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":false}]],[["{","    let input: u128 = 18_446_744_073_709_551_615; // edge case upper bound","    Number::from_u128(input);","    let n = Number::from_u128(input);","    assert!(n.is_none());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":false}]],[["{","    let input: u128 = 18_446_744_073_709_551_616; // test input greater than u64::MAX","    let result = Number::from_u128(input);","    assert!(result.is_none()); // excepted to evaluate to None if not under arbitrary precision","    let input: u128 = 18_446_744_073_709_551_616;","    let result = Number::from_u128(input);","    assert!(result.is_none());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","    let result = Number::from_u128(1 << 64); // 2^64","    let result = Number::from_u128(1 << 64); // 2^64","    assert!(result.is_some());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   let result = result.unwrap(); // Unwrap to get the Number","   assert!(result.as_u64().is_none());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   let result = result.as_ref(); // Moved from Number to Option<Number>","   assert!(result.is_none());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   let result = result.as_ref(); // Use as_ref to get a reference to the Option","   assert!(result.is_none());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let result = Number::from_u128(1 << 64).unwrap(); // 2^64","   assert!(result.as_i128().is_some());","   ","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let result = Number::from_u128(1 << 64); // 2^64","   assert!(result.is_some()); ","   assert!(result.unwrap().as_u128().is_some());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","    let result = Number::from_u128(u128::MAX); // maximum value for u128","    let n = Number::from_u128(u128::MAX);","    assert!(n.is_some());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let n = Number::from_u128(u128::MAX).unwrap();  ","   assert!(n.as_u64().is_none());  "," ","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let result = Number::from_u128(u128::MAX); // maximum value for u128  ","   let n = result.unwrap();  ","   assert!(n.as_f64().is_none());  ","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let n = Number::from_u128(u128::MAX); // maximum value for u128","   assert!(n.is_some()); // Check if the Number is Some","   assert!(n.unwrap().as_u128().is_some()); // Now unwrap to access the underlying Number and assert as u128","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","   let result = Number::from_u128(u128::MAX); // maximum value for u128  ","   let n = result.unwrap();  ","   assert!(n.as_i128().is_none());  ","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":false,"negative":true}]],[["{","    let result = Number::from_u128(10_000_000_000_000_000_000); // A value greater than u64::MAX","    let result = Number::from_u128(10_000_000_000_000_000_000);","    assert!(result.is_some());","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":false}]],[["{","    let result = Number::from_u128(10_000_000_000_000_000_000); // A value greater than u64::MAX","    let result = Number::from_u128(10_000_000_000_000_000_000);","    assert!(matches!(result.as_ref().unwrap().n, N::PosInt(_)));","}"],[{"start_line":268,"start_column":24,"end_line":268,"end_column":29,"positive":true,"negative":false}]]]}