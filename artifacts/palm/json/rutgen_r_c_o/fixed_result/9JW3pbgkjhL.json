{"function_name":"serde_json::de::de::VariantAccess<'a, R>::new","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/de.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":9,"tests_lines":[15,15,15,15,15,5,5,15,17],"oracles":4,"oracles_compiled":1,"oracles_compiled_rate":25.0,"tests_compiled":1,"tests_compiled_rate":11.11111111111111,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[2040,2041,2042],"codes_lines_covered":[[["{","    let mut deserializer = Deserializer {","        read: Vec::<u8>::new(),","        scratch: Vec::new(),","        remaining_depth: 0,","        #[cfg(feature = \"float_roundtrip\")]","        single_precision: false,","        #[cfg(feature = \"unbounded_depth\")]","        disable_recursion_limit: false,","    };","    let variant_access = VariantAccess::new(&mut deserializer);","    let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 0 };","    #[cfg(feature = \"float_roundtrip\")] assert_eq!(deserializer.single_precision, false);","    #[cfg(feature = \"unbounded_depth\")] assert_eq!(deserializer.disable_recursion_limit, false);","    let variant_access = VariantAccess::new(&mut deserializer);","    assert_eq!(variant_access.de as *const _, &deserializer as *const _);","}"],[2040,2041,2042]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut deserializer = Deserializer {","        read: Vec::<u8>::new(),","        scratch: Vec::new(),","        remaining_depth: 0,","        #[cfg(feature = \"float_roundtrip\")]","        single_precision: false,","        #[cfg(feature = \"unbounded_depth\")]","        disable_recursion_limit: false,","    };","    let variant_access = VariantAccess::new(&mut deserializer);","    let mut deserializer = Deserializer { read: Vec::<u8>::new(), scratch: Vec::new(), remaining_depth: 0 };","    #[cfg(feature = \"float_roundtrip\")] assert_eq!(deserializer.single_precision, false);","    #[cfg(feature = \"unbounded_depth\")] assert_eq!(deserializer.disable_recursion_limit, false);","    let variant_access = VariantAccess::new(&mut deserializer);","    assert_eq!(variant_access.de as *const _, &deserializer as *const _);","}"],[]]]}