{"function_name":"serde_json::ser::to_string","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/ser.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":33,"tests_lines":[9,9,13,11,11,11,11,20,20,7,7,7,7,7,7,29,30,30,30,30,30,13,14,13,13,12,12,7,7,7,7,7,8],"oracles":14,"oracles_compiled":13,"oracles_compiled_rate":92.85714285714286,"tests_compiled":30,"tests_compiled_rate":90.9090909090909,"oracles_run":13,"oracles_passed":11,"oracles_passed_rate":84.61538461538461,"tests_run":30,"tests_passed":21,"tests_passed_rate":70.0,"lines":11,"lines_covered":11,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247],"codes_lines_covered":[[["{","  #[derive(serde::Serialize)]  ","  struct NonSerializable;  ","  ","  let _value = NonSerializable;  ","  let result = to_string(&_value);  ","  let _value = NonSerializable;  ","   assert!(result.is_err());  ","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","  #[derive(serde::Serialize)]  ","  struct NonSerializable;  ","  ","  let value = NonSerializable;  ","  let result = to_string(&value);  ","  assert!(result.is_ok());  ","  assert_eq!(result.unwrap(), \"{\\\"type\\\":\\\"NonSerializable\\\"}\");  ","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","   #[derive(serde::Serialize)]","   struct Node<'a> {","       value: i32,","       next: Option<&'a Node<'a>>,","   }","   ","   let node1 = Node { value: 1, next: None };","   let node2 = Node { value: 2, next: Some(&node1) };","   ","   let result = to_string(&node2);","   assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    use std::collections::HashMap;","","    let mut map = HashMap::new();","    map.insert(1, \"value\"); // integer key is non-serializable in a JSON context","    ","    let result = to_string(&map);","    let mut map = HashMap::new();","    map.insert(1, \"value\");","    assert_eq!(result.is_err(), true);","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    use std::collections::HashMap;","","    let mut map = HashMap::new();","    map.insert(1, \"value\"); // integer key is non-serializable in a JSON context","    ","    let result = to_string(&map);","    let mut map = HashMap::new();","    map.insert(1, \"value\");","    assert!(result.is_err());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","   use std::collections::HashMap;  "," ","   let mut map = HashMap::new();  ","   map.insert(1, \"value\"); // integer key is non-serializable in a JSON context  ","   ","   let result = to_string(&map);  ","   let mut map = HashMap::new();  ","   map.insert(1, \"value\");  ","   assert_ne!(result.unwrap_err().to_string(), \"\");  ","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = 42;","    let result = to_string(&value);","    let value = 42;","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = 42;","    let result = to_string(&value);","    let value = 42;","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"42\");","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = \"Hello, world!\";","    let result = to_string(&value);","    let value = \"Hello, world!\";","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = \"Hello, world!\";","    let result = to_string(&value);","    let value = \"Hello, world!\";","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"Hello, world!\");","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"[1,2,3,4,5]\");","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"\\\"a\\\":\"));","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"\\\"b\\\":\"));","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"10\"));","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"\\\"Inner String\\\"\"));","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"[1,2,3]\"));","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    use std::collections::HashMap;","","   let mut map = HashMap::new();","   map.insert(\"key1\", 100);","   map.insert(\"key2\", 200);","   let _result = to_string(&map);","   let mut map = HashMap::new();","   map.insert(\"key1\", 100);","   map.insert(\"key2\", 200);","   let result = to_string(&map);","   assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    use std::collections::HashMap;","","   let mut map = HashMap::new();","   map.insert(\"key1\", 100);","   map.insert(\"key2\", 200);","   let result = to_string(&map).unwrap();  ","   assert_eq!(result, r#\"{\"key1\":100,\"key2\":200}\"#);  ","   let mut map = HashMap::new();  ","   map.insert(\"key1\", 100);  ","   map.insert(\"key2\", 200);  ","   let result = to_string(&map).unwrap();  ","   assert_eq!(result, r#\"{\"key1\":100,\"key2\":200}\"#);","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    enum MyEnum {","        VariantOne,","        VariantTwo(i32),","    }","","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    enum MyEnum {","        VariantOne,","        VariantTwo(i32),","    }","","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    assert_eq!(result.unwrap(), r#\"{\"VariantTwo\":10}\"#);","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct OptionStruct {","        optional: Option<String>,","    }","","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    #[derive(serde::Serialize)]","    struct OptionStruct {","        optional: Option<String>,","    }","","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"{\\\"optional\\\":\\\"Some Value\\\"}\");","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = \"\";","    let result = to_string(&value);","    let value = \"\";","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = \"\";","    let result = to_string(&value);","    let value = \"\";","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"\");","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"[]\");","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]],[["{","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    let string = result.unwrap();","    assert_eq!(string, \"String with \\\"quotes\\\", newline \\n and backslash \\\\\".to_string());","}"],[2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247]]],"codes_branches":[],"codes_branches_covered":[[["{","  #[derive(serde::Serialize)]  ","  struct NonSerializable;  ","  ","  let _value = NonSerializable;  ","  let result = to_string(&_value);  ","  let _value = NonSerializable;  ","   assert!(result.is_err());  ","}"],[]],[["{","  #[derive(serde::Serialize)]  ","  struct NonSerializable;  ","  ","  let value = NonSerializable;  ","  let result = to_string(&value);  ","  assert!(result.is_ok());  ","  assert_eq!(result.unwrap(), \"{\\\"type\\\":\\\"NonSerializable\\\"}\");  ","}"],[]],[["{","   #[derive(serde::Serialize)]","   struct Node<'a> {","       value: i32,","       next: Option<&'a Node<'a>>,","   }","   ","   let node1 = Node { value: 1, next: None };","   let node2 = Node { value: 2, next: Some(&node1) };","   ","   let result = to_string(&node2);","   assert!(result.is_ok());","}"],[]],[["{","    use std::collections::HashMap;","","    let mut map = HashMap::new();","    map.insert(1, \"value\"); // integer key is non-serializable in a JSON context","    ","    let result = to_string(&map);","    let mut map = HashMap::new();","    map.insert(1, \"value\");","    assert_eq!(result.is_err(), true);","}"],[]],[["{","    use std::collections::HashMap;","","    let mut map = HashMap::new();","    map.insert(1, \"value\"); // integer key is non-serializable in a JSON context","    ","    let result = to_string(&map);","    let mut map = HashMap::new();","    map.insert(1, \"value\");","    assert!(result.is_err());","}"],[]],[["{","   use std::collections::HashMap;  "," ","   let mut map = HashMap::new();  ","   map.insert(1, \"value\"); // integer key is non-serializable in a JSON context  ","   ","   let result = to_string(&map);  ","   let mut map = HashMap::new();  ","   map.insert(1, \"value\");  ","   assert_ne!(result.unwrap_err().to_string(), \"\");  ","}"],[]],[["{","    let value = 42;","    let result = to_string(&value);","    let value = 42;","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    let value = 42;","    let result = to_string(&value);","    let value = 42;","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"42\");","}"],[]],[["{","    let value = \"Hello, world!\";","    let result = to_string(&value);","    let value = \"Hello, world!\";","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    let value = \"Hello, world!\";","    let result = to_string(&value);","    let value = \"Hello, world!\";","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"Hello, world!\");","}"],[]],[["{","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    let value = vec![1, 2, 3, 4, 5];","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"[1,2,3,4,5]\");","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    assert!(result.is_ok());","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"\\\"a\\\":\"));","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"\\\"b\\\":\"));","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"10\"));","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"\\\"Inner String\\\"\"));","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct Inner {","        x: i32,","        y: String,","    }","","    #[derive(serde::Serialize)]","    struct Outer {","        a: Inner,","        b: Vec<i32>,","    }","","    let inner = Inner {","        x: 10,","        y: \"Inner String\".to_string(),","    };","","    let outer = Outer {","        a: inner,","        b: vec![1, 2, 3],","    };","","    let result = to_string(&outer);","    let inner = Inner { x: 10, y: \"Inner String\".to_string() };","    let outer = Outer { a: inner, b: vec![1, 2, 3] };","    let result = to_string(&outer);","    let string = result.unwrap();","    assert!(string.contains(\"[1,2,3]\"));","}"],[]],[["{","    use std::collections::HashMap;","","   let mut map = HashMap::new();","   map.insert(\"key1\", 100);","   map.insert(\"key2\", 200);","   let _result = to_string(&map);","   let mut map = HashMap::new();","   map.insert(\"key1\", 100);","   map.insert(\"key2\", 200);","   let result = to_string(&map);","   assert!(result.is_ok());","}"],[]],[["{","    use std::collections::HashMap;","","   let mut map = HashMap::new();","   map.insert(\"key1\", 100);","   map.insert(\"key2\", 200);","   let result = to_string(&map).unwrap();  ","   assert_eq!(result, r#\"{\"key1\":100,\"key2\":200}\"#);  ","   let mut map = HashMap::new();  ","   map.insert(\"key1\", 100);  ","   map.insert(\"key2\", 200);  ","   let result = to_string(&map).unwrap();  ","   assert_eq!(result, r#\"{\"key1\":100,\"key2\":200}\"#);","}"],[]],[["{","    #[derive(serde::Serialize)]","    enum MyEnum {","        VariantOne,","        VariantTwo(i32),","    }","","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    #[derive(serde::Serialize)]","    enum MyEnum {","        VariantOne,","        VariantTwo(i32),","    }","","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    let value = MyEnum::VariantTwo(10);","    let result = to_string(&value);","    assert_eq!(result.unwrap(), r#\"{\"VariantTwo\":10}\"#);","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct OptionStruct {","        optional: Option<String>,","    }","","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    #[derive(serde::Serialize)]","    struct OptionStruct {","        optional: Option<String>,","    }","","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    let value = OptionStruct { optional: Some(\"Some Value\".to_string()) };","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"{\\\"optional\\\":\\\"Some Value\\\"}\");","}"],[]],[["{","    let value = \"\";","    let result = to_string(&value);","    let value = \"\";","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    let value = \"\";","    let result = to_string(&value);","    let value = \"\";","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"\");","}"],[]],[["{","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    let value: Vec<i32> = Vec::new();","    let result = to_string(&value);","    assert_eq!(result.unwrap(), \"[]\");","}"],[]],[["{","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    assert!(result.is_ok());","}"],[]],[["{","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    let value = \"String with \\\"quotes\\\", newline \\n and backslash \\\\\";","    let result = to_string(&value);","    let string = result.unwrap();","    assert_eq!(string, \"String with \\\"quotes\\\", newline \\n and backslash \\\\\".to_string());","}"],[]]]}