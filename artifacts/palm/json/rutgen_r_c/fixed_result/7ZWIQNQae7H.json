{"function_name":"serde_json::de::de::Deserializer<read::IoRead<R>>::from_reader","tests":5,"tests_lines":[9,8,9,9,9],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":5,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[82,83,84],"codes_lines_covered":[[["{","    use std::io::Cursor;","","    let data = b\"{\\\"key\\\": \\\"value\\\"}\";","    let cursor = Cursor::new(data);","    let deserializer = Deserializer::from_reader(cursor);","    // Check that deserializer has been created with no panic","    assert!(deserializer.remaining_depth == 8); // Assume default depth is 8","}"],[82,83,84]],[["{","    use std::io::Cursor;","","    let data = b\"{key: value}\"; // Invalid JSON (unquoted key)","    let cursor = Cursor::new(data);","    // This should panic due to invalid JSON format","    let _deserializer = Deserializer::from_reader(cursor);","}"],[82,83,84]],[["{","    use std::io::Cursor;","","    let data = b\"\";","    let cursor = Cursor::new(data);","    let deserializer = Deserializer::from_reader(cursor);","    // Check that deserializer is still valid despite empty input","    assert!(deserializer.remaining_depth == 8); // Assume default depth is 8","}"],[82,83,84]],[["{","    use std::io::Cursor;","","    let data = br#\"[{\"key\": {\"nested\": {\"deep\": {\"limit\": \"exceeded\"}}}}]\"#;","    let cursor = Cursor::new(data);","    ","    // Assume the default depth is too low and will panic","    let _deserializer = Deserializer::from_reader(cursor);","}"],[82,83,84]],[["{","    use std::io::Cursor;","","    let large_data = [&b\"{\\\"key\\\": \"[..], &vec![b'0'; 1024].as_slice(), b\"}\"].concat();","    let cursor = Cursor::new(large_data);","    let deserializer = Deserializer::from_reader(cursor);","    // Check that deserializer has been created with no panic, even for large input","    assert!(deserializer.remaining_depth == 8); // Assume default depth is 8","}"],[82,83,84]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::io::Cursor;","","    let data = b\"{\\\"key\\\": \\\"value\\\"}\";","    let cursor = Cursor::new(data);","    let deserializer = Deserializer::from_reader(cursor);","    // Check that deserializer has been created with no panic","    assert!(deserializer.remaining_depth == 8); // Assume default depth is 8","}"],[]],[["{","    use std::io::Cursor;","","    let data = b\"{key: value}\"; // Invalid JSON (unquoted key)","    let cursor = Cursor::new(data);","    // This should panic due to invalid JSON format","    let _deserializer = Deserializer::from_reader(cursor);","}"],[]],[["{","    use std::io::Cursor;","","    let data = b\"\";","    let cursor = Cursor::new(data);","    let deserializer = Deserializer::from_reader(cursor);","    // Check that deserializer is still valid despite empty input","    assert!(deserializer.remaining_depth == 8); // Assume default depth is 8","}"],[]],[["{","    use std::io::Cursor;","","    let data = br#\"[{\"key\": {\"nested\": {\"deep\": {\"limit\": \"exceeded\"}}}}]\"#;","    let cursor = Cursor::new(data);","    ","    // Assume the default depth is too low and will panic","    let _deserializer = Deserializer::from_reader(cursor);","}"],[]],[["{","    use std::io::Cursor;","","    let large_data = [&b\"{\\\"key\\\": \"[..], &vec![b'0'; 1024].as_slice(), b\"}\"].concat();","    let cursor = Cursor::new(large_data);","    let deserializer = Deserializer::from_reader(cursor);","    // Check that deserializer has been created with no panic, even for large input","    assert!(deserializer.remaining_depth == 8); // Assume default depth is 8","}"],[]]]}