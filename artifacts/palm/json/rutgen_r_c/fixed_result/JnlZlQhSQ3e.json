{"function_name":"serde_json::read::read::SliceRead<'a>::position_of_index","tests":10,"tests_lines":[13,13,13,13,13,12,12,12,12,14],"oracles":10,"oracles_compiled":10,"oracles_compiled_rate":100.0,"tests_compiled":10,"tests_compiled_rate":100.0,"oracles_run":10,"oracles_passed":6,"oracles_passed_rate":60.0,"tests_run":10,"tests_passed":6,"tests_passed_rate":60.0,"lines":9,"lines_covered":9,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[421,422,423,424,426,427,428,429,430],"codes_lines_covered":[[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"HelloWorld\"; // No new lines","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(5);","    assert_eq!(position.line, 1); // There should be 1 line","    assert_eq!(position.column, 5); // Column should be 5 for character index 5","}"],[421,422,424,426,427,428,429,430]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"Hello\\nWorld\"; // Contains one newline","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(6); // Position after '\\n'","    assert_eq!(position.line, 2); // 2 lines","    assert_eq!(position.column, 0); // Column after newline should be 0","}"],[421,422,423,426,427,428,429,430]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"Line1\\nLine2\\nLine3\"; // Contains multiple newlines","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(11); // Position at '2'","    assert_eq!(position.line, 2); // 2 lines total","    assert_eq!(position.column, 1); // Column should be 1 for index 11","}"],[421,422,423,426,427,428,429,430]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"\\nHello\\n\"; // Newline at the start","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(1); // Position after the first byte '\\n'","    assert_eq!(position.line, 1); // 1 line only","    assert_eq!(position.column, 1); // Column should be 1 for index 1","}"],[421,422,423,426,427,428,429,430]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"Hello\\nWorld\"; // End of slice after characters","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(10); // Position at the end of the slice","    assert_eq!(position.line, 2); // 2 lines total","    assert_eq!(position.column, 5); // Column at end of second line","}"],[421,422,423,426,427,428,429,430]],[["{","    let data = b\"Hello World! This is a test.\"; ","    let slice_read = SliceRead::new(data);","    ","    // Test with an index that is within bounds and where there is no newline.","    let index = 5;  // 'o' in \"Hello\"","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 1);","    assert_eq!(position.column, index); // column should equal the index since no newlines.","}"],[421,422,424,426,427,428,429,430]],[["{","    let data = b\"Hello World!\\nThis is a test.\"; ","    let slice_read = SliceRead::new(data);","    ","    // Test with an index where there is a newline before it.","    let index = 13;  // After the '!' in \"Hello World!\"","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 2); // There's one newline, so line should be 2.","    assert_eq!(position.column, 0); // The column should be 0 since this is right after the newline.","}"],[421,422,423,426,427,428,429,430]],[["{","    let data = b\"\";","    let slice_read = SliceRead::new(data);","    ","    // Test with an index of 0 on an empty slice.","    let index = 0;","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 1); // Even with an empty slice, it should return line 1.","    assert_eq!(position.column, 0); // Column should be 0 since there's no character at index.","}"],[421,422,424,426,427,428,429,430]],[["{","    let data = b\"a\";","    let slice_read = SliceRead::new(data);","    ","    // Test with an index of 0 on a slice with a single character.","    let index = 0;","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 1); // Line count should still be 1.","    assert_eq!(position.column, 0); // Column should be 0 for index 0.","}"],[421,422,424,426,427,428,429,430]],[["{","    let data = b\"Line1\\nLine2\\nLine3\\n\"; ","    let slice_read = SliceRead::new(data);","    ","    // Testing multiple indices for their positions","    let indexes = vec![0, 5, 11, 17]; // Start of Line1, 'n' of Line1, start of Line2, start of Line3","    let expected_positions = vec![(1, 0), (1, 1), (2, 0), (3, 0)]; // Expected (line, column)","","    for (i, &index) in indexes.iter().enumerate() {","        let position = slice_read.position_of_index(index);","        assert_eq!(position.line, expected_positions[i].0);","        assert_eq!(position.column, expected_positions[i].1);","    }","}"],[421,422,424,426,427,428,429,430]]],"codes_branches":[],"codes_branches_covered":[[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"HelloWorld\"; // No new lines","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(5);","    assert_eq!(position.line, 1); // There should be 1 line","    assert_eq!(position.column, 5); // Column should be 5 for character index 5","}"],[]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"Hello\\nWorld\"; // Contains one newline","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(6); // Position after '\\n'","    assert_eq!(position.line, 2); // 2 lines","    assert_eq!(position.column, 0); // Column after newline should be 0","}"],[]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"Line1\\nLine2\\nLine3\"; // Contains multiple newlines","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(11); // Position at '2'","    assert_eq!(position.line, 2); // 2 lines total","    assert_eq!(position.column, 1); // Column should be 1 for index 11","}"],[]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"\\nHello\\n\"; // Newline at the start","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(1); // Position after the first byte '\\n'","    assert_eq!(position.line, 1); // 1 line only","    assert_eq!(position.column, 1); // Column should be 1 for index 1","}"],[]],[["{","#[should_panic]","fn test_position_of_index_panic_condition() {","    let data = b\"Hello\\nWorld\"; // Valid data","    let slice_read = SliceRead::new(data);","    let _ = slice_read.position_of_index(12); // Out of bounds index, should panic","}","    let data = b\"Hello\\nWorld\"; // End of slice after characters","    let slice_read = SliceRead::new(data);","    let position = slice_read.position_of_index(10); // Position at the end of the slice","    assert_eq!(position.line, 2); // 2 lines total","    assert_eq!(position.column, 5); // Column at end of second line","}"],[]],[["{","    let data = b\"Hello World! This is a test.\"; ","    let slice_read = SliceRead::new(data);","    ","    // Test with an index that is within bounds and where there is no newline.","    let index = 5;  // 'o' in \"Hello\"","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 1);","    assert_eq!(position.column, index); // column should equal the index since no newlines.","}"],[]],[["{","    let data = b\"Hello World!\\nThis is a test.\"; ","    let slice_read = SliceRead::new(data);","    ","    // Test with an index where there is a newline before it.","    let index = 13;  // After the '!' in \"Hello World!\"","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 2); // There's one newline, so line should be 2.","    assert_eq!(position.column, 0); // The column should be 0 since this is right after the newline.","}"],[]],[["{","    let data = b\"\";","    let slice_read = SliceRead::new(data);","    ","    // Test with an index of 0 on an empty slice.","    let index = 0;","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 1); // Even with an empty slice, it should return line 1.","    assert_eq!(position.column, 0); // Column should be 0 since there's no character at index.","}"],[]],[["{","    let data = b\"a\";","    let slice_read = SliceRead::new(data);","    ","    // Test with an index of 0 on a slice with a single character.","    let index = 0;","    ","    let position = slice_read.position_of_index(index);","    ","    assert_eq!(position.line, 1); // Line count should still be 1.","    assert_eq!(position.column, 0); // Column should be 0 for index 0.","}"],[]],[["{","    let data = b\"Line1\\nLine2\\nLine3\\n\"; ","    let slice_read = SliceRead::new(data);","    ","    // Testing multiple indices for their positions","    let indexes = vec![0, 5, 11, 17]; // Start of Line1, 'n' of Line1, start of Line2, start of Line3","    let expected_positions = vec![(1, 0), (1, 1), (2, 0), (3, 0)]; // Expected (line, column)","","    for (i, &index) in indexes.iter().enumerate() {","        let position = slice_read.position_of_index(index);","        assert_eq!(position.line, expected_positions[i].0);","        assert_eq!(position.column, expected_positions[i].1);","    }","}"],[]]]}