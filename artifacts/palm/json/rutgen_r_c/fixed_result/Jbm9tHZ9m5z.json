{"function_name":"serde_json::ser::format_escaped_str_contents","tests":19,"tests_lines":[38,48,38,37,67,37,44,40,41,44,37,47,47,50,48,55,35,35,48],"oracles":19,"oracles_compiled":1,"oracles_compiled_rate":5.263157894736842,"tests_compiled":1,"tests_compiled_rate":5.263157894736842,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":30,"lines_covered":21,"lines_coveraged_rate":70.0,"branches":6,"branches_covered":2,"branches_coverage_rate":33.33333333333333,"codes_lines":[2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2104,2105,2106,2107,2108,2109,2110,2111,2112,2114,2115,2117,2120,2121,2122,2123,2124,2125],"codes_lines_covered":[[["{","    struct MockWriter {","        output: String,","    }","    ","    impl io::Write for MockWriter {","        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {","            self.output.push_str(&String::from_utf8_lossy(buf));","            Ok(buf.len())","        }","        fn flush(&mut self) -> io::Result<()> {","            Ok(())","        }","    }","    ","    struct MockFormatter{","        written_fragments: Vec<String>,","    }","    ","    impl MockFormatter {","        fn new() -> Self {","            MockFormatter {","                written_fragments: Vec::new(),","            }","        }","    }","","    impl Formatter for MockFormatter {","       fn write_string_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>","       where","           W: ?Sized + io::Write,","       {","           self.written_fragments.push(fragment.to_string());","           writer.write_all(fragment.as_bytes())?;","           Ok(())","       }","       ","    }","","    let mut writer = MockWriter { output: String::new() };","    let mut formatter = MockFormatter::new();","    let value = \"hello world\";","","    let result = format_escaped_str_contents(&mut writer, &mut formatter, value);","","    assert!(result.is_ok());","    assert_eq!(writer.output, \"hello world\");","}"],[2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2104,2105,2106,2107,2120,2122,2123,2124,2125]]],"codes_branches":[{"start_line":2106,"start_column":12,"end_line":2106,"end_column":23,"positive":true,"negative":false},{"start_line":2110,"start_column":12,"end_line":2110,"end_column":21,"positive":false,"negative":false},{"start_line":2120,"start_column":8,"end_line":2120,"end_column":28,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    struct MockWriter {","        output: String,","    }","    ","    impl io::Write for MockWriter {","        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {","            self.output.push_str(&String::from_utf8_lossy(buf));","            Ok(buf.len())","        }","        fn flush(&mut self) -> io::Result<()> {","            Ok(())","        }","    }","    ","    struct MockFormatter{","        written_fragments: Vec<String>,","    }","    ","    impl MockFormatter {","        fn new() -> Self {","            MockFormatter {","                written_fragments: Vec::new(),","            }","        }","    }","","    impl Formatter for MockFormatter {","       fn write_string_fragment<W>(&mut self, writer: &mut W, fragment: &str) -> io::Result<()>","       where","           W: ?Sized + io::Write,","       {","           self.written_fragments.push(fragment.to_string());","           writer.write_all(fragment.as_bytes())?;","           Ok(())","       }","       ","    }","","    let mut writer = MockWriter { output: String::new() };","    let mut formatter = MockFormatter::new();","    let value = \"hello world\";","","    let result = format_escaped_str_contents(&mut writer, &mut formatter, value);","","    assert!(result.is_ok());","    assert_eq!(writer.output, \"hello world\");","}"],[{"start_line":2106,"start_column":12,"end_line":2106,"end_column":23,"positive":true,"negative":false},{"start_line":2110,"start_column":12,"end_line":2110,"end_column":21,"positive":false,"negative":false},{"start_line":2120,"start_column":8,"end_line":2120,"end_column":28,"positive":false,"negative":true}]]]}