{"function_name":"serde_json::value::de::value::de::<impl serde::Deserializer<'de> for value::Value>::deserialize_enum","tests":9,"tests_lines":[26,26,25,27,26,22,35,34,12],"oracles":9,"oracles_compiled":5,"oracles_compiled_rate":55.55555555555556,"tests_compiled":5,"tests_compiled_rate":55.55555555555556,"oracles_run":5,"oracles_passed":3,"oracles_passed_rate":60.0,"tests_run":5,"tests_passed":3,"tests_passed_rate":60.0,"lines":20,"lines_covered":20,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,341],"codes_lines_covered":[[["{","struct MyVisitor {}","","impl<'de> Visitor<'de> for MyVisitor {","    type Value = ();","","    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","        formatter.write_str(\"an enum\")","    }","","    // Implement other required methods by not actually using them for this test","   fn visit_enum<V>(self, _enum: V) -> Result<Self::Value, <V as serde::de::EnumAccess<'de>>::Error>","   where","        V: EnumAccess<'de>,","    {","        Ok(())","    }","    // Other methods like visit_bool, visit_str, etc., can be added as no-op.","}","    // Create a Value that does not match Value::Object or Value::String","    let value = Value::Null; // This violates both constraints","","    let result: Result<(), Error> = value.deserialize_enum(\"enum_name\", &[\"variant1\", \"variant2\"], MyVisitor {});","","    assert!(result.is_err()); // We expect an error","}"],[321,322,323,324,325,326,327,328,329,330,336,337,338,339,341]],[["{","struct MyVisitor {}","","impl<'de> Visitor<'de> for MyVisitor {","    type Value = ();","","    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","        formatter.write_str(\"an enum\")","    }","","    // Implement other required methods by not actually using them for this test","   fn visit_enum<V>(self, _enum: V) -> Result<(), <V as EnumAccess<'de>>::Error>  ","   where  ","        V: EnumAccess<'de>,","    {","        Ok(())","    }","    // Other methods like visit_bool, visit_str, etc., can be added as no-op.","}","    // Create a Value that does not match Value::Object or Value::String","    let value = Value::Array(vec![Value::Bool(true)]); // This violates both constraints","","    let result: Result<(), Error> = value.deserialize_enum(\"enum_name\", &[\"variant1\", \"variant2\"], MyVisitor {});","","    assert!(result.is_err()); // We expect an error","}"],[321,322,323,324,325,326,327,328,329,330,336,337,338,339,341]],[["{","struct MyVisitor {}","","impl<'de> Visitor<'de> for MyVisitor {","    type Value = ();","","    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","        formatter.write_str(\"an enum\")","    }","","    // Implement other required methods by not actually using them for this test","   fn visit_enum<V>(self, _enum: V) -> Result<Self::Value, V::Error>","   where","       V: EnumAccess<'de>,","   {","       Ok(())","    }","    // Other methods like visit_bool, visit_str, etc., can be added as no-op.","}","    // Create a Value::Object but will handle that case in the expected way","   let value = Value::Object(Map::new()); // This is technically a valid object","   let result: Result<(), Error> = value.deserialize_enum(\"enum_name\", &[\"variant1\", \"variant2\"], MyVisitor {});","   ","   assert!(result.is_ok()); // This should invoke the correct internal logic","}"],[321,322,323,324,325,326,327,328,329,330,331,341]],[["{","   struct DummyVisitor;","   ","  impl<'de> Visitor<'de> for DummyVisitor {","      type Value = String;","      ","     fn visit_enum<V>(self, _enum_access: V) -> Result<Self::Value, <V as EnumAccess<'de>>::Error>","       where","           V: EnumAccess<'de>,","       {","           Ok(\"visited enum\".to_string())","       }","       ","       fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {","           formatter.write_str(\"a variant of the enum\")","        }","","        // Implement other required methods of Visitor with default behavior","    }","","    let value = Value::String(\"variant1\".to_string());","","    let result = value.deserialize_enum(\"test_enum\", &[\"variant1\", \"variant2\"], DummyVisitor);","    assert!(result.is_ok());","    assert_eq!(result.unwrap(), \"visited enum\".to_string());","}"],[321,322,323,324,325,326,327,328,329,330,332,333,334,335,341]],[["{","  struct DummyVisitor;","  ","  impl<'de> Visitor<'de> for DummyVisitor {","      type Value = String;","      ","      fn visit_enum<V>(self, _enum: V) -> Result<Self::Value, <V as EnumAccess<'de>>::Error>","       where","           V: EnumAccess<'de>,","       {","           Ok(\"visited enum\".to_string())","       }","","       fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::result::Result<(), std::fmt::Error> {","           formatter.write_str(\"an enum\")","       }","   }","","   let value = Value::Null; // `Value::Null` should trigger a panic","","    let _ = value.deserialize_enum(\"test_enum\", &[\"variant1\", \"variant2\"], DummyVisitor);","}"],[321,322,323,324,325,326,327,328,329,330,336,337,338,339,341]]],"codes_branches":[],"codes_branches_covered":[[["{","struct MyVisitor {}","","impl<'de> Visitor<'de> for MyVisitor {","    type Value = ();","","    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","        formatter.write_str(\"an enum\")","    }","","    // Implement other required methods by not actually using them for this test","   fn visit_enum<V>(self, _enum: V) -> Result<Self::Value, <V as serde::de::EnumAccess<'de>>::Error>","   where","        V: EnumAccess<'de>,","    {","        Ok(())","    }","    // Other methods like visit_bool, visit_str, etc., can be added as no-op.","}","    // Create a Value that does not match Value::Object or Value::String","    let value = Value::Null; // This violates both constraints","","    let result: Result<(), Error> = value.deserialize_enum(\"enum_name\", &[\"variant1\", \"variant2\"], MyVisitor {});","","    assert!(result.is_err()); // We expect an error","}"],[]],[["{","struct MyVisitor {}","","impl<'de> Visitor<'de> for MyVisitor {","    type Value = ();","","    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","        formatter.write_str(\"an enum\")","    }","","    // Implement other required methods by not actually using them for this test","   fn visit_enum<V>(self, _enum: V) -> Result<(), <V as EnumAccess<'de>>::Error>  ","   where  ","        V: EnumAccess<'de>,","    {","        Ok(())","    }","    // Other methods like visit_bool, visit_str, etc., can be added as no-op.","}","    // Create a Value that does not match Value::Object or Value::String","    let value = Value::Array(vec![Value::Bool(true)]); // This violates both constraints","","    let result: Result<(), Error> = value.deserialize_enum(\"enum_name\", &[\"variant1\", \"variant2\"], MyVisitor {});","","    assert!(result.is_err()); // We expect an error","}"],[]],[["{","struct MyVisitor {}","","impl<'de> Visitor<'de> for MyVisitor {","    type Value = ();","","    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","        formatter.write_str(\"an enum\")","    }","","    // Implement other required methods by not actually using them for this test","   fn visit_enum<V>(self, _enum: V) -> Result<Self::Value, V::Error>","   where","       V: EnumAccess<'de>,","   {","       Ok(())","    }","    // Other methods like visit_bool, visit_str, etc., can be added as no-op.","}","    // Create a Value::Object but will handle that case in the expected way","   let value = Value::Object(Map::new()); // This is technically a valid object","   let result: Result<(), Error> = value.deserialize_enum(\"enum_name\", &[\"variant1\", \"variant2\"], MyVisitor {});","   ","   assert!(result.is_ok()); // This should invoke the correct internal logic","}"],[]],[["{","   struct DummyVisitor;","   ","  impl<'de> Visitor<'de> for DummyVisitor {","      type Value = String;","      ","     fn visit_enum<V>(self, _enum_access: V) -> Result<Self::Value, <V as EnumAccess<'de>>::Error>","       where","           V: EnumAccess<'de>,","       {","           Ok(\"visited enum\".to_string())","       }","       ","       fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {","           formatter.write_str(\"a variant of the enum\")","        }","","        // Implement other required methods of Visitor with default behavior","    }","","    let value = Value::String(\"variant1\".to_string());","","    let result = value.deserialize_enum(\"test_enum\", &[\"variant1\", \"variant2\"], DummyVisitor);","    assert!(result.is_ok());","    assert_eq!(result.unwrap(), \"visited enum\".to_string());","}"],[]],[["{","  struct DummyVisitor;","  ","  impl<'de> Visitor<'de> for DummyVisitor {","      type Value = String;","      ","      fn visit_enum<V>(self, _enum: V) -> Result<Self::Value, <V as EnumAccess<'de>>::Error>","       where","           V: EnumAccess<'de>,","       {","           Ok(\"visited enum\".to_string())","       }","","       fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::result::Result<(), std::fmt::Error> {","           formatter.write_str(\"an enum\")","       }","   }","","   let value = Value::Null; // `Value::Null` should trigger a panic","","    let _ = value.deserialize_enum(\"test_enum\", &[\"variant1\", \"variant2\"], DummyVisitor);","}"],[]]]}