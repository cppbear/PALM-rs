{"function_name":"serde_json::number::number::Number::is_i64","tests":13,"tests_lines":[6,6,6,6,14,14,14,8,4,4,4,4,4],"oracles":13,"oracles_compiled":13,"oracles_compiled_rate":100.0,"tests_compiled":13,"tests_compiled_rate":100.0,"oracles_run":13,"oracles_passed":10,"oracles_passed_rate":76.92307692307693,"tests_run":13,"tests_passed":10,"tests_passed_rate":76.92307692307693,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[81,82,83,84,85,86,90],"codes_lines_covered":[[["{","    // Initialize a Number with a floating point value","    let num = Number { n: N::Float(3.14) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[81,82,83,86,90]],[["{","    // Initialize a Number with a negative floating point value","    let num = Number { n: N::Float(-2.71) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[81,82,83,86,90]],[["{","    // Initialize a Number with zero as a float","    let num = Number { n: N::Float(0.0) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[81,82,83,86,90]],[["{","    // Initialize a Number with a large floating point value","    let num = Number { n: N::Float(1e20) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[81,82,83,86,90]],[["{","    struct NegativeInteger(i64);","","    impl From<NegativeInteger> for Number {","        fn from(neg: NegativeInteger) -> Self {","            Number { n: N::NegInt(neg.0) }","        }","    }","","    let negative_num = NegativeInteger(-1);","    let number: Number = negative_num.into();","    ","    assert!(number.is_i64());","}"],[81,82,83,85,90]],[["{","    struct Zero;","","    impl From<Zero> for Number {","        fn from(_: Zero) -> Self {","            Number { n: N::PosInt(0) }","        }","    }","","    let zero = Zero;","    let number: Number = zero.into();","","    assert!(number.is_i64());","}"],[81,82,83,84,90]],[["{","    struct LargeNegativeInteger(i64);","","    impl From<LargeNegativeInteger> for Number {","        fn from(neg: LargeNegativeInteger) -> Self {","            Number { n: N::NegInt(neg.0) }","        }","    }","","    let large_negative = LargeNegativeInteger(-i64::MAX);","    let number: Number = large_negative.into();","","    assert!(number.is_i64());","}"],[81,82,83,85,90]],[["{","    let num = Number::from(u64::MAX); // boundary value","    assert!(!num.is_i64());","    let num = Number::from(u64::MAX - 1); // boundary case","    assert!(num.is_i64());","    let num = Number::from(0); // minimum boundary","    assert!(num.is_i64());","}"],[81,82,83,84,90]],[["{","    let num = Number::from(-1i64);","    assert!(num.is_i64());","}"],[81,82,83,85,90]],[["{","   let num = Number::from(1.0_f64 as i64);","   assert!(!num.is_i64());","}"],[81,82,83,84,90]],[["{","   let num = Number::from(-1); // changed to an integer","   assert!(!num.is_i64());","}"],[81,82,83,85,90]],[["{","    let num = Number::from(u64::MAX); // exceeds i64::MAX","    assert!(!num.is_i64());","}"],[81,82,83,84,90]],[["{","    let num = Number::from(0u64);","    assert!(num.is_i64());","}"],[81,82,83,84,90]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Initialize a Number with a floating point value","    let num = Number { n: N::Float(3.14) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[]],[["{","    // Initialize a Number with a negative floating point value","    let num = Number { n: N::Float(-2.71) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[]],[["{","    // Initialize a Number with zero as a float","    let num = Number { n: N::Float(0.0) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[]],[["{","    // Initialize a Number with a large floating point value","    let num = Number { n: N::Float(1e20) };","    // Test is_i64 which should return false for floating points","    assert_eq!(num.is_i64(), false);","}"],[]],[["{","    struct NegativeInteger(i64);","","    impl From<NegativeInteger> for Number {","        fn from(neg: NegativeInteger) -> Self {","            Number { n: N::NegInt(neg.0) }","        }","    }","","    let negative_num = NegativeInteger(-1);","    let number: Number = negative_num.into();","    ","    assert!(number.is_i64());","}"],[]],[["{","    struct Zero;","","    impl From<Zero> for Number {","        fn from(_: Zero) -> Self {","            Number { n: N::PosInt(0) }","        }","    }","","    let zero = Zero;","    let number: Number = zero.into();","","    assert!(number.is_i64());","}"],[]],[["{","    struct LargeNegativeInteger(i64);","","    impl From<LargeNegativeInteger> for Number {","        fn from(neg: LargeNegativeInteger) -> Self {","            Number { n: N::NegInt(neg.0) }","        }","    }","","    let large_negative = LargeNegativeInteger(-i64::MAX);","    let number: Number = large_negative.into();","","    assert!(number.is_i64());","}"],[]],[["{","    let num = Number::from(u64::MAX); // boundary value","    assert!(!num.is_i64());","    let num = Number::from(u64::MAX - 1); // boundary case","    assert!(num.is_i64());","    let num = Number::from(0); // minimum boundary","    assert!(num.is_i64());","}"],[]],[["{","    let num = Number::from(-1i64);","    assert!(num.is_i64());","}"],[]],[["{","   let num = Number::from(1.0_f64 as i64);","   assert!(!num.is_i64());","}"],[]],[["{","   let num = Number::from(-1); // changed to an integer","   assert!(!num.is_i64());","}"],[]],[["{","    let num = Number::from(u64::MAX); // exceeds i64::MAX","    assert!(!num.is_i64());","}"],[]],[["{","    let num = Number::from(0u64);","    assert!(num.is_i64());","}"],[]]]}