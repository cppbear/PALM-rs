{"function_name":"serde_json::value::de::value::de::<impl serde::Deserializer<'de> for &'de value::Value>::deserialize_bytes","tests":10,"tests_lines":[30,32,29,33,32,29,33,31,39,27],"oracles":10,"oracles_compiled":2,"oracles_compiled_rate":20.0,"tests_compiled":2,"tests_compiled_rate":20.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[928,929,930,931,932,933,934,935,937],"codes_lines_covered":[[["{","    struct InvalidVisitor;","","    impl<'de> Visitor<'de> for InvalidVisitor {","        type Value = ();","","        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","            formatter.write_str(\"a valid JSON string or array\")","        }","","       fn visit_borrowed_str<E>(self, _: &'de str) -> Result<Self::Value, E> {","           unreachable!()","        }","","       fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>","       where","           V: serde::de::SeqAccess<'de>,","       {","           unreachable!()","        }","","        // Add other visit methods if required","    }","","    let value = Value::Bool(true); // This does not match Value::String(v) or Value::Array(v)","    let visitor = InvalidVisitor;","","    let result: Result<(), Error> = value.deserialize_bytes(visitor);","    assert!(result.is_err());","}"],[]],[["{","    struct InvalidVisitor;","","    impl<'de> Visitor<'de> for InvalidVisitor {","        type Value = ();","","        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","            formatter.write_str(\"a valid JSON string or array\")","        }","","       fn visit_borrowed_str<E>(self, _: &'de str) -> Result<Self::Value, E> {","           unreachable!()","        }","","       fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>","       where","           V: serde::de::SeqAccess<'de>,","       {","           unreachable!()","       }","","        // Add other visit methods if required","    }","","    let mut map = Map::new(); // This will be an object type","    map.insert(String::from(\"key\"), Value::Bool(false));","    let value = Value::Object(map); // This does not match Value::String(v) or Value::Array(v)","    let visitor = InvalidVisitor;","","    let result: Result<(), Error> = value.deserialize_bytes(visitor);","    assert!(result.is_err());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct InvalidVisitor;","","    impl<'de> Visitor<'de> for InvalidVisitor {","        type Value = ();","","        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","            formatter.write_str(\"a valid JSON string or array\")","        }","","       fn visit_borrowed_str<E>(self, _: &'de str) -> Result<Self::Value, E> {","           unreachable!()","        }","","       fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>","       where","           V: serde::de::SeqAccess<'de>,","       {","           unreachable!()","        }","","        // Add other visit methods if required","    }","","    let value = Value::Bool(true); // This does not match Value::String(v) or Value::Array(v)","    let visitor = InvalidVisitor;","","    let result: Result<(), Error> = value.deserialize_bytes(visitor);","    assert!(result.is_err());","}"],[]],[["{","    struct InvalidVisitor;","","    impl<'de> Visitor<'de> for InvalidVisitor {","        type Value = ();","","        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {","            formatter.write_str(\"a valid JSON string or array\")","        }","","       fn visit_borrowed_str<E>(self, _: &'de str) -> Result<Self::Value, E> {","           unreachable!()","        }","","       fn visit_seq<V>(self, _: V) -> Result<Self::Value, V::Error>","       where","           V: serde::de::SeqAccess<'de>,","       {","           unreachable!()","       }","","        // Add other visit methods if required","    }","","    let mut map = Map::new(); // This will be an object type","    map.insert(String::from(\"key\"), Value::Bool(false));","    let value = Value::Object(map); // This does not match Value::String(v) or Value::Array(v)","    let visitor = InvalidVisitor;","","    let result: Result<(), Error> = value.deserialize_bytes(visitor);","    assert!(result.is_err());","}"],[]]]}