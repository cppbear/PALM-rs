{"function_name":"serde_json::read::<read::SliceRead<'a> as read::Read<'a>>::parse_str","tests":5,"tests_lines":[16,16,16,9,16],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":5,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[587,588,589],"codes_lines_covered":[[["{","   let mut scratch: Vec<u8> = Vec::new();  ","   let mut slice_read = SliceRead {  ","       slice: &[],  ","       index: 0,  ","   };  "," ","   let result = slice_read.parse_str(&mut scratch);  ","   assert!(result.is_ok());  ","   match result {  ","       Ok(ref result_value) => {  ","           assert!(matches!(result_value, Reference::Borrowed(_)));  ","       }  ","       _ => {}  ","   }  ","}"],[587,588,589]],[["{","   let mut scratch: Vec<u8> = Vec::new();","   let mut slice_read = SliceRead {  // Changed to mutable","       slice: b\"A\",","       index: 0,","   };","","   let result = slice_read.parse_str(&mut scratch);","   assert!(result.is_ok());","   match result {","       Ok(ref result_value) => {","           assert!(matches!(result_value, Reference::Borrowed(_)));","       }","       _ => {}","   }","}"],[587,588,589]],[["{","   let mut scratch: Vec<u8> = Vec::new();  ","   let mut slice_read = SliceRead {  ","       slice: b\"Hello, World!\",  ","       index: 0,  ","    };","","    let result = slice_read.parse_str(&mut scratch);","    assert!(result.is_ok());","    match result {","        Ok(ref result_value) => {","            assert!(matches!(result_value, Reference::Borrowed(_)));","        }","        _ => {}","    }","}"],[587,588,589]],[["{","   let mut scratch: Vec<u8> = Vec::new();","   let mut slice_read = SliceRead { // Changed to mutable","       slice: b\"\\xFF\", // Invalid UTF-8 byte","       index: 0,","   };","   ","   let _ = slice_read.parse_str(&mut scratch); // This should panic based on the context provided.","}"],[587,588,589]],[["{","   let mut scratch: Vec<u8> = Vec::new();","   let mut slice_read = SliceRead {","       slice: b\"Boundary Test\",","       index: 0,","   };","","   let result = slice_read.parse_str(&mut scratch);","   assert!(result.is_ok());","    match result {","        Ok(ref result_value) => {","            assert!(matches!(result_value, Reference::Borrowed(_)));","        }","        _ => {}","    }","}"],[587,588,589]]],"codes_branches":[],"codes_branches_covered":[[["{","   let mut scratch: Vec<u8> = Vec::new();  ","   let mut slice_read = SliceRead {  ","       slice: &[],  ","       index: 0,  ","   };  "," ","   let result = slice_read.parse_str(&mut scratch);  ","   assert!(result.is_ok());  ","   match result {  ","       Ok(ref result_value) => {  ","           assert!(matches!(result_value, Reference::Borrowed(_)));  ","       }  ","       _ => {}  ","   }  ","}"],[]],[["{","   let mut scratch: Vec<u8> = Vec::new();","   let mut slice_read = SliceRead {  // Changed to mutable","       slice: b\"A\",","       index: 0,","   };","","   let result = slice_read.parse_str(&mut scratch);","   assert!(result.is_ok());","   match result {","       Ok(ref result_value) => {","           assert!(matches!(result_value, Reference::Borrowed(_)));","       }","       _ => {}","   }","}"],[]],[["{","   let mut scratch: Vec<u8> = Vec::new();  ","   let mut slice_read = SliceRead {  ","       slice: b\"Hello, World!\",  ","       index: 0,  ","    };","","    let result = slice_read.parse_str(&mut scratch);","    assert!(result.is_ok());","    match result {","        Ok(ref result_value) => {","            assert!(matches!(result_value, Reference::Borrowed(_)));","        }","        _ => {}","    }","}"],[]],[["{","   let mut scratch: Vec<u8> = Vec::new();","   let mut slice_read = SliceRead { // Changed to mutable","       slice: b\"\\xFF\", // Invalid UTF-8 byte","       index: 0,","   };","   ","   let _ = slice_read.parse_str(&mut scratch); // This should panic based on the context provided.","}"],[]],[["{","   let mut scratch: Vec<u8> = Vec::new();","   let mut slice_read = SliceRead {","       slice: b\"Boundary Test\",","       index: 0,","   };","","   let result = slice_read.parse_str(&mut scratch);","   assert!(result.is_ok());","    match result {","        Ok(ref result_value) => {","            assert!(matches!(result_value, Reference::Borrowed(_)));","        }","        _ => {}","    }","}"],[]]]}