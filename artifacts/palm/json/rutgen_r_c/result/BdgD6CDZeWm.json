{"function_name":"serde_json::number::number::Number::as_f64","tests":9,"tests_lines":[23,4,4,18,18,18,12,12,12],"oracles":9,"oracles_compiled":6,"oracles_compiled_rate":66.66666666666666,"tests_compiled":6,"tests_compiled_rate":66.66666666666666,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[162,163,164,165,166,167,171],"codes_lines_covered":[[["{","    let number_pos_int = Number { n: N::PosInt(42) };","    assert_eq!(number_pos_int.as_f64(), Some(42.0));","}"],[162,163,164,165,171]],[["{","    let number_neg_int = Number { n: N::NegInt(-10) };","    assert_eq!(number_neg_int.as_f64(), Some(-10.0));","}"],[162,163,164,166,171]],[["{","    struct NumberTest {","        n: N,","    }","","    impl NumberTest {","        pub fn as_f64(&self) -> Option<f64> {","            match self.n {","                N::PosInt(n) => Some(n as f64),","                N::NegInt(n) => Some(n as f64),","                N::Float(n) => Some(n),","            }","        }","    }","","    let negative_int = NumberTest { n: N::NegInt(-42) };","    assert_eq!(negative_int.as_f64(), Some(-42.0));","}"],[]],[["{","    struct NumberTest {","        n: N,","    }","","    impl NumberTest {","        pub fn as_f64(&self) -> Option<f64> {","            match self.n {","                N::PosInt(n) => Some(n as f64),","                N::NegInt(n) => Some(n as f64),","                N::Float(n) => Some(n),","            }","        }","    }","","    let positive_int = NumberTest { n: N::PosInt(42) };","    assert_eq!(positive_int.as_f64(), Some(42.0));","}"],[]],[["{","    struct NumberTest {","        n: N,","    }","","    impl NumberTest {","        pub fn as_f64(&self) -> Option<f64> {","            match self.n {","                N::PosInt(n) => Some(n as f64),","                N::NegInt(n) => Some(n as f64),","                N::Float(n) => Some(n),","            }","        }","    }","","    let float_value = NumberTest { n: N::Float(3.14) };","    assert_eq!(float_value.as_f64(), Some(3.14));","}"],[]],[["{","    struct FloatValue(f64);","","    impl From<f64> for Number {","        fn from(f: f64) -> Self {","            Number { n: N::Float(f) }","        }","    }","","    let number = Number::from(3.14f64);","    assert_eq!(number.as_f64(), Some(3.14));","}"],[162,163,164,167,171]]],"codes_branches":[],"codes_branches_covered":[[["{","    let number_pos_int = Number { n: N::PosInt(42) };","    assert_eq!(number_pos_int.as_f64(), Some(42.0));","}"],[]],[["{","    let number_neg_int = Number { n: N::NegInt(-10) };","    assert_eq!(number_neg_int.as_f64(), Some(-10.0));","}"],[]],[["{","    struct NumberTest {","        n: N,","    }","","    impl NumberTest {","        pub fn as_f64(&self) -> Option<f64> {","            match self.n {","                N::PosInt(n) => Some(n as f64),","                N::NegInt(n) => Some(n as f64),","                N::Float(n) => Some(n),","            }","        }","    }","","    let negative_int = NumberTest { n: N::NegInt(-42) };","    assert_eq!(negative_int.as_f64(), Some(-42.0));","}"],[]],[["{","    struct NumberTest {","        n: N,","    }","","    impl NumberTest {","        pub fn as_f64(&self) -> Option<f64> {","            match self.n {","                N::PosInt(n) => Some(n as f64),","                N::NegInt(n) => Some(n as f64),","                N::Float(n) => Some(n),","            }","        }","    }","","    let positive_int = NumberTest { n: N::PosInt(42) };","    assert_eq!(positive_int.as_f64(), Some(42.0));","}"],[]],[["{","    struct NumberTest {","        n: N,","    }","","    impl NumberTest {","        pub fn as_f64(&self) -> Option<f64> {","            match self.n {","                N::PosInt(n) => Some(n as f64),","                N::NegInt(n) => Some(n as f64),","                N::Float(n) => Some(n),","            }","        }","    }","","    let float_value = NumberTest { n: N::Float(3.14) };","    assert_eq!(float_value.as_f64(), Some(3.14));","}"],[]],[["{","    struct FloatValue(f64);","","    impl From<f64> for Number {","        fn from(f: f64) -> Self {","            Number { n: N::Float(f) }","        }","    }","","    let number = Number::from(3.14f64);","    assert_eq!(number.as_f64(), Some(3.14));","}"],[]]]}