{"function_name":"serde_json::iter::iter::LineColIterator<I>::new","tests":3,"tests_lines":[16,24,29],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[26,27,28,29,30,31,32,33],"codes_lines_covered":[[["{","    struct EmptyIter;","    impl Iterator for EmptyIter {","        type Item = io::Result<u8>;","","        fn next(&mut self) -> Option<Self::Item> {","            None","        }","    }","","    let iter = EmptyIter;","    let line_col_iterator = LineColIterator::new(iter);","    assert_eq!(line_col_iterator.line, 1);","    assert_eq!(line_col_iterator.col, 0);","    assert_eq!(line_col_iterator.start_of_line, 0);","}"],[26,27,28,29,30,31,32,33]],[["{","    struct SingleElementIter {","        count: usize,","    }","","    impl Iterator for SingleElementIter {","        type Item = io::Result<u8>;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.count > 0 {","                self.count -= 1;","                Some(Ok(b'a'))","            } else {","                None","            }","        }","    }","","    let iter = SingleElementIter { count: 1 };","    let line_col_iterator = LineColIterator::new(iter);","    assert_eq!(line_col_iterator.line, 1);","    assert_eq!(line_col_iterator.col, 0);","    assert_eq!(line_col_iterator.start_of_line, 0);","}"],[26,27,28,29,30,31,32,33]],[["{","    struct MultiElementIter {","        data: Vec<u8>,","        index: usize,","    }","","    impl Iterator for MultiElementIter {","        type Item = io::Result<u8>;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let byte = self.data[self.index];","                self.index += 1;","                Some(Ok(byte))","            } else {","                None","            }","        }","    }","","    let iter = MultiElementIter {","        data: b\"hello\\nworld\".to_vec(),","        index: 0,","    };","    let line_col_iterator = LineColIterator::new(iter);","    assert_eq!(line_col_iterator.line, 1);","    assert_eq!(line_col_iterator.col, 0);","    assert_eq!(line_col_iterator.start_of_line, 0);","}"],[26,27,28,29,30,31,32,33]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct EmptyIter;","    impl Iterator for EmptyIter {","        type Item = io::Result<u8>;","","        fn next(&mut self) -> Option<Self::Item> {","            None","        }","    }","","    let iter = EmptyIter;","    let line_col_iterator = LineColIterator::new(iter);","    assert_eq!(line_col_iterator.line, 1);","    assert_eq!(line_col_iterator.col, 0);","    assert_eq!(line_col_iterator.start_of_line, 0);","}"],[]],[["{","    struct SingleElementIter {","        count: usize,","    }","","    impl Iterator for SingleElementIter {","        type Item = io::Result<u8>;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.count > 0 {","                self.count -= 1;","                Some(Ok(b'a'))","            } else {","                None","            }","        }","    }","","    let iter = SingleElementIter { count: 1 };","    let line_col_iterator = LineColIterator::new(iter);","    assert_eq!(line_col_iterator.line, 1);","    assert_eq!(line_col_iterator.col, 0);","    assert_eq!(line_col_iterator.start_of_line, 0);","}"],[]],[["{","    struct MultiElementIter {","        data: Vec<u8>,","        index: usize,","    }","","    impl Iterator for MultiElementIter {","        type Item = io::Result<u8>;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let byte = self.data[self.index];","                self.index += 1;","                Some(Ok(byte))","            } else {","                None","            }","        }","    }","","    let iter = MultiElementIter {","        data: b\"hello\\nworld\".to_vec(),","        index: 0,","    };","    let line_col_iterator = LineColIterator::new(iter);","    assert_eq!(line_col_iterator.line, 1);","    assert_eq!(line_col_iterator.col, 0);","    assert_eq!(line_col_iterator.start_of_line, 0);","}"],[]]]}