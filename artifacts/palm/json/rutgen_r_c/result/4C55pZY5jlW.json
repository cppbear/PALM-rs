{"function_name":"serde_json::ser::ser::CharEscape::from_escape_table","tests":40,"tests_lines":[21,5,9,8,9,25,25,25,25,25,25,25,26,6,6,6,6,6,6,6,6,9,7,7,7,7,7,7,7,7,10,9,9,9,9,9,9,9,9,5],"oracles":40,"oracles_compiled":21,"oracles_compiled_rate":52.5,"tests_compiled":21,"tests_compiled_rate":52.5,"oracles_run":21,"oracles_passed":21,"oracles_passed_rate":100.0,"tests_run":21,"tests_passed":21,"tests_passed_rate":100.0,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1551],"codes_lines_covered":[[["{","    let escape = 0x10; // Any byte that does not map to a valid CharEscape.","    let byte = 0x00; ","    CharEscape::from_escape_table(escape, byte);","}"],[1539,1540,1549]],[["{","    let escape: u8 = 255; // Invalid escape, should panic","    let byte: u8 = 0; // Byte value is not used in this case","    let result = std::panic::catch_unwind(|| {","        CharEscape::from_escape_table(escape, byte);","    });","    assert!(result.is_err(), \"Expected panic on invalid escape value\");","}"],[1539,1540,1549]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(QU, 0);","    match result {","        CharEscape::Quote => {}","        _ => panic!(\"Expected CharEscape::Quote\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(BB, 0);","    match result {","        CharEscape::Backspace => {}","        _ => panic!(\"Expected CharEscape::Backspace\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(TT, 0);","    match result {","        CharEscape::Tab => {}","        _ => panic!(\"Expected CharEscape::Tab\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(NN, 0);","    match result {","        CharEscape::LineFeed => {}","        _ => panic!(\"Expected CharEscape::LineFeed\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(FF, 0);","    match result {","        CharEscape::FormFeed => {}","        _ => panic!(\"Expected CharEscape::FormFeed\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(RR, 0);","    match result {","        CharEscape::CarriageReturn => {}","        _ => panic!(\"Expected CharEscape::CarriageReturn\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(BS, 0);","    match result {","        CharEscape::ReverseSolidus => {}","        _ => panic!(\"Expected CharEscape::ReverseSolidus\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let byte_value: u8 = 65; // ASCII value for 'A'","    let result = TestStruct::from_escape_table(UU, byte_value);","    match result {","        CharEscape::AsciiControl(65) => {}","        _ => panic!(\"Expected CharEscape::AsciiControl with byte 65\"),","    }","}"],[]],[["{","    let escape: u8 = b'f'; // Corresponds to self::FF","    let byte: u8 = 0; // Arbitrary value, not used in this case","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::FormFeed => (),","        _ => panic!(\"Expected CharEscape::FormFeed\"),","    }","}"],[1539,1540,1544,1551]],[["{","    let escape = b't';  // Value that matches self::TT","    let byte = 0;      // Any byte value is acceptable, here we use 0.","","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Tab => {},","        _ => panic!(\"Expected CharEscape::Tab, but got a different variant.\"),","    }","}"],[1539,1540,1542,1551]],[["{","    let escape = b'b'; // Matches self::BB","    let byte = 0; // Arbitrary value, not used for Backspace","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Backspace => {},","        _ => panic!(\"Expected CharEscape::Backspace\"),","    }","}"],[1539,1540,1541,1551]],[["{","    let escape = b't'; // Matches self::TT","    let byte = 0; // Arbitrary value, valid for Tab","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Tab => {},","        _ => panic!(\"Expected CharEscape::Tab\"),","    }","}"],[1539,1540,1542,1551]],[["{","    let escape = b'n'; // Matches self::NN","    let byte = 0; // Arbitrary value, valid for LineFeed","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::LineFeed => {},","        _ => panic!(\"Expected CharEscape::LineFeed\"),","    }","}"],[1539,1540,1543,1551]],[["{","    let escape = b'f'; // Matches self::FF","    let byte = 0; // Arbitrary value, valid for FormFeed","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::FormFeed => {},","        _ => panic!(\"Expected CharEscape::FormFeed\"),","    }","}"],[1539,1540,1544,1551]],[["{","    let escape = b'r'; // Matches self::RR","    let byte = 0; // Arbitrary value, valid for CarriageReturn","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::CarriageReturn => {},","        _ => panic!(\"Expected CharEscape::CarriageReturn\"),","    }","}"],[1539,1540,1545,1551]],[["{","    let escape = b'\"'; // Matches self::QU","    let byte = 0; // Arbitrary value, valid for Quote","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Quote => {},","        _ => panic!(\"Expected CharEscape::Quote\"),","    }","}"],[1539,1540,1546,1551]],[["{","    let escape = b'\\\\'; // Matches self::BS","    let byte = 0; // Arbitrary value, valid for ReverseSolidus","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::ReverseSolidus => {},","        _ => panic!(\"Expected CharEscape::ReverseSolidus\"),","    }","}"],[1539,1540,1547,1551]],[["{","    let escape = b'u'; // Matches self::UU","    let byte = 0xFF; // Example ASCII control value","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::AsciiControl(0xFF) => {},","        _ => panic!(\"Expected CharEscape::AsciiControl(0xFF)\"),","    }","}"],[1539,1540,1548,1551]],[["{","    let escape = b'x'; // Invalid escape","    let byte = 0; // Arbitrary value","    CharEscape::from_escape_table(escape, byte); // Should panic","}"],[1539,1540,1549]]],"codes_branches":[],"codes_branches_covered":[[["{","    let escape = 0x10; // Any byte that does not map to a valid CharEscape.","    let byte = 0x00; ","    CharEscape::from_escape_table(escape, byte);","}"],[]],[["{","    let escape: u8 = 255; // Invalid escape, should panic","    let byte: u8 = 0; // Byte value is not used in this case","    let result = std::panic::catch_unwind(|| {","        CharEscape::from_escape_table(escape, byte);","    });","    assert!(result.is_err(), \"Expected panic on invalid escape value\");","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(QU, 0);","    match result {","        CharEscape::Quote => {}","        _ => panic!(\"Expected CharEscape::Quote\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(BB, 0);","    match result {","        CharEscape::Backspace => {}","        _ => panic!(\"Expected CharEscape::Backspace\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(TT, 0);","    match result {","        CharEscape::Tab => {}","        _ => panic!(\"Expected CharEscape::Tab\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(NN, 0);","    match result {","        CharEscape::LineFeed => {}","        _ => panic!(\"Expected CharEscape::LineFeed\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(FF, 0);","    match result {","        CharEscape::FormFeed => {}","        _ => panic!(\"Expected CharEscape::FormFeed\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(RR, 0);","    match result {","        CharEscape::CarriageReturn => {}","        _ => panic!(\"Expected CharEscape::CarriageReturn\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let result = TestStruct::from_escape_table(BS, 0);","    match result {","        CharEscape::ReverseSolidus => {}","        _ => panic!(\"Expected CharEscape::ReverseSolidus\"),","    }","}"],[]],[["{","    struct TestStruct;","","    impl TestStruct {","        fn from_escape_table(escape: u8, byte: u8) -> CharEscape {","            match escape {","                BB => CharEscape::Backspace,","                TT => CharEscape::Tab,","                NN => CharEscape::LineFeed,","                FF => CharEscape::FormFeed,","                RR => CharEscape::CarriageReturn,","                QU => CharEscape::Quote,","                BS => CharEscape::ReverseSolidus,","                UU => CharEscape::AsciiControl(byte),","                _ => unreachable!(),","            }","        }","    }","","    let byte_value: u8 = 65; // ASCII value for 'A'","    let result = TestStruct::from_escape_table(UU, byte_value);","    match result {","        CharEscape::AsciiControl(65) => {}","        _ => panic!(\"Expected CharEscape::AsciiControl with byte 65\"),","    }","}"],[]],[["{","    let escape: u8 = b'f'; // Corresponds to self::FF","    let byte: u8 = 0; // Arbitrary value, not used in this case","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::FormFeed => (),","        _ => panic!(\"Expected CharEscape::FormFeed\"),","    }","}"],[]],[["{","    let escape = b't';  // Value that matches self::TT","    let byte = 0;      // Any byte value is acceptable, here we use 0.","","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Tab => {},","        _ => panic!(\"Expected CharEscape::Tab, but got a different variant.\"),","    }","}"],[]],[["{","    let escape = b'b'; // Matches self::BB","    let byte = 0; // Arbitrary value, not used for Backspace","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Backspace => {},","        _ => panic!(\"Expected CharEscape::Backspace\"),","    }","}"],[]],[["{","    let escape = b't'; // Matches self::TT","    let byte = 0; // Arbitrary value, valid for Tab","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Tab => {},","        _ => panic!(\"Expected CharEscape::Tab\"),","    }","}"],[]],[["{","    let escape = b'n'; // Matches self::NN","    let byte = 0; // Arbitrary value, valid for LineFeed","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::LineFeed => {},","        _ => panic!(\"Expected CharEscape::LineFeed\"),","    }","}"],[]],[["{","    let escape = b'f'; // Matches self::FF","    let byte = 0; // Arbitrary value, valid for FormFeed","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::FormFeed => {},","        _ => panic!(\"Expected CharEscape::FormFeed\"),","    }","}"],[]],[["{","    let escape = b'r'; // Matches self::RR","    let byte = 0; // Arbitrary value, valid for CarriageReturn","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::CarriageReturn => {},","        _ => panic!(\"Expected CharEscape::CarriageReturn\"),","    }","}"],[]],[["{","    let escape = b'\"'; // Matches self::QU","    let byte = 0; // Arbitrary value, valid for Quote","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::Quote => {},","        _ => panic!(\"Expected CharEscape::Quote\"),","    }","}"],[]],[["{","    let escape = b'\\\\'; // Matches self::BS","    let byte = 0; // Arbitrary value, valid for ReverseSolidus","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::ReverseSolidus => {},","        _ => panic!(\"Expected CharEscape::ReverseSolidus\"),","    }","}"],[]],[["{","    let escape = b'u'; // Matches self::UU","    let byte = 0xFF; // Example ASCII control value","    let result = CharEscape::from_escape_table(escape, byte);","    match result {","        CharEscape::AsciiControl(0xFF) => {},","        _ => panic!(\"Expected CharEscape::AsciiControl(0xFF)\"),","    }","}"],[]],[["{","    let escape = b'x'; // Invalid escape","    let byte = 0; // Arbitrary value","    CharEscape::from_escape_table(escape, byte); // Should panic","}"],[]]]}