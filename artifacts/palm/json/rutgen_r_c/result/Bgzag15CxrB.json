{"function_name":"serde_json::number::number::Number::is_f64","tests":10,"tests_lines":[34,34,34,34,13,13,13,15,15,15],"oracles":10,"oracles_compiled":5,"oracles_compiled_rate":50.0,"tests_compiled":5,"tests_compiled_rate":50.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":6,"lines_covered":5,"lines_coveraged_rate":83.33333333333334,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[113,114,115,116,117,128],"codes_lines_covered":[[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_float = Number { n: N::Float(3.14) };","    assert_eq!(num_float.is_f64(), true);","}"],[]],[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_float = Number { n: N::Float(-2.71) };","    assert_eq!(num_float.is_f64(), true);","}"],[]],[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_int = Number { n: N::PosInt(5) }; ","    assert_eq!(num_int.is_f64(), false);","}"],[]],[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_int = Number { n: N::NegInt(-3) }; ","    assert_eq!(num_int.is_f64(), false);","}"],[]],[["{","    struct FloatNumber(f64);","    ","    impl From<f64> for Number {","        fn from(f: f64) -> Self {","            let n = N::Float(f);","            Number { n }","        }","    }","    ","    let float_number = Number::from(42.0f64);","    assert!(float_number.is_f64());","}"],[113,114,115,116,128]]],"codes_branches":[],"codes_branches_covered":[[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_float = Number { n: N::Float(3.14) };","    assert_eq!(num_float.is_f64(), true);","}"],[]],[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_float = Number { n: N::Float(-2.71) };","    assert_eq!(num_float.is_f64(), true);","}"],[]],[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_int = Number { n: N::PosInt(5) }; ","    assert_eq!(num_int.is_f64(), false);","}"],[]],[["{","    #[derive(Copy, Clone)]","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","    ","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn is_f64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::Float(_) => true,","                N::PosInt(_) | N::NegInt(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            {","                for c in self.n.chars() {","                    if c == '.' || c == 'e' || c == 'E' {","                        return self.n.parse::<f64>().ok().map_or(false, f64::is_finite);","                    }","                }","                false","            }","        }","    }","","    let num_int = Number { n: N::NegInt(-3) }; ","    assert_eq!(num_int.is_f64(), false);","}"],[]],[["{","    struct FloatNumber(f64);","    ","    impl From<f64> for Number {","        fn from(f: f64) -> Self {","            let n = N::Float(f);","            Number { n }","        }","    }","    ","    let float_number = Number::from(42.0f64);","    assert!(float_number.is_f64());","}"],[]]]}