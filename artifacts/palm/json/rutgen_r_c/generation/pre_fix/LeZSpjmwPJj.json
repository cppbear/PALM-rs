{
  "name": "serde_json::read::error",
  "name_with_impl": "serde_json::read::error",
  "mod_info": {
    "name": "read",
    "loc": "src/lib.rs:434:1:434:10"
  },
  "visible": false,
  "loc": "src/read.rs:860:1:866:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: Err(Error::syntax(reason, position.line, position.column))\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[cfg(test)]",
            "fn test_error() {",
            "    struct MockRead {",
            "        position: Position,",
            "    }",
            "",
            "    impl MockRead {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            MockRead {",
            "                position: Position { line, column },",
            "            }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for MockRead {",
            "        fn position(&self) -> Position {",
            "            self.position",
            "        }",
            "    }",
            "",
            "    let mock_reader = MockRead::new(1, 10);",
            "    let reason = ErrorCode::EofWhileParsingValue;",
            "    ",
            "    let result: Result<()> = error(&mock_reader, reason);",
            "    ",
            "    match result {",
            "        Err(e) => {",
            "            assert_eq!(e.err.line, 1);",
            "            assert_eq!(e.err.column, 10);",
            "            if let ErrorCode::Message(ref msg) = *e.err.code {",
            "                assert!(msg.contains(\"EOF while parsing a JSON value.\"));",
            "            }",
            "        },",
            "        _ => panic!(\"Expected an error but got Ok\"),",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "fn test_error_with_different_positions() {",
            "    struct MockRead {",
            "        position: Position,",
            "    }",
            "",
            "    impl MockRead {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            MockRead {",
            "                position: Position { line, column },",
            "            }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for MockRead {",
            "        fn position(&self) -> Position {",
            "            self.position",
            "        }",
            "    }",
            "",
            "    let positions = vec![(2, 20), (5, 15), (10, 40)];",
            "    let reason = ErrorCode::ExpectedColon;",
            "",
            "    for (line, column) in positions {",
            "        let mock_reader = MockRead::new(line, column);",
            "        let result: Result<()> = error(&mock_reader, reason);",
            "        ",
            "        match result {",
            "            Err(e) => {",
            "                assert_eq!(e.err.line, line);",
            "                assert_eq!(e.err.column, column);",
            "            },",
            "            _ => panic!(\"Expected an error but got Ok\"),",
            "        }",
            "    }",
            "}",
            "",
            "#[cfg(test)]",
            "fn test_error_with_different_reasons() {",
            "    struct MockRead {",
            "        position: Position,",
            "    }",
            "",
            "    impl MockRead {",
            "        fn new(line: usize, column: usize) -> Self {",
            "            MockRead {",
            "                position: Position { line, column },",
            "            }",
            "        }",
            "    }",
            "",
            "    impl<'de> Read<'de> for MockRead {",
            "        fn position(&self) -> Position {",
            "            self.position",
            "        }",
            "    }",
            "",
            "    let mock_reader = MockRead::new(0, 0);",
            "    let reasons = vec![",
            "        ErrorCode::EofWhileParsingString,",
            "        ErrorCode::ExpectedDoubleQuote,",
            "        ErrorCode::InvalidNumber,",
            "    ];",
            "",
            "    for reason in reasons {",
            "        let result: Result<()> = error(&mock_reader, reason);",
            "        ",
            "        match result {",
            "            Err(e) => {",
            "                assert_eq!(e.err.line, 0);",
            "                assert_eq!(e.err.column, 0);",
            "            },",
            "            _ => panic!(\"Expected an error but got Ok\"),",
            "        }",
            "    }",
            "}"
          ],
          "chain_tests": []
        }
      ]
    }
  ]
}