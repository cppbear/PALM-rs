{
  "name": "serde_json::error::error::<impl std::convert::From<error::Error> for std::io::Error>::from",
  "name_with_impl": "serde_json::error::{impl#1}::from",
  "mod_info": {
    "name": "error",
    "loc": "src/lib.rs:419:1:419:15"
  },
  "visible": true,
  "loc": "src/error.rs:217:5:227:6",
  "doc": "/// Convert a `serde_json::Error` into an `io::Error`.\n///\n/// JSON syntax and data errors are turned into `InvalidData` I/O errors.\n/// EOF errors are turned into `UnexpectedEof` I/O errors.\n///\n/// ```\n/// use std::io;\n///\n/// enum MyError {\n///     Io(io::Error),\n///     Json(serde_json::Error),\n/// }\n///\n/// impl From<serde_json::Error> for MyError {\n///     fn from(err: serde_json::Error) -> MyError {\n///         use serde_json::error::Category;\n///         match err.classify() {\n///             Category::Io => {\n///                 MyError::Io(err.into())\n///             }\n///             Category::Syntax | Category::Data | Category::Eof => {\n///                 MyError::Json(err)\n///             }\n///         }\n///     }\n/// }\n/// ```\n",
  "code": [
    "fn from(j: Error) -> Self {",
    "    if let ErrorCode::Io(err) = j.err.code {",
    "        err",
    "    } else {",
    "        match j.classify() {",
    "            Category::Io => unreachable!(),",
    "            Category::Syntax | Category::Data => io::Error::new(ErrorKind::InvalidData, j),",
    "            Category::Eof => io::Error::new(ErrorKind::UnexpectedEof, j),",
    "        }",
    "    }",
    "}"
  ],
  "size": {
    "chain": 5,
    "contra": 0,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let ErrorCode::Io(err) = j.err.code",
          "norm": null,
          "value": "true",
          "line": 218,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "j.classify() matches Category::Eof",
          "norm": null,
          "value": "true",
          "line": 221,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        8,
        13,
        14,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let ErrorCode::Io(err) = j.err.code",
          "norm": null,
          "value": "true",
          "line": 218,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "j.classify() matches Category::Data",
          "norm": null,
          "value": "true",
          "line": 221,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "j.classify() matches Category::Data or Category::Syntax",
          "norm": null,
          "value": "true",
          "line": 221,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        9,
        11,
        12,
        14,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "let ErrorCode::Io(err) = j.err.code",
          "norm": null,
          "value": "true",
          "line": 218,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "j.classify() matches Category::Syntax",
          "norm": null,
          "value": "true",
          "line": 221,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "j.classify() matches Category::Data or Category::Syntax",
          "norm": null,
          "value": "true",
          "line": 221,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        9,
        11,
        12,
        14,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "let ErrorCode::Io(err) = j.err.code",
          "norm": null,
          "value": "true",
          "line": 218,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "j.classify() matches Category::Io",
          "norm": null,
          "value": "true",
          "line": 221,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "j.classify() matches Category::Io",
          "norm": null,
          "value": "true",
          "line": 221,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        7,
        10,
        19,
        20
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "let ErrorCode::Io(err) = j.err.code",
          "norm": null,
          "value": "true",
          "line": 218,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "err",
      "path": [
        0,
        1,
        2,
        4,
        15,
        16
      ],
      "may_contra": false,
      "min_set": false
    }
  ]
}