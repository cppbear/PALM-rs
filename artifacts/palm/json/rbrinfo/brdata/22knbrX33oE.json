{
  "name": "serde_json::de::de::StreamDeserializer<'de, R, T>::byte_offset",
  "name_with_impl": "serde_json::de::{impl#20}::byte_offset",
  "mod_info": {
    "name": "de",
    "loc": "src/lib.rs:418:1:418:12"
  },
  "visible": true,
  "loc": "src/de.rs:2412:5:2414:6",
  "doc": "/// Returns the number of bytes so far deserialized into a successful `T`.\n///\n/// If a stream deserializer returns an EOF error, new data can be joined to\n/// `old_data[stream.byte_offset()..]` to try again.\n///\n/// ```\n/// let data = b\"[0] [1] [\";\n///\n/// let de = serde_json::Deserializer::from_slice(data);\n/// let mut stream = de.into_iter::<Vec<i32>>();\n/// assert_eq!(0, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // [0]\n/// assert_eq!(3, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // [1]\n/// assert_eq!(7, stream.byte_offset());\n///\n/// println!(\"{:?}\", stream.next()); // error\n/// assert_eq!(8, stream.byte_offset());\n///\n/// // If err.is_eof(), can join the remaining data to new data and continue.\n/// let remaining = &data[stream.byte_offset()..];\n/// ```\n///\n/// *Note:* In the future this method may be changed to return the number of\n/// bytes so far deserialized into a successful T *or* syntactically valid\n/// JSON skipped over due to a type error. See [serde-rs/json#70] for an\n/// example illustrating this.\n///\n/// [serde-rs/json#70]: https://github.com/serde-rs/json/issues/70\n",
  "code": [
    "pub fn byte_offset(&self) -> usize {",
    "    self.offset",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "self.offset",
      "path": [
        0
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}