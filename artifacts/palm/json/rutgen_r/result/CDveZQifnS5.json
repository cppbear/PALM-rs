{"function_name":"serde_json::value::de::<value::de::SeqDeserializer as serde::de::SeqAccess<'de>>::size_hint","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/value/de.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":6,"tests_lines":[38,38,38,36,36,42],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[639,640,641,642,644],"codes_lines_covered":[[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let item = self.data[self.index];","                self.index += 1;","                Some(item)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","    ","    let test_iter = TestIter { data: vec![1, 2, 3], index: 0 }; // Here the size hint will be (3, Some(3))","    let test_struct = TestStruct { iter: test_iter };","","    assert_eq!(test_struct.size_hint(), None); // we expect None because the size hint matches the constraint.","}"],[]],[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let item = self.data[self.index];","                self.index += 1;","                Some(item)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","    ","    let test_iter = TestIter { data: vec![1, 2], index: 0 }; // Here the size hint will be (2, Some(2))","    let test_struct = TestStruct { iter: test_iter };","","    assert_eq!(test_struct.size_hint(), None); // we expect None because it doesn't fulfill the size hint criteria.","}"],[]],[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let item = self.data[self.index];","                self.index += 1;","                Some(item)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","    ","    let test_iter = TestIter { data: vec![], index: 0 }; // Empty iterator, size hint is (0, Some(0))","    let test_struct = TestStruct { iter: test_iter };","","    assert_eq!(test_struct.size_hint(), None); // we expect None because the size hint does not fulfill the equality criterion.","}"],[]],[["{","    struct SizeHintIterator {","        data: Vec<i32>,","    }","","    impl SizeHintIterator {","        fn new(data: Vec<i32>) -> Self {","            SizeHintIterator { data }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            let len = self.data.len();","            (len, Some(len))","        }","    }","","    struct MyStruct {","        iter: SizeHintIterator,","    }","","    impl MyStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let data = vec![1, 2, 3]; // A case where lower == upper; len is 3","    let my_struct = MyStruct {","        iter: SizeHintIterator::new(data),","    };","","    assert_eq!(my_struct.size_hint(), Some(3));","}"],[]],[["{","    struct SizeHintIterator {","        data: Vec<i32>,","    }","","    impl SizeHintIterator {","        fn new(data: Vec<i32>) -> Self {","            SizeHintIterator { data }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            let len = self.data.len();","            (len, Some(len))","        }","    }","","    struct MyStruct {","        iter: SizeHintIterator,","    }","","    impl MyStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let data: Vec<i32> = Vec::new(); // A case where lower == upper and is 0","    let my_struct = MyStruct {","        iter: SizeHintIterator::new(data),","    };","","    assert_eq!(my_struct.size_hint(), Some(0));","}"],[]],[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let value = self.data[self.index];","                self.index += 1;","                Some(value)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iter = TestIter {","        data: vec![1, 2, 3], // 3 elements","        index: 0,","    };","    ","    let test_struct = TestStruct { iter };","","    assert_eq!(test_struct.size_hint(), None); // lower = 3, upper = 3 ","}"],[]]],"codes_branches":[{"start_line":641,"start_column":37,"end_line":641,"end_column":51,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let item = self.data[self.index];","                self.index += 1;","                Some(item)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","    ","    let test_iter = TestIter { data: vec![1, 2, 3], index: 0 }; // Here the size hint will be (3, Some(3))","    let test_struct = TestStruct { iter: test_iter };","","    assert_eq!(test_struct.size_hint(), None); // we expect None because the size hint matches the constraint.","}"],[{"start_line":641,"start_column":37,"end_line":641,"end_column":51,"positive":false,"negative":false}]],[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let item = self.data[self.index];","                self.index += 1;","                Some(item)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","    ","    let test_iter = TestIter { data: vec![1, 2], index: 0 }; // Here the size hint will be (2, Some(2))","    let test_struct = TestStruct { iter: test_iter };","","    assert_eq!(test_struct.size_hint(), None); // we expect None because it doesn't fulfill the size hint criteria.","}"],[{"start_line":641,"start_column":37,"end_line":641,"end_column":51,"positive":false,"negative":false}]],[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let item = self.data[self.index];","                self.index += 1;","                Some(item)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","    ","    let test_iter = TestIter { data: vec![], index: 0 }; // Empty iterator, size hint is (0, Some(0))","    let test_struct = TestStruct { iter: test_iter };","","    assert_eq!(test_struct.size_hint(), None); // we expect None because the size hint does not fulfill the equality criterion.","}"],[{"start_line":641,"start_column":37,"end_line":641,"end_column":51,"positive":false,"negative":false}]],[["{","    struct SizeHintIterator {","        data: Vec<i32>,","    }","","    impl SizeHintIterator {","        fn new(data: Vec<i32>) -> Self {","            SizeHintIterator { data }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            let len = self.data.len();","            (len, Some(len))","        }","    }","","    struct MyStruct {","        iter: SizeHintIterator,","    }","","    impl MyStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let data = vec![1, 2, 3]; // A case where lower == upper; len is 3","    let my_struct = MyStruct {","        iter: SizeHintIterator::new(data),","    };","","    assert_eq!(my_struct.size_hint(), Some(3));","}"],[{"start_line":641,"start_column":37,"end_line":641,"end_column":51,"positive":false,"negative":false}]],[["{","    struct SizeHintIterator {","        data: Vec<i32>,","    }","","    impl SizeHintIterator {","        fn new(data: Vec<i32>) -> Self {","            SizeHintIterator { data }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            let len = self.data.len();","            (len, Some(len))","        }","    }","","    struct MyStruct {","        iter: SizeHintIterator,","    }","","    impl MyStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let data: Vec<i32> = Vec::new(); // A case where lower == upper and is 0","    let my_struct = MyStruct {","        iter: SizeHintIterator::new(data),","    };","","    assert_eq!(my_struct.size_hint(), Some(0));","}"],[{"start_line":641,"start_column":37,"end_line":641,"end_column":51,"positive":false,"negative":false}]],[["{","    struct TestIter {","        data: Vec<i32>,","        index: usize,","    }","","    impl Iterator for TestIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.index < self.data.len() {","                let value = self.data[self.index];","                self.index += 1;","                Some(value)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIter,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iter = TestIter {","        data: vec![1, 2, 3], // 3 elements","        index: 0,","    };","    ","    let test_struct = TestStruct { iter };","","    assert_eq!(test_struct.size_hint(), None); // lower = 3, upper = 3 ","}"],[{"start_line":641,"start_column":37,"end_line":641,"end_column":51,"positive":false,"negative":false}]]]}