{"function_name":"serde_json::read::decode_four_hex_digits","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/read.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":5,"tests_lines":[9,9,7,7,6],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":3,"oracles_passed_rate":60.0,"tests_run":5,"tests_passed":3,"tests_passed_rate":60.0,"lines":13,"lines_covered":12,"lines_coveraged_rate":92.3076923076923,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1087,1089],"codes_lines_covered":[[["{","    let a: u8 = 0; // corresponds to '0'","    let b: u8 = 0; // corresponds to '0'","    let c: u8 = 0; // corresponds to '0'","    let d: u8 = 0; // corresponds to '0'","    ","    let result = decode_four_hex_digits(a, b, c, d);","    assert_eq!(result, Some(0)); // codepoint == 0 should return Some(0)","}"],[1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1087,1089]],[["{","    let a: u8 = 0; // corresponds to '0'","    let b: u8 = 1; // corresponds to '1'","    let c: u8 = 0; // corresponds to '0'","    let d: u8 = 0; // corresponds to '0'","    ","    let result = decode_four_hex_digits(a, b, c, d);","    assert_eq!(result, Some(256)); // codepoint == 256 should return Some(256)","}"],[1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1087,1089]],[["{","    // The inputs for this test are chosen to ensure the calculated codepoint is negative.","    // We can use upper values that lead to an invalid character beyond the extended range for codepoint.","    ","    let result = decode_four_hex_digits(0x10, 0x0F, 0x10, 0x0F); // HEX1[16], HEX0[15]","    assert_eq!(result, None);","}"],[1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1087,1089]],[["{","    // Using values that result in a codepoint that is exactly negative, ","    // for example, utilizing high values for inputs to cross the signed boundary.","    ","    let result = decode_four_hex_digits(0x0F, 0x0F, 0x0F, 0x0F); // HEX1[15], HEX0[15]","    assert_eq!(result, None);","}"],[1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1087,1089]],[["{","    // This test ensures to check combinations that will also lead to an invalid codepoint.","    ","    let result = decode_four_hex_digits(0xF0, 0xF0, 0xF0, 0xF0); // HEX1[240], HEX0[240]","    assert_eq!(result, None);","}"],[1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1087,1089]]],"codes_branches":[{"start_line":1084,"start_column":8,"end_line":1084,"end_column":22,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let a: u8 = 0; // corresponds to '0'","    let b: u8 = 0; // corresponds to '0'","    let c: u8 = 0; // corresponds to '0'","    let d: u8 = 0; // corresponds to '0'","    ","    let result = decode_four_hex_digits(a, b, c, d);","    assert_eq!(result, Some(0)); // codepoint == 0 should return Some(0)","}"],[{"start_line":1084,"start_column":8,"end_line":1084,"end_column":22,"positive":false,"negative":true}]],[["{","    let a: u8 = 0; // corresponds to '0'","    let b: u8 = 1; // corresponds to '1'","    let c: u8 = 0; // corresponds to '0'","    let d: u8 = 0; // corresponds to '0'","    ","    let result = decode_four_hex_digits(a, b, c, d);","    assert_eq!(result, Some(256)); // codepoint == 256 should return Some(256)","}"],[{"start_line":1084,"start_column":8,"end_line":1084,"end_column":22,"positive":false,"negative":true}]],[["{","    // The inputs for this test are chosen to ensure the calculated codepoint is negative.","    // We can use upper values that lead to an invalid character beyond the extended range for codepoint.","    ","    let result = decode_four_hex_digits(0x10, 0x0F, 0x10, 0x0F); // HEX1[16], HEX0[15]","    assert_eq!(result, None);","}"],[{"start_line":1084,"start_column":8,"end_line":1084,"end_column":22,"positive":false,"negative":true}]],[["{","    // Using values that result in a codepoint that is exactly negative, ","    // for example, utilizing high values for inputs to cross the signed boundary.","    ","    let result = decode_four_hex_digits(0x0F, 0x0F, 0x0F, 0x0F); // HEX1[15], HEX0[15]","    assert_eq!(result, None);","}"],[{"start_line":1084,"start_column":8,"end_line":1084,"end_column":22,"positive":false,"negative":true}]],[["{","    // This test ensures to check combinations that will also lead to an invalid codepoint.","    ","    let result = decode_four_hex_digits(0xF0, 0xF0, 0xF0, 0xF0); // HEX1[240], HEX0[240]","    assert_eq!(result, None);","}"],[{"start_line":1084,"start_column":8,"end_line":1084,"end_column":22,"positive":false,"negative":true}]]]}