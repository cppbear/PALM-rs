{"function_name":"serde_json::ser::<ser::PrettyFormatter<'a> as ser::Formatter>::end_object","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/ser.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":3,"tests_lines":[54,55,65],"oracles":3,"oracles_compiled":2,"oracles_compiled_rate":66.66666666666666,"tests_compiled":2,"tests_compiled_rate":66.66666666666666,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":12,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2051,2052],"codes_lines_covered":[[["{","    use std::io::{self, Write};","","    struct TestWriter {","        should_fail: bool,","    }","","    impl Write for TestWriter {","        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {","            if self.should_fail {","                Err(io::Error::new(io::ErrorKind::Other, \"test error\"))","            } else {","                Ok(buf.len())","            }","        }","","        fn flush(&mut self) -> io::Result<()> {","            Ok(())","        }","    }","","    struct MyStruct {","        current_indent: usize,","        has_value: bool,","        indent: usize,","    }","","    impl MyStruct {","        fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>","        where","            W: ?Sized + Write,","        {","            self.current_indent -= 1;","","            if self.has_value {","                writer.write_all(b\"\\n\")?;","            }","","            writer.write_all(b\"}\")?;","            Ok(())","        }","    }","","    let mut my_struct = MyStruct {","        current_indent: 1,","        has_value: true,","        indent: 0,","    };","","    let mut writer = TestWriter { should_fail: true };","    ","    let result = my_struct.end_object(&mut writer);","    assert!(result.is_err());","}"],[]],[["{","    use std::io::{self, Cursor};","","    struct TestWriter {","        buffer: Cursor<Vec<u8>>,","    }","","    impl TestWriter {","        fn new() -> Self {","            Self {","                buffer: Cursor::new(Vec::new()),","            }","        }","","        fn get_result(self) -> Vec<u8> {","            self.buffer.into_inner()","        }","    }","","    struct Serializer {","        current_indent: i32,","        indent: i32,","        has_value: bool,","    }","","    impl Serializer {","        fn new() -> Self {","            Self {","                current_indent: 0,","                indent: 2,","                has_value: false,","            }","        }","","        fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>","        where","            W: ?Sized + io::Write,","        {","            self.current_indent -= 1;","","            if self.has_value {","                writer.write_all(b\"\\n\")?;","                self.indent(writer, self.current_indent, self.indent)?;","            }","","            writer.write_all(b\"}\")","        }","","        fn indent<W>(&self, writer: &mut W, current_indent: i32, indent: i32) -> io::Result<()>","        where","            W: ?Sized + io::Write,","        {","            // Implementation of indentation logic here","            Ok(())","        }","    }","","    let mut serializer = Serializer::new();","    let mut writer = TestWriter::new();","","    let result = serializer.end_object(&mut writer.buffer);","    ","    assert!(result.is_ok());","    assert_eq!(writer.get_result(), b\"}\");","}"],[]]],"codes_branches":[{"start_line":2046,"start_column":12,"end_line":2046,"end_column":26,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    use std::io::{self, Write};","","    struct TestWriter {","        should_fail: bool,","    }","","    impl Write for TestWriter {","        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {","            if self.should_fail {","                Err(io::Error::new(io::ErrorKind::Other, \"test error\"))","            } else {","                Ok(buf.len())","            }","        }","","        fn flush(&mut self) -> io::Result<()> {","            Ok(())","        }","    }","","    struct MyStruct {","        current_indent: usize,","        has_value: bool,","        indent: usize,","    }","","    impl MyStruct {","        fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>","        where","            W: ?Sized + Write,","        {","            self.current_indent -= 1;","","            if self.has_value {","                writer.write_all(b\"\\n\")?;","            }","","            writer.write_all(b\"}\")?;","            Ok(())","        }","    }","","    let mut my_struct = MyStruct {","        current_indent: 1,","        has_value: true,","        indent: 0,","    };","","    let mut writer = TestWriter { should_fail: true };","    ","    let result = my_struct.end_object(&mut writer);","    assert!(result.is_err());","}"],[{"start_line":2046,"start_column":12,"end_line":2046,"end_column":26,"positive":false,"negative":false}]],[["{","    use std::io::{self, Cursor};","","    struct TestWriter {","        buffer: Cursor<Vec<u8>>,","    }","","    impl TestWriter {","        fn new() -> Self {","            Self {","                buffer: Cursor::new(Vec::new()),","            }","        }","","        fn get_result(self) -> Vec<u8> {","            self.buffer.into_inner()","        }","    }","","    struct Serializer {","        current_indent: i32,","        indent: i32,","        has_value: bool,","    }","","    impl Serializer {","        fn new() -> Self {","            Self {","                current_indent: 0,","                indent: 2,","                has_value: false,","            }","        }","","        fn end_object<W>(&mut self, writer: &mut W) -> io::Result<()>","        where","            W: ?Sized + io::Write,","        {","            self.current_indent -= 1;","","            if self.has_value {","                writer.write_all(b\"\\n\")?;","                self.indent(writer, self.current_indent, self.indent)?;","            }","","            writer.write_all(b\"}\")","        }","","        fn indent<W>(&self, writer: &mut W, current_indent: i32, indent: i32) -> io::Result<()>","        where","            W: ?Sized + io::Write,","        {","            // Implementation of indentation logic here","            Ok(())","        }","    }","","    let mut serializer = Serializer::new();","    let mut writer = TestWriter::new();","","    let result = serializer.end_object(&mut writer.buffer);","    ","    assert!(result.is_ok());","    assert_eq!(writer.get_result(), b\"}\");","}"],[{"start_line":2046,"start_column":12,"end_line":2046,"end_column":26,"positive":false,"negative":false}]]]}