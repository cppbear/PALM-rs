{"function_name":"serde_json::de::de::Deserializer<R>::peek_error","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/de.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":2,"tests_lines":[45,44],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[248,249,250,251],"codes_lines_covered":[[["{","    struct MockReader {","        position: (usize, usize),","    }","","    impl MockReader {","        fn new(line: usize, column: usize) -> Self {","            Self {","                position: (line, column),","            }","        }","        ","        fn peek_position(&self) -> (usize, usize) {","            self.position","        }","    }","","    struct Error {","        kind: String,","        line: usize,","        column: usize,","    }","","    impl Error {","        fn syntax(reason: &str, line: usize, column: usize) -> Self {","            Self {","                kind: format!(\"Syntax error: {} at line {}, column {}\", reason, line, column),","                line,","                column,","            }","        }","    }","","    fn peek_error(reader: &MockReader, reason: &str) -> Error {","        let position = reader.peek_position();","        Error::syntax(reason, position.0, position.1)","    }","","    let reader = MockReader::new(1, 10);","    let error = peek_error(&reader, \"Unexpected token\");","","    assert_eq!(error.kind, \"Syntax error: Unexpected token at line 1, column 10\");","    assert_eq!(error.line, 1);","    assert_eq!(error.column, 10);","}"],[]],[["{","    struct MockReader {","        position: (usize, usize),","    }","","    impl MockReader {","        fn new(line: usize, column: usize) -> Self {","            Self {","                position: (line, column),","            }","        }","","        fn peek_position(&self) -> (usize, usize) {","            self.position","        }","    }","","    struct Error {","        kind: String,","        line: usize,","        column: usize,","    }","","    impl Error {","        fn syntax(reason: &str, line: usize, column: usize) -> Self {","            Self {","                kind: format!(\"Syntax error: {} at line {}, column {}\", reason, line, column),","                line,","                column,","            }","        }","    }","","    fn peek_error(reader: &MockReader, reason: &str) -> Error {","        let position = reader.peek_position();","        if position.0 == 0 && position.1 == 0 { // Panic condition","            panic!(\"Position cannot be zero for line and column.\");","        }","        Error::syntax(reason, position.0, position.1)","    }","","    let reader = MockReader::new(0, 0); // This will trigger a panic","    let _error = peek_error(&reader, \"Invalid input\");","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockReader {","        position: (usize, usize),","    }","","    impl MockReader {","        fn new(line: usize, column: usize) -> Self {","            Self {","                position: (line, column),","            }","        }","        ","        fn peek_position(&self) -> (usize, usize) {","            self.position","        }","    }","","    struct Error {","        kind: String,","        line: usize,","        column: usize,","    }","","    impl Error {","        fn syntax(reason: &str, line: usize, column: usize) -> Self {","            Self {","                kind: format!(\"Syntax error: {} at line {}, column {}\", reason, line, column),","                line,","                column,","            }","        }","    }","","    fn peek_error(reader: &MockReader, reason: &str) -> Error {","        let position = reader.peek_position();","        Error::syntax(reason, position.0, position.1)","    }","","    let reader = MockReader::new(1, 10);","    let error = peek_error(&reader, \"Unexpected token\");","","    assert_eq!(error.kind, \"Syntax error: Unexpected token at line 1, column 10\");","    assert_eq!(error.line, 1);","    assert_eq!(error.column, 10);","}"],[]],[["{","    struct MockReader {","        position: (usize, usize),","    }","","    impl MockReader {","        fn new(line: usize, column: usize) -> Self {","            Self {","                position: (line, column),","            }","        }","","        fn peek_position(&self) -> (usize, usize) {","            self.position","        }","    }","","    struct Error {","        kind: String,","        line: usize,","        column: usize,","    }","","    impl Error {","        fn syntax(reason: &str, line: usize, column: usize) -> Self {","            Self {","                kind: format!(\"Syntax error: {} at line {}, column {}\", reason, line, column),","                line,","                column,","            }","        }","    }","","    fn peek_error(reader: &MockReader, reason: &str) -> Error {","        let position = reader.peek_position();","        if position.0 == 0 && position.1 == 0 { // Panic condition","            panic!(\"Position cannot be zero for line and column.\");","        }","        Error::syntax(reason, position.0, position.1)","    }","","    let reader = MockReader::new(0, 0); // This will trigger a panic","    let _error = peek_error(&reader, \"Invalid input\");","}"],[]]]}