{"function_name":"serde_json::map::map::Map<std::string::String, value::Value>::keys","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":3,"tests_lines":[18,21,25],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[319,320,321,322,323],"codes_lines_covered":[[["{","    use std::collections::HashMap;","    ","    struct MyMap {","        map: HashMap<String, i32>,","    }","","    impl MyMap {","        pub fn keys(&self) -> std::collections::hash_map::Keys<'_, String, i32> {","            self.map.keys()","        }","    }","","    let my_map = MyMap { map: HashMap::new() };","    let mut keys_iter = my_map.keys();","","    assert!(keys_iter.next().is_none()); // No keys should be present","}"],[]],[["{","    use std::collections::HashMap;","    ","    struct MyMap {","        map: HashMap<String, i32>,","    }","","    impl MyMap {","        pub fn keys(&self) -> std::collections::hash_map::Keys<'_, String, i32> {","            self.map.keys()","        }","    }","","    let mut my_map = MyMap { map: HashMap::new() };","    my_map.map.insert(\"key1\".to_string(), 1);","","    let mut keys_iter = my_map.keys();","    ","    assert_eq!(keys_iter.next(), Some(&\"key1\".to_string())); // Should return the existing key","    assert!(keys_iter.next().is_none()); // There are no more keys","}"],[]],[["{","    use std::collections::HashMap;","    ","    struct MyMap {","        map: HashMap<String, i32>,","    }","","    impl MyMap {","        pub fn keys(&self) -> std::collections::hash_map::Keys<'_, String, i32> {","            self.map.keys()","        }","    }","","    let mut my_map = MyMap { map: HashMap::new() };","    my_map.map.insert(\"key1\".to_string(), 1);","    my_map.map.insert(\"key2\".to_string(), 2);","    my_map.map.insert(\"key3\".to_string(), 3);","","    let keys: Vec<_> = my_map.keys().cloned().collect();","    ","    assert_eq!(keys.len(), 3); // Should be 3 keys","    assert!(keys.contains(&\"key1\".to_string()));","    assert!(keys.contains(&\"key2\".to_string()));","    assert!(keys.contains(&\"key3\".to_string()));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::collections::HashMap;","    ","    struct MyMap {","        map: HashMap<String, i32>,","    }","","    impl MyMap {","        pub fn keys(&self) -> std::collections::hash_map::Keys<'_, String, i32> {","            self.map.keys()","        }","    }","","    let my_map = MyMap { map: HashMap::new() };","    let mut keys_iter = my_map.keys();","","    assert!(keys_iter.next().is_none()); // No keys should be present","}"],[]],[["{","    use std::collections::HashMap;","    ","    struct MyMap {","        map: HashMap<String, i32>,","    }","","    impl MyMap {","        pub fn keys(&self) -> std::collections::hash_map::Keys<'_, String, i32> {","            self.map.keys()","        }","    }","","    let mut my_map = MyMap { map: HashMap::new() };","    my_map.map.insert(\"key1\".to_string(), 1);","","    let mut keys_iter = my_map.keys();","    ","    assert_eq!(keys_iter.next(), Some(&\"key1\".to_string())); // Should return the existing key","    assert!(keys_iter.next().is_none()); // There are no more keys","}"],[]],[["{","    use std::collections::HashMap;","    ","    struct MyMap {","        map: HashMap<String, i32>,","    }","","    impl MyMap {","        pub fn keys(&self) -> std::collections::hash_map::Keys<'_, String, i32> {","            self.map.keys()","        }","    }","","    let mut my_map = MyMap { map: HashMap::new() };","    my_map.map.insert(\"key1\".to_string(), 1);","    my_map.map.insert(\"key2\".to_string(), 2);","    my_map.map.insert(\"key3\".to_string(), 3);","","    let keys: Vec<_> = my_map.keys().cloned().collect();","    ","    assert_eq!(keys.len(), 3); // Should be 3 keys","    assert!(keys.contains(&\"key1\".to_string()));","    assert!(keys.contains(&\"key2\".to_string()));","    assert!(keys.contains(&\"key3\".to_string()));","}"],[]]]}