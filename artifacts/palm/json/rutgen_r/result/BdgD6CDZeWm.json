{"function_name":"serde_json::number::number::Number::as_f64","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/number.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":7,"tests_lines":[30,23,23,23,27,27,27],"oracles":7,"oracles_compiled":7,"oracles_compiled_rate":100.0,"tests_compiled":7,"tests_compiled_rate":100.0,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":7,"tests_passed":7,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[162,163,164,165,166,167,171],"codes_lines_covered":[[["{","    struct N {","        float: f64,","    }","","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n.float {","                n if n.is_finite() => Some(n),","                _ => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.float.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let number = Number { n: N { float: 3.14 } };","    assert_eq!(number.as_f64(), Some(3.14));","","    let number_neg = Number { n: N { float: -2.71 } };","    assert_eq!(number_neg.as_f64(), Some(-2.71));","","    let number_zero = Number { n: N { float: 0.0 } };","    assert_eq!(number_zero.as_f64(), Some(0.0));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","    ","    struct NegInt(i32);","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f64),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let negative_integer = NegInt(-42);","    let n = N { n: negative_integer };","    let result = n.as_f64();","    assert_eq!(result, Some(-42.0));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","    ","    struct NegInt(i32);","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f64),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let negative_integer_zero = NegInt(0);","    let n = N { n: negative_integer_zero };","    let result = n.as_f64();","    assert_eq!(result, Some(0.0));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","    ","    struct NegInt(i32);","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f64),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let negative_integer_large = NegInt(-100000);","    let n = N { n: negative_integer_large };","    let result = n.as_f64();","    assert_eq!(result, Some(-100000.0));","}"],[]],[["{","    struct N {","        n: Option<PosInt>,","    }","","    struct PosInt {","        value: u64,","    }","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Some(PosInt { value }) => Some(*value as f64),","                None => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            None // Not handling parsing for this test","        }","    }","","    let num = N {","        n: Some(PosInt { value: 42 }),","    };","","    assert_eq!(num.as_f64(), Some(42.0));","}"],[]],[["{","    struct N {","        n: Option<PosInt>,","    }","","    struct PosInt {","        value: u64,","    }","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Some(PosInt { value }) => Some(*value as f64),","                None => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            None // Not handling parsing for this test","        }","    }","","    let num = N {","        n: Some(PosInt { value: 0 }),","    };","","    assert_eq!(num.as_f64(), Some(0.0));","}"],[]],[["{","    struct N {","        n: Option<PosInt>,","    }","","    struct PosInt {","        value: u64,","    }","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Some(PosInt { value }) => Some(*value as f64),","                None => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            None // Not handling parsing for this test","        }","    }","","    let num = N {","        n: Some(PosInt { value: u64::MAX }),","    };","","    assert_eq!(num.as_f64(), Some(u64::MAX as f64));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct N {","        float: f64,","    }","","    struct Number {","        n: N,","    }","","    impl Number {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n.float {","                n if n.is_finite() => Some(n),","                _ => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.float.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let number = Number { n: N { float: 3.14 } };","    assert_eq!(number.as_f64(), Some(3.14));","","    let number_neg = Number { n: N { float: -2.71 } };","    assert_eq!(number_neg.as_f64(), Some(-2.71));","","    let number_zero = Number { n: N { float: 0.0 } };","    assert_eq!(number_zero.as_f64(), Some(0.0));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","    ","    struct NegInt(i32);","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f64),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let negative_integer = NegInt(-42);","    let n = N { n: negative_integer };","    let result = n.as_f64();","    assert_eq!(result, Some(-42.0));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","    ","    struct NegInt(i32);","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f64),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let negative_integer_zero = NegInt(0);","    let n = N { n: negative_integer_zero };","    let result = n.as_f64();","    assert_eq!(result, Some(0.0));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","    ","    struct NegInt(i32);","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f64),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.parse::<f64>().ok().filter(|float| float.is_finite())","        }","    }","","    let negative_integer_large = NegInt(-100000);","    let n = N { n: negative_integer_large };","    let result = n.as_f64();","    assert_eq!(result, Some(-100000.0));","}"],[]],[["{","    struct N {","        n: Option<PosInt>,","    }","","    struct PosInt {","        value: u64,","    }","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Some(PosInt { value }) => Some(*value as f64),","                None => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            None // Not handling parsing for this test","        }","    }","","    let num = N {","        n: Some(PosInt { value: 42 }),","    };","","    assert_eq!(num.as_f64(), Some(42.0));","}"],[]],[["{","    struct N {","        n: Option<PosInt>,","    }","","    struct PosInt {","        value: u64,","    }","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Some(PosInt { value }) => Some(*value as f64),","                None => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            None // Not handling parsing for this test","        }","    }","","    let num = N {","        n: Some(PosInt { value: 0 }),","    };","","    assert_eq!(num.as_f64(), Some(0.0));","}"],[]],[["{","    struct N {","        n: Option<PosInt>,","    }","","    struct PosInt {","        value: u64,","    }","","    impl N {","        pub fn as_f64(&self) -> Option<f64> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Some(PosInt { value }) => Some(*value as f64),","                None => None,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            None // Not handling parsing for this test","        }","    }","","    let num = N {","        n: Some(PosInt { value: u64::MAX }),","    };","","    assert_eq!(num.as_f64(), Some(u64::MAX as f64));","}"],[]]]}