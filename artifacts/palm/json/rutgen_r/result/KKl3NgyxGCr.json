{"function_name":"serde_json::number::number::Number::is_i64","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/number.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":6,"tests_lines":[23,39,42,36,39,39],"oracles":6,"oracles_compiled":5,"oracles_compiled_rate":83.33333333333334,"tests_compiled":5,"tests_compiled_rate":83.33333333333334,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[81,82,83,84,85,86,90],"codes_lines_covered":[[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        pub fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","        ","        // Dummy implementation for context, this method is used in the feature flag case.","        pub fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","    ","    // Test case where `n` is a negative integer","    let number = Number { n: N::NegInt(-1) };","    assert_eq!(number.is_i64(), true);","","    let number_large_neg = Number { n: N::NegInt(i64::MIN) };","    assert_eq!(number_large_neg.is_i64(), true);","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a positive integer within the bounds of i64","    let number = Number { n: N::PosInt(0) };","    assert!(number.is_i64());","","    let number = Number { n: N::PosInt(1) };","    assert!(number.is_i64());","","    let number = Number { n: N::PosInt(i64::MAX as u64) };","    assert!(number.is_i64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a positive integer out of the bounds of i64","    let number = Number { n: N::PosInt(i64::MAX as u64 + 1) };","    assert!(!number.is_i64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a negative integer","    let number = Number { n: N::NegInt(-1) };","    assert!(number.is_i64());","","    let number = Number { n: N::NegInt(i64::MIN) };","    assert!(number.is_i64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a float","    let number = Number { n: N::Float(3.14) };","    assert!(!number.is_i64());","","    let number = Number { n: N::Float(0.0) };","    assert!(!number.is_i64());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        pub fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","        ","        // Dummy implementation for context, this method is used in the feature flag case.","        pub fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","    ","    // Test case where `n` is a negative integer","    let number = Number { n: N::NegInt(-1) };","    assert_eq!(number.is_i64(), true);","","    let number_large_neg = Number { n: N::NegInt(i64::MIN) };","    assert_eq!(number_large_neg.is_i64(), true);","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a positive integer within the bounds of i64","    let number = Number { n: N::PosInt(0) };","    assert!(number.is_i64());","","    let number = Number { n: N::PosInt(1) };","    assert!(number.is_i64());","","    let number = Number { n: N::PosInt(i64::MAX as u64) };","    assert!(number.is_i64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a positive integer out of the bounds of i64","    let number = Number { n: N::PosInt(i64::MAX as u64 + 1) };","    assert!(!number.is_i64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a negative integer","    let number = Number { n: N::NegInt(-1) };","    assert!(number.is_i64());","","    let number = Number { n: N::NegInt(i64::MIN) };","    assert!(number.is_i64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        fn is_i64(&self) -> bool {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match self.n {","                N::PosInt(v) => v <= i64::MAX as u64,","                N::NegInt(_) => true,","                N::Float(_) => false,","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.as_i64().is_some()","        }","","        fn as_i64(&self) -> Option<i64> {","            match self.n {","                N::PosInt(v) if v <= i64::MAX as u64 => Some(v as i64),","                N::NegInt(v) => Some(v),","                _ => None,","            }","        }","    }","","    // Test with a float","    let number = Number { n: N::Float(3.14) };","    assert!(!number.is_i64());","","    let number = Number { n: N::Float(0.0) };","    assert!(!number.is_i64());","}"],[]]]}