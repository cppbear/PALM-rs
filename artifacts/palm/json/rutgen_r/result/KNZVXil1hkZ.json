{"function_name":"serde_json::read::push_wtf8_codepoint","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/read.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":24,"tests_lines":[13,6,6,6,6,5,5,5,5,5,5,5,4,4,5,4,4,4,5,5,5,5,6,35],"oracles":24,"oracles_compiled":24,"oracles_compiled_rate":100.0,"tests_compiled":24,"tests_compiled_rate":100.0,"oracles_run":24,"oracles_passed":6,"oracles_passed_rate":25.0,"tests_run":24,"tests_passed":6,"tests_passed_rate":25.0,"lines":38,"lines_covered":38,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1000,1001,1002,1003,1004,1006,1007,1008,1009,1010,1011,1012,1014,1016,1017,1018,1019,1021],"codes_lines_covered":[[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x00, &mut scratch);","    assert_eq!(scratch, vec![0x00]); // Testing lower bound","","    scratch.clear();","    push_wtf8_codepoint(0x1F, &mut scratch);","    assert_eq!(scratch, vec![0x1F]); // Testing another value below 0x80","","    scratch.clear();","    push_wtf8_codepoint(0x7F, &mut scratch);","    assert_eq!(scratch, vec![0x7F]); // Testing upper bound for n < 0x80","}"],[978,979,980,981,1021]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x20; // Within ASCII range 0..=0x7F","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0x20]);","}"],[978,979,980,981,1021]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x80; // Boundary condition where n < 0x80 is false","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]); // UTF-8 encoding for 0x80","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x150; // Within the range 0x80..=0x7FF","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0101, 0b1000_1000]); // UTF-8 encoding for 0x150","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x1F600; // Within the range 0x10000..=0x10FFFF","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0b1111_1000, 0b1001_1111, 0b1001_1000, 0b1000_0000]); // UTF-8 encoding for 0x1F600","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1006,1007,1008,1009,1010,1011,1012,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x80, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x200, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0010, 0b1000_0000]);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x7FF, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0111, 0b1011_1111]);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x800, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0000, 0b1000_0000]);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1001,1002,1003,1004,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10000, &mut scratch);","    assert_eq!(scratch, vec![0b1111_0000, 0b1000_0000, 0b1000_0000, 0b1000_0000]);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1006,1007,1008,1009,1010,1011,1012,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x800, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0000]); // Expectation for 0x800","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1001,1002,1003,1004,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0xFFFF, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1011_1111, 0b1001_1111]); // Expectation for 0xFFFF","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1001,1002,1003,1004,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x7F, &mut scratch); // Should panic due to constraint violation","}"],[978,979,980,981,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x110000, &mut scratch); // Should panic due to constraint violation","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1006,1014]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x801, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0001, 0b1000_0000]); // Expectation for 0x801","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1001,1002,1003,1004,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x7F, &mut scratch);","}"],[978,979,980,981,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x80, &mut scratch);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x800, &mut scratch);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1001,1002,1003,1004,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10000, &mut scratch);","    assert_eq!(scratch.len(), 4);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1006,1007,1008,1009,1010,1011,1012,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10FFFF, &mut scratch);","    assert_eq!(scratch.len(), 4);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1006,1007,1008,1009,1010,1011,1012,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    // n is greater than 0x10FFFF, triggering a panic.","    push_wtf8_codepoint(0x11_0000, &mut scratch);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1006,1014]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x80, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10_FFFF, &mut scratch);","    let expected = vec![0b1111_0000, 0b1000_0000, 0b1000_0000, 0b1000_0000];","    assert_eq!(scratch, expected);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,1000,1006,1007,1008,1009,1010,1011,1012,1016,1017,1018,1019,1021]],[["{","    let mut scratch = Vec::new();","","    // Test input where n == 0x80, which should trigger the case for n > 0x7F","    push_wtf8_codepoint(0x80, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0x7FF, which should also validate proper encoding","    push_wtf8_codepoint(0x7FF, &mut scratch);","    assert_eq!(scratch, vec![0b1101_1111, 0b1011_1111]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0x800, which is the beginning of the next range","    push_wtf8_codepoint(0x800, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0000, 0b0000_0000]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0xFFFF, which should validate the 3-byte encoding","    push_wtf8_codepoint(0xFFFF, &mut scratch);","    assert_eq!(scratch, vec![0b1110_1111, 0b1011_1111, 0b1000_0000]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0x10FFFF, which should validate the 4-byte encoding","    push_wtf8_codepoint(0x10FFFF, &mut scratch);","    assert_eq!(scratch, vec![0b1111_0000, 0b1000_0000, 0b1000_0000, 0b1000_0000]);","}"],[978,979,982,983,984,985,986,987,988,989,990,991,992,994,995,996,997,998,1016,1017,1018,1019,1021]]],"codes_branches":[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x00, &mut scratch);","    assert_eq!(scratch, vec![0x00]); // Testing lower bound","","    scratch.clear();","    push_wtf8_codepoint(0x1F, &mut scratch);","    assert_eq!(scratch, vec![0x1F]); // Testing another value below 0x80","","    scratch.clear();","    push_wtf8_codepoint(0x7F, &mut scratch);","    assert_eq!(scratch, vec![0x7F]); // Testing upper bound for n < 0x80","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":true,"negative":false}]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x20; // Within ASCII range 0..=0x7F","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0x20]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":true,"negative":false}]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x80; // Boundary condition where n < 0x80 is false","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]); // UTF-8 encoding for 0x80","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x150; // Within the range 0x80..=0x7FF","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0101, 0b1000_1000]); // UTF-8 encoding for 0x150","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch: Vec<u8> = Vec::new();","    let n: u32 = 0x1F600; // Within the range 0x10000..=0x10FFFF","    push_wtf8_codepoint(n, &mut scratch);","    assert_eq!(scratch, vec![0b1111_1000, 0b1001_1111, 0b1001_1000, 0b1000_0000]); // UTF-8 encoding for 0x1F600","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x80, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x200, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0010, 0b1000_0000]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x7FF, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0111, 0b1011_1111]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x800, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0000, 0b1000_0000]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10000, &mut scratch);","    assert_eq!(scratch, vec![0b1111_0000, 0b1000_0000, 0b1000_0000, 0b1000_0000]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x800, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0000]); // Expectation for 0x800","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0xFFFF, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1011_1111, 0b1001_1111]); // Expectation for 0xFFFF","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x7F, &mut scratch); // Should panic due to constraint violation","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":true,"negative":false}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x110000, &mut scratch); // Should panic due to constraint violation","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x801, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0001, 0b1000_0000]); // Expectation for 0x801","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x7F, &mut scratch);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":true,"negative":false}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x80, &mut scratch);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x800, &mut scratch);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10000, &mut scratch);","    assert_eq!(scratch.len(), 4);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10FFFF, &mut scratch);","    assert_eq!(scratch.len(), 4);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    // n is greater than 0x10FFFF, triggering a panic.","    push_wtf8_codepoint(0x11_0000, &mut scratch);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x80, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","    push_wtf8_codepoint(0x10_FFFF, &mut scratch);","    let expected = vec![0b1111_0000, 0b1000_0000, 0b1000_0000, 0b1000_0000];","    assert_eq!(scratch, expected);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]],[["{","    let mut scratch = Vec::new();","","    // Test input where n == 0x80, which should trigger the case for n > 0x7F","    push_wtf8_codepoint(0x80, &mut scratch);","    assert_eq!(scratch, vec![0b1100_0000, 0b1000_0000]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0x7FF, which should also validate proper encoding","    push_wtf8_codepoint(0x7FF, &mut scratch);","    assert_eq!(scratch, vec![0b1101_1111, 0b1011_1111]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0x800, which is the beginning of the next range","    push_wtf8_codepoint(0x800, &mut scratch);","    assert_eq!(scratch, vec![0b1110_0000, 0b1000_0000, 0b0000_0000]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0xFFFF, which should validate the 3-byte encoding","    push_wtf8_codepoint(0xFFFF, &mut scratch);","    assert_eq!(scratch, vec![0b1110_1111, 0b1011_1111, 0b1000_0000]);","","    // Clear the scratch for the next test","    scratch.clear();","","    // Test input where n == 0x10FFFF, which should validate the 4-byte encoding","    push_wtf8_codepoint(0x10FFFF, &mut scratch);","    assert_eq!(scratch, vec![0b1111_0000, 0b1000_0000, 0b1000_0000, 0b1000_0000]);","}"],[{"start_line":979,"start_column":8,"end_line":979,"end_column":16,"positive":false,"negative":true}]]]}