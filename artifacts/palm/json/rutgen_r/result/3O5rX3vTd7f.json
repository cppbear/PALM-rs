{"function_name":"serde_json::number::number::Number::as_u128","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/number.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":6,"tests_lines":[15,15,14,24,20,21],"oracles":6,"oracles_compiled":3,"oracles_compiled_rate":50.0,"tests_compiled":3,"tests_compiled_rate":50.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[216,217,218,219,220,224],"codes_lines_covered":[[["{","    struct N {","        value: i64,","    }","","    impl N {","        fn as_u128(&self) -> Option<u128> {","            match self.value {","                n if n >= 0 => Some(n as u128),","                _ => None,","            }","        }","    }","","    let pos_int_0 = N { value: 0 };","    let pos_int_1 = N { value: 1 };","    let pos_int_100 = N { value: 100 };","    let pos_int_max = N { value: i64::MAX };","","    assert_eq!(pos_int_0.as_u128(), Some(0));","    assert_eq!(pos_int_1.as_u128(), Some(1));","    assert_eq!(pos_int_100.as_u128(), Some(100));","    assert_eq!(pos_int_max.as_u128(), Some(u128::MAX)); // i64::MAX fits within u128","}"],[]],[["{","    struct N {","        value: i64,","    }","","    impl N {","        fn as_u128(&self) -> Option<u128> {","            match self.value {","                n if n >= 0 => Some(n as u128),","                _ => None,","            }","        }","    }","","    let neg_int_neg1 = N { value: -1 };","    let neg_int_neg100 = N { value: -100 };","","    assert_eq!(neg_int_neg1.as_u128(), None);","    assert_eq!(neg_int_neg100.as_u128(), None);","}"],[]],[["{","    struct N {","        value: f64,","    }","","    impl N {","        fn as_u128(&self) -> Option<u128> {","            if self.value.fract() == 0.0 && self.value >= 0.0 {","                Some(self.value as u128)","            } else {","                None","            }","        }","    }","","    let float_value = N { value: 1.5 };","    let float_neg_value = N { value: -1.5 };","","    assert_eq!(float_value.as_u128(), None);","    assert_eq!(float_neg_value.as_u128(), None);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct N {","        value: i64,","    }","","    impl N {","        fn as_u128(&self) -> Option<u128> {","            match self.value {","                n if n >= 0 => Some(n as u128),","                _ => None,","            }","        }","    }","","    let pos_int_0 = N { value: 0 };","    let pos_int_1 = N { value: 1 };","    let pos_int_100 = N { value: 100 };","    let pos_int_max = N { value: i64::MAX };","","    assert_eq!(pos_int_0.as_u128(), Some(0));","    assert_eq!(pos_int_1.as_u128(), Some(1));","    assert_eq!(pos_int_100.as_u128(), Some(100));","    assert_eq!(pos_int_max.as_u128(), Some(u128::MAX)); // i64::MAX fits within u128","}"],[]],[["{","    struct N {","        value: i64,","    }","","    impl N {","        fn as_u128(&self) -> Option<u128> {","            match self.value {","                n if n >= 0 => Some(n as u128),","                _ => None,","            }","        }","    }","","    let neg_int_neg1 = N { value: -1 };","    let neg_int_neg100 = N { value: -100 };","","    assert_eq!(neg_int_neg1.as_u128(), None);","    assert_eq!(neg_int_neg100.as_u128(), None);","}"],[]],[["{","    struct N {","        value: f64,","    }","","    impl N {","        fn as_u128(&self) -> Option<u128> {","            if self.value.fract() == 0.0 && self.value >= 0.0 {","                Some(self.value as u128)","            } else {","                None","            }","        }","    }","","    let float_value = N { value: 1.5 };","    let float_neg_value = N { value: -1.5 };","","    assert_eq!(float_value.as_u128(), None);","    assert_eq!(float_neg_value.as_u128(), None);","}"],[]]]}