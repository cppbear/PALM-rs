{"function_name":"serde_json::number::number::Number::as_f32","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/number.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":12,"tests_lines":[4,4,4,4,4,30,30,4,4,4,4,4],"oracles":12,"oracles_compiled":12,"oracles_compiled_rate":100.0,"tests_compiled":12,"tests_compiled_rate":100.0,"oracles_run":12,"oracles_passed":12,"oracles_passed_rate":100.0,"tests_run":12,"tests_passed":12,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[309,310,311,312,313,314,318],"codes_lines_covered":[[["{","    let number = Number { n: N::Float(3.14) };","    assert_eq!(number.as_f32(), Some(3.14f32));","}"],[]],[["{","    let number = Number { n: N::Float(-1.5) };","    assert_eq!(number.as_f32(), Some(-1.5f32));","}"],[]],[["{","    let number = Number { n: N::Float(0.0) };","    assert_eq!(number.as_f32(), Some(0.0f32));","}"],[]],[["{","    let number = Number { n: N::Float(1e10) };","    assert_eq!(number.as_f32(), Some(1e10f32));","}"],[]],[["{","    let number = Number { n: N::Float(1e-10) };","    assert_eq!(number.as_f32(), Some(1e-10f32));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","","    struct NegInt(i32);","","    impl N {","        pub(crate) fn as_f32(&self) -> Option<f32> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f32),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.0.parse::<f32>().ok().filter(|float| float.is_finite())","        }","    }","","    let neg_int = NegInt(-42);","    let instance = N { n: neg_int };","    assert_eq!(instance.as_f32(), Some(-42.0));","","    let neg_int_zero = NegInt(0);","    let instance_zero = N { n: neg_int_zero };","    assert_eq!(instance_zero.as_f32(), Some(0.0));","","    let neg_int_large = NegInt(-123456);","    let instance_large = N { n: neg_int_large };","    assert_eq!(instance_large.as_f32(), Some(-123456.0));","}"],[]],[["{","    struct N {","        n: Float,","    }","","    struct Float(f32);","","    impl N {","        pub(crate) fn as_f32(&self) -> Option<f32> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Float(n) => Some(*n),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.0.parse::<f32>().ok().filter(|float| float.is_finite())","        }","    }","","    let float_value = Float(-3.14);","    let instance = N { n: float_value };","    assert_eq!(instance.as_f32(), Some(-3.14));","    ","    let float_zero = Float(0.0);","    let instance_zero = N { n: float_zero };","    assert_eq!(instance_zero.as_f32(), Some(0.0));","","    let float_large = Float(1e38);","    let instance_large = N { n: float_large };","    assert_eq!(instance_large.as_f32(), Some(1e38));","}"],[]],[["{","    let number = Number { n: N::PosInt(42) };","    assert_eq!(number.as_f32(), Some(42.0));","}"],[]],[["{","    let number = Number { n: N::NegInt(-42) };","    assert_eq!(number.as_f32(), Some(-42.0));","}"],[]],[["{","    let number = Number { n: N::Float(42.0) };","    assert_eq!(number.as_f32(), Some(42.0));","}"],[]],[["{","    let number = Number { n: N::PosInt(0) };","    assert_eq!(number.as_f32(), Some(0.0));","}"],[]],[["{","    let number = Number { n: N::NegInt(0) };","    assert_eq!(number.as_f32(), Some(0.0));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let number = Number { n: N::Float(3.14) };","    assert_eq!(number.as_f32(), Some(3.14f32));","}"],[]],[["{","    let number = Number { n: N::Float(-1.5) };","    assert_eq!(number.as_f32(), Some(-1.5f32));","}"],[]],[["{","    let number = Number { n: N::Float(0.0) };","    assert_eq!(number.as_f32(), Some(0.0f32));","}"],[]],[["{","    let number = Number { n: N::Float(1e10) };","    assert_eq!(number.as_f32(), Some(1e10f32));","}"],[]],[["{","    let number = Number { n: N::Float(1e-10) };","    assert_eq!(number.as_f32(), Some(1e-10f32));","}"],[]],[["{","    struct N {","        n: NegInt,","    }","","    struct NegInt(i32);","","    impl N {","        pub(crate) fn as_f32(&self) -> Option<f32> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                NegInt(n) => Some(*n as f32),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.0.parse::<f32>().ok().filter(|float| float.is_finite())","        }","    }","","    let neg_int = NegInt(-42);","    let instance = N { n: neg_int };","    assert_eq!(instance.as_f32(), Some(-42.0));","","    let neg_int_zero = NegInt(0);","    let instance_zero = N { n: neg_int_zero };","    assert_eq!(instance_zero.as_f32(), Some(0.0));","","    let neg_int_large = NegInt(-123456);","    let instance_large = N { n: neg_int_large };","    assert_eq!(instance_large.as_f32(), Some(-123456.0));","}"],[]],[["{","    struct N {","        n: Float,","    }","","    struct Float(f32);","","    impl N {","        pub(crate) fn as_f32(&self) -> Option<f32> {","            #[cfg(not(feature = \"arbitrary_precision\"))]","            match &self.n {","                Float(n) => Some(*n),","            }","            #[cfg(feature = \"arbitrary_precision\")]","            self.n.0.parse::<f32>().ok().filter(|float| float.is_finite())","        }","    }","","    let float_value = Float(-3.14);","    let instance = N { n: float_value };","    assert_eq!(instance.as_f32(), Some(-3.14));","    ","    let float_zero = Float(0.0);","    let instance_zero = N { n: float_zero };","    assert_eq!(instance_zero.as_f32(), Some(0.0));","","    let float_large = Float(1e38);","    let instance_large = N { n: float_large };","    assert_eq!(instance_large.as_f32(), Some(1e38));","}"],[]],[["{","    let number = Number { n: N::PosInt(42) };","    assert_eq!(number.as_f32(), Some(42.0));","}"],[]],[["{","    let number = Number { n: N::NegInt(-42) };","    assert_eq!(number.as_f32(), Some(-42.0));","}"],[]],[["{","    let number = Number { n: N::Float(42.0) };","    assert_eq!(number.as_f32(), Some(42.0));","}"],[]],[["{","    let number = Number { n: N::PosInt(0) };","    assert_eq!(number.as_f32(), Some(0.0));","}"],[]],[["{","    let number = Number { n: N::NegInt(0) };","    assert_eq!(number.as_f32(), Some(0.0));","}"],[]]]}