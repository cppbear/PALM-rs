{"function_name":"serde_json::value::de::<value::de::SeqRefDeserializer<'de> as serde::de::SeqAccess<'de>>::size_hint","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/value/de.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":5,"tests_lines":[32,32,37,31,36],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":5,"tests_passed":4,"tests_passed_rate":80.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1147,1148,1149,1150,1152],"codes_lines_covered":[[["{","    struct MyIter {","        data: Vec<i32>,","    }","","    impl Iterator for MyIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            self.data.pop()","        }","    }","","    struct MyCollection {","        iter: MyIter,","    }","","    impl MyCollection {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let collection = MyCollection {","        iter: MyIter { data: vec![1, 2, 3] }, // This setup will not satisfy lower == upper","    };","","    assert_eq!(collection.size_hint(), None);","}"],[]],[["{","    struct MyIter {","        data: Vec<i32>,","    }","","    impl Iterator for MyIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            self.data.pop()","        }","    }","","    struct MyCollection {","        iter: MyIter,","    }","","    impl MyCollection {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let collection = MyCollection {","        iter: MyIter { data: vec![] }, // Lower and upper will be (0, 0), but doesn't trigger lower == upper","    };","","    assert_eq!(collection.size_hint(), None);","}"],[]],[["{","    struct TestIterator {","        count: usize,","        limit: usize,","    }","    ","    impl Iterator for TestIterator {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.count < self.limit {","                self.count += 1;","                Some(self.count - 1)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIterator,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iter = TestIterator { count: 0, limit: 5 };","    let test_struct = TestStruct { iter };","    ","    assert_eq!(test_struct.size_hint(), Some(5));","}"],[]],[["{","    struct TestIterator {","        count: usize,","    }","    ","    impl Iterator for TestIterator {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            None","        }","    }","","    struct TestStruct {","        iter: TestIterator,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iter = TestIterator { count: 0 };","    let test_struct = TestStruct { iter };","    ","    assert_eq!(test_struct.size_hint(), None);","}"],[]],[["{","    struct TestIterator {","        count: usize,","        limit: usize,","    }","","    impl Iterator for TestIterator {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.count < self.limit {","                self.count += 1;","                Some(self.count)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIterator,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iterator = TestIterator { count: 0, limit: 5 };","    let test_struct = TestStruct { iter: iterator };","    assert_eq!(test_struct.size_hint(), None);","}"],[]]],"codes_branches":[{"start_line":1149,"start_column":37,"end_line":1149,"end_column":51,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MyIter {","        data: Vec<i32>,","    }","","    impl Iterator for MyIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            self.data.pop()","        }","    }","","    struct MyCollection {","        iter: MyIter,","    }","","    impl MyCollection {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let collection = MyCollection {","        iter: MyIter { data: vec![1, 2, 3] }, // This setup will not satisfy lower == upper","    };","","    assert_eq!(collection.size_hint(), None);","}"],[{"start_line":1149,"start_column":37,"end_line":1149,"end_column":51,"positive":false,"negative":false}]],[["{","    struct MyIter {","        data: Vec<i32>,","    }","","    impl Iterator for MyIter {","        type Item = i32;","","        fn next(&mut self) -> Option<Self::Item> {","            self.data.pop()","        }","    }","","    struct MyCollection {","        iter: MyIter,","    }","","    impl MyCollection {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let collection = MyCollection {","        iter: MyIter { data: vec![] }, // Lower and upper will be (0, 0), but doesn't trigger lower == upper","    };","","    assert_eq!(collection.size_hint(), None);","}"],[{"start_line":1149,"start_column":37,"end_line":1149,"end_column":51,"positive":false,"negative":false}]],[["{","    struct TestIterator {","        count: usize,","        limit: usize,","    }","    ","    impl Iterator for TestIterator {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.count < self.limit {","                self.count += 1;","                Some(self.count - 1)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIterator,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iter = TestIterator { count: 0, limit: 5 };","    let test_struct = TestStruct { iter };","    ","    assert_eq!(test_struct.size_hint(), Some(5));","}"],[{"start_line":1149,"start_column":37,"end_line":1149,"end_column":51,"positive":false,"negative":false}]],[["{","    struct TestIterator {","        count: usize,","    }","    ","    impl Iterator for TestIterator {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            None","        }","    }","","    struct TestStruct {","        iter: TestIterator,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iter = TestIterator { count: 0 };","    let test_struct = TestStruct { iter };","    ","    assert_eq!(test_struct.size_hint(), None);","}"],[{"start_line":1149,"start_column":37,"end_line":1149,"end_column":51,"positive":false,"negative":false}]],[["{","    struct TestIterator {","        count: usize,","        limit: usize,","    }","","    impl Iterator for TestIterator {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.count < self.limit {","                self.count += 1;","                Some(self.count)","            } else {","                None","            }","        }","    }","","    struct TestStruct {","        iter: TestIterator,","    }","","    impl TestStruct {","        fn size_hint(&self) -> Option<usize> {","            match self.iter.size_hint() {","                (lower, Some(upper)) if lower == upper => Some(upper),","                _ => None,","            }","        }","    }","","    let iterator = TestIterator { count: 0, limit: 5 };","    let test_struct = TestStruct { iter: iterator };","    assert_eq!(test_struct.size_hint(), None);","}"],[{"start_line":1149,"start_column":37,"end_line":1149,"end_column":51,"positive":false,"negative":false}]]]}