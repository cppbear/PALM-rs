{"function_name":"serde_json::map::map::Map<std::string::String, value::Value>::append","file_path":"/home/abezbm/rust-utgen-test-crates-new/json/src/map.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/json","tests":3,"tests_lines":[50,41,39],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[264,265,266,267,268,269,270],"codes_lines_covered":[[["{","    #[derive(Default)]","    struct MapImpl {","        inner: std::collections::HashMap<String, String>,","    }","","    #[derive(Default)]","    struct MyMap {","        map: MapImpl,","    }","","    impl MyMap {","        pub fn append(&mut self, other: &mut Self) {","            #[cfg(feature = \"preserve_order\")]","            self.map","                .inner","                .extend(std::mem::replace(&mut other.map.inner, MapImpl::default()));","            #[cfg(not(feature = \"preserve_order\"))]","            self.map.inner.extend(other.map.inner.drain());","        }","    }","","    let mut map1 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key1\".to_string(), \"value1\".to_string());","                m.insert(\"key2\".to_string(), \"value2\".to_string());","                m","            }","        },","    };","    let mut map2 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key3\".to_string(), \"value3\".to_string());","                m.insert(\"key4\".to_string(), \"value4\".to_string());","                m","            }","        },","    };","","    map1.append(&mut map2);","","    assert_eq!(map1.map.inner.len(), 4);","    assert_eq!(map1.map.inner.get(\"key1\"), Some(&\"value1\".to_string()));","    assert_eq!(map1.map.inner.get(\"key3\"), Some(&\"value3\".to_string()));","    assert!(map2.map.inner.is_empty());","}"],[]],[["{","    #[derive(Default)]","    struct MapImpl {","        inner: std::collections::HashMap<String, String>,","    }","","    #[derive(Default)]","    struct MyMap {","        map: MapImpl,","    }","","    impl MyMap {","        pub fn append(&mut self, other: &mut Self) {","            #[cfg(feature = \"preserve_order\")]","            self.map","                .inner","                .extend(std::mem::replace(&mut other.map.inner, MapImpl::default()));","            #[cfg(not(feature = \"preserve_order\"))]","            self.map.inner.extend(other.map.inner.drain());","        }","    }","","    let mut map1 = MyMap::default(); // empty map","    let mut map2 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key1\".to_string(), \"value1\".to_string());","                m.insert(\"key2\".to_string(), \"value2\".to_string());","                m","            }","        },","    };","","    map1.append(&mut map2);","","    assert_eq!(map1.map.inner.len(), 2);","    assert_eq!(map1.map.inner.get(\"key1\"), Some(&\"value1\".to_string()));","    assert_eq!(map1.map.inner.get(\"key2\"), Some(&\"value2\".to_string()));","    assert!(map2.map.inner.is_empty());","}"],[]],[["{","    #[derive(Default)]","    struct MapImpl {","        inner: std::collections::HashMap<String, String>,","    }","","    #[derive(Default)]","    struct MyMap {","        map: MapImpl,","    }","","    impl MyMap {","        pub fn append(&mut self, other: &mut Self) {","            #[cfg(feature = \"preserve_order\")]","            self.map","                .inner","                .extend(std::mem::replace(&mut other.map.inner, MapImpl::default()));","            #[cfg(not(feature = \"preserve_order\"))]","            self.map.inner.extend(other.map.inner.drain());","        }","    }","","    let mut map1 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key1\".to_string(), \"value1\".to_string());","                m","            }","        },","    }; ","    let mut map2 = MyMap::default(); // empty map","","    map1.append(&mut map2);","","    assert_eq!(map1.map.inner.len(), 1);","    assert_eq!(map1.map.inner.get(\"key1\"), Some(&\"value1\".to_string()));","    assert!(map2.map.inner.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    #[derive(Default)]","    struct MapImpl {","        inner: std::collections::HashMap<String, String>,","    }","","    #[derive(Default)]","    struct MyMap {","        map: MapImpl,","    }","","    impl MyMap {","        pub fn append(&mut self, other: &mut Self) {","            #[cfg(feature = \"preserve_order\")]","            self.map","                .inner","                .extend(std::mem::replace(&mut other.map.inner, MapImpl::default()));","            #[cfg(not(feature = \"preserve_order\"))]","            self.map.inner.extend(other.map.inner.drain());","        }","    }","","    let mut map1 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key1\".to_string(), \"value1\".to_string());","                m.insert(\"key2\".to_string(), \"value2\".to_string());","                m","            }","        },","    };","    let mut map2 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key3\".to_string(), \"value3\".to_string());","                m.insert(\"key4\".to_string(), \"value4\".to_string());","                m","            }","        },","    };","","    map1.append(&mut map2);","","    assert_eq!(map1.map.inner.len(), 4);","    assert_eq!(map1.map.inner.get(\"key1\"), Some(&\"value1\".to_string()));","    assert_eq!(map1.map.inner.get(\"key3\"), Some(&\"value3\".to_string()));","    assert!(map2.map.inner.is_empty());","}"],[]],[["{","    #[derive(Default)]","    struct MapImpl {","        inner: std::collections::HashMap<String, String>,","    }","","    #[derive(Default)]","    struct MyMap {","        map: MapImpl,","    }","","    impl MyMap {","        pub fn append(&mut self, other: &mut Self) {","            #[cfg(feature = \"preserve_order\")]","            self.map","                .inner","                .extend(std::mem::replace(&mut other.map.inner, MapImpl::default()));","            #[cfg(not(feature = \"preserve_order\"))]","            self.map.inner.extend(other.map.inner.drain());","        }","    }","","    let mut map1 = MyMap::default(); // empty map","    let mut map2 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key1\".to_string(), \"value1\".to_string());","                m.insert(\"key2\".to_string(), \"value2\".to_string());","                m","            }","        },","    };","","    map1.append(&mut map2);","","    assert_eq!(map1.map.inner.len(), 2);","    assert_eq!(map1.map.inner.get(\"key1\"), Some(&\"value1\".to_string()));","    assert_eq!(map1.map.inner.get(\"key2\"), Some(&\"value2\".to_string()));","    assert!(map2.map.inner.is_empty());","}"],[]],[["{","    #[derive(Default)]","    struct MapImpl {","        inner: std::collections::HashMap<String, String>,","    }","","    #[derive(Default)]","    struct MyMap {","        map: MapImpl,","    }","","    impl MyMap {","        pub fn append(&mut self, other: &mut Self) {","            #[cfg(feature = \"preserve_order\")]","            self.map","                .inner","                .extend(std::mem::replace(&mut other.map.inner, MapImpl::default()));","            #[cfg(not(feature = \"preserve_order\"))]","            self.map.inner.extend(other.map.inner.drain());","        }","    }","","    let mut map1 = MyMap {","        map: MapImpl {","            inner: {","                let mut m = std::collections::HashMap::new();","                m.insert(\"key1\".to_string(), \"value1\".to_string());","                m","            }","        },","    }; ","    let mut map2 = MyMap::default(); // empty map","","    map1.append(&mut map2);","","    assert_eq!(map1.map.inner.len(), 1);","    assert_eq!(map1.map.inner.get(\"key1\"), Some(&\"value1\".to_string()));","    assert!(map2.map.inner.is_empty());","}"],[]]]}