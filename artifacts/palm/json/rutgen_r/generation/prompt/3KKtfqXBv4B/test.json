{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/de.rs\n// crate name is serde_json\nThe function to be tested is presented as follows:\n/// Parses a JSON string as bytes. Note that this function does not check\n/// whether the bytes represent a valid UTF-8 string.\n///\n/// The relevant part of the JSON specification is Section 8.2 of [RFC\n/// 7159]:\n///\n/// > When all the strings represented in a JSON text are composed entirely\n/// > of Unicode characters (however escaped), then that JSON text is\n/// > interoperable in the sense that all software implementations that\n/// > parse it will agree on the contents of names and of string values in\n/// > objects and arrays.\n/// >\n/// > However, the ABNF in this specification allows member names and string\n/// > values to contain bit sequences that cannot encode Unicode characters;\n/// > for example, \"\\uDEAD\" (a single unpaired UTF-16 surrogate). Instances\n/// > of this have been observed, for example, when a library truncates a\n/// > UTF-16 string without checking whether the truncation split a\n/// > surrogate pair.  The behavior of software that receives JSON texts\n/// > containing such values is unpredictable; for example, implementations\n/// > might return different values for the length of a string value or even\n/// > suffer fatal runtime exceptions.\n///\n/// [RFC 7159]: https://tools.ietf.org/html/rfc7159\n///\n/// The behavior of serde_json is specified to fail on non-UTF-8 strings\n/// when deserializing into Rust UTF-8 string types such as String, and\n/// succeed with the bytes representing the [WTF-8] encoding of code points\n/// when deserializing using this method.\n///\n/// [WTF-8]: https://simonsapin.github.io/wtf-8\n///\n/// Escape sequences are processed as usual, and for `\\uXXXX` escapes it is\n/// still checked if the hex number represents a valid Unicode code point.\n///\n/// # Examples\n///\n/// You can use this to parse JSON strings containing invalid UTF-8 bytes,\n/// or unpaired surrogates.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"some bytes: \\xe5\\x00\\xe5\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///\n///     assert_eq!(b'\\xe5', bytes[12]);\n///     assert_eq!(b'\\0', bytes[13]);\n///     assert_eq!(b'\\xe5', bytes[14]);\n///\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes().unwrap();\n/// ```\n///\n/// Backslash escape sequences like `\\n` are still interpreted and required\n/// to be valid. `\\u` escape sequences are required to represent a valid\n/// Unicode code point or lone surrogate.\n///\n/// ```\n/// use serde_bytes::ByteBuf;\n///\n/// fn look_at_bytes() -> Result<(), serde_json::Error> {\n///     let json_data = b\"\\\"lone surrogate: \\\\uD801\\\"\";\n///     let bytes: ByteBuf = serde_json::from_slice(json_data)?;\n///     let expected = b\"lone surrogate: \\xED\\xA0\\x81\";\n///     assert_eq!(expected, bytes.as_slice());\n///     Ok(())\n/// }\n/// #\n/// # look_at_bytes();\n/// ```\nfn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value>\nwhere\n    V: de::Visitor<'de>,\n{\n    let peek = match tri!(self.parse_whitespace()) {\n        Some(b) => b,\n        None => {\n            return Err(self.peek_error(ErrorCode::EofWhileParsingValue));\n        }\n    };\n\n    let value = match peek {\n        b'\"' => {\n            self.eat_char();\n            self.scratch.clear();\n            match tri!(self.read.parse_str_raw(&mut self.scratch)) {\n                Reference::Borrowed(b) => visitor.visit_borrowed_bytes(b),\n                Reference::Copied(b) => visitor.visit_bytes(b),\n            }\n        }\n        b'[' => self.deserialize_seq(visitor),\n        _ => Err(self.peek_invalid_type(&visitor)),\n    };\n\n    match value {\n        Ok(value) => Ok(value),\n        Err(err) => Err(self.fix_position(err)),\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}