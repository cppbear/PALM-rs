{
  "name": "serde_json::read::read::SliceRead<'a>::skip_to_escape",
  "name_with_impl": "serde_json::read::{impl#5}::skip_to_escape",
  "mod_info": {
    "name": "read",
    "loc": "src/lib.rs:434:1:434:10"
  },
  "visible": false,
  "loc": "src/read.rs:432:5:481:6",
  "fn_tests": [
    {
      "chain_id": 0,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "struct Slice {",
            "    index: usize,",
            "    slice: Vec<u8>,",
            "}",
            "",
            "impl Slice {",
            "    fn skip_to_escape(&mut self, forbid_control_characters: bool) {",
            "        // Function definition pasted here...",
            "        if self.index == self.slice.len()",
            "            || is_escape(self.slice[self.index], forbid_control_characters)",
            "        {",
            "            return;",
            "        }",
            "        self.index += 1;",
            "",
            "        let rest = &self.slice[self.index..];",
            "",
            "        if !forbid_control_characters {",
            "            self.index += memchr::memchr2(b'\"', b'\\\\', rest).unwrap_or(rest.len());",
            "            return;",
            "        }",
            "",
            "        #[cfg(fast_arithmetic = \"64\")]",
            "        type Chunk = u64;",
            "        #[cfg(fast_arithmetic = \"32\")]",
            "        type Chunk = u32;",
            "",
            "        const STEP: usize = mem::size_of::<Chunk>();",
            "        const ONE_BYTES: Chunk = Chunk::MAX / 255; // 0x0101...01",
            "",
            "        for chunk in rest.chunks_exact(STEP) {",
            "            let chars = Chunk::from_le_bytes(chunk.try_into().unwrap());",
            "            let contains_ctrl = chars.wrapping_sub(ONE_BYTES * 0x20) & !chars;",
            "            let chars_quote = chars ^ (ONE_BYTES * Chunk::from(b'\"'));",
            "            let contains_quote = chars_quote.wrapping_sub(ONE_BYTES) & !chars_quote;",
            "            let chars_backslash = chars ^ (ONE_BYTES * Chunk::from(b'\\\\'));",
            "            let contains_backslash = chars_backslash.wrapping_sub(ONE_BYTES) & !chars_backslash;",
            "            let masked = (contains_ctrl | contains_quote | contains_backslash) & (ONE_BYTES << 7);",
            "            if masked != 0 {",
            "                self.index = unsafe { chunk.as_ptr().offset_from(self.slice.as_ptr()) } as usize",
            "                    + masked.trailing_zeros() as usize / 8;",
            "                return;",
            "            }",
            "        }",
            "",
            "        self.index += rest.len() / STEP * STEP;",
            "        self.skip_to_escape_slow();",
            "    }",
            "",
            "    fn skip_to_escape_slow(&mut self) {",
            "        // Implementation of skip_to_escape_slow goes here...",
            "    }",
            "}",
            "",
            "fn is_escape(byte: u8, forbid_control_characters: bool) -> bool {",
            "    // Implementation of is_escape goes here...",
            "    false // Dummy implementation for example purposes",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut slice = Slice { index: 0, slice: b\"\".to_vec() };",
                  "    slice.skip_to_escape(false);",
                  "    assert_eq!(slice.index, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut slice = Slice { index: 0, slice: b\"\\\\u041b\\\\u0435\".to_vec() };",
                  "    slice.skip_to_escape(false);",
                  "    assert_eq!(slice.index, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut slice = Slice { index: 0, slice: b\"Hello, World!\".to_vec() };",
                  "    slice.skip_to_escape(false);",
                  "    assert_eq!(slice.index, slice.slice.len());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut slice = Slice { index: 0, slice: b\"Hello\\x01World\".to_vec() };",
                  "    slice.skip_to_escape(true);",
                  "    assert_ne!(slice.index, slice.slice.len());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut slice = Slice { index: 0, slice: b\"Hello \\\" World\".to_vec() };",
                  "    slice.skip_to_escape(true);",
                  "    assert!(slice.index < slice.slice.len()); // Should not skip to the end",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut slice = Slice { index: 0, slice: b\"Hello \\\\ World\".to_vec() };",
                  "    slice.skip_to_escape(true);",
                  "    assert!(slice.index < slice.slice.len()); // Should not skip to the end",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}