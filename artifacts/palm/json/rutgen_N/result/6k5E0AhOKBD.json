{"function_name":"serde_json::number::number::Number::is_u64","tests":3,"tests_lines":[38,38,38],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[96,97,98,99,100,104],"codes_lines_covered":[[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        #[cfg(not(feature = \"arbitrary_precision\"))]","        pub fn is_u64(&self) -> bool {","            match self.n {","                N::PosInt(_) => true,","                N::NegInt(_) | N::Float(_) => false,","            }","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn is_u64(&self) -> bool {","            self.as_u64().is_some()","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn as_u64(&self) -> Option<u64> {","            if let N::PosInt(value) = self.n {","                Some(value)","            } else {","                None","            }","        }","    }","","    let number = Number { n: N::PosInt(42) };","    assert!(number.is_u64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        #[cfg(not(feature = \"arbitrary_precision\"))]","        pub fn is_u64(&self) -> bool {","            match self.n {","                N::PosInt(_) => true,","                N::NegInt(_) | N::Float(_) => false,","            }","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn is_u64(&self) -> bool {","            self.as_u64().is_some()","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn as_u64(&self) -> Option<u64> {","            if let N::PosInt(value) = self.n {","                Some(value)","            } else {","                None","            }","        }","    }","","    let number = Number { n: N::NegInt(-1) };","    assert!(!number.is_u64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        #[cfg(not(feature = \"arbitrary_precision\"))]","        pub fn is_u64(&self) -> bool {","            match self.n {","                N::PosInt(_) => true,","                N::NegInt(_) | N::Float(_) => false,","            }","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn is_u64(&self) -> bool {","            self.as_u64().is_some()","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn as_u64(&self) -> Option<u64> {","            if let N::PosInt(value) = self.n {","                Some(value)","            } else {","                None","            }","        }","    }","","    let number = Number { n: N::Float(3.14) };","    assert!(!number.is_u64());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        #[cfg(not(feature = \"arbitrary_precision\"))]","        pub fn is_u64(&self) -> bool {","            match self.n {","                N::PosInt(_) => true,","                N::NegInt(_) | N::Float(_) => false,","            }","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn is_u64(&self) -> bool {","            self.as_u64().is_some()","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn as_u64(&self) -> Option<u64> {","            if let N::PosInt(value) = self.n {","                Some(value)","            } else {","                None","            }","        }","    }","","    let number = Number { n: N::PosInt(42) };","    assert!(number.is_u64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        #[cfg(not(feature = \"arbitrary_precision\"))]","        pub fn is_u64(&self) -> bool {","            match self.n {","                N::PosInt(_) => true,","                N::NegInt(_) | N::Float(_) => false,","            }","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn is_u64(&self) -> bool {","            self.as_u64().is_some()","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn as_u64(&self) -> Option<u64> {","            if let N::PosInt(value) = self.n {","                Some(value)","            } else {","                None","            }","        }","    }","","    let number = Number { n: N::NegInt(-1) };","    assert!(!number.is_u64());","}"],[]],[["{","    struct Number {","        n: N,","    }","","    enum N {","        PosInt(u64),","        NegInt(i64),","        Float(f64),","    }","","    impl Number {","        #[cfg(not(feature = \"arbitrary_precision\"))]","        pub fn is_u64(&self) -> bool {","            match self.n {","                N::PosInt(_) => true,","                N::NegInt(_) | N::Float(_) => false,","            }","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn is_u64(&self) -> bool {","            self.as_u64().is_some()","        }","","        #[cfg(feature = \"arbitrary_precision\")]","        pub fn as_u64(&self) -> Option<u64> {","            if let N::PosInt(value) = self.n {","                Some(value)","            } else {","                None","            }","        }","    }","","    let number = Number { n: N::Float(3.14) };","    assert!(!number.is_u64());","}"],[]]]}