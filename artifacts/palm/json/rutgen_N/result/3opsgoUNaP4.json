{"function_name":"serde_json::map::map::Entry<'a>::key","tests":2,"tests_lines":[21,21],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[659,660,661,662,664],"codes_lines_covered":[[["{","    struct OccupiedEntry {","        key: String,","    }","","    impl OccupiedEntry {","        fn key(&self) -> &String {","            &self.key","        }","    }","","    enum Entry {","        Vacant,","        Occupied(OccupiedEntry),","    }","","    let entry = Entry::Occupied(OccupiedEntry { key: \"serde\".to_string() });","    if let Entry::Occupied(e) = entry {","        assert_eq!(e.key(), &\"serde\".to_string());","    }","}"],[]],[["{","    struct VacantEntry {","        key: String,","    }","","    impl VacantEntry {","        fn key(&self) -> &String {","            &self.key","        }","    }","","    enum Entry {","        Vacant(VacantEntry),","        Occupied,","    }","","    let entry = Entry::Vacant(VacantEntry { key: \"serde\".to_string() });","    if let Entry::Vacant(e) = entry {","        assert_eq!(e.key(), &\"serde\".to_string());","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct OccupiedEntry {","        key: String,","    }","","    impl OccupiedEntry {","        fn key(&self) -> &String {","            &self.key","        }","    }","","    enum Entry {","        Vacant,","        Occupied(OccupiedEntry),","    }","","    let entry = Entry::Occupied(OccupiedEntry { key: \"serde\".to_string() });","    if let Entry::Occupied(e) = entry {","        assert_eq!(e.key(), &\"serde\".to_string());","    }","}"],[]],[["{","    struct VacantEntry {","        key: String,","    }","","    impl VacantEntry {","        fn key(&self) -> &String {","            &self.key","        }","    }","","    enum Entry {","        Vacant(VacantEntry),","        Occupied,","    }","","    let entry = Entry::Vacant(VacantEntry { key: \"serde\".to_string() });","    if let Entry::Vacant(e) = entry {","        assert_eq!(e.key(), &\"serde\".to_string());","    }","}"],[]]]}