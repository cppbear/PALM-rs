{"function_name":"serde_json::de::de::Deserializer<R>::parse_long_integer","tests":3,"tests_lines":[64,64,64],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":3,"tests_passed":0,"tests_passed_rate":0.0,"lines":13,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[717,718,720,721,722,723,724,725,726,728,731,734,738],"codes_lines_covered":[[["{","    struct TestParser {","        input: Vec<u8>,","        pos: usize,","    }","","    impl TestParser {","        fn new(input: Vec<u8>) -> Self {","            TestParser { input, pos: 0 }","        }","","        fn peek_or_null(&mut self) -> Result<u8> {","            if self.pos < self.input.len() {","                Ok(self.input[self.pos])","            } else {","                Ok(0)","            }","        }","","        fn eat_char(&mut self) {","            if self.pos < self.input.len() {","                self.pos += 1;","            }","        }","","        fn parse_decimal(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_exponent(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            // Simplified for testing purposes","            Ok(significand as f64 * 10f64.powi(exponent as i32))","        }","","        fn f64_from_parts(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {","            let mut exponent = 0;","            loop {","                match self.peek_or_null() {","                    Ok(b'0') | Ok(b'1') | Ok(b'2') | Ok(b'3') | Ok(b'4') | Ok(b'5') | Ok(b'6') | Ok(b'7') | Ok(b'8') | Ok(b'9') => {","                        self.eat_char();","                        exponent += 1;","                    }","                    Ok(b'.') => {","                        return self.parse_decimal(positive, significand, exponent);","                    }","                    Ok(b'e') | Ok(b'E') => {","                        return self.parse_exponent(positive, significand, exponent);","                    }","                    _ => {","                        return self.f64_from_parts(positive, significand, exponent);","                    }","                }","            }","        }","    }","","    let mut parser = TestParser::new(b\"12345\".to_vec());","    let result = parser.parse_long_integer(true, 12345);","    assert_eq!(result.unwrap(), 12345.0);","}"],[]],[["{","    struct TestParser {","        input: Vec<u8>,","        pos: usize,","    }","","    impl TestParser {","        fn new(input: Vec<u8>) -> Self {","            TestParser { input, pos: 0 }","        }","","        fn peek_or_null(&mut self) -> Result<u8> {","            if self.pos < self.input.len() {","                Ok(self.input[self.pos])","            } else {","                Ok(0)","            }","        }","","        fn eat_char(&mut self) {","            if self.pos < self.input.len() {","                self.pos += 1;","            }","        }","","        fn parse_decimal(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_exponent(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            // Simplified for testing purposes","            Ok(significand as f64 * 10f64.powi(exponent as i32))","        }","","        fn f64_from_parts(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {","            let mut exponent = 0;","            loop {","                match self.peek_or_null() {","                    Ok(b'0') | Ok(b'1') | Ok(b'2') | Ok(b'3') | Ok(b'4') | Ok(b'5') | Ok(b'6') | Ok(b'7') | Ok(b'8') | Ok(b'9') => {","                        self.eat_char();","                        exponent += 1;","                    }","                    Ok(b'.') => {","                        return self.parse_decimal(positive, significand, exponent);","                    }","                    Ok(b'e') | Ok(b'E') => {","                        return self.parse_exponent(positive, significand, exponent);","                    }","                    _ => {","                        return self.f64_from_parts(positive, significand, exponent);","                    }","                }","            }","        }","    }","","    let mut parser = TestParser::new(b\"12345\".to_vec());","    let result = parser.parse_long_integer(false, 12345);","    assert_eq!(result.unwrap(), -12345.0);","}"],[]],[["{","    struct TestParser {","        input: Vec<u8>,","        pos: usize,","    }","","    impl TestParser {","        fn new(input: Vec<u8>) -> Self {","            TestParser { input, pos: 0 }","        }","","        fn peek_or_null(&mut self) -> Result<u8> {","            if self.pos < self.input.len() {","                Ok(self.input[self.pos])","            } else {","                Ok(0)","            }","        }","","        fn eat_char(&mut self) {","            if self.pos < self.input.len() {","                self.pos += 1;","            }","        }","","        fn parse_decimal(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_exponent(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            // Simplified for testing purposes","            Ok(significand as f64 * 10f64.powi(exponent as i32))","        }","","        fn f64_from_parts(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {","            let mut exponent = 0;","            loop {","                match self.peek_or_null() {","                    Ok(b'0') | Ok(b'1') | Ok(b'2') | Ok(b'3') | Ok(b'4') | Ok(b'5') | Ok(b'6') | Ok(b'7') | Ok(b'8') | Ok(b'9') => {","                        self.eat_char();","                        exponent += 1;","                    }","                    Ok(b'.') => {","                        return self.parse_decimal(positive, significand, exponent);","                    }","                    Ok(b'e') | Ok(b'E') => {","                        return self.parse_exponent(positive, significand, exponent);","                    }","                    _ => {","                        return self.f64_from_parts(positive, significand, exponent);","                    }","                }","            }","        }","    }","","    let mut parser = TestParser::new(b\"123.456\".to_vec());","    let result = parser.parse_long_integer(true, 123);","    assert_eq!(result.unwrap(), 123.0); // Adjust according to expected behavior","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestParser {","        input: Vec<u8>,","        pos: usize,","    }","","    impl TestParser {","        fn new(input: Vec<u8>) -> Self {","            TestParser { input, pos: 0 }","        }","","        fn peek_or_null(&mut self) -> Result<u8> {","            if self.pos < self.input.len() {","                Ok(self.input[self.pos])","            } else {","                Ok(0)","            }","        }","","        fn eat_char(&mut self) {","            if self.pos < self.input.len() {","                self.pos += 1;","            }","        }","","        fn parse_decimal(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_exponent(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            // Simplified for testing purposes","            Ok(significand as f64 * 10f64.powi(exponent as i32))","        }","","        fn f64_from_parts(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {","            let mut exponent = 0;","            loop {","                match self.peek_or_null() {","                    Ok(b'0') | Ok(b'1') | Ok(b'2') | Ok(b'3') | Ok(b'4') | Ok(b'5') | Ok(b'6') | Ok(b'7') | Ok(b'8') | Ok(b'9') => {","                        self.eat_char();","                        exponent += 1;","                    }","                    Ok(b'.') => {","                        return self.parse_decimal(positive, significand, exponent);","                    }","                    Ok(b'e') | Ok(b'E') => {","                        return self.parse_exponent(positive, significand, exponent);","                    }","                    _ => {","                        return self.f64_from_parts(positive, significand, exponent);","                    }","                }","            }","        }","    }","","    let mut parser = TestParser::new(b\"12345\".to_vec());","    let result = parser.parse_long_integer(true, 12345);","    assert_eq!(result.unwrap(), 12345.0);","}"],[]],[["{","    struct TestParser {","        input: Vec<u8>,","        pos: usize,","    }","","    impl TestParser {","        fn new(input: Vec<u8>) -> Self {","            TestParser { input, pos: 0 }","        }","","        fn peek_or_null(&mut self) -> Result<u8> {","            if self.pos < self.input.len() {","                Ok(self.input[self.pos])","            } else {","                Ok(0)","            }","        }","","        fn eat_char(&mut self) {","            if self.pos < self.input.len() {","                self.pos += 1;","            }","        }","","        fn parse_decimal(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_exponent(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            // Simplified for testing purposes","            Ok(significand as f64 * 10f64.powi(exponent as i32))","        }","","        fn f64_from_parts(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {","            let mut exponent = 0;","            loop {","                match self.peek_or_null() {","                    Ok(b'0') | Ok(b'1') | Ok(b'2') | Ok(b'3') | Ok(b'4') | Ok(b'5') | Ok(b'6') | Ok(b'7') | Ok(b'8') | Ok(b'9') => {","                        self.eat_char();","                        exponent += 1;","                    }","                    Ok(b'.') => {","                        return self.parse_decimal(positive, significand, exponent);","                    }","                    Ok(b'e') | Ok(b'E') => {","                        return self.parse_exponent(positive, significand, exponent);","                    }","                    _ => {","                        return self.f64_from_parts(positive, significand, exponent);","                    }","                }","            }","        }","    }","","    let mut parser = TestParser::new(b\"12345\".to_vec());","    let result = parser.parse_long_integer(false, 12345);","    assert_eq!(result.unwrap(), -12345.0);","}"],[]],[["{","    struct TestParser {","        input: Vec<u8>,","        pos: usize,","    }","","    impl TestParser {","        fn new(input: Vec<u8>) -> Self {","            TestParser { input, pos: 0 }","        }","","        fn peek_or_null(&mut self) -> Result<u8> {","            if self.pos < self.input.len() {","                Ok(self.input[self.pos])","            } else {","                Ok(0)","            }","        }","","        fn eat_char(&mut self) {","            if self.pos < self.input.len() {","                self.pos += 1;","            }","        }","","        fn parse_decimal(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_exponent(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            // Simplified for testing purposes","            Ok(significand as f64 * 10f64.powi(exponent as i32))","        }","","        fn f64_from_parts(&self, positive: bool, significand: u64, exponent: usize) -> Result<f64> {","            Ok(if positive { significand as f64 } else { -(significand as f64) } * 10f64.powi(exponent as i32))","        }","","        fn parse_long_integer(&mut self, positive: bool, significand: u64) -> Result<f64> {","            let mut exponent = 0;","            loop {","                match self.peek_or_null() {","                    Ok(b'0') | Ok(b'1') | Ok(b'2') | Ok(b'3') | Ok(b'4') | Ok(b'5') | Ok(b'6') | Ok(b'7') | Ok(b'8') | Ok(b'9') => {","                        self.eat_char();","                        exponent += 1;","                    }","                    Ok(b'.') => {","                        return self.parse_decimal(positive, significand, exponent);","                    }","                    Ok(b'e') | Ok(b'E') => {","                        return self.parse_exponent(positive, significand, exponent);","                    }","                    _ => {","                        return self.f64_from_parts(positive, significand, exponent);","                    }","                }","            }","        }","    }","","    let mut parser = TestParser::new(b\"123.456\".to_vec());","    let result = parser.parse_long_integer(true, 123);","    assert_eq!(result.unwrap(), 123.0); // Adjust according to expected behavior","}"],[]]]}