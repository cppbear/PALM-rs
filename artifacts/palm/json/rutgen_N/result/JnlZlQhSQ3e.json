{"function_name":"serde_json::read::read::SliceRead<'a>::position_of_index","tests":3,"tests_lines":[32,32,32],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[421,422,423,424,426,427,428,429,430],"codes_lines_covered":[[["{","    struct TestStruct {","        slice: Vec<u8>,","    }","","    impl TestStruct {","        fn position_of_index(&self, i: usize) -> Position {","            let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {","                Some(position) => position + 1,","                None => 0,","            };","            Position {","                line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),","                column: i - start_of_line,","            }","        }","    }","","    struct Position {","        line: usize,","        column: usize,","    }","","    let data = b\"Hello, World!\\nThis is a test.\";","    let test_struct = TestStruct {","        slice: data.to_vec(),","    };","    ","    let pos = test_struct.position_of_index(5);","    assert_eq!(pos.line, 1);","    assert_eq!(pos.column, 5);","}"],[]],[["{","    struct TestStruct {","        slice: Vec<u8>,","    }","","    impl TestStruct {","        fn position_of_index(&self, i: usize) -> Position {","            let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {","                Some(position) => position + 1,","                None => 0,","            };","            Position {","                line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),","                column: i - start_of_line,","            }","        }","    }","","    struct Position {","        line: usize,","        column: usize,","    }","","    let data = b\"Hello, World!\\nThis is a test.\";","    let test_struct = TestStruct {","        slice: data.to_vec(),","    };","    ","    let pos = test_struct.position_of_index(15);","    assert_eq!(pos.line, 2);","    assert_eq!(pos.column, 0);","}"],[]],[["{","    struct TestStruct {","        slice: Vec<u8>,","    }","","    impl TestStruct {","        fn position_of_index(&self, i: usize) -> Position {","            let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {","                Some(position) => position + 1,","                None => 0,","            };","            Position {","                line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),","                column: i - start_of_line,","            }","        }","    }","","    struct Position {","        line: usize,","        column: usize,","    }","","    let data = b\"Hello, World!\";","    let test_struct = TestStruct {","        slice: data.to_vec(),","    };","    ","    let pos = test_struct.position_of_index(5);","    assert_eq!(pos.line, 1);","    assert_eq!(pos.column, 5);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestStruct {","        slice: Vec<u8>,","    }","","    impl TestStruct {","        fn position_of_index(&self, i: usize) -> Position {","            let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {","                Some(position) => position + 1,","                None => 0,","            };","            Position {","                line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),","                column: i - start_of_line,","            }","        }","    }","","    struct Position {","        line: usize,","        column: usize,","    }","","    let data = b\"Hello, World!\\nThis is a test.\";","    let test_struct = TestStruct {","        slice: data.to_vec(),","    };","    ","    let pos = test_struct.position_of_index(5);","    assert_eq!(pos.line, 1);","    assert_eq!(pos.column, 5);","}"],[]],[["{","    struct TestStruct {","        slice: Vec<u8>,","    }","","    impl TestStruct {","        fn position_of_index(&self, i: usize) -> Position {","            let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {","                Some(position) => position + 1,","                None => 0,","            };","            Position {","                line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),","                column: i - start_of_line,","            }","        }","    }","","    struct Position {","        line: usize,","        column: usize,","    }","","    let data = b\"Hello, World!\\nThis is a test.\";","    let test_struct = TestStruct {","        slice: data.to_vec(),","    };","    ","    let pos = test_struct.position_of_index(15);","    assert_eq!(pos.line, 2);","    assert_eq!(pos.column, 0);","}"],[]],[["{","    struct TestStruct {","        slice: Vec<u8>,","    }","","    impl TestStruct {","        fn position_of_index(&self, i: usize) -> Position {","            let start_of_line = match memchr::memrchr(b'\\n', &self.slice[..i]) {","                Some(position) => position + 1,","                None => 0,","            };","            Position {","                line: 1 + memchr::memchr_iter(b'\\n', &self.slice[..start_of_line]).count(),","                column: i - start_of_line,","            }","        }","    }","","    struct Position {","        line: usize,","        column: usize,","    }","","    let data = b\"Hello, World!\";","    let test_struct = TestStruct {","        slice: data.to_vec(),","    };","    ","    let pos = test_struct.position_of_index(5);","    assert_eq!(pos.line, 1);","    assert_eq!(pos.column, 5);","}"],[]]]}