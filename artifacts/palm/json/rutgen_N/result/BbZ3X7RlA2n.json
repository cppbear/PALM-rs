{"function_name":"serde_json::map::<map::Map<std::string::String, value::Value> as std::fmt::Debug>::fmt","tests":2,"tests_lines":[23,20],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[485,486,487],"codes_lines_covered":[[["{","    use std::fmt;","    use std::collections::HashMap;","","    struct MyStruct<'a> {","        map: &'a HashMap<&'a str, &'a str>,","    }","","    impl<'a> fmt::Display for MyStruct<'a> {","        fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {","            self.map.fmt(formatter)","        }","    }","","    let mut map = HashMap::new();","    map.insert(\"key1\", \"value1\");","    map.insert(\"key2\", \"value2\");","","    let my_struct = MyStruct { map: &map };","    let result = format!(\"{}\", my_struct);","","    assert_eq!(result, \"key1: value1\\nkey2: value2\\n\"); // Assuming the default Display of HashMap uses the key:value format","}"],[]],[["{","    use std::fmt;","    use std::collections::HashMap;","","    struct MyStruct<'a> {","        map: &'a HashMap<&'a str, &'a str>,","    }","","    impl<'a> fmt::Display for MyStruct<'a> {","        fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {","            self.map.fmt(formatter)","        }","    }","","    let map: HashMap<&str, &str> = HashMap::new();","    let my_struct = MyStruct { map: &map };","","    // Intentionally causing a panic by formatting an empty map","    let _ = format!(\"{}\", my_struct);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::fmt;","    use std::collections::HashMap;","","    struct MyStruct<'a> {","        map: &'a HashMap<&'a str, &'a str>,","    }","","    impl<'a> fmt::Display for MyStruct<'a> {","        fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {","            self.map.fmt(formatter)","        }","    }","","    let mut map = HashMap::new();","    map.insert(\"key1\", \"value1\");","    map.insert(\"key2\", \"value2\");","","    let my_struct = MyStruct { map: &map };","    let result = format!(\"{}\", my_struct);","","    assert_eq!(result, \"key1: value1\\nkey2: value2\\n\"); // Assuming the default Display of HashMap uses the key:value format","}"],[]],[["{","    use std::fmt;","    use std::collections::HashMap;","","    struct MyStruct<'a> {","        map: &'a HashMap<&'a str, &'a str>,","    }","","    impl<'a> fmt::Display for MyStruct<'a> {","        fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {","            self.map.fmt(formatter)","        }","    }","","    let map: HashMap<&str, &str> = HashMap::new();","    let my_struct = MyStruct { map: &map };","","    // Intentionally causing a panic by formatting an empty map","    let _ = format!(\"{}\", my_struct);","}"],[]]]}