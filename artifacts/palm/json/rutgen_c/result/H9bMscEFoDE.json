{"function_name":"serde_json::error::error::Error::is_syntax","tests":2,"tests_lines":[50,50],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[92,93,94],"codes_lines_covered":[[["{","    struct ErrorImpl {","        code: ErrorCode,","        line: usize,","        column: usize,","    }","","    struct Error {","        err: Box<ErrorImpl>,","    }","","    impl Error {","        pub fn classify(&self) -> Category {","            match self.err.code {","                ErrorCode::Message(_) => Category::Data,","                ErrorCode::Io(_) => Category::Io,","                // Syntax errors as indicated by the given codes","                _ if matches!(self.err.code, ErrorCode::ExpectedColon | ErrorCode::ExpectedListCommaOrEnd) => Category::Syntax,","                _ => Category::Data, // Default case for this test","            }","        }","","        pub fn is_syntax(&self) -> bool {","            self.classify() == Category::Syntax","        }","    }","","    enum ErrorCode {","        Message(String),","        Io(ErrorKind),","        ExpectedColon,","        ExpectedListCommaOrEnd,","    }","","    // Given a syntax error","    let error_impl = ErrorImpl {","        code: ErrorCode::ExpectedColon,","        line: 1,","        column: 5,","    };","    let error = Error {","        err: Box::new(error_impl),","    };","","    // When we call is_syntax","    let result = error.is_syntax();","","    // Then it should return true","    assert!(result);","}"],[]],[["{","    struct ErrorImpl {","        code: ErrorCode,","        line: usize,","        column: usize,","    }","","    struct Error {","        err: Box<ErrorImpl>,","    }","","    impl Error {","        pub fn classify(&self) -> Category {","            match self.err.code {","                ErrorCode::Message(_) => Category::Data,","                ErrorCode::Io(_) => Category::Io,","                // Syntax errors as indicated by the given codes","                _ if matches!(self.err.code, ErrorCode::ExpectedColon | ErrorCode::ExpectedListCommaOrEnd) => Category::Syntax,","                _ => Category::Data, // Default case for this test","            }","        }","","        pub fn is_syntax(&self) -> bool {","            self.classify() == Category::Syntax","        }","    }","","    enum ErrorCode {","        Message(String),","        Io(ErrorKind),","        ExpectedColon,","        ExpectedListCommaOrEnd,","    }","","    // Given a non-syntax error","    let error_impl = ErrorImpl {","        code: ErrorCode::Message(\"Some other error\".to_string()),","        line: 1,","        column: 5,","    };","    let error = Error {","        err: Box::new(error_impl),","    };","","    // When we call is_syntax","    let result = error.is_syntax();","","    // Then it should return false","    assert!(!result);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct ErrorImpl {","        code: ErrorCode,","        line: usize,","        column: usize,","    }","","    struct Error {","        err: Box<ErrorImpl>,","    }","","    impl Error {","        pub fn classify(&self) -> Category {","            match self.err.code {","                ErrorCode::Message(_) => Category::Data,","                ErrorCode::Io(_) => Category::Io,","                // Syntax errors as indicated by the given codes","                _ if matches!(self.err.code, ErrorCode::ExpectedColon | ErrorCode::ExpectedListCommaOrEnd) => Category::Syntax,","                _ => Category::Data, // Default case for this test","            }","        }","","        pub fn is_syntax(&self) -> bool {","            self.classify() == Category::Syntax","        }","    }","","    enum ErrorCode {","        Message(String),","        Io(ErrorKind),","        ExpectedColon,","        ExpectedListCommaOrEnd,","    }","","    // Given a syntax error","    let error_impl = ErrorImpl {","        code: ErrorCode::ExpectedColon,","        line: 1,","        column: 5,","    };","    let error = Error {","        err: Box::new(error_impl),","    };","","    // When we call is_syntax","    let result = error.is_syntax();","","    // Then it should return true","    assert!(result);","}"],[]],[["{","    struct ErrorImpl {","        code: ErrorCode,","        line: usize,","        column: usize,","    }","","    struct Error {","        err: Box<ErrorImpl>,","    }","","    impl Error {","        pub fn classify(&self) -> Category {","            match self.err.code {","                ErrorCode::Message(_) => Category::Data,","                ErrorCode::Io(_) => Category::Io,","                // Syntax errors as indicated by the given codes","                _ if matches!(self.err.code, ErrorCode::ExpectedColon | ErrorCode::ExpectedListCommaOrEnd) => Category::Syntax,","                _ => Category::Data, // Default case for this test","            }","        }","","        pub fn is_syntax(&self) -> bool {","            self.classify() == Category::Syntax","        }","    }","","    enum ErrorCode {","        Message(String),","        Io(ErrorKind),","        ExpectedColon,","        ExpectedListCommaOrEnd,","    }","","    // Given a non-syntax error","    let error_impl = ErrorImpl {","        code: ErrorCode::Message(\"Some other error\".to_string()),","        line: 1,","        column: 5,","    };","    let error = Error {","        err: Box::new(error_impl),","    };","","    // When we call is_syntax","    let result = error.is_syntax();","","    // Then it should return false","    assert!(!result);","}"],[]]]}