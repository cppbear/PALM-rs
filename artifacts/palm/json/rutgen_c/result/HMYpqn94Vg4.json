{"function_name":"serde_json::read::<read::SliceRead<'a> as read::Read<'a>>::decode_hex_escape","tests":4,"tests_lines":[9,9,9,9],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":10,"lines_covered":10,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[621,622,623,624,625,626,627,631,632,635],"codes_lines_covered":[[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1', b'0', b'1'],","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert_eq!(result.unwrap(), 0x0101);","    assert_eq!(slice_read.index, 4);","}"],[621,622,623,624,625,626,635]],[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1', b'G', b'1'], // 'G' is invalid in hex","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert!(result.is_err());","    assert_eq!(slice_read.index, 4); // even though invalid, the index is incremented","}"],[621,622,623,624,625,627,635]],[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1'], // not enough bytes to read 4 hex digits","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert!(result.is_err());","    assert_eq!(slice_read.index, 2); // index should be set to the end","}"],[621,622,631,632,635]],[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1', b'0', b'1', b'A'], // valid hex followed by extra byte","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert_eq!(result.unwrap(), 0x0101);","    assert_eq!(slice_read.index, 4);","}"],[621,622,623,624,625,626,635]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1', b'0', b'1'],","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert_eq!(result.unwrap(), 0x0101);","    assert_eq!(slice_read.index, 4);","}"],[]],[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1', b'G', b'1'], // 'G' is invalid in hex","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert!(result.is_err());","    assert_eq!(slice_read.index, 4); // even though invalid, the index is incremented","}"],[]],[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1'], // not enough bytes to read 4 hex digits","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert!(result.is_err());","    assert_eq!(slice_read.index, 2); // index should be set to the end","}"],[]],[["{","    let mut slice_read = SliceRead {","        slice: &[b'0', b'1', b'0', b'1', b'A'], // valid hex followed by extra byte","        index: 0,","    };","    let result = slice_read.decode_hex_escape();","    assert_eq!(result.unwrap(), 0x0101);","    assert_eq!(slice_read.index, 4);","}"],[]]]}