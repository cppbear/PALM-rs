{"function_name":"http::header::map::header::map::HeaderMap<T>::remove_all_extra_values","tests":3,"tests_lines":[50,57,52],"oracles":3,"oracles_compiled":2,"oracles_compiled_rate":66.66666666666666,"tests_compiled":2,"tests_compiled_rate":66.66666666666666,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1614,1616,1618,1619,1620,1621,1622,1623,1624],"codes_lines_covered":[[["{","    #[derive(Debug, Clone)]","    enum Link {","        Extra(usize),","        None,","    }","","    #[derive(Debug, Clone)]","    struct ExtraValue {","        value: usize,","        next: Link,","    }","","    #[derive(Debug)]","    struct HeaderMap {","        extra_values: Vec<ExtraValue>,","    }","","    impl HeaderMap {","        fn new() -> Self {","            HeaderMap {","                extra_values: Vec::new(),","            }","        }","","        fn add_extra_value(&mut self, value: usize, next: Link) {","            self.extra_values.push(ExtraValue { value, next });","        }","","        fn remove_extra_value(&mut self, idx: usize) -> ExtraValue {","            self.extra_values.remove(idx)","        }","","        fn remove_all_extra_values(&mut self, mut head: usize) {","            loop {","                let extra = self.remove_extra_value(head);","                if let Link::Extra(idx) = extra.next {","                    head = idx;","                } else {","                    break;","                }","            }","        }","    }","","    let mut header_map = HeaderMap::new();","    header_map.add_extra_value(1, Link::Extra(1));","    header_map.add_extra_value(2, Link::Extra(2));","    header_map.add_extra_value(3, Link::None); // This will stop the loop","","    // This should remove all extra values linked in the structure","    header_map.remove_all_extra_values(0);","","    // After the removal, we should only have one extra value (the last one linked to None)","    assert_eq!(header_map.extra_values.len(), 1);","    assert_eq!(header_map.extra_values[0].value, 3);","}"],[]],[["{","    #[derive(Debug, Clone)]","    enum Link {","        Extra(usize),","        None,","    }","","    #[derive(Debug, Clone)]","    struct ExtraValue {","        value: usize,","        next: Link,","    }","","    #[derive(Debug)]","    struct HeaderMap {","        extra_values: Vec<ExtraValue>,","    }","","    impl HeaderMap {","        fn new() -> Self {","            HeaderMap {","                extra_values: Vec::new(),","            }","        }","","        fn add_extra_value(&mut self, value: usize, next: Link) {","            self.extra_values.push(ExtraValue { value, next });","        }","","        fn remove_extra_value(&mut self, idx: usize) -> ExtraValue {","            self.extra_values.remove(idx)","        }","","        fn remove_all_extra_values(&mut self, mut head: usize) {","            loop {","                let extra = self.remove_extra_value(head);","                if let Link::Extra(idx) = extra.next {","                    head = idx;","                } else {","                    break;","                }","            }","        }","    }","","    let mut header_map = HeaderMap::new();","    header_map.add_extra_value(1, Link::Extra(1));","    header_map.add_extra_value(2, Link::Extra(2));","    header_map.add_extra_value(3, Link::Extra(3));","    // This is out of bound and will cause a panic","    header_map.remove_all_extra_values(10);","}"],[]]],"codes_branches":[{"start_line":1618,"start_column":20,"end_line":1618,"end_column":36,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    #[derive(Debug, Clone)]","    enum Link {","        Extra(usize),","        None,","    }","","    #[derive(Debug, Clone)]","    struct ExtraValue {","        value: usize,","        next: Link,","    }","","    #[derive(Debug)]","    struct HeaderMap {","        extra_values: Vec<ExtraValue>,","    }","","    impl HeaderMap {","        fn new() -> Self {","            HeaderMap {","                extra_values: Vec::new(),","            }","        }","","        fn add_extra_value(&mut self, value: usize, next: Link) {","            self.extra_values.push(ExtraValue { value, next });","        }","","        fn remove_extra_value(&mut self, idx: usize) -> ExtraValue {","            self.extra_values.remove(idx)","        }","","        fn remove_all_extra_values(&mut self, mut head: usize) {","            loop {","                let extra = self.remove_extra_value(head);","                if let Link::Extra(idx) = extra.next {","                    head = idx;","                } else {","                    break;","                }","            }","        }","    }","","    let mut header_map = HeaderMap::new();","    header_map.add_extra_value(1, Link::Extra(1));","    header_map.add_extra_value(2, Link::Extra(2));","    header_map.add_extra_value(3, Link::None); // This will stop the loop","","    // This should remove all extra values linked in the structure","    header_map.remove_all_extra_values(0);","","    // After the removal, we should only have one extra value (the last one linked to None)","    assert_eq!(header_map.extra_values.len(), 1);","    assert_eq!(header_map.extra_values[0].value, 3);","}"],[{"start_line":1618,"start_column":20,"end_line":1618,"end_column":36,"positive":false,"negative":false}]],[["{","    #[derive(Debug, Clone)]","    enum Link {","        Extra(usize),","        None,","    }","","    #[derive(Debug, Clone)]","    struct ExtraValue {","        value: usize,","        next: Link,","    }","","    #[derive(Debug)]","    struct HeaderMap {","        extra_values: Vec<ExtraValue>,","    }","","    impl HeaderMap {","        fn new() -> Self {","            HeaderMap {","                extra_values: Vec::new(),","            }","        }","","        fn add_extra_value(&mut self, value: usize, next: Link) {","            self.extra_values.push(ExtraValue { value, next });","        }","","        fn remove_extra_value(&mut self, idx: usize) -> ExtraValue {","            self.extra_values.remove(idx)","        }","","        fn remove_all_extra_values(&mut self, mut head: usize) {","            loop {","                let extra = self.remove_extra_value(head);","                if let Link::Extra(idx) = extra.next {","                    head = idx;","                } else {","                    break;","                }","            }","        }","    }","","    let mut header_map = HeaderMap::new();","    header_map.add_extra_value(1, Link::Extra(1));","    header_map.add_extra_value(2, Link::Extra(2));","    header_map.add_extra_value(3, Link::Extra(3));","    // This is out of bound and will cause a panic","    header_map.remove_all_extra_values(10);","}"],[{"start_line":1618,"start_column":20,"end_line":1618,"end_column":36,"positive":false,"negative":false}]]]}