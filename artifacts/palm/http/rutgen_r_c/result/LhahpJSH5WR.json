{"function_name":"http::header::map::header::map::HeaderMap<T>::keys","tests":5,"tests_lines":[5,9,18,13,15],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":4,"tests_compiled_rate":80.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[938,939,940,941,942],"codes_lines_covered":[[["{","    let map: HeaderMap = HeaderMap::with_capacity(0);","    let keys: Keys<'_, HeaderValue> = map.keys();","    assert_eq!(keys.inner.len(), 0);","}"],[938,939,940,941,942]],[["{","    let mut map: HeaderMap = HeaderMap::with_capacity(1);","    let key = HeaderName::from_static(\"key1\");","    map.insert(key.clone(), HeaderValue::from_static(\"value1\"));","    let keys: Keys<'_, HeaderValue> = map.keys();","    let keys_vec: Vec<_> = keys.inner.map(|bucket| &bucket.key).collect();","    assert_eq!(keys_vec.len(), 1);","    assert_eq!(keys_vec[0], &key);","}"],[938,939,940,941,942]],[["{","    let mut map: HeaderMap = HeaderMap::with_capacity(3);","    let key1 = HeaderName::from_static(\"key1\");","    let key2 = HeaderName::from_static(\"key2\");","    let key3 = HeaderName::from_static(\"key3\");","    ","    map.insert(key1.clone(), HeaderValue::from_static(\"value1\"));","    map.insert(key2.clone(), HeaderValue::from_static(\"value2\"));","    map.insert(key3.clone(), HeaderValue::from_static(\"value3\"));","","    let keys: Keys<'_, HeaderValue> = map.keys();","    let keys_vec: Vec<_> = keys.inner.map(|bucket| &bucket.key).collect();","    ","    assert_eq!(keys_vec.len(), 3);","    assert!(keys_vec.contains(&&key1));","    assert!(keys_vec.contains(&&key2));","    assert!(keys_vec.contains(&&key3));","}"],[938,939,940,941,942]],[["{","    let mut map: HeaderMap = HeaderMap::with_capacity(2);","    let key = HeaderName::from_static(\"duplicate\");","    ","    map.insert(key.clone(), HeaderValue::from_static(\"value1\"));","    map.append(key.clone(), HeaderValue::from_static(\"value2\")); // Append should create a duplicate key in terms of stored values","    ","    let keys: Keys<'_, HeaderValue> = map.keys();","    let keys_vec: Vec<_> = keys.inner.map(|bucket| &bucket.key).collect();","","    assert_eq!(keys_vec.len(), 1); // Still should only return one key","    assert_eq!(keys_vec[0], &key);","}"],[938,939,940,941,942]]],"codes_branches":[],"codes_branches_covered":[[["{","    let map: HeaderMap = HeaderMap::with_capacity(0);","    let keys: Keys<'_, HeaderValue> = map.keys();","    assert_eq!(keys.inner.len(), 0);","}"],[]],[["{","    let mut map: HeaderMap = HeaderMap::with_capacity(1);","    let key = HeaderName::from_static(\"key1\");","    map.insert(key.clone(), HeaderValue::from_static(\"value1\"));","    let keys: Keys<'_, HeaderValue> = map.keys();","    let keys_vec: Vec<_> = keys.inner.map(|bucket| &bucket.key).collect();","    assert_eq!(keys_vec.len(), 1);","    assert_eq!(keys_vec[0], &key);","}"],[]],[["{","    let mut map: HeaderMap = HeaderMap::with_capacity(3);","    let key1 = HeaderName::from_static(\"key1\");","    let key2 = HeaderName::from_static(\"key2\");","    let key3 = HeaderName::from_static(\"key3\");","    ","    map.insert(key1.clone(), HeaderValue::from_static(\"value1\"));","    map.insert(key2.clone(), HeaderValue::from_static(\"value2\"));","    map.insert(key3.clone(), HeaderValue::from_static(\"value3\"));","","    let keys: Keys<'_, HeaderValue> = map.keys();","    let keys_vec: Vec<_> = keys.inner.map(|bucket| &bucket.key).collect();","    ","    assert_eq!(keys_vec.len(), 3);","    assert!(keys_vec.contains(&&key1));","    assert!(keys_vec.contains(&&key2));","    assert!(keys_vec.contains(&&key3));","}"],[]],[["{","    let mut map: HeaderMap = HeaderMap::with_capacity(2);","    let key = HeaderName::from_static(\"duplicate\");","    ","    map.insert(key.clone(), HeaderValue::from_static(\"value1\"));","    map.append(key.clone(), HeaderValue::from_static(\"value2\")); // Append should create a duplicate key in terms of stored values","    ","    let keys: Keys<'_, HeaderValue> = map.keys();","    let keys_vec: Vec<_> = keys.inner.map(|bucket| &bucket.key).collect();","","    assert_eq!(keys_vec.len(), 1); // Still should only return one key","    assert_eq!(keys_vec[0], &key);","}"],[]]]}