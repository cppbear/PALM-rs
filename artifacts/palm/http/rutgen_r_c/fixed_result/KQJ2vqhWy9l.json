{"function_name":"http::header::map::header::map::HeaderMap<T>::rebuild","tests":9,"tests_lines":[13,13,21,29,5,7,11,10,8],"oracles":9,"oracles_compiled":6,"oracles_compiled_rate":66.66666666666666,"tests_compiled":6,"tests_compiled_rate":66.66666666666666,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":6,"tests_passed":5,"tests_passed_rate":83.33333333333334,"lines":21,"lines_covered":21,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[1647,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1660,1661,1662,1664,1665,1668,1669,1672,1675,1677],"codes_lines_covered":[[["{","    struct TestValue;","    ","    let mut header_map: HeaderMap<TestValue> = HeaderMap {","        mask: 0,","        indices: Box::from([]),","        entries: vec![],","        extra_values: vec![],","        danger: Danger::Green,","    };","    ","    header_map.rebuild();","}"],[1647,1649,1677]],[["{","    struct TestValue;","","    let mut header_map: HeaderMap<TestValue> = HeaderMap {","        mask: 0,","        indices: Box::from([Pos::none()]),","        entries: vec![],","        extra_values: vec![],","        danger: Danger::Green,","    };","","    header_map.rebuild();","}"],[1647,1649,1677]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(0);","    assert_eq!(map.len(), 0);","    map.rebuild(); // Should not panic","}"],[1647,1649,1677]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(1);","    map.insert(\"key1\", 42);","    assert_eq!(map.len(), 1);","    map.rebuild(); // Should not panic","    assert_eq!(map.get(\"key1\"), Some(&42));","}"],[1647,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1660,1661,1662,1664,1665,1672,1675]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(5);","    map.insert(\"key1\", 42);","    map.insert(\"key2\", 84);","    map.insert(\"key3\", 21);","    assert_eq!(map.len(), 3);","    map.rebuild(); // Should not panic","    assert_eq!(map.get(\"key1\"), Some(&42));","    assert_eq!(map.get(\"key2\"), Some(&84));","    assert_eq!(map.get(\"key3\"), Some(&21));","}"],[1647,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1660,1661,1662,1665,1668,1669,1672,1677]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(5);","    map.insert(\"key1\", 42);","    // Simulate a collision by inserting a key that results in the same hash.","    map.insert(\"key1_collision\", 84); // Assuming it collides with \"key1\"","    assert_eq!(map.len(), 2);","    map.rebuild(); // Should not panic","    assert_eq!(map.get(\"key1\"), Some(&42));","    assert_eq!(map.get(\"key1_collision\"), Some(&84));","}"],[1647,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1660,1661,1662,1664,1665,1668,1669,1672,1675,1677]]],"codes_branches":[{"start_line":1658,"start_column":24,"end_line":1658,"end_column":45,"positive":true,"negative":true},{"start_line":1662,"start_column":24,"end_line":1662,"end_column":41,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestValue;","    ","    let mut header_map: HeaderMap<TestValue> = HeaderMap {","        mask: 0,","        indices: Box::from([]),","        entries: vec![],","        extra_values: vec![],","        danger: Danger::Green,","    };","    ","    header_map.rebuild();","}"],[{"start_line":1658,"start_column":24,"end_line":1658,"end_column":45,"positive":false,"negative":false},{"start_line":1662,"start_column":24,"end_line":1662,"end_column":41,"positive":false,"negative":false}]],[["{","    struct TestValue;","","    let mut header_map: HeaderMap<TestValue> = HeaderMap {","        mask: 0,","        indices: Box::from([Pos::none()]),","        entries: vec![],","        extra_values: vec![],","        danger: Danger::Green,","    };","","    header_map.rebuild();","}"],[{"start_line":1658,"start_column":24,"end_line":1658,"end_column":45,"positive":false,"negative":false},{"start_line":1662,"start_column":24,"end_line":1662,"end_column":41,"positive":false,"negative":false}]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(0);","    assert_eq!(map.len(), 0);","    map.rebuild(); // Should not panic","}"],[{"start_line":1658,"start_column":24,"end_line":1658,"end_column":45,"positive":false,"negative":false},{"start_line":1662,"start_column":24,"end_line":1662,"end_column":41,"positive":false,"negative":false}]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(1);","    map.insert(\"key1\", 42);","    assert_eq!(map.len(), 1);","    map.rebuild(); // Should not panic","    assert_eq!(map.get(\"key1\"), Some(&42));","}"],[{"start_line":1658,"start_column":24,"end_line":1658,"end_column":45,"positive":true,"negative":false},{"start_line":1662,"start_column":24,"end_line":1662,"end_column":41,"positive":true,"negative":true}]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(5);","    map.insert(\"key1\", 42);","    map.insert(\"key2\", 84);","    map.insert(\"key3\", 21);","    assert_eq!(map.len(), 3);","    map.rebuild(); // Should not panic","    assert_eq!(map.get(\"key1\"), Some(&42));","    assert_eq!(map.get(\"key2\"), Some(&84));","    assert_eq!(map.get(\"key3\"), Some(&21));","}"],[{"start_line":1658,"start_column":24,"end_line":1658,"end_column":45,"positive":true,"negative":true},{"start_line":1662,"start_column":24,"end_line":1662,"end_column":41,"positive":false,"negative":true}]],[["{","    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(5);","    map.insert(\"key1\", 42);","    // Simulate a collision by inserting a key that results in the same hash.","    map.insert(\"key1_collision\", 84); // Assuming it collides with \"key1\"","    assert_eq!(map.len(), 2);","    map.rebuild(); // Should not panic","    assert_eq!(map.get(\"key1\"), Some(&42));","    assert_eq!(map.get(\"key1_collision\"), Some(&84));","}"],[{"start_line":1658,"start_column":24,"end_line":1658,"end_column":45,"positive":true,"negative":true},{"start_line":1662,"start_column":24,"end_line":1662,"end_column":41,"positive":true,"negative":true}]]]}