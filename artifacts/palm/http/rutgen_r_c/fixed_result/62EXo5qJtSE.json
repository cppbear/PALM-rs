{"function_name":"http::header::map::hash_elem_using","tests":4,"tests_lines":[21,19,30,27],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":14,"lines_covered":10,"lines_coveraged_rate":71.42857142857143,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[3608,3609,3610,3611,3616,3618,3619,3620,3621,3625,3626,3627,3631,3632],"codes_lines_covered":[[["{","    use std::hash::Hasher;","","    // Create a simple struct that implements Hash","    #[derive(Hash)]","    struct TestKey {","        value: usize,","    }","","    // Initialize the Fast Hash Danger state","    let danger = Danger::Green;","","    // Create an instance of the key to hash","    let key = TestKey { value: 42 };","","    // Call the function under test","    let result = hash_elem_using(&danger, &key);","","    // Verify the result has a value in the expected range","    assert!(result.0 <= (MAX_SIZE as u16) - 1);","}"],[3608,3609,3610,3611,3616,3625,3626,3627,3631,3632]],[["{","    use std::hash::Hasher;","","    #[derive(Hash)]","    struct TestKey {","        value: i32,","    }","","    let danger = Danger::Green; // Ensure it is not a Red state","","    // Test with a key of different value","    let key1 = TestKey { value: 1 };","    let result1 = hash_elem_using(&danger, &key1);","    assert!(result1.0 <= (MAX_SIZE as u16) - 1);","","    let key2 = TestKey { value: 100 };","    let result2 = hash_elem_using(&danger, &key2);","    assert!(result2.0 <= (MAX_SIZE as u16) - 1);","}"],[3608,3609,3610,3611,3616,3625,3626,3627,3631,3632]],[["{","    use std::hash::{Hash, Hasher};","    ","    struct TestKey(u64);","    ","    impl Hash for TestKey {","        fn hash<H: Hasher>(&self, state: &mut H) {","            self.0.hash(state);","        }","    }","","    // Use the fast hash danger","    let danger = Danger::Green;","    let key = TestKey(123);","    ","    // Hash the key using the Danger::Green hasher","    let result = hash_elem_using(&danger, &key);","","    // Calculate expected hash to validate against the result","    let expected_hash = {","        let mut hasher = fnv::FnvHasher::default();","        key.hash(&mut hasher);","        hasher.finish() & ((MAX_SIZE as u64) - 1) as u64","    };","","    assert_eq!(result, HashValue(expected_hash as u16));","}"],[3608,3609,3610,3611,3616,3625,3626,3627,3631,3632]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::hash::Hasher;","","    // Create a simple struct that implements Hash","    #[derive(Hash)]","    struct TestKey {","        value: usize,","    }","","    // Initialize the Fast Hash Danger state","    let danger = Danger::Green;","","    // Create an instance of the key to hash","    let key = TestKey { value: 42 };","","    // Call the function under test","    let result = hash_elem_using(&danger, &key);","","    // Verify the result has a value in the expected range","    assert!(result.0 <= (MAX_SIZE as u16) - 1);","}"],[]],[["{","    use std::hash::Hasher;","","    #[derive(Hash)]","    struct TestKey {","        value: i32,","    }","","    let danger = Danger::Green; // Ensure it is not a Red state","","    // Test with a key of different value","    let key1 = TestKey { value: 1 };","    let result1 = hash_elem_using(&danger, &key1);","    assert!(result1.0 <= (MAX_SIZE as u16) - 1);","","    let key2 = TestKey { value: 100 };","    let result2 = hash_elem_using(&danger, &key2);","    assert!(result2.0 <= (MAX_SIZE as u16) - 1);","}"],[]],[["{","    use std::hash::{Hash, Hasher};","    ","    struct TestKey(u64);","    ","    impl Hash for TestKey {","        fn hash<H: Hasher>(&self, state: &mut H) {","            self.0.hash(state);","        }","    }","","    // Use the fast hash danger","    let danger = Danger::Green;","    let key = TestKey(123);","    ","    // Hash the key using the Danger::Green hasher","    let result = hash_elem_using(&danger, &key);","","    // Calculate expected hash to validate against the result","    let expected_hash = {","        let mut hasher = fnv::FnvHasher::default();","        key.hash(&mut hasher);","        hasher.finish() & ((MAX_SIZE as u64) - 1) as u64","    };","","    assert_eq!(result, HashValue(expected_hash as u16));","}"],[]]]}