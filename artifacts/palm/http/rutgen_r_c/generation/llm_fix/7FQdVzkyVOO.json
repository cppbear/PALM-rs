{
  "name": "http::header::map::header::map::OccupiedEntry<'a, T>::iter_mut",
  "name_with_impl": "http::header::map::{impl#52}::iter_mut",
  "mod_info": {
    "name": "header::map",
    "loc": "src/header/mod.rs:73:1:73:9"
  },
  "visible": true,
  "loc": "src/header/map.rs:3390:5:3392:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut map: HeaderMap<String> = HeaderMap::with_capacity(1);",
                  "    let entry = map.entry(\"host\");",
                  "    if let Entry::Vacant(_) = entry {",
                  "        // No panic expected, simply validating the state",
                  "    } else {",
                  "        panic!(\"Expected entry to be vacant\");",
                  "    }",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(2);",
                  "    map.insert(\"host\", \"world\".to_string());",
                  "    ",
                  "    if let Entry::Occupied(mut entry) = map.entry(\"host\") {",
                  "        let mut iter = entry.iter_mut();",
                  "        let value = iter.next().unwrap();",
                  "        assert_eq!(value, \"world\");",
                  "        value.push_str(\"-boop\");",
                  "        assert_eq!(value, \"world-boop\");",
                  "    } else {",
                  "        panic!(\"Expected entry to be occupied\");",
                  "    }",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut map = HeaderMap::with_capacity(3);",
                  "    map.insert(\"host\", \"world\".to_string());",
                  "    map.append(\"host\", \"earth\".to_string());",
                  "    ",
                  "    if let Entry::Occupied(mut entry) = map.entry(\"host\") {",
                  "        let mut iter = entry.iter_mut();",
                  "        let first_value = iter.next().unwrap();",
                  "        assert_eq!(first_value, \"world\");",
                  "        first_value.push_str(\"-boop\");",
                  "        ",
                  "        let second_value = iter.next().unwrap();",
                  "        assert_eq!(second_value, \"earth\");",
                  "        second_value.push_str(\"-boop\");",
                  "        ",
                  "        assert_eq!(first_value, \"world-boop\");",
                  "        assert_eq!(second_value, \"earth-boop\");",
                  "    } else {",
                  "        panic!(\"Expected entry to be occupied\");",
                  "    }",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}