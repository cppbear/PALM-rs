{
  "name": "http::header::map::header::map::HeaderMap<T>::remove_found",
  "name_with_impl": "http::header::map::{impl#1}::remove_found",
  "mod_info": {
    "name": "header::map",
    "loc": "src/header/mod.rs:73:1:73:9"
  },
  "visible": false,
  "loc": "src/header/map.rs:1552:5:1605:6",
  "fn_tests": [
    {
      "chain_id": 13,
      "prompt_conds": [
        "// may panic: self.entries.swap_remove(found) may panic in certain situations\n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((i, _)) = self.indices[probe].resolve() is true\n",
        "// constraint: i >= self.entries.len() is true, with bound i == self.entries.len()\n",
        "// constraint: let Some(links) = entry.links is true\n",
        "// may panic: self.extra_values[links.next] may panic in certain situations\n",
        "// may panic: self.extra_values[links.tail] may panic in certain situations\n",
        "// constraint: self.entries.is_empty() is true\n",
        "// expected return value/type: entry\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "   struct TestHeaderValue;",
                  "   impl fmt::Debug for TestHeaderValue {",
                  "       fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "           write!(f, \"TestHeaderValue\")",
                  "       }",
                  "   }",
                  "",
                  "   let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(2);",
                  "   let key = HeaderName::from_static(\"Test-Header\");",
                  "   let value = TestHeaderValue;",
                  "",
                  "   // Insert a test entry directly to the HeaderMap",
                  "   header_map.entries.push(Bucket {",
                  "       hash: HashValue(1),",
                  "       key,",
                  "       value: value,",
                  "       links: Some(Links { next: 0, tail: 0 }),",
                  "   });",
                  "   header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "   let probe = 0;",
                  "   let found = 0;",
                  "",
                  "   // Call remove_found with a known good probe and found index",
                  "   let entry = header_map.remove_found(probe, found);",
                  "",
                  "   // Assert that the removed entry matches the initial entry",
                  "   assert_eq!(entry.key, Key::from_static(\"Test-Header\"));",
                  "   assert_eq!(format!(\"{:?}\", entry.value), \"TestHeaderValue\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `Key`\n    --> src/header/map.rs:3940:26\n     |\n3940 |    assert_eq!(entry.key, Key::from_static(\"Test-Header\"));\n     |                          ^^^\n     |                          |\n     |                          use of undeclared type `Key`\n     |                          help: a struct with a similar name exists: `Keys`\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestHeaderValue;",
                  "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(1);",
                  "    let probe = 0;",
                  "    let found = 0;",
                  "",
                  "    // This should panic since entries is empty",
                  "    header_map.remove_found(probe, found);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestHeaderValue;",
                  "    impl fmt::Debug for TestHeaderValue {",
                  "        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {",
                  "            write!(f, \"TestHeaderValue\")",
                  "        }",
                  "    }",
                  "",
                  "    // Setup HeaderMap with multiple entries",
                  "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(2);",
                  "    ",
                  "    // Add two test entries to enforce conditions in remove_found",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key: HeaderName::from_static(\"Header-One\"),",
                  "        value: TestHeaderValue,",
                  "        links: Some(Links { next: 1, tail: 1 }),",
                  "    });",
                  "    ",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(2),",
                  "        key: HeaderName::from_static(\"Header-Two\"),",
                  "        value: TestHeaderValue,",
                  "        links: Some(Links { next: 0, tail: 0 }),",
                  "    });",
                  "",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1)), Pos::new(1, HashValue(2))]);",
                  "    let probe = 0; // Test removing the first entry",
                  "    let found = 0; // Should return the first entry",
                  "",
                  "    // Call remove_found with a valid probe and found index",
                  "    let entry = header_map.remove_found(probe, found);",
                  "",
                  "    // Assert removed entry is as expected",
                  "    assert_eq!(entry.key, HeaderName::from_static(\"Header-One\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestHeaderValue;",
                  "    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(2);",
                  "    ",
                  "    // Prepare valid entries for testing",
                  "    let key = HeaderName::from_static(\"Header-At-Probe\");",
                  "    let value = TestHeaderValue;",
                  "",
                  "    header_map.entries.push(Bucket {",
                  "        hash: HashValue(1),",
                  "        key,",
                  "        value: value,",
                  "        links: None,",
                  "    });",
                  "    header_map.indices = Box::new([Pos::new(0, HashValue(1))]);",
                  "",
                  "    // Set an invalid probe for removal",
                  "    let probe = 1; // Out of bounds",
                  "    let found = 0;",
                  "",
                  "    // This should panic due to invalid probe handling",
                  "    header_map.remove_found(probe, found);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "// may panic: self.entries.swap_remove(found) may panic in certain situations\n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((i, _)) = self.indices[probe].resolve() is true\n",
        "// constraint: i >= self.entries.len() is true, with bound i == self.entries.len()\n",
        "// constraint: let Some(links) = entry.links is true\n",
        "// may panic: self.extra_values[links.next] may panic in certain situations\n",
        "// may panic: self.extra_values[links.tail] may panic in certain situations\n",
        "// constraint: self.entries.is_empty() is false\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((_, entry_hash)) = self.indices[probe].resolve() is true\n",
        "// constraint: probe_distance(self.mask, entry_hash, probe) > 0 is false, with bound probe_distance(self.mask, entry_hash, probe) == 0\n",
        "// expected return value/type: entry\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    // Create a HeaderMap with a small capacity for testing",
                  "    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(4);",
                  "    ",
                  "    // Insert some entries to ensure we have a populated map",
                  "    map.insert(\"key1\", 1);",
                  "    map.insert(\"key2\", 2);",
                  "    map.insert(\"key3\", 3);",
                  "    map.insert(\"key4\", 4);",
                  "",
                  "    // Get the index of the entry to be removed",
                  "    let found = 2; // Assuming we want to remove the entry with key \"key3\"",
                  "    ",
                  "    // Simulate the probe index. In a real scenario, this would need to be set accordingly",
                  "    let probe = desired_pos(map.mask, HashValue(3)); // HashValue corresponding to \"key3\"",
                  "    ",
                  "    // Create links to ensure we hit link constraints",
                  "    let link = Links { next: 0, tail: 1 };",
                  "    map.entries[found].links = Some(link);",
                  "    map.extra_values.push(ExtraValue { value: 10, prev: Link::Entry(0), next: Link::Entry(1) });",
                  "    map.extra_values.push(ExtraValue { value: 20, prev: Link::Entry(1), next: Link::Entry(0) });",
                  "",
                  "    // The main function call we want to test",
                  "    let entry = map.remove_found(probe, found);",
                  "",
                  "    // Check that the returned entry matches the expected entry",
                  "    assert_eq!(entry.key, \"key3\");",
                  "    assert_eq!(entry.value, 3);",
                  "",
                  "    // Verify the current state of the map",
                  "    assert_eq!(map.entries.len(), 3); // One entry should be removed",
                  "    assert!(map.indices[probe].is_none()); // The probe should be empty",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 30,
      "prompt_conds": [
        "// may panic: self.entries.swap_remove(found) may panic in certain situations\n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is true\n",
        "// constraint: $probe_var is false, with bound $probe_var == self.indices.len()\n",
        "// constraint: $probe_var is true\n",
        "// constraint: let Some((i, _)) = self.indices[probe].resolve() is true\n",
        "// constraint: i >= self.entries.len() is true, with bound i == self.entries.len()\n",
        "// constraint: let Some(links) = entry.links is true\n",
        "// may panic: self.extra_values[links.next] may panic in certain situations\n",
        "// may panic: self.extra_values[links.tail] may panic in certain situations\n",
        "// constraint: self.entries.is_empty() is false\n",
        "// constraint: $len > 0 is false, with bound self.indices.len() == 0\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestValue;",
                  "    struct TestHeaderMap {",
                  "        map: HeaderMap<TestValue>,",
                  "    }",
                  "",
                  "    impl TestHeaderMap {",
                  "        fn new() -> Self {",
                  "            let mut map = HeaderMap::with_capacity(4);",
                  "            // Add a dummy entry for removal",
                  "            map.insert(\"Key1\", TestValue);",
                  "            map.insert(\"Key2\", TestValue);",
                  "            map.insert(\"Key3\", TestValue);",
                  "            Self { map }",
                  "        }",
                  "",
                  "        fn setup_for_removal(&mut self) -> (usize, usize) {",
                  "            let found = 1; // Index for \"Key2\"",
                  "            let probe = found; // Probe index corresponding to found",
                  "            (probe, found)",
                  "        }",
                  "    }",
                  "",
                  "    let mut header_map = TestHeaderMap::new();",
                  "    let (probe, found) = header_map.setup_for_removal();",
                  "    let bucket = header_map.map.remove_found(probe, found);",
                  "    assert!(bucket.key == HeaderName::try_from(\"Key2\").unwrap());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestValue;",
                  "    struct TestHeaderMap {",
                  "        map: HeaderMap<TestValue>,",
                  "    }",
                  "",
                  "    impl TestHeaderMap {",
                  "        fn new() -> Self {",
                  "            let mut map = HeaderMap::with_capacity(2);",
                  "            // Add two dummy entries",
                  "            map.insert(\"Key1\", TestValue);",
                  "            map.insert(\"Key2\", TestValue);",
                  "            Self { map }",
                  "        }",
                  "    }",
                  "",
                  "    let mut header_map = TestHeaderMap::new();",
                  "    let probe = 0; // Valid probe index",
                  "    let found = 2; // Out of bounds found index",
                  "    header_map.map.remove_found(probe, found);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestValue;",
                  "    struct TestHeaderMap {",
                  "        map: HeaderMap<TestValue>,",
                  "    }",
                  "",
                  "    impl TestHeaderMap {",
                  "        fn new() -> Self {",
                  "            let map = HeaderMap::with_capacity(0);",
                  "            Self { map }",
                  "        }",
                  "    }",
                  "",
                  "    let mut header_map = TestHeaderMap::new();",
                  "    let probe = 0; // Valid probe index (though map is empty)",
                  "    let found = 0; // Found index (also empty)",
                  "    // calling remove_found on an empty map should not panic, ",
                  "    // will just return a default Bucket.",
                  "    let bucket = header_map.map.remove_found(probe, found);",
                  "    assert_eq!(bucket.hash, HashValue(0)); // Bucket should be default",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 31,
      "prompt_conds": [
        "// may panic: self.entries.swap_remove(found) may panic in certain situations\n",
        "// constraint: let Some(entry) = self.entries.get(found) is true\n",
        "// constraint: $len > 0 is false, with bound self.indices.len() == 0\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(1);",
                  "    let result = std::panic::catch_unwind(|| {",
                  "        let _ = map.remove_found(0, 0);",
                  "    });",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the type `&mut map::HeaderMap<u32>` may not be safely transferred across an unwind boundary\n    --> src/header/map.rs:3915:43\n     |\n3915 |       let result = std::panic::catch_unwind(|| {\n     |                    ------------------------ ^-\n     |                    |                        |\n     |  __________________|________________________within this `{closure@src/header/map.rs:3915:43: 3915:45}`\n     | |                  |\n     | |                  required by a bound introduced by this call\n3916 | |         let _ = map.remove_found(0, 0);\n3917 | |     });\n     | |_____^ `&mut map::HeaderMap<u32>` may not be safely transferred across an unwind boundary\n     |\n     = help: within `{closure@src/header/map.rs:3915:43: 3915:45}`, the trait `UnwindSafe` is not implemented for `&mut map::HeaderMap<u32>`, which is required by `{closure@src/header/map.rs:3915:43: 3915:45}: UnwindSafe`\n     = note: `UnwindSafe` is implemented for `&map::HeaderMap<u32>`, but not for `&mut map::HeaderMap<u32>`\nnote: required because it's used within this closure\n    --> src/header/map.rs:3915:43\n     |\n3915 |     let result = std::panic::catch_unwind(|| {\n     |                                           ^^\nnote: required by a bound in `std::panic::catch_unwind`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n     |\n349  | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct ValidHeader(String);",
                  "    impl IntoHeaderName for ValidHeader {",
                  "        fn into_header_name(self) -> HeaderName {",
                  "            HeaderName::try_from(self.0).unwrap()",
                  "        }",
                  "    }",
                  "    ",
                  "    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(2);",
                  "    map.insert(ValidHeader(\"Header1\".to_string()), 100);",
                  "    map.insert(ValidHeader(\"Header2\".to_string()), 200);",
                  "",
                  "    let found = 0; // assume that we are removing the first entry",
                  "    let probe = { ",
                  "        let pos = desired_pos(map.mask, HashValue(100)); ",
                  "        pos as usize ",
                  "    };",
                  "",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::try_from(\"Header1\").unwrap());",
                  "    assert_eq!(entry.value, 100);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0407]: method `into_header_name` is not a member of trait `IntoHeaderName`\n    --> src/header/map.rs:3916:9\n     |\n3916 | /         fn into_header_name(self) -> HeaderName {\n3917 | |             HeaderName::try_from(self.0).unwrap()\n3918 | |         }\n     | |_________^ not a member of trait `IntoHeaderName`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `ValidHeader: into_header_name::Sealed` is not satisfied\n    --> src/header/map.rs:3915:29\n     |\n3915 |     impl IntoHeaderName for ValidHeader {\n     |                             ^^^^^^^^^^^ the trait `into_header_name::Sealed` is not implemented for `ValidHeader`\n     |\n     = help: the following other types implement trait `into_header_name::Sealed`:\n               &'a name::HeaderName\n               &'static str\n               name::HeaderName\nnote: required by a bound in `into_header_name::IntoHeaderName`\n    --> src/header/map.rs:3645:31\n     |\n3645 |     pub trait IntoHeaderName: Sealed {}\n     |                               ^^^^^^ required by this bound in `IntoHeaderName`\n     = note: `IntoHeaderName` is a \"sealed trait\", because to implement it you also need to implement `header::map::into_header_name::Sealed`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it\n     = help: the following types implement the trait:\n               header::name::HeaderName\n               &'a header::name::HeaderName\n               &'static str\n\nSome errors have detailed explanations: E0277, E0407.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct ValidHeader(String);",
                  "    impl IntoHeaderName for ValidHeader {",
                  "        fn into_header_name(self) -> HeaderName {",
                  "            HeaderName::try_from(self.0).unwrap()",
                  "        }",
                  "    }",
                  "",
                  "    let mut map: HeaderMap<u32> = HeaderMap::with_capacity(3);",
                  "    map.insert(ValidHeader(\"Header1\".to_string()), 100);",
                  "    map.insert(ValidHeader(\"Header2\".to_string()), 200);",
                  "    map.insert(ValidHeader(\"Header3\".to_string()), 300);",
                  "",
                  "    let found = 1; // Removing the second entry",
                  "    let probe = { ",
                  "        let pos = desired_pos(map.mask, HashValue(200)); ",
                  "        pos as usize ",
                  "    };",
                  "",
                  "    let entry = map.remove_found(probe, found);",
                  "    assert_eq!(entry.key, HeaderName::try_from(\"Header2\").unwrap());",
                  "    assert_eq!(entry.value, 200);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0407]: method `into_header_name` is not a member of trait `IntoHeaderName`\n    --> src/header/map.rs:3916:9\n     |\n3916 | /         fn into_header_name(self) -> HeaderName {\n3917 | |             HeaderName::try_from(self.0).unwrap()\n3918 | |         }\n     | |_________^ not a member of trait `IntoHeaderName`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `ValidHeader: into_header_name::Sealed` is not satisfied\n    --> src/header/map.rs:3915:29\n     |\n3915 |     impl IntoHeaderName for ValidHeader {\n     |                             ^^^^^^^^^^^ the trait `into_header_name::Sealed` is not implemented for `ValidHeader`\n     |\n     = help: the following other types implement trait `into_header_name::Sealed`:\n               &'a name::HeaderName\n               &'static str\n               name::HeaderName\nnote: required by a bound in `into_header_name::IntoHeaderName`\n    --> src/header/map.rs:3645:31\n     |\n3645 |     pub trait IntoHeaderName: Sealed {}\n     |                               ^^^^^^ required by this bound in `IntoHeaderName`\n     = note: `IntoHeaderName` is a \"sealed trait\", because to implement it you also need to implement `header::map::into_header_name::Sealed`, which is not accessible; this is usually done to force you to use one of the provided types that already implement it\n     = help: the following types implement the trait:\n               header::name::HeaderName\n               &'a header::name::HeaderName\n               &'static str\n\nSome errors have detailed explanations: E0277, E0407.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}