{"function_name":"http::request::<request::Parts as std::fmt::Debug>::fmt","tests":3,"tests_lines":[37,34,38],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":10,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[724,725,726,727,728,729,730,731,732,733],"codes_lines_covered":[[["{","    use std::fmt;","","    struct Parts {","        method: String,","        uri: String,","        version: String,","        headers: Vec<(String, String)>,","    }","","    impl fmt::Debug for Parts {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Parts\")","                .field(\"method\", &self.method)","                .field(\"uri\", &self.uri)","                .field(\"version\", &self.version)","                .field(\"headers\", &self.headers)","                .finish()","        }","    }","","    let parts = Parts {","        method: \"GET\".to_string(),","        uri: \"http://example.com\".to_string(),","        version: \"HTTP/1.1\".to_string(),","        headers: vec![","            (\"Content-Type\".to_string(), \"application/json\".to_string()),","            (\"User-Agent\".to_string(), \"test-agent\".to_string()),","        ],","    };","","    let result = format!(\"{:?}\", parts);","    assert!(result.contains(\"method: \\\"GET\\\"\"));","    assert!(result.contains(\"uri: \\\"http://example.com\\\"\"));","    assert!(result.contains(\"version: \\\"HTTP/1.1\\\"\"));","    assert!(result.contains(\"headers: [(\"));","}"],[]],[["{","    use std::fmt;","","    struct Parts {","        method: String,","        uri: String,","        version: String,","        headers: Vec<(String, String)>,","    }","","    impl fmt::Debug for Parts {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Parts\")","                .field(\"method\", &self.method)","                .field(\"uri\", &self.uri)","                .field(\"version\", &self.version)","                .field(\"headers\", &self.headers)","                .finish()","        }","    }","","    let parts = Parts {","        method: \"\".to_string(),","        uri: \"\".to_string(),","        version: \"\".to_string(),","        headers: vec![],","    };","","    let result = format!(\"{:?}\", parts);","    assert!(result.contains(\"method: \\\"\\\"\"));","    assert!(result.contains(\"uri: \\\"\\\"\"));","    assert!(result.contains(\"version: \\\"\\\"\"));","    assert!(result.contains(\"headers: []\"));","}"],[]],[["{","    use std::fmt;","","    struct Parts {","        method: String,","        uri: String,","        version: String,","        headers: Vec<(String, String)>,","    }","","    impl fmt::Debug for Parts {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Parts\")","                .field(\"method\", &self.method)","                .field(\"uri\", &self.uri)","                .field(\"version\", &self.version)","                .field(\"headers\", &self.headers)","                .finish()","        }","    }","","    let large_header_key = \"X-Long-Header-Name\".repeat(20);","    let large_header_value = \"Value\".repeat(100);","","    let parts = Parts {","        method: \"POST\".to_string(),","        uri: \"http://example.com\".to_string(),","        version: \"HTTP/1.1\".to_string(),","        headers: vec![(large_header_key.clone(), large_header_value.clone())],","    };","","    let result = format!(\"{:?}\", parts);","    assert!(result.contains(&format!(\"method: \\\"POST\\\"\")));","    assert!(result.contains(&format!(\"uri: \\\"http://example.com\\\"\")));","    assert!(result.contains(&format!(\"version: \\\"HTTP/1.1\\\"\")));","    assert!(result.contains(&format!(\"headers: [(\\\"{}\\\", \\\"{}\\\")]\",","        large_header_key, large_header_value)));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::fmt;","","    struct Parts {","        method: String,","        uri: String,","        version: String,","        headers: Vec<(String, String)>,","    }","","    impl fmt::Debug for Parts {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Parts\")","                .field(\"method\", &self.method)","                .field(\"uri\", &self.uri)","                .field(\"version\", &self.version)","                .field(\"headers\", &self.headers)","                .finish()","        }","    }","","    let parts = Parts {","        method: \"GET\".to_string(),","        uri: \"http://example.com\".to_string(),","        version: \"HTTP/1.1\".to_string(),","        headers: vec![","            (\"Content-Type\".to_string(), \"application/json\".to_string()),","            (\"User-Agent\".to_string(), \"test-agent\".to_string()),","        ],","    };","","    let result = format!(\"{:?}\", parts);","    assert!(result.contains(\"method: \\\"GET\\\"\"));","    assert!(result.contains(\"uri: \\\"http://example.com\\\"\"));","    assert!(result.contains(\"version: \\\"HTTP/1.1\\\"\"));","    assert!(result.contains(\"headers: [(\"));","}"],[]],[["{","    use std::fmt;","","    struct Parts {","        method: String,","        uri: String,","        version: String,","        headers: Vec<(String, String)>,","    }","","    impl fmt::Debug for Parts {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Parts\")","                .field(\"method\", &self.method)","                .field(\"uri\", &self.uri)","                .field(\"version\", &self.version)","                .field(\"headers\", &self.headers)","                .finish()","        }","    }","","    let parts = Parts {","        method: \"\".to_string(),","        uri: \"\".to_string(),","        version: \"\".to_string(),","        headers: vec![],","    };","","    let result = format!(\"{:?}\", parts);","    assert!(result.contains(\"method: \\\"\\\"\"));","    assert!(result.contains(\"uri: \\\"\\\"\"));","    assert!(result.contains(\"version: \\\"\\\"\"));","    assert!(result.contains(\"headers: []\"));","}"],[]],[["{","    use std::fmt;","","    struct Parts {","        method: String,","        uri: String,","        version: String,","        headers: Vec<(String, String)>,","    }","","    impl fmt::Debug for Parts {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Parts\")","                .field(\"method\", &self.method)","                .field(\"uri\", &self.uri)","                .field(\"version\", &self.version)","                .field(\"headers\", &self.headers)","                .finish()","        }","    }","","    let large_header_key = \"X-Long-Header-Name\".repeat(20);","    let large_header_value = \"Value\".repeat(100);","","    let parts = Parts {","        method: \"POST\".to_string(),","        uri: \"http://example.com\".to_string(),","        version: \"HTTP/1.1\".to_string(),","        headers: vec![(large_header_key.clone(), large_header_value.clone())],","    };","","    let result = format!(\"{:?}\", parts);","    assert!(result.contains(&format!(\"method: \\\"POST\\\"\")));","    assert!(result.contains(&format!(\"uri: \\\"http://example.com\\\"\")));","    assert!(result.contains(&format!(\"version: \\\"HTTP/1.1\\\"\")));","    assert!(result.contains(&format!(\"headers: [(\\\"{}\\\", \\\"{}\\\")]\",","        large_header_key, large_header_value)));","}"],[]]]}