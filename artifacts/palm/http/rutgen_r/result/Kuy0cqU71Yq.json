{"function_name":"http::header::map::header::map::HeaderMap<T>::reinsert_entry_in_order","tests":8,"tests_lines":[52,50,46,7,6,11,9,8],"oracles":8,"oracles_compiled":5,"oracles_compiled_rate":62.5,"tests_compiled":5,"tests_compiled_rate":62.5,"oracles_run":5,"oracles_passed":1,"oracles_passed_rate":20.0,"tests_run":5,"tests_passed":1,"tests_passed_rate":20.0,"lines":11,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1679,1680,1682,1683,1684,1685,1687,1688,1689,1691,1692],"codes_lines_covered":[[["{","    let mut map = HashMap::new(4);","    let pos = Pos { index: 1 }; // this will resolve correctly","    map.indices[2] = Pos { index: 3 }; // Fill some buckets","    map.reinsert_entry_in_order(pos);","    assert_eq!(map.indices[1].index, 1); // Check the insertion","}"],[]],[["{","    let mut map = HashMap::new(4);","    let pos = Pos { index: 2 }; // This will resolve correctly","    map.reinsert_entry_in_order(pos);","    assert_eq!(map.indices[2].index, 2); // Check the insertion","}"],[]],[["{","    let mut map = HashMap::new(4);","    map.indices = vec![Pos { index: 0 }, Pos { index: 1 }, Pos { index: 2 }, Pos { index: 3 }]; // All filled","    let pos = Pos { index: 4 }; // This will resolve correctly","    map.reinsert_entry_in_order(pos);","    // Since it should not panic but there's no empty bucket, we check contents stay the same","    assert_eq!(map.indices[0].index, 0);","    assert_eq!(map.indices[1].index, 1);","    assert_eq!(map.indices[2].index, 2);","    assert_eq!(map.indices[3].index, 3);","}"],[]],[["{","    let mut header_map = HeaderMap::new(7); // mask = 7","    let pos = Pos { entry: Some((1, 12)) }; // valid position","","    header_map.reinsert_entry_in_order(pos);","","    // The insert should succeed since indices are empty","    assert_eq!(header_map.indices.len(), 1);","}"],[]],[["{","    let mut header_map = HeaderMap::new(0); // mask = 0","    let pos = Pos { entry: Some((2, 15)) }; // valid position","","    header_map.reinsert_entry_in_order(pos);","","    // This should panic because there are no buckets to insert into","}"],[]]],"codes_branches":[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":false,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut map = HashMap::new(4);","    let pos = Pos { index: 1 }; // this will resolve correctly","    map.indices[2] = Pos { index: 3 }; // Fill some buckets","    map.reinsert_entry_in_order(pos);","    assert_eq!(map.indices[1].index, 1); // Check the insertion","}"],[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":false,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":false,"negative":false}]],[["{","    let mut map = HashMap::new(4);","    let pos = Pos { index: 2 }; // This will resolve correctly","    map.reinsert_entry_in_order(pos);","    assert_eq!(map.indices[2].index, 2); // Check the insertion","}"],[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":false,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":false,"negative":false}]],[["{","    let mut map = HashMap::new(4);","    map.indices = vec![Pos { index: 0 }, Pos { index: 1 }, Pos { index: 2 }, Pos { index: 3 }]; // All filled","    let pos = Pos { index: 4 }; // This will resolve correctly","    map.reinsert_entry_in_order(pos);","    // Since it should not panic but there's no empty bucket, we check contents stay the same","    assert_eq!(map.indices[0].index, 0);","    assert_eq!(map.indices[1].index, 1);","    assert_eq!(map.indices[2].index, 2);","    assert_eq!(map.indices[3].index, 3);","}"],[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":false,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":false,"negative":false}]],[["{","    let mut header_map = HeaderMap::new(7); // mask = 7","    let pos = Pos { entry: Some((1, 12)) }; // valid position","","    header_map.reinsert_entry_in_order(pos);","","    // The insert should succeed since indices are empty","    assert_eq!(header_map.indices.len(), 1);","}"],[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":false,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":false,"negative":false}]],[["{","    let mut header_map = HeaderMap::new(0); // mask = 0","    let pos = Pos { entry: Some((2, 15)) }; // valid position","","    header_map.reinsert_entry_in_order(pos);","","    // This should panic because there are no buckets to insert into","}"],[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":false,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":false,"negative":false}]]]}