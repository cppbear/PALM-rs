{"function_name":"http::header::map::header::map::HeaderMap<T>::try_with_capacity","tests":13,"tests_lines":[11,14,6,5,30,7,8,9,8,9,6,7,17],"oracles":13,"oracles_compiled":8,"oracles_compiled_rate":61.53846153846154,"tests_compiled":8,"tests_compiled_rate":61.53846153846154,"oracles_run":8,"oracles_passed":5,"oracles_passed_rate":62.5,"tests_run":8,"tests_passed":5,"tests_passed_rate":62.5,"lines":24,"lines_covered":22,"lines_coveraged_rate":91.66666666666666,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[502,503,504,505,506,507,508,509,510,512,513,514,516,517,518,519,521,522,523,524,525,526,527,529],"codes_lines_covered":[[["{","    // Attempt to create a HeaderMap with a capacity that exceeds the max size.","    let capacity = usize::MAX; // Using the maximum usize to cause an error.","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(capacity);","    assert!(map.is_err());","}"],[502,503,512,513,516,518,519]],[["{","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    assert!(map.is_ok());","    assert_eq!(map.unwrap().capacity(), 0);","}"],[502,503,504,505,506,507,508,509,510,529]],[["{","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    assert!(map.is_ok());","    let map = map.unwrap();","    assert!(map.is_empty());","    assert_eq!(0, map.capacity());","}"],[502,503,504,505,506,507,508,509,510,529]],[["{","    let capacity = 16; // Example value below max size","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(capacity);","    assert!(map.is_ok());","    let map = map.unwrap();","    assert!(map.capacity() >= capacity);","    assert!(map.mask == (map.capacity() - 1) as Size);","    assert!(map.indices.len() == map.capacity());","}"],[502,503,512,513,516,518,519,521,522,523,524,525,526,527,529]],[["{","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    ","    assert!(map.is_ok());","    let header_map = map.unwrap();","    assert!(header_map.is_empty());","    assert_eq!(header_map.capacity(), 0);","}"],[502,503,504,505,506,507,508,509,510,529]],[["{","    const MAX_SIZE: usize = 1024; // Assuming a hypothetical max size for testing","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(MAX_SIZE);","    ","    assert!(map.is_ok());","    // Ensuring header_map does not exceed MAX_SIZE","    let header_map = map.unwrap();","    assert!(header_map.capacity() <= MAX_SIZE);","}"],[502,503,512,513,516,518,519,521,522,523,524,525,526,527,529]],[["{","    const MAX_SIZE: usize = 1024; // Assuming a hypothetical max size for testing","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(MAX_SIZE + 1);","    ","    assert!(map.is_err());","}"],[502,503,512,513,516,518,519,521,522,523,524,525,526,527,529]],[["{","    let result: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    assert!(result.is_ok());","    let map = result.unwrap();","    assert!(map.is_empty());","    assert_eq!(0, map.capacity());","}"],[502,503,504,505,506,507,508,509,510,529]]],"codes_branches":[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":true,"negative":true},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    // Attempt to create a HeaderMap with a capacity that exceeds the max size.","    let capacity = usize::MAX; // Using the maximum usize to cause an error.","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(capacity);","    assert!(map.is_err());","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":false,"negative":true},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":true}]],[["{","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    assert!(map.is_ok());","    assert_eq!(map.unwrap().capacity(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":true,"negative":false},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":false}]],[["{","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    assert!(map.is_ok());","    let map = map.unwrap();","    assert!(map.is_empty());","    assert_eq!(0, map.capacity());","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":true,"negative":false},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":false}]],[["{","    let capacity = 16; // Example value below max size","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(capacity);","    assert!(map.is_ok());","    let map = map.unwrap();","    assert!(map.capacity() >= capacity);","    assert!(map.mask == (map.capacity() - 1) as Size);","    assert!(map.indices.len() == map.capacity());","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":false,"negative":true},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":true}]],[["{","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    ","    assert!(map.is_ok());","    let header_map = map.unwrap();","    assert!(header_map.is_empty());","    assert_eq!(header_map.capacity(), 0);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":true,"negative":false},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":false}]],[["{","    const MAX_SIZE: usize = 1024; // Assuming a hypothetical max size for testing","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(MAX_SIZE);","    ","    assert!(map.is_ok());","    // Ensuring header_map does not exceed MAX_SIZE","    let header_map = map.unwrap();","    assert!(header_map.capacity() <= MAX_SIZE);","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":false,"negative":true},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":true}]],[["{","    const MAX_SIZE: usize = 1024; // Assuming a hypothetical max size for testing","    let map: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(MAX_SIZE + 1);","    ","    assert!(map.is_err());","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":false,"negative":true},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":true}]],[["{","    let result: Result<HeaderMap<u32>, MaxSizeReached> = HeaderMap::try_with_capacity(0);","    assert!(result.is_ok());","    let map = result.unwrap();","    assert!(map.is_empty());","    assert_eq!(0, map.capacity());","}"],[{"start_line":503,"start_column":12,"end_line":503,"end_column":25,"positive":true,"negative":false},{"start_line":516,"start_column":16,"end_line":516,"end_column":34,"positive":false,"negative":false}]]]}