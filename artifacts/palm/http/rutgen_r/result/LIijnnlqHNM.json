{"function_name":"http::header::map::header::map::HeaderMap<T>::try_insert2","tests":15,"tests_lines":[52,58,50,55,51,58,50,83,57,74,71,76,71,79,82],"oracles":15,"oracles_compiled":1,"oracles_compiled_rate":6.666666666666667,"tests_compiled":1,"tests_compiled_rate":6.666666666666667,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":17,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1274,1275,1276,1277,1278,1279,1281,1283,1290,1291,1292,1293,1294,1297,1300,1301,1304],"codes_lines_covered":[[["{","    use std::hash::Hash;","    use std::collections::HashMap;","","    #[derive(Hash, PartialEq)]","    struct HeaderName(String);","","    struct MyMap<K, T> {","        entries: Vec<(K, T)>,","        indices: Vec<usize>,","        max_size: usize,","    }","","    impl<K: Hash + Into<HeaderName>, T> MyMap<K, T> {","        fn new(max_size: usize) -> Self {","            MyMap {","                entries: Vec::new(),","                indices: Vec::new(),","                max_size,","            }","        }","","        fn try_reserve_one(&mut self) -> Result<(), ()> {","            if self.entries.len() >= self.max_size {","                Err(())","            } else {","                Ok(())","            }","        }","","        fn try_insert_entry(&mut self, _hash: usize, key: K, value: T) -> Result<(), ()> {","            self.entries.push((key, value));","            Ok(())","        }","","        fn try_insert2(&mut self, key: K, value: T) -> Result<Option<T>, ()> {","            self.try_reserve_one()?;","","            self.try_insert_entry(0, key, value)?;","            Ok(None)","        }","    }","","    let mut my_map = MyMap::new(2);","    my_map.entries.push((HeaderName(\"Key1\".to_string()), 1));","    my_map.indices.push(0);","    ","    // Trying to insert the third element should hit the max size reached constraint","    let result = my_map.try_insert2(HeaderName(\"Key2\".to_string()), 2);","","    assert!(result.is_err());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::hash::Hash;","    use std::collections::HashMap;","","    #[derive(Hash, PartialEq)]","    struct HeaderName(String);","","    struct MyMap<K, T> {","        entries: Vec<(K, T)>,","        indices: Vec<usize>,","        max_size: usize,","    }","","    impl<K: Hash + Into<HeaderName>, T> MyMap<K, T> {","        fn new(max_size: usize) -> Self {","            MyMap {","                entries: Vec::new(),","                indices: Vec::new(),","                max_size,","            }","        }","","        fn try_reserve_one(&mut self) -> Result<(), ()> {","            if self.entries.len() >= self.max_size {","                Err(())","            } else {","                Ok(())","            }","        }","","        fn try_insert_entry(&mut self, _hash: usize, key: K, value: T) -> Result<(), ()> {","            self.entries.push((key, value));","            Ok(())","        }","","        fn try_insert2(&mut self, key: K, value: T) -> Result<Option<T>, ()> {","            self.try_reserve_one()?;","","            self.try_insert_entry(0, key, value)?;","            Ok(None)","        }","    }","","    let mut my_map = MyMap::new(2);","    my_map.entries.push((HeaderName(\"Key1\".to_string()), 1));","    my_map.indices.push(0);","    ","    // Trying to insert the third element should hit the max size reached constraint","    let result = my_map.try_insert2(HeaderName(\"Key2\".to_string()), 2);","","    assert!(result.is_err());","}"],[]]]}