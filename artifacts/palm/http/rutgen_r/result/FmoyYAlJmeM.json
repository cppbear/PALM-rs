{"function_name":"http::extensions::extensions::Extensions::extend","tests":3,"tests_lines":[50,40,46],"oracles":3,"oracles_compiled":2,"oracles_compiled_rate":66.66666666666666,"tests_compiled":2,"tests_compiled_rate":66.66666666666666,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[257,258,259,260,261,262,263,264,265],"codes_lines_covered":[[["{","    struct Extensions {","        map: Option<std::collections::HashMap<std::any::TypeId, Box<dyn std::any::Any>>>,","    }","","    impl Extensions {","        fn new() -> Self {","            Extensions { map: Some(std::collections::HashMap::new()) }","        }","","        fn insert<T: 'static>(&mut self, value: T) {","            if let Some(map) = &mut self.map {","                map.insert(std::any::TypeId::of::<T>(), Box::new(value));","            }","        }","","        fn get<T: 'static>(&self) -> Option<&T> {","            self.map.as_ref()?.get(&std::any::TypeId::of::<T>())","                .and_then(|value| value.downcast_ref::<T>())","        }","","        fn len(&self) -> usize {","            self.map.as_ref().map_or(0, |map| map.len())","        }","","        fn extend(&mut self, other: Self) {","            if let Some(other_map) = other.map {","                if let Some(map) = &mut self.map {","                    map.extend(other_map);","                } else {","                    self.map = Some(other_map);","                }","            }","        }","    }","","    let mut ext_a = Extensions::new();","    ext_a.insert(8u8);","    ext_a.insert(16u16);","","    let mut ext_b = Extensions::new();","    ext_b.insert(4u8);","    ext_b.insert(\"hello\");","","    ext_a.extend(ext_b);","    assert_eq!(ext_a.len(), 3);","    assert_eq!(ext_a.get::<u8>(), Some(&4u8));","    assert_eq!(ext_a.get::<u16>(), Some(&16u16));","    assert_eq!(ext_a.get::<&'static str>().copied(), Some(\"hello\"));","}"],[]],[["{","    struct Extensions {","        map: Option<std::collections::HashMap<std::any::TypeId, Box<dyn std::any::Any>>>,","    }","","    impl Extensions {","        fn new() -> Self {","            Extensions { map: Some(std::collections::HashMap::new()) }","        }","","        fn insert<T: 'static>(&mut self, value: T) {","            if let Some(map) = &mut self.map {","                map.insert(std::any::TypeId::of::<T>(), Box::new(value));","            }","        }","","        fn get<T: 'static>(&self) -> Option<&T> {","            self.map.as_ref()?.get(&std::any::TypeId::of::<T>())","                .and_then(|value| value.downcast_ref::<T>())","        }","","        fn len(&self) -> usize {","            self.map.as_ref().map_or(0, |map| map.len())","        }","","        fn extend(&mut self, other: Self) {","            if let Some(other_map) = other.map {","                if let Some(map) = &mut self.map {","                    map.extend(other_map);","                } else {","                    self.map = Some(other_map);","                }","            }","        }","    }","","    let mut ext_a = Extensions::new();","    ext_a.insert(8u8);","","    let mut ext_b = Extensions::new();","    ext_b.insert(4u8);","    ","    ext_a.extend(ext_b);","    assert_eq!(ext_a.len(), 1);","    assert_eq!(ext_a.get::<u8>(), Some(&4u8));","}"],[]]],"codes_branches":[{"start_line":258,"start_column":16,"end_line":258,"end_column":27,"positive":false,"negative":false},{"start_line":259,"start_column":20,"end_line":259,"end_column":29,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct Extensions {","        map: Option<std::collections::HashMap<std::any::TypeId, Box<dyn std::any::Any>>>,","    }","","    impl Extensions {","        fn new() -> Self {","            Extensions { map: Some(std::collections::HashMap::new()) }","        }","","        fn insert<T: 'static>(&mut self, value: T) {","            if let Some(map) = &mut self.map {","                map.insert(std::any::TypeId::of::<T>(), Box::new(value));","            }","        }","","        fn get<T: 'static>(&self) -> Option<&T> {","            self.map.as_ref()?.get(&std::any::TypeId::of::<T>())","                .and_then(|value| value.downcast_ref::<T>())","        }","","        fn len(&self) -> usize {","            self.map.as_ref().map_or(0, |map| map.len())","        }","","        fn extend(&mut self, other: Self) {","            if let Some(other_map) = other.map {","                if let Some(map) = &mut self.map {","                    map.extend(other_map);","                } else {","                    self.map = Some(other_map);","                }","            }","        }","    }","","    let mut ext_a = Extensions::new();","    ext_a.insert(8u8);","    ext_a.insert(16u16);","","    let mut ext_b = Extensions::new();","    ext_b.insert(4u8);","    ext_b.insert(\"hello\");","","    ext_a.extend(ext_b);","    assert_eq!(ext_a.len(), 3);","    assert_eq!(ext_a.get::<u8>(), Some(&4u8));","    assert_eq!(ext_a.get::<u16>(), Some(&16u16));","    assert_eq!(ext_a.get::<&'static str>().copied(), Some(\"hello\"));","}"],[{"start_line":258,"start_column":16,"end_line":258,"end_column":27,"positive":false,"negative":false},{"start_line":259,"start_column":20,"end_line":259,"end_column":29,"positive":false,"negative":false}]],[["{","    struct Extensions {","        map: Option<std::collections::HashMap<std::any::TypeId, Box<dyn std::any::Any>>>,","    }","","    impl Extensions {","        fn new() -> Self {","            Extensions { map: Some(std::collections::HashMap::new()) }","        }","","        fn insert<T: 'static>(&mut self, value: T) {","            if let Some(map) = &mut self.map {","                map.insert(std::any::TypeId::of::<T>(), Box::new(value));","            }","        }","","        fn get<T: 'static>(&self) -> Option<&T> {","            self.map.as_ref()?.get(&std::any::TypeId::of::<T>())","                .and_then(|value| value.downcast_ref::<T>())","        }","","        fn len(&self) -> usize {","            self.map.as_ref().map_or(0, |map| map.len())","        }","","        fn extend(&mut self, other: Self) {","            if let Some(other_map) = other.map {","                if let Some(map) = &mut self.map {","                    map.extend(other_map);","                } else {","                    self.map = Some(other_map);","                }","            }","        }","    }","","    let mut ext_a = Extensions::new();","    ext_a.insert(8u8);","","    let mut ext_b = Extensions::new();","    ext_b.insert(4u8);","    ","    ext_a.extend(ext_b);","    assert_eq!(ext_a.len(), 1);","    assert_eq!(ext_a.get::<u8>(), Some(&4u8));","}"],[{"start_line":258,"start_column":16,"end_line":258,"end_column":27,"positive":false,"negative":false},{"start_line":259,"start_column":20,"end_line":259,"end_column":29,"positive":false,"negative":false}]]]}