{"function_name":"http::header::value::<header::value::HeaderValue as std::fmt::Debug>::fmt","tests":29,"tests_lines":[52,29,30,30,30,10,10,10,10,10,10,10,9,17,17,22,15,15,15,8,8,8,8,33,29,29,23,23,23],"oracles":29,"oracles_compiled":9,"oracles_compiled_rate":31.03448275862069,"tests_compiled":9,"tests_compiled_rate":31.03448275862069,"oracles_run":9,"oracles_passed":7,"oracles_passed_rate":77.77777777777779,"tests_run":9,"tests_passed":7,"tests_passed_rate":77.77777777777779,"lines":19,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":10,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[386,387,388,390,391,392,393,394,395,396,397,398,399,401,403,404,407,408,410],"codes_lines_covered":[[["{","    struct HeaderValue {","        is_sensitive: bool,","        data: Vec<u8>,","    }","","    impl HeaderValue {","        fn new(is_sensitive: bool, data: Vec<u8>) -> Self {","            HeaderValue { is_sensitive, data }","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    use std::fmt;","","    impl fmt::Display for HeaderValue {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            if self.is_sensitive {","                f.write_str(\"Sensitive\")","            } else {","                f.write_str(\"\\\"\")?;","                let mut from = 0;","                let bytes = self.as_bytes();","                for (i, &b) in bytes.iter().enumerate() {","                    if !is_visible_ascii(b) || b == b'\"' {","                        if from != i {","                            f.write_str(unsafe { std::str::from_utf8_unchecked(&bytes[from..i]) })?;","                        }","                        if b == b'\"' {","                            f.write_str(\"\\\\\\\"\")?;","                        } else {","                            write!(f, \"\\\\x{:x}\", b)?;","                        }","                        from = i + 1;","                    }","                }","                f.write_str(unsafe { std::str::from_utf8_unchecked(&bytes[from..]) })?;","                f.write_str(\"\\\"\")","            }","        }","    }","","    fn is_visible_ascii(b: u8) -> bool {","        b.is_ascii() && (b >= 32 && b <= 126)","    }","","    let sensitive_value = HeaderValue::new(true, b\"Sensitive Information\".to_vec());","    assert_eq!(format!(\"{}\", sensitive_value), \"Sensitive\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"Hello World!\".to_vec(),","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"Hello World!\\\"\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"Hello \\\"World\\\"!\".to_vec(),","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"Hello \\\\\\\"World\\\\\\\"!\\\"\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"Hello\\x00World!\".to_vec(), // non-visible ASCII","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"Hello\\\\x0World!\\\"\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"\\\"\".to_vec(),","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"\\\\\\\"\\\"\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: vec![b'\\\\', b'\\x00', b'\"', b'\\xFF'], // Contains non-visible ASCII and a quote","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"\\\"\\\\x5c\\\\x0\\\\\\\"\\\\xff\\\"\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"visible\".to_vec(),","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"\\\"visible\\\"\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: true,","        bytes: b\"some_value\".to_vec(),","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"Sensitive\");","}"],[]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: vec![],","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"\\\"\\\"\"); // This line may panic","}"],[]]],"codes_branches":[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct HeaderValue {","        is_sensitive: bool,","        data: Vec<u8>,","    }","","    impl HeaderValue {","        fn new(is_sensitive: bool, data: Vec<u8>) -> Self {","            HeaderValue { is_sensitive, data }","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    use std::fmt;","","    impl fmt::Display for HeaderValue {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            if self.is_sensitive {","                f.write_str(\"Sensitive\")","            } else {","                f.write_str(\"\\\"\")?;","                let mut from = 0;","                let bytes = self.as_bytes();","                for (i, &b) in bytes.iter().enumerate() {","                    if !is_visible_ascii(b) || b == b'\"' {","                        if from != i {","                            f.write_str(unsafe { std::str::from_utf8_unchecked(&bytes[from..i]) })?;","                        }","                        if b == b'\"' {","                            f.write_str(\"\\\\\\\"\")?;","                        } else {","                            write!(f, \"\\\\x{:x}\", b)?;","                        }","                        from = i + 1;","                    }","                }","                f.write_str(unsafe { std::str::from_utf8_unchecked(&bytes[from..]) })?;","                f.write_str(\"\\\"\")","            }","        }","    }","","    fn is_visible_ascii(b: u8) -> bool {","        b.is_ascii() && (b >= 32 && b <= 126)","    }","","    let sensitive_value = HeaderValue::new(true, b\"Sensitive Information\".to_vec());","    assert_eq!(format!(\"{}\", sensitive_value), \"Sensitive\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"Hello World!\".to_vec(),","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"Hello World!\\\"\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"Hello \\\"World\\\"!\".to_vec(),","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"Hello \\\\\\\"World\\\\\\\"!\\\"\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"Hello\\x00World!\".to_vec(), // non-visible ASCII","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"Hello\\\\x0World!\\\"\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"\\\"\".to_vec(),","    };","    let mut output = String::new();","    let result = write!(&mut output, \"{}\", header_value);","    assert!(result.is_ok());","    assert_eq!(output, \"\\\"\\\\\\\"\\\"\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: vec![b'\\\\', b'\\x00', b'\"', b'\\xFF'], // Contains non-visible ASCII and a quote","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"\\\"\\\\x5c\\\\x0\\\\\\\"\\\\xff\\\"\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: b\"visible\".to_vec(),","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"\\\"visible\\\"\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: true,","        bytes: b\"some_value\".to_vec(),","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"Sensitive\");","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]],[["{","    let header_value = HeaderValue {","        is_sensitive: false,","        bytes: vec![],","    };","    let result = format!(\"{:?}\", header_value);","    assert_eq!(result, \"\\\"\\\"\"); // This line may panic","}"],[{"start_line":387,"start_column":12,"end_line":387,"end_column":29,"positive":false,"negative":false},{"start_line":394,"start_column":20,"end_line":394,"end_column":40,"positive":false,"negative":false},{"start_line":394,"start_column":44,"end_line":394,"end_column":53,"positive":false,"negative":false},{"start_line":395,"start_column":24,"end_line":395,"end_column":33,"positive":false,"negative":false},{"start_line":398,"start_column":24,"end_line":398,"end_column":33,"positive":false,"negative":false}]]]}