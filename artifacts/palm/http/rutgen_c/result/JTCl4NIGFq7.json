{"function_name":"http::header::map::header::map::OccupiedEntry<'a, T>::insert_mult","tests":3,"tests_lines":[29,15,20],"oracles":3,"oracles_compiled":2,"oracles_compiled_rate":66.66666666666666,"tests_compiled":2,"tests_compiled_rate":66.66666666666666,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[3236,3237,3238],"codes_lines_covered":[[["{","    // Define necessary structs for the test","    struct FakeHeaderValue(String);","    impl From<&str> for FakeHeaderValue {","        fn from(value: &str) -> Self {","            FakeHeaderValue(value.to_string())","        }","    }","    ","    // Initialize the HeaderMap","    let mut map = HeaderMap::<FakeHeaderValue>::with_capacity(10);","","    // Insert initial values","    map.insert(HeaderName::from_static(\"host\"), FakeHeaderValue::from(\"world\"));","    map.append(HeaderName::from_static(\"host\"), FakeHeaderValue::from(\"world2\"));","","    // Test inserting multiple values","    if let Entry::Occupied(mut entry) = map.entry(HeaderName::from_static(\"host\")) {","        let mut drain = entry.insert_mult(FakeHeaderValue::from(\"earth\"));","        ","        // Verify the previous values are returned correctly","        assert_eq!(\"world\", drain.next().unwrap().0);","        assert_eq!(\"world2\", drain.next().unwrap().0);","        assert!(drain.next().is_none());","    }","","    // Verify the current value for \"host\"","    assert_eq!(\"earth\", map.get(HeaderName::from_static(\"host\")).unwrap().0);","}"],[3236,3237,3238]],[["{","    // Define necessary structs for the test","    struct LimitedHeaderValue(String);","    impl From<&str> for LimitedHeaderValue {","        fn from(value: &str) -> Self {","            LimitedHeaderValue(value.to_string())","        }","    }","    ","    // Initialize the HeaderMap with a small capacity","    let mut map = HeaderMap::<LimitedHeaderValue>::try_with_capacity(1).unwrap();","","    // Insert a value","    map.insert(HeaderName::from_static(\"host\"), LimitedHeaderValue::from(\"initial\"));","","    // This should panic because inserting exceeds the capacity","    if let Entry::Occupied(mut entry) = map.entry(HeaderName::from_static(\"host\")) {","        entry.insert_mult(LimitedHeaderValue::from(\"second\"));","    }","}"],[3236,3237,3238]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Define necessary structs for the test","    struct FakeHeaderValue(String);","    impl From<&str> for FakeHeaderValue {","        fn from(value: &str) -> Self {","            FakeHeaderValue(value.to_string())","        }","    }","    ","    // Initialize the HeaderMap","    let mut map = HeaderMap::<FakeHeaderValue>::with_capacity(10);","","    // Insert initial values","    map.insert(HeaderName::from_static(\"host\"), FakeHeaderValue::from(\"world\"));","    map.append(HeaderName::from_static(\"host\"), FakeHeaderValue::from(\"world2\"));","","    // Test inserting multiple values","    if let Entry::Occupied(mut entry) = map.entry(HeaderName::from_static(\"host\")) {","        let mut drain = entry.insert_mult(FakeHeaderValue::from(\"earth\"));","        ","        // Verify the previous values are returned correctly","        assert_eq!(\"world\", drain.next().unwrap().0);","        assert_eq!(\"world2\", drain.next().unwrap().0);","        assert!(drain.next().is_none());","    }","","    // Verify the current value for \"host\"","    assert_eq!(\"earth\", map.get(HeaderName::from_static(\"host\")).unwrap().0);","}"],[]],[["{","    // Define necessary structs for the test","    struct LimitedHeaderValue(String);","    impl From<&str> for LimitedHeaderValue {","        fn from(value: &str) -> Self {","            LimitedHeaderValue(value.to_string())","        }","    }","    ","    // Initialize the HeaderMap with a small capacity","    let mut map = HeaderMap::<LimitedHeaderValue>::try_with_capacity(1).unwrap();","","    // Insert a value","    map.insert(HeaderName::from_static(\"host\"), LimitedHeaderValue::from(\"initial\"));","","    // This should panic because inserting exceeds the capacity","    if let Entry::Occupied(mut entry) = map.entry(HeaderName::from_static(\"host\")) {","        entry.insert_mult(LimitedHeaderValue::from(\"second\"));","    }","}"],[]]]}