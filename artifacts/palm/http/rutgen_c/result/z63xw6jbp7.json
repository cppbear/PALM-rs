{"function_name":"http::header::map::header::map::HeaderMap<T>::insert_occupied_mult","tests":2,"tests_lines":[40,21],"oracles":2,"oracles_compiled":1,"oracles_compiled_rate":50.0,"tests_compiled":1,"tests_compiled_rate":50.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":23,"lines_covered":23,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339],"codes_lines_covered":[[["{","    struct TestHeaderMap {","        map: HeaderMap<i32>,","    }","","    impl TestHeaderMap {","        fn new() -> Self {","            let capacity = 10;","            let map = HeaderMap::with_capacity(capacity);","            Self { map }","        }","","        fn insert_value(&mut self, index: usize, value: i32) -> ValueDrain<i32> {","            self.map.insert_occupied_mult(index, value)","        }","    }","","    let mut map = TestHeaderMap::new();","    let value_drain = map.insert_value(0, 15);","    assert_eq!(value_drain.first, Some(0)); // Expect 0 because no entry exists","}"],[1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestHeaderMap {","        map: HeaderMap<i32>,","    }","","    impl TestHeaderMap {","        fn new() -> Self {","            let capacity = 10;","            let map = HeaderMap::with_capacity(capacity);","            Self { map }","        }","","        fn insert_value(&mut self, index: usize, value: i32) -> ValueDrain<i32> {","            self.map.insert_occupied_mult(index, value)","        }","    }","","    let mut map = TestHeaderMap::new();","    let value_drain = map.insert_value(0, 15);","    assert_eq!(value_drain.first, Some(0)); // Expect 0 because no entry exists","}"],[]]]}