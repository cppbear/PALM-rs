{"function_name":"http::extensions::<extensions::Extensions as std::fmt::Debug>::fmt","tests":2,"tests_lines":[32,29],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[269,270,271],"codes_lines_covered":[[["{","    use std::any::{Any, TypeId};","    use std::collections::HashMap;","    use std::fmt;","    use std::hash::{BuildHasherDefault, Hasher};","","    type AnyMap = HashMap<","        TypeId,","        Box<dyn Any + Send + Sync>,","        BuildHasherDefault<IdHasher>,","    >;","","    #[derive(Default)]","    struct Extensions {","        map: Option<Box<AnyMap>>,","    }","","    impl fmt::Debug for Extensions {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Extensions\").finish()","        }","    }","","    // Create an instance of Extensions","    let extensions = Extensions::default();","    ","    // Capture the output of the debug implementation","    let debug_output = format!(\"{:?}\", extensions);","    ","    // Check if the output is as expected","    assert_eq!(debug_output, \"Extensions\");","}"],[]],[["{","    use std::any::{Any, TypeId};","    use std::collections::HashMap;","    use std::fmt;","    use std::hash::{BuildHasherDefault, Hasher};","","    type AnyMap = HashMap<","        TypeId,","        Box<dyn Any + Send + Sync>,","        BuildHasherDefault<IdHasher>,","    >;","","    #[derive(Default)]","    struct Extensions {","        map: Option<Box<AnyMap>>,","    }","","    impl fmt::Debug for Extensions {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Extensions\").finish()","        }","    }","","    // Create another instance of Extensions","    let empty_extensions = Extensions::default();","    ","    // Directly asserting debug, as it's known to return the same for empty.","    assert_eq!(format!(\"{:?}\", empty_extensions), \"Extensions\");","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::any::{Any, TypeId};","    use std::collections::HashMap;","    use std::fmt;","    use std::hash::{BuildHasherDefault, Hasher};","","    type AnyMap = HashMap<","        TypeId,","        Box<dyn Any + Send + Sync>,","        BuildHasherDefault<IdHasher>,","    >;","","    #[derive(Default)]","    struct Extensions {","        map: Option<Box<AnyMap>>,","    }","","    impl fmt::Debug for Extensions {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Extensions\").finish()","        }","    }","","    // Create an instance of Extensions","    let extensions = Extensions::default();","    ","    // Capture the output of the debug implementation","    let debug_output = format!(\"{:?}\", extensions);","    ","    // Check if the output is as expected","    assert_eq!(debug_output, \"Extensions\");","}"],[]],[["{","    use std::any::{Any, TypeId};","    use std::collections::HashMap;","    use std::fmt;","    use std::hash::{BuildHasherDefault, Hasher};","","    type AnyMap = HashMap<","        TypeId,","        Box<dyn Any + Send + Sync>,","        BuildHasherDefault<IdHasher>,","    >;","","    #[derive(Default)]","    struct Extensions {","        map: Option<Box<AnyMap>>,","    }","","    impl fmt::Debug for Extensions {","        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {","            f.debug_struct(\"Extensions\").finish()","        }","    }","","    // Create another instance of Extensions","    let empty_extensions = Extensions::default();","    ","    // Directly asserting debug, as it's known to return the same for empty.","    assert_eq!(format!(\"{:?}\", empty_extensions), \"Extensions\");","}"],[]]]}