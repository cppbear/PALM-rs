{"function_name":"http::header::map::header::map::HeaderMap<T>::reinsert_entry_in_order","tests":2,"tests_lines":[12,13],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":11,"lines_covered":10,"lines_coveraged_rate":90.9090909090909,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[1679,1680,1682,1683,1684,1685,1687,1688,1689,1691,1692],"codes_lines_covered":[[["{","    struct TestHeaderValue;","","    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(4);","    let pos = Pos::new(0, HashValue(1));","    header_map.indices = Box::from([Pos::none(); 4]); // Initialize indices with None positions","    header_map.mask = 3; // Assuming 4 buckets, mask is 3 (2^n - 1)","    ","    header_map.reinsert_entry_in_order(pos);","","    assert!(header_map.indices[desired_pos(header_map.mask, HashValue(1))].is_some());","}"],[1679,1680,1682,1683,1684,1685,1687,1688,1692]],[["{","    struct TestHeaderValue;","","    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(4);","    let pos = Pos::new(1, HashValue(1));","    header_map.indices = Box::from([Pos::new(0, HashValue(1)), Pos::new(0, HashValue(2)), Pos::none(), Pos::none()]); // Fill two buckets","    header_map.mask = 3; // Assuming 4 buckets, mask is 3","","    header_map.reinsert_entry_in_order(pos);","","    // Since indices were full at first two positions, we check that the `pos` is inserted at the next available one","    assert!(header_map.indices[desired_pos(header_map.mask, HashValue(1))].is_some());","}"],[1679,1680,1682,1683,1684,1685,1687,1688,1689,1692]]],"codes_branches":[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":true,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestHeaderValue;","","    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(4);","    let pos = Pos::new(0, HashValue(1));","    header_map.indices = Box::from([Pos::none(); 4]); // Initialize indices with None positions","    header_map.mask = 3; // Assuming 4 buckets, mask is 3 (2^n - 1)","    ","    header_map.reinsert_entry_in_order(pos);","","    assert!(header_map.indices[desired_pos(header_map.mask, HashValue(1))].is_some());","}"],[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":true,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":true,"negative":false}]],[["{","    struct TestHeaderValue;","","    let mut header_map: HeaderMap<TestHeaderValue> = HeaderMap::with_capacity(4);","    let pos = Pos::new(1, HashValue(1));","    header_map.indices = Box::from([Pos::new(0, HashValue(1)), Pos::new(0, HashValue(2)), Pos::none(), Pos::none()]); // Fill two buckets","    header_map.mask = 3; // Assuming 4 buckets, mask is 3","","    header_map.reinsert_entry_in_order(pos);","","    // Since indices were full at first two positions, we check that the `pos` is inserted at the next available one","    assert!(header_map.indices[desired_pos(header_map.mask, HashValue(1))].is_some());","}"],[{"start_line":1680,"start_column":16,"end_line":1680,"end_column":37,"positive":true,"negative":false},{"start_line":1685,"start_column":20,"end_line":1685,"end_column":59,"positive":true,"negative":true}]]]}