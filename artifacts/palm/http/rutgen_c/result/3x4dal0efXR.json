{"function_name":"http::header::map::header::map::HeaderMap<T>::try_reserve_one","tests":5,"tests_lines":[7,13,15,13,12],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":4,"tests_compiled_rate":80.0,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":4,"tests_passed":2,"tests_passed_rate":50.0,"lines":31,"lines_covered":26,"lines_coveraged_rate":83.87096774193549,"branches":8,"branches_covered":7,"branches_coverage_rate":87.5,"codes_lines":[1694,1695,1696,1697,1698,1699,1700,1702,1703,1704,1705,1706,1707,1708,1710,1713,1714,1715,1717,1719,1720,1721,1722,1723,1724,1725,1726,1727,1729,1731,1732],"codes_lines_covered":[[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(0);","    ","    header_map.try_reserve(7).unwrap(); // Ensure we can reserve initially","    assert!(header_map.capacity() > 0); // Check that capacity has increased","}"],[]],[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(1);","    ","    // Fill the map","    header_map.try_insert(\"key1\", DummyValue).unwrap();","    header_map.try_insert(\"key2\", DummyValue).unwrap();","    header_map.danger.set_yellow(); // Set danger to yellow","    ","    // Reserve one, this should trigger capacity doubling","    header_map.try_reserve_one().unwrap();","    assert_eq!(header_map.capacity(), 2); // Check that capacity has doubled","}"],[1694,1695,1696,1697,1698,1699,1700,1702,1703,1704,1705,1706,1707,1708,1719,1720,1726,1727,1729,1731,1732]],[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(0);","    ","    // The initial capacity should be 0","    assert_eq!(header_map.capacity(), 0);","    ","    // Trying to reserve one should allocate the initial value","    header_map.try_reserve_one().unwrap();","    ","    // After reserving, it should have capacity of 8","    assert_eq!(header_map.capacity(), 8);","}"],[1694,1695,1696,1697,1719,1720,1721,1722,1723,1724,1725,1731,1732]],[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(MAX_SIZE);","    ","    // Fill to max size","    for _ in 0..MAX_SIZE {","        header_map.try_insert(\"key\", DummyValue).unwrap();","    }","    ","    // This should panic due to reaching max size","    header_map.try_reserve_one().unwrap();","}"],[]]],"codes_branches":[{"start_line":1697,"start_column":12,"end_line":1697,"end_column":35,"positive":true,"negative":true},{"start_line":1700,"start_column":16,"end_line":1700,"end_column":52,"positive":true,"negative":false},{"start_line":1719,"start_column":19,"end_line":1719,"end_column":41,"positive":true,"negative":true},{"start_line":1720,"start_column":16,"end_line":1720,"end_column":24,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(0);","    ","    header_map.try_reserve(7).unwrap(); // Ensure we can reserve initially","    assert!(header_map.capacity() > 0); // Check that capacity has increased","}"],[{"start_line":1697,"start_column":12,"end_line":1697,"end_column":35,"positive":false,"negative":false},{"start_line":1700,"start_column":16,"end_line":1700,"end_column":52,"positive":false,"negative":false},{"start_line":1719,"start_column":19,"end_line":1719,"end_column":41,"positive":false,"negative":false},{"start_line":1720,"start_column":16,"end_line":1720,"end_column":24,"positive":false,"negative":false}]],[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(1);","    ","    // Fill the map","    header_map.try_insert(\"key1\", DummyValue).unwrap();","    header_map.try_insert(\"key2\", DummyValue).unwrap();","    header_map.danger.set_yellow(); // Set danger to yellow","    ","    // Reserve one, this should trigger capacity doubling","    header_map.try_reserve_one().unwrap();","    assert_eq!(header_map.capacity(), 2); // Check that capacity has doubled","}"],[{"start_line":1697,"start_column":12,"end_line":1697,"end_column":35,"positive":true,"negative":true},{"start_line":1700,"start_column":16,"end_line":1700,"end_column":52,"positive":true,"negative":false},{"start_line":1719,"start_column":19,"end_line":1719,"end_column":41,"positive":true,"negative":true},{"start_line":1720,"start_column":16,"end_line":1720,"end_column":24,"positive":false,"negative":true}]],[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(0);","    ","    // The initial capacity should be 0","    assert_eq!(header_map.capacity(), 0);","    ","    // Trying to reserve one should allocate the initial value","    header_map.try_reserve_one().unwrap();","    ","    // After reserving, it should have capacity of 8","    assert_eq!(header_map.capacity(), 8);","}"],[{"start_line":1697,"start_column":12,"end_line":1697,"end_column":35,"positive":false,"negative":true},{"start_line":1700,"start_column":16,"end_line":1700,"end_column":52,"positive":false,"negative":false},{"start_line":1719,"start_column":19,"end_line":1719,"end_column":41,"positive":true,"negative":false},{"start_line":1720,"start_column":16,"end_line":1720,"end_column":24,"positive":true,"negative":false}]],[["{","    struct DummyValue;","    let mut header_map: HeaderMap<DummyValue> = HeaderMap::with_capacity(MAX_SIZE);","    ","    // Fill to max size","    for _ in 0..MAX_SIZE {","        header_map.try_insert(\"key\", DummyValue).unwrap();","    }","    ","    // This should panic due to reaching max size","    header_map.try_reserve_one().unwrap();","}"],[{"start_line":1697,"start_column":12,"end_line":1697,"end_column":35,"positive":false,"negative":false},{"start_line":1700,"start_column":16,"end_line":1700,"end_column":52,"positive":false,"negative":false},{"start_line":1719,"start_column":19,"end_line":1719,"end_column":41,"positive":false,"negative":false},{"start_line":1720,"start_column":16,"end_line":1720,"end_column":24,"positive":false,"negative":false}]]]}