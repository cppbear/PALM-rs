{
  "name": "http::header::map::<header::map::HeaderMap<T> as std::iter::IntoIterator>::into_iter",
  "name_with_impl": "http::header::map::{impl#4}::into_iter",
  "mod_info": {
    "name": "header::map",
    "loc": "src/header/mod.rs:73:1:73:9"
  },
  "visible": true,
  "loc": "src/header/map.rs:1990:5:1996:6",
  "doc": "/// Creates a consuming iterator, that is, one that moves keys and values\n/// out of the map in arbitrary order. The map cannot be used after calling\n/// this.\n///\n/// For each yielded item that has `None` provided for the `HeaderName`,\n/// then the associated header name is the same as that of the previously\n/// yielded item. The first yielded item will have `HeaderName` set.\n///\n/// # Examples\n///\n/// Basic usage.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n/// map.insert(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n/// map.insert(header::CONTENT_TYPE, \"json\".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\n///\n/// Multiple values per key.\n///\n/// ```\n/// # use http::header;\n/// # use http::header::*;\n/// let mut map = HeaderMap::new();\n///\n/// map.append(header::CONTENT_LENGTH, \"123\".parse().unwrap());\n/// map.append(header::CONTENT_LENGTH, \"456\".parse().unwrap());\n///\n/// map.append(header::CONTENT_TYPE, \"json\".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, \"html\".parse().unwrap());\n/// map.append(header::CONTENT_TYPE, \"xml\".parse().unwrap());\n///\n/// let mut iter = map.into_iter();\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_LENGTH), \"123\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"456\".parse().unwrap())));\n///\n/// assert_eq!(iter.next(), Some((Some(header::CONTENT_TYPE), \"json\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"html\".parse().unwrap())));\n/// assert_eq!(iter.next(), Some((None, \"xml\".parse().unwrap())));\n/// assert!(iter.next().is_none());\n/// ```\n",
  "code": [
    "fn into_iter(self) -> IntoIter<T> {",
    "    IntoIter {",
    "        next: None,",
    "        entries: self.entries.into_iter(),",
    "        extra_values: self.extra_values,",
    "    }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "IntoIter {\n            next: None,\n            entries: self.entries.into_iter(),\n            extra_values: self.extra_values,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}