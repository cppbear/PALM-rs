{
  "name": "http::status::status::StatusCode::as_str",
  "name_with_impl": "http::status::{impl#0}::as_str",
  "mod_info": {
    "name": "status",
    "loc": "src/lib.rs:176:1:176:16"
  },
  "visible": true,
  "loc": "src/status.rs:135:5:151:6",
  "doc": "/// Returns a &str representation of the `StatusCode`\n///\n/// The return value only includes a numerical representation of the\n/// status code. The canonical reason is not included.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.as_str(), \"200\");\n/// ```\n",
  "code": [
    "pub fn as_str(&self) -> &str {",
    "    let offset = (self.0.get() - 100) as usize;",
    "    let offset = offset * 3;",
    "",
    "    // Invariant: self has checked range [100, 999] and CODE_DIGITS is",
    "    // ASCII-only, of length 900 * 3 = 2700 bytes",
    "",
    "    #[cfg(debug_assertions)]",
    "    {",
    "        &CODE_DIGITS[offset..offset + 3]",
    "    }",
    "",
    "    #[cfg(not(debug_assertions))]",
    "    unsafe {",
    "        CODE_DIGITS.get_unchecked(offset..offset + 3)",
    "    }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "CODE_DIGITS[offset..offset + 3]",
          "norm": null,
          "value": "",
          "line": 144,
          "bound": null,
          "may_panic": true
        }
      ],
      "ret": "&CODE_DIGITS[offset..offset + 3]",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}