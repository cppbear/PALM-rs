{
  "name": "http::status::status::StatusCode::canonical_reason",
  "name_with_impl": "http::status::{impl#0}::canonical_reason",
  "mod_info": {
    "name": "status",
    "loc": "src/lib.rs:176:1:176:16"
  },
  "visible": true,
  "loc": "src/status.rs:171:5:173:6",
  "doc": "/// Get the standardised `reason-phrase` for this status code.\n///\n/// This is mostly here for servers writing responses, but could potentially have application\n/// at other times.\n///\n/// The reason phrase is defined as being exclusively for human readers. You should avoid\n/// deriving any meaning from it at all costs.\n///\n/// Bear in mind also that in HTTP/2.0 and HTTP/3.0 the reason phrase is abolished from\n/// transmission, and so this canonical reason phrase really is the only reason phrase youâ€™ll\n/// find.\n///\n/// # Example\n///\n/// ```\n/// let status = http::StatusCode::OK;\n/// assert_eq!(status.canonical_reason(), Some(\"OK\"));\n/// ```\n",
  "code": [
    "pub fn canonical_reason(&self) -> Option<&'static str> {",
    "    canonical_reason(self.0.get())",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}