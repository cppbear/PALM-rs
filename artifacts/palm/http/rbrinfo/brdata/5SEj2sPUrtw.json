{
  "name": "http::header::value::header::value::HeaderValue::from_static",
  "name_with_impl": "http::header::value::{impl#0}::from_static",
  "mod_info": {
    "name": "header::value",
    "loc": "src/header/mod.rs:75:1:75:11"
  },
  "visible": true,
  "loc": "src/header/value.rs:84:5:104:6",
  "doc": "/// Convert a static string to a `HeaderValue`.\n///\n/// This function will not perform any copying, however the string is\n/// checked to ensure that no invalid characters are present. Only visible\n/// ASCII characters (32-127) are permitted.\n///\n/// # Panics\n///\n/// This function panics if the argument contains invalid header value\n/// characters.\n///\n/// Until [Allow panicking in constants](https://github.com/rust-lang/rfcs/pull/2345)\n/// makes its way into stable, the panic message at compile-time is\n/// going to look cryptic, but should at least point at your header value:\n///\n/// ```text\n/// error: any use of this value will cause an error\n///   --> http/src/header/value.rs:67:17\n///    |\n/// 67 |                 ([] as [u8; 0])[0]; // Invalid header value\n///    |                 ^^^^^^^^^^^^^^^^^^\n///    |                 |\n///    |                 index out of bounds: the length is 0 but the index is 0\n///    |                 inside `HeaderValue::from_static` at http/src/header/value.rs:67:17\n///    |                 inside `INVALID_HEADER` at src/main.rs:73:33\n///    |\n///   ::: src/main.rs:73:1\n///    |\n/// 73 | const INVALID_HEADER: HeaderValue = HeaderValue::from_static(\"Ð¶some value\");\n///    | ----------------------------------------------------------------------------\n/// ```\n///\n/// # Examples\n///\n/// ```\n/// # use http::header::HeaderValue;\n/// let val = HeaderValue::from_static(\"hello\");\n/// assert_eq!(val, \"hello\");\n/// ```\n",
  "code": [
    "pub const fn from_static(src: &'static str) -> HeaderValue {",
    "    let bytes = src.as_bytes();",
    "    let mut i = 0;",
    "    while i < bytes.len() {",
    "        if !is_visible_ascii(bytes[i]) {",
    "            // TODO: When msrv is bumped to larger than 1.57, this should be",
    "            // replaced with `panic!` macro.",
    "            // https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html#panic-in-const-contexts",
    "            //",
    "            // See the panics section of this method's document for details.",
    "            #[allow(clippy::no_effect, clippy::out_of_bounds_indexing)]",
    "            ([] as [u8; 0])[0]; // Invalid header value",
    "        }",
    "        i += 1;",
    "    }",
    "",
    "    HeaderValue {",
    "        inner: Bytes::from_static(bytes),",
    "        is_sensitive: false,",
    "    }",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 2,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "i < bytes.len()",
          "norm": "bytes.len() > i",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "is_visible_ascii(bytes[i])",
          "norm": null,
          "value": "true",
          "line": 88,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "i < bytes.len()",
          "norm": "bytes.len() > i",
          "value": "false",
          "line": 87,
          "bound": "i == bytes.len()",
          "may_panic": false
        }
      ],
      "ret": "HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        12,
        2,
        3,
        4,
        13,
        14,
        15
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "i < bytes.len()",
          "norm": "bytes.len() > i",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "is_visible_ascii(bytes[i])",
          "norm": null,
          "value": "false",
          "line": 88,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "i < bytes.len()",
          "norm": "bytes.len() > i",
          "value": "false",
          "line": 87,
          "bound": "i == bytes.len()",
          "may_panic": false
        }
      ],
      "ret": "HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        9,
        10,
        11,
        12,
        2,
        3,
        4,
        13,
        14,
        15
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "i < bytes.len()",
          "norm": "bytes.len() > i",
          "value": "false",
          "line": 87,
          "bound": "i == bytes.len()",
          "may_panic": false
        }
      ],
      "ret": "HeaderValue {\n            inner: Bytes::from_static(bytes),\n            is_sensitive: false,\n        }",
      "path": [
        0,
        1,
        2,
        3,
        4,
        13,
        14,
        15
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}