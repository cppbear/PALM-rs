{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. Omit test oracles and assertions; concentrate on generating test inputs and function calls of the focal function; do not use \"_\" for the return values of the focal function.\n3. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides.\n6. If the method under test uses generics, instantiate them with suitable types based on the context.\n7. Define any necessary helper structures or implementations directly within the test function when required.\n8. Create a minimal yet comprehensive set of test functions, ensuring each test input satisfies all given constraints, with some explicitly covering edge scenarios.\n9. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/header/name.rs\n// crate name is http\nuse crate::byte_str::ByteStr;\nuse bytes::{Bytes, BytesMut};\nuse std::borrow::Borrow;\nuse std::convert::TryFrom;\nuse std::error::Error;\nuse std::fmt;\nuse std::hash::{Hash, Hasher};\nuse std::mem::MaybeUninit;\nuse std::str::FromStr;\n#[rustfmt::skip]\nconst HEADER_CHARS: [u8; 256] = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, b'!', 0, b'#', b'$', b'%', b'&', b'\\'', 0, 0, b'*', b'+', 0, b'-',\n    b'.', 0, b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', 0, 0, 0, 0, 0,\n    0, 0, b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j', b'k', b'l', b'm',\n    b'n', b'o', b'p', b'q', b'r', b's', b't', b'u', b'v', b'w', b'x', b'y', b'z', 0, 0,\n    0, b'^', b'_', b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j',\n    b'k', b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't', b'u', b'v', b'w', b'x',\n    b'y', b'z', 0, b'|', 0, b'~', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\n#[rustfmt::skip]\nconst HEADER_CHARS_H2: [u8; 256] = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, b'!', b'\"', b'#', b'$', b'%', b'&', b'\\'', 0, 0, b'*', b'+', 0, b'-',\n    b'.', 0, b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, b'^', b'_', b'`', b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i',\n    b'j', b'k', b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't', b'u', b'v', b'w',\n    b'x', b'y', b'z', 0, b'|', 0, b'~', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n];\nconst SCRATCH_BUF_SIZE: usize = 64;\nconst SCRATCH_BUF_OVERFLOW: usize = SCRATCH_BUF_SIZE + 1;\nmacro_rules! standard_headers {\n    ($($(#[$docs:meta])* ($konst:ident, $upcase:ident, $name_bytes:literal);)+) => {\n        #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)] enum StandardHeader {\n        $($konst,)+ } $($(#[$docs])* pub const $upcase : HeaderName = HeaderName { inner\n        : Repr::Standard(StandardHeader::$konst), };)+ impl StandardHeader { #[inline] fn\n        as_str(& self) -> &'static str { match * self { $(StandardHeader::$konst =>\n        unsafe { std::str::from_utf8_unchecked($name_bytes) },)+ } } const fn\n        from_bytes(name_bytes : & [u8]) -> Option < StandardHeader > { match name_bytes {\n        $($name_bytes => Some(StandardHeader::$konst),)+ _ => None, } } } #[cfg(test)]\n        const TEST_HEADERS : &'static [(StandardHeader, &'static [u8])] = &\n        [$((StandardHeader::$konst, $name_bytes),)+];\n    };\n}\nstandard_headers! {\n    #[doc = \" Advertises which content types the client is able to understand.\"] #[doc =\n    \"\"] #[doc =\n    \" The Accept request HTTP header advertises which content types, expressed\"] #[doc =\n    \" as MIME types, the client is able to understand. Using content\"] #[doc =\n    \" negotiation, the server then selects one of the proposals, uses it and\"] #[doc =\n    \" informs the client of its choice with the Content-Type response header.\"] #[doc =\n    \" Browsers set adequate values for this header depending of the context\"] #[doc =\n    \" where the request is done: when fetching a CSS stylesheet a different\"] #[doc =\n    \" value is set for the request than when fetching an image, video or a\"] #[doc =\n    \" script.\"] (Accept, ACCEPT, b\"accept\"); #[doc =\n    \" Advertises which character set the client is able to understand.\"] #[doc = \"\"]\n    #[doc = \" The Accept-Charset request HTTP header advertises which character set\"]\n    #[doc = \" the client is able to understand. Using content negotiation, the server\"]\n    #[doc = \" then selects one of the proposals, uses it and informs the client of its\"]\n    #[doc = \" choice within the Content-Type response header. Browsers usually don't\"]\n    #[doc = \" set this header as the default value for each content type is usually\"]\n    #[doc = \" correct and transmitting it would allow easier fingerprinting.\"] #[doc =\n    \"\"] #[doc = \" If the server cannot serve any matching character set, it can\"] #[doc =\n    \" theoretically send back a 406 (Not Acceptable) error code. But, for a\"] #[doc =\n    \" better user experience, this is rarely done and the more common way is\"] #[doc =\n    \" to ignore the Accept-Charset header in this case.\"] (AcceptCharset, ACCEPT_CHARSET,\n    b\"accept-charset\"); #[doc =\n    \" Advertises which content encoding the client is able to understand.\"] #[doc = \"\"]\n    #[doc = \" The Accept-Encoding request HTTP header advertises which content\"] #[doc =\n    \" encoding, usually a compression algorithm, the client is able to\"] #[doc =\n    \" understand. Using content negotiation, the server selects one of the\"] #[doc =\n    \" proposals, uses it and informs the client of its choice with the\"] #[doc =\n    \" Content-Encoding response header.\"] #[doc = \"\"] #[doc =\n    \" Even if both the client and the server supports the same compression\"] #[doc =\n    \" algorithms, the server may choose not to compress the body of a\"] #[doc =\n    \" response, if the identity value is also acceptable. Two common cases\"] #[doc =\n    \" lead to this:\"] #[doc = \"\"] #[doc =\n    \" * The data to be sent is already compressed and a second compression\"] #[doc =\n    \" won't lead to smaller data to be transmitted. This may the case with\"] #[doc =\n    \" some image formats;\"] #[doc = \"\"] #[doc =\n    \" * The server is overloaded and cannot afford the computational overhead\"] #[doc =\n    \" induced by the compression requirement. Typically, Microsoft recommends\"] #[doc =\n    \" not to compress if a server use more than 80 % of its computational\"] #[doc =\n    \" power.\"] #[doc = \"\"] #[doc =\n    \" As long as the identity value, meaning no compression, is not explicitly\"] #[doc =\n    \" forbidden, by an identity;q=0 or a *;q=0 without another explicitly set\"] #[doc =\n    \" value for identity, the server must never send back a 406 Not Acceptable\"] #[doc =\n    \" error.\"] (AcceptEncoding, ACCEPT_ENCODING, b\"accept-encoding\"); #[doc =\n    \" Advertises which languages the client is able to understand.\"] #[doc = \"\"] #[doc =\n    \" The Accept-Language request HTTP header advertises which languages the\"] #[doc =\n    \" client is able to understand, and which locale variant is preferred.\"] #[doc =\n    \" Using content negotiation, the server then selects one of the proposals,\"] #[doc =\n    \" uses it and informs the client of its choice with the Content-Language\"] #[doc =\n    \" response header. Browsers set adequate values for this header according\"] #[doc =\n    \" their user interface language and even if a user can change it, this\"] #[doc =\n    \" happens rarely (and is frown upon as it leads to fingerprinting).\"] #[doc = \"\"]\n    #[doc = \" This header is a hint to be used when the server has no way of\"] #[doc =\n    \" determining the language via another way, like a specific URL, that is\"] #[doc =\n    \" controlled by an explicit user decision. It is recommended that the\"] #[doc =\n    \" server never overrides an explicit decision. The content of the\"] #[doc =\n    \" Accept-Language is often out of the control of the user (like when\"] #[doc =\n    \" traveling and using an Internet Cafe in a different country); the user\"] #[doc =\n    \" may also want to visit a page in another language than the locale of\"] #[doc =\n    \" their user interface.\"] #[doc = \"\"] #[doc =\n    \" If the server cannot serve any matching language, it can theoretically\"] #[doc =\n    \" send back a 406 (Not Acceptable) error code. But, for a better user\"] #[doc =\n    \" experience, this is rarely done and more common way is to ignore the\"] #[doc =\n    \" Accept-Language header in this case.\"] (AcceptLanguage, ACCEPT_LANGUAGE,\n    b\"accept-language\"); #[doc =\n    \" Marker used by the server to advertise partial request support.\"] #[doc = \"\"] #[doc\n    = \" The Accept-Ranges response HTTP header is a marker used by the server to\"] #[doc\n    = \" advertise its support of partial requests. The value of this field\"] #[doc =\n    \" indicates the unit that can be used to define a range.\"] #[doc = \"\"] #[doc =\n    \" In presence of an Accept-Ranges header, the browser may try to resume an\"] #[doc =\n    \" interrupted download, rather than to start it from the start again.\"]\n    (AcceptRanges, ACCEPT_RANGES, b\"accept-ranges\"); #[doc =\n    \" Preflight response indicating if the response to the request can be\"] #[doc =\n    \" exposed to the page.\"] #[doc = \"\"] #[doc =\n    \" The Access-Control-Allow-Credentials response header indicates whether\"] #[doc =\n    \" or not the response to the request can be exposed to the page. It can be\"] #[doc =\n    \" exposed when the true value is returned; it can't in other cases.\"] #[doc = \"\"]\n    #[doc = \" Credentials are cookies, authorization headers or TLS client\"] #[doc =\n    \" certificates.\"] #[doc = \"\"] #[doc =\n    \" When used as part of a response to a preflight request, this indicates\"] #[doc =\n    \" whether or not the actual request can be made using credentials. Note\"] #[doc =\n    \" that simple GET requests are not preflighted, and so if a request is\"] #[doc =\n    \" made for a resource with credentials, if this header is not returned\"] #[doc =\n    \" with the resource, the response is ignored by the browser and not\"] #[doc =\n    \" returned to web content.\"] #[doc = \"\"] #[doc =\n    \" The Access-Control-Allow-Credentials header works in conjunction with\"] #[doc =\n    \" the XMLHttpRequest.withCredentials property or with the credentials\"] #[doc =\n    \" option in the Request() constructor of the Fetch API. Credentials must\"] #[doc =\n    \" be set on both sides (the Access-Control-Allow-Credentials header and in\"] #[doc =\n    \" the XHR or Fetch request) in order for the CORS request with credentials\"] #[doc =\n    \" to succeed.\"] (AccessControlAllowCredentials, ACCESS_CONTROL_ALLOW_CREDENTIALS,\n    b\"access-control-allow-credentials\"); #[doc =\n    \" Preflight response indicating permitted HTTP headers.\"] #[doc = \"\"] #[doc =\n    \" The Access-Control-Allow-Headers response header is used in response to\"] #[doc =\n    \" a preflight request to indicate which HTTP headers will be available via\"] #[doc =\n    \" Access-Control-Expose-Headers when making the actual request.\"] #[doc = \"\"] #[doc =\n    \" The simple headers, Accept, Accept-Language, Content-Language,\"] #[doc =\n    \" Content-Type (but only with a MIME type of its parsed value (ignoring\"] #[doc =\n    \" parameters) of either application/x-www-form-urlencoded,\"] #[doc =\n    \" multipart/form-data, or text/plain), are always available and don't need\"] #[doc =\n    \" to be listed by this header.\"] #[doc = \"\"] #[doc =\n    \" This header is required if the request has an\"] #[doc =\n    \" Access-Control-Request-Headers header.\"] (AccessControlAllowHeaders,\n    ACCESS_CONTROL_ALLOW_HEADERS, b\"access-control-allow-headers\"); #[doc =\n    \" Preflight header response indicating permitted access methods.\"] #[doc = \"\"] #[doc\n    = \" The Access-Control-Allow-Methods response header specifies the method or\"] #[doc\n    = \" methods allowed when accessing the resource in response to a preflight\"] #[doc =\n    \" request.\"] (AccessControlAllowMethods, ACCESS_CONTROL_ALLOW_METHODS,\n    b\"access-control-allow-methods\"); #[doc =\n    \" Indicates whether the response can be shared with resources with the\"] #[doc =\n    \" given origin.\"] (AccessControlAllowOrigin, ACCESS_CONTROL_ALLOW_ORIGIN,\n    b\"access-control-allow-origin\"); #[doc =\n    \" Indicates which headers can be exposed as part of the response by\"] #[doc =\n    \" listing their names.\"] (AccessControlExposeHeaders, ACCESS_CONTROL_EXPOSE_HEADERS,\n    b\"access-control-expose-headers\"); #[doc =\n    \" Indicates how long the results of a preflight request can be cached.\"]\n    (AccessControlMaxAge, ACCESS_CONTROL_MAX_AGE, b\"access-control-max-age\"); #[doc =\n    \" Informs the server which HTTP headers will be used when an actual\"] #[doc =\n    \" request is made.\"] (AccessControlRequestHeaders, ACCESS_CONTROL_REQUEST_HEADERS,\n    b\"access-control-request-headers\"); #[doc =\n    \" Informs the server know which HTTP method will be used when the actual\"] #[doc =\n    \" request is made.\"] (AccessControlRequestMethod, ACCESS_CONTROL_REQUEST_METHOD,\n    b\"access-control-request-method\"); #[doc =\n    \" Indicates the time in seconds the object has been in a proxy cache.\"] #[doc = \"\"]\n    #[doc = \" The Age header is usually close to zero. If it is Age: 0, it was\"] #[doc =\n    \" probably just fetched from the origin server; otherwise It is usually\"] #[doc =\n    \" calculated as a difference between the proxy's current date and the Date\"] #[doc =\n    \" general header included in the HTTP response.\"] (Age, AGE, b\"age\"); #[doc =\n    \" Lists the set of methods support by a resource.\"] #[doc = \"\"] #[doc =\n    \" This header must be sent if the server responds with a 405 Method Not\"] #[doc =\n    \" Allowed status code to indicate which request methods can be used. An\"] #[doc =\n    \" empty Allow header indicates that the resource allows no request\"] #[doc =\n    \" methods, which might occur temporarily for a given resource, for\"] #[doc =\n    \" example.\"] (Allow, ALLOW, b\"allow\"); #[doc =\n    \" Advertises the availability of alternate services to clients.\"] (AltSvc, ALT_SVC,\n    b\"alt-svc\"); #[doc =\n    \" Contains the credentials to authenticate a user agent with a server.\"] #[doc = \"\"]\n    #[doc = \" Usually this header is included after the server has responded with a\"]\n    #[doc = \" 401 Unauthorized status and the WWW-Authenticate header.\"] (Authorization,\n    AUTHORIZATION, b\"authorization\"); #[doc =\n    \" Specifies directives for caching mechanisms in both requests and\"] #[doc =\n    \" responses.\"] #[doc = \"\"] #[doc =\n    \" Caching directives are unidirectional, meaning that a given directive in\"] #[doc =\n    \" a request is not implying that the same directive is to be given in the\"] #[doc =\n    \" response.\"] (CacheControl, CACHE_CONTROL, b\"cache-control\"); #[doc =\n    \" Indicates how caches have handled a response and its corresponding request.\"] #[doc\n    = \"\"] #[doc = \" See [RFC 9211](https://www.rfc-editor.org/rfc/rfc9211.html).\"]\n    (CacheStatus, CACHE_STATUS, b\"cache-status\"); #[doc =\n    \" Specifies directives that allow origin servers to control the behavior of CDN caches\"]\n    #[doc =\n    \" interposed between them and clients separately from other caches that might handle the\"]\n    #[doc = \" response.\"] #[doc = \"\"] #[doc =\n    \" See [RFC 9213](https://www.rfc-editor.org/rfc/rfc9213.html).\"] (CdnCacheControl,\n    CDN_CACHE_CONTROL, b\"cdn-cache-control\"); #[doc =\n    \" Controls whether or not the network connection stays open after the\"] #[doc =\n    \" current transaction finishes.\"] #[doc = \"\"] #[doc =\n    \" If the value sent is keep-alive, the connection is persistent and not\"] #[doc =\n    \" closed, allowing for subsequent requests to the same server to be done.\"] #[doc =\n    \"\"] #[doc = \" Except for the standard hop-by-hop headers (Keep-Alive,\"] #[doc =\n    \" Transfer-Encoding, TE, Connection, Trailer, Upgrade, Proxy-Authorization\"] #[doc =\n    \" and Proxy-Authenticate), any hop-by-hop headers used by the message must\"] #[doc =\n    \" be listed in the Connection header, so that the first proxy knows he has\"] #[doc =\n    \" to consume them and not to forward them further. Standard hop-by-hop\"] #[doc =\n    \" headers can be listed too (it is often the case of Keep-Alive, but this\"] #[doc =\n    \" is not mandatory.\"] (Connection, CONNECTION, b\"connection\"); #[doc =\n    \" Indicates if the content is expected to be displayed inline.\"] #[doc = \"\"] #[doc =\n    \" In a regular HTTP response, the Content-Disposition response header is a\"] #[doc =\n    \" header indicating if the content is expected to be displayed inline in\"] #[doc =\n    \" the browser, that is, as a Web page or as part of a Web page, or as an\"] #[doc =\n    \" attachment, that is downloaded and saved locally.\"] #[doc = \"\"] #[doc =\n    \" In a multipart/form-data body, the HTTP Content-Disposition general\"] #[doc =\n    \" header is a header that can be used on the subpart of a multipart body\"] #[doc =\n    \" to give information about the field it applies to. The subpart is\"] #[doc =\n    \" delimited by the boundary defined in the Content-Type header. Used on\"] #[doc =\n    \" the body itself, Content-Disposition has no effect.\"] #[doc = \"\"] #[doc =\n    \" The Content-Disposition header is defined in the larger context of MIME\"] #[doc =\n    \" messages for e-mail, but only a subset of the possible parameters apply\"] #[doc =\n    \" to HTTP forms and POST requests. Only the value form-data, as well as\"] #[doc =\n    \" the optional directive name and filename, can be used in the HTTP\"] #[doc =\n    \" context.\"] (ContentDisposition, CONTENT_DISPOSITION, b\"content-disposition\"); #[doc\n    = \" Used to compress the media-type.\"] #[doc = \"\"] #[doc =\n    \" When present, its value indicates what additional content encoding has\"] #[doc =\n    \" been applied to the entity-body. It lets the client know, how to decode\"] #[doc =\n    \" in order to obtain the media-type referenced by the Content-Type header.\"] #[doc =\n    \"\"] #[doc =\n    \" It is recommended to compress data as much as possible and therefore to\"] #[doc =\n    \" use this field, but some types of resources, like jpeg images, are\"] #[doc =\n    \" already compressed.  Sometimes using additional compression doesn't\"] #[doc =\n    \" reduce payload size and can even make the payload longer.\"] (ContentEncoding,\n    CONTENT_ENCODING, b\"content-encoding\"); #[doc =\n    \" Used to describe the languages intended for the audience.\"] #[doc = \"\"] #[doc =\n    \" This header allows a user to differentiate according to the users' own\"] #[doc =\n    \" preferred language. For example, if \\\"Content-Language: de-DE\\\" is set, it\"] #[doc\n    = \" says that the document is intended for German language speakers\"] #[doc =\n    \" (however, it doesn't indicate the document is written in German. For\"] #[doc =\n    \" example, it might be written in English as part of a language course for\"] #[doc =\n    \" German speakers).\"] #[doc = \"\"] #[doc =\n    \" If no Content-Language is specified, the default is that the content is\"] #[doc =\n    \" intended for all language audiences. Multiple language tags are also\"] #[doc =\n    \" possible, as well as applying the Content-Language header to various\"] #[doc =\n    \" media types and not only to textual documents.\"] (ContentLanguage,\n    CONTENT_LANGUAGE, b\"content-language\"); #[doc =\n    \" Indicates the size of the entity-body.\"] #[doc = \"\"] #[doc =\n    \" The header value must be a decimal indicating the number of octets sent\"] #[doc =\n    \" to the recipient.\"] (ContentLength, CONTENT_LENGTH, b\"content-length\"); #[doc =\n    \" Indicates an alternate location for the returned data.\"] #[doc = \"\"] #[doc =\n    \" The principal use case is to indicate the URL of the resource\"] #[doc =\n    \" transmitted as the result of content negotiation.\"] #[doc = \"\"] #[doc =\n    \" Location and Content-Location are different: Location indicates the\"] #[doc =\n    \" target of a redirection (or the URL of a newly created document), while\"] #[doc =\n    \" Content-Location indicates the direct URL to use to access the resource,\"] #[doc =\n    \" without the need of further content negotiation. Location is a header\"] #[doc =\n    \" associated with the response, while Content-Location is associated with\"] #[doc =\n    \" the entity returned.\"] (ContentLocation, CONTENT_LOCATION, b\"content-location\");\n    #[doc = \" Indicates where in a full body message a partial message belongs.\"]\n    (ContentRange, CONTENT_RANGE, b\"content-range\"); #[doc =\n    \" Allows controlling resources the user agent is allowed to load for a\"] #[doc =\n    \" given page.\"] #[doc = \"\"] #[doc =\n    \" With a few exceptions, policies mostly involve specifying server origins\"] #[doc =\n    \" and script endpoints. This helps guard against cross-site scripting\"] #[doc =\n    \" attacks (XSS).\"] (ContentSecurityPolicy, CONTENT_SECURITY_POLICY,\n    b\"content-security-policy\"); #[doc =\n    \" Allows experimenting with policies by monitoring their effects.\"] #[doc = \"\"] #[doc\n    = \" The HTTP Content-Security-Policy-Report-Only response header allows web\"] #[doc =\n    \" developers to experiment with policies by monitoring (but not enforcing)\"] #[doc =\n    \" their effects. These violation reports consist of JSON documents sent\"] #[doc =\n    \" via an HTTP POST request to the specified URI.\"] (ContentSecurityPolicyReportOnly,\n    CONTENT_SECURITY_POLICY_REPORT_ONLY, b\"content-security-policy-report-only\"); #[doc =\n    \" Used to indicate the media type of the resource.\"] #[doc = \"\"] #[doc =\n    \" In responses, a Content-Type header tells the client what the content\"] #[doc =\n    \" type of the returned content actually is. Browsers will do MIME sniffing\"] #[doc =\n    \" in some cases and will not necessarily follow the value of this header;\"] #[doc =\n    \" to prevent this behavior, the header X-Content-Type-Options can be set\"] #[doc =\n    \" to nosniff.\"] #[doc = \"\"] #[doc =\n    \" In requests, (such as POST or PUT), the client tells the server what\"] #[doc =\n    \" type of data is actually sent.\"] (ContentType, CONTENT_TYPE, b\"content-type\");\n    #[doc = \" Contains stored HTTP cookies previously sent by the server with the\"] #[doc\n    = \" Set-Cookie header.\"] #[doc = \"\"] #[doc =\n    \" The Cookie header might be omitted entirely, if the privacy setting of\"] #[doc =\n    \" the browser are set to block them, for example.\"] (Cookie, COOKIE, b\"cookie\");\n    #[doc = \" Indicates the client's tracking preference.\"] #[doc = \"\"] #[doc =\n    \" This header lets users indicate whether they would prefer privacy rather\"] #[doc =\n    \" than personalized content.\"] (Dnt, DNT, b\"dnt\"); #[doc =\n    \" Contains the date and time at which the message was originated.\"] (Date, DATE,\n    b\"date\"); #[doc = \" Identifier for a specific version of a resource.\"] #[doc = \"\"]\n    #[doc = \" This header allows caches to be more efficient, and saves bandwidth, as\"]\n    #[doc = \" a web server does not need to send a full response if the content has\"]\n    #[doc = \" not changed. On the other side, if the content has changed, etags are\"]\n    #[doc = \" useful to help prevent simultaneous updates of a resource from\"] #[doc =\n    \" overwriting each other (\\\"mid-air collisions\\\").\"] #[doc = \"\"] #[doc =\n    \" If the resource at a given URL changes, a new Etag value must be\"] #[doc =\n    \" generated. Etags are therefore similar to fingerprints and might also be\"] #[doc =\n    \" used for tracking purposes by some servers. A comparison of them allows\"] #[doc =\n    \" to quickly determine whether two representations of a resource are the\"] #[doc =\n    \" same, but they might also be set to persist indefinitely by a tracking\"] #[doc =\n    \" server.\"] (Etag, ETAG, b\"etag\"); #[doc =\n    \" Indicates expectations that need to be fulfilled by the server in order\"] #[doc =\n    \" to properly handle the request.\"] #[doc = \"\"] #[doc =\n    \" The only expectation defined in the specification is Expect:\"] #[doc =\n    \" 100-continue, to which the server shall respond with:\"] #[doc = \"\"] #[doc =\n    \" * 100 if the information contained in the header is sufficient to cause\"] #[doc =\n    \" an immediate success,\"] #[doc = \"\"] #[doc =\n    \" * 417 (Expectation Failed) if it cannot meet the expectation; or any\"] #[doc =\n    \" other 4xx status otherwise.\"] #[doc = \"\"] #[doc =\n    \" For example, the server may reject a request if its Content-Length is\"] #[doc =\n    \" too large.\"] #[doc = \"\"] #[doc =\n    \" No common browsers send the Expect header, but some other clients such\"] #[doc =\n    \" as cURL do so by default.\"] (Expect, EXPECT, b\"expect\"); #[doc =\n    \" Contains the date/time after which the response is considered stale.\"] #[doc = \"\"]\n    #[doc = \" Invalid dates, like the value 0, represent a date in the past and mean\"]\n    #[doc = \" that the resource is already expired.\"] #[doc = \"\"] #[doc =\n    \" If there is a Cache-Control header with the \\\"max-age\\\" or \\\"s-max-age\\\"\"] #[doc =\n    \" directive in the response, the Expires header is ignored.\"] (Expires, EXPIRES,\n    b\"expires\"); #[doc =\n    \" Contains information from the client-facing side of proxy servers that\"] #[doc =\n    \" is altered or lost when a proxy is involved in the path of the request.\"] #[doc =\n    \"\"] #[doc = \" The alternative and de-facto standard versions of this header are the\"]\n    #[doc = \" X-Forwarded-For, X-Forwarded-Host and X-Forwarded-Proto headers.\"] #[doc =\n    \"\"] #[doc = \" This header is used for debugging, statistics, and generating\"] #[doc =\n    \" location-dependent content and by design it exposes privacy sensitive\"] #[doc =\n    \" information, such as the IP address of the client. Therefore the user's\"] #[doc =\n    \" privacy must be kept in mind when deploying this header.\"] (Forwarded, FORWARDED,\n    b\"forwarded\"); #[doc =\n    \" Contains an Internet email address for a human user who controls the\"] #[doc =\n    \" requesting user agent.\"] #[doc = \"\"] #[doc =\n    \" If you are running a robotic user agent (e.g. a crawler), the From\"] #[doc =\n    \" header should be sent, so you can be contacted if problems occur on\"] #[doc =\n    \" servers, such as if the robot is sending excessive, unwanted, or invalid\"] #[doc =\n    \" requests.\"] (From, FROM, b\"from\"); #[doc =\n    \" Specifies the domain name of the server and (optionally) the TCP port\"] #[doc =\n    \" number on which the server is listening.\"] #[doc = \"\"] #[doc =\n    \" If no port is given, the default port for the service requested (e.g.,\"] #[doc =\n    \" \\\"80\\\" for an HTTP URL) is implied.\"] #[doc = \"\"] #[doc =\n    \" A Host header field must be sent in all HTTP/1.1 request messages. A 400\"] #[doc =\n    \" (Bad Request) status code will be sent to any HTTP/1.1 request message\"] #[doc =\n    \" that lacks a Host header field or contains more than one.\"] (Host, HOST, b\"host\");\n    #[doc = \" Makes a request conditional based on the E-Tag.\"] #[doc = \"\"] #[doc =\n    \" For GET and HEAD methods, the server will send back the requested\"] #[doc =\n    \" resource only if it matches one of the listed ETags. For PUT and other\"] #[doc =\n    \" non-safe methods, it will only upload the resource in this case.\"] #[doc = \"\"]\n    #[doc = \" The comparison with the stored ETag uses the strong comparison\"] #[doc =\n    \" algorithm, meaning two files are considered identical byte to byte only.\"] #[doc =\n    \" This is weakened when the  W/ prefix is used in front of the ETag.\"] #[doc = \"\"]\n    #[doc = \" There are two common use cases:\"] #[doc = \"\"] #[doc =\n    \" * For GET and HEAD methods, used in combination with an Range header, it\"] #[doc =\n    \" can guarantee that the new ranges requested comes from the same resource\"] #[doc =\n    \" than the previous one. If it doesn't match, then a 416 (Range Not\"] #[doc =\n    \" Satisfiable) response is returned.\"] #[doc = \"\"] #[doc =\n    \" * For other methods, and in particular for PUT, If-Match can be used to\"] #[doc =\n    \" prevent the lost update problem. It can check if the modification of a\"] #[doc =\n    \" resource that the user wants to upload will not override another change\"] #[doc =\n    \" that has been done since the original resource was fetched. If the\"] #[doc =\n    \" request cannot be fulfilled, the 412 (Precondition Failed) response is\"] #[doc =\n    \" returned.\"] (IfMatch, IF_MATCH, b\"if-match\"); #[doc =\n    \" Makes a request conditional based on the modification date.\"] #[doc = \"\"] #[doc =\n    \" The If-Modified-Since request HTTP header makes the request conditional:\"] #[doc =\n    \" the server will send back the requested resource, with a 200 status,\"] #[doc =\n    \" only if it has been last modified after the given date. If the request\"] #[doc =\n    \" has not been modified since, the response will be a 304 without any\"] #[doc =\n    \" body; the Last-Modified header will contain the date of last\"] #[doc =\n    \" modification. Unlike If-Unmodified-Since, If-Modified-Since can only be\"] #[doc =\n    \" used with a GET or HEAD.\"] #[doc = \"\"] #[doc =\n    \" When used in combination with If-None-Match, it is ignored, unless the\"] #[doc =\n    \" server doesn't support If-None-Match.\"] #[doc = \"\"] #[doc =\n    \" The most common use case is to update a cached entity that has no\"] #[doc =\n    \" associated ETag.\"] (IfModifiedSince, IF_MODIFIED_SINCE, b\"if-modified-since\");\n    #[doc = \" Makes a request conditional based on the E-Tag.\"] #[doc = \"\"] #[doc =\n    \" The If-None-Match HTTP request header makes the request conditional. For\"] #[doc =\n    \" GET and HEAD methods, the server will send back the requested resource,\"] #[doc =\n    \" with a 200 status, only if it doesn't have an ETag matching the given\"] #[doc =\n    \" ones. For other methods, the request will be processed only if the\"] #[doc =\n    \" eventually existing resource's ETag doesn't match any of the values\"] #[doc =\n    \" listed.\"] #[doc = \"\"] #[doc =\n    \" When the condition fails for GET and HEAD methods, then the server must\"] #[doc =\n    \" return HTTP status code 304 (Not Modified). For methods that apply\"] #[doc =\n    \" server-side changes, the status code 412 (Precondition Failed) is used.\"] #[doc =\n    \" Note that the server generating a 304 response MUST generate any of the\"] #[doc =\n    \" following header fields that would have been sent in a 200 (OK) response\"] #[doc =\n    \" to the same request: Cache-Control, Content-Location, Date, ETag,\"] #[doc =\n    \" Expires, and Vary.\"] #[doc = \"\"] #[doc =\n    \" The comparison with the stored ETag uses the weak comparison algorithm,\"] #[doc =\n    \" meaning two files are considered identical not only if they are\"] #[doc =\n    \" identical byte to byte, but if the content is equivalent. For example,\"] #[doc =\n    \" two pages that would differ only by the date of generation in the footer\"] #[doc =\n    \" would be considered as identical.\"] #[doc = \"\"] #[doc =\n    \" When used in combination with If-Modified-Since, it has precedence (if\"] #[doc =\n    \" the server supports it).\"] #[doc = \"\"] #[doc = \" There are two common use cases:\"]\n    #[doc = \"\"] #[doc =\n    \" * For `GET` and `HEAD` methods, to update a cached entity that has an associated ETag.\"]\n    #[doc =\n    \" * For other methods, and in particular for `PUT`, `If-None-Match` used with\"] #[doc\n    = \" the `*` value can be used to save a file not known to exist,\"] #[doc =\n    \" guaranteeing that another upload didn't happen before, losing the data\"] #[doc =\n    \" of the previous put; this problems is the variation of the lost update\"] #[doc =\n    \" problem.\"] (IfNoneMatch, IF_NONE_MATCH, b\"if-none-match\"); #[doc =\n    \" Makes a request conditional based on range.\"] #[doc = \"\"] #[doc =\n    \" The If-Range HTTP request header makes a range request conditional: if\"] #[doc =\n    \" the condition is fulfilled, the range request will be issued and the\"] #[doc =\n    \" server sends back a 206 Partial Content answer with the appropriate\"] #[doc =\n    \" body. If the condition is not fulfilled, the full resource is sent back,\"] #[doc =\n    \" with a 200 OK status.\"] #[doc = \"\"] #[doc =\n    \" This header can be used either with a Last-Modified validator, or with\"] #[doc =\n    \" an ETag, but not with both.\"] #[doc = \"\"] #[doc =\n    \" The most common use case is to resume a download, to guarantee that the\"] #[doc =\n    \" stored resource has not been modified since the last fragment has been\"] #[doc =\n    \" received.\"] (IfRange, IF_RANGE, b\"if-range\"); #[doc =\n    \" Makes the request conditional based on the last modification date.\"] #[doc = \"\"]\n    #[doc = \" The If-Unmodified-Since request HTTP header makes the request\"] #[doc =\n    \" conditional: the server will send back the requested resource, or accept\"] #[doc =\n    \" it in the case of a POST or another non-safe method, only if it has not\"] #[doc =\n    \" been last modified after the given date. If the request has been\"] #[doc =\n    \" modified after the given date, the response will be a 412 (Precondition\"] #[doc =\n    \" Failed) error.\"] #[doc = \"\"] #[doc = \" There are two common use cases:\"] #[doc =\n    \"\"] #[doc = \" * In conjunction non-safe methods, like POST, it can be used to\"] #[doc\n    = \" implement an optimistic concurrency control, like done by some wikis:\"] #[doc =\n    \" editions are rejected if the stored document has been modified since the\"] #[doc =\n    \" original has been retrieved.\"] #[doc = \"\"] #[doc =\n    \" * In conjunction with a range request with a If-Range header, it can be\"] #[doc =\n    \" used to ensure that the new fragment requested comes from an unmodified\"] #[doc =\n    \" document.\"] (IfUnmodifiedSince, IF_UNMODIFIED_SINCE, b\"if-unmodified-since\"); #[doc\n    = \" The Last-Modified header contains the date and time when the origin believes\"]\n    #[doc = \" the resource was last modified.\"] #[doc = \"\"] #[doc =\n    \" The value is a valid Date/Time string defined in [RFC9910](https://datatracker.ietf.org/doc/html/rfc9110#section-5.6.7)\"]\n    (LastModified, LAST_MODIFIED, b\"last-modified\"); #[doc =\n    \" Allows the server to point an interested client to another resource\"] #[doc =\n    \" containing metadata about the requested resource.\"] (Link, LINK, b\"link\"); #[doc =\n    \" Indicates the URL to redirect a page to.\"] #[doc = \"\"] #[doc =\n    \" The Location response header indicates the URL to redirect a page to. It\"] #[doc =\n    \" only provides a meaning when served with a 3xx status response.\"] #[doc = \"\"] #[doc\n    = \" The HTTP method used to make the new request to fetch the page pointed\"] #[doc =\n    \" to by Location depends of the original method and of the kind of\"] #[doc =\n    \" redirection:\"] #[doc = \"\"] #[doc =\n    \" * If 303 (See Also) responses always lead to the use of a GET method,\"] #[doc =\n    \" 307 (Temporary Redirect) and 308 (Permanent Redirect) don't change the\"] #[doc =\n    \" method used in the original request;\"] #[doc = \"\"] #[doc =\n    \" * 301 (Permanent Redirect) and 302 (Found) doesn't change the method\"] #[doc =\n    \" most of the time, though older user-agents may (so you basically don't\"] #[doc =\n    \" know).\"] #[doc = \"\"] #[doc =\n    \" All responses with one of these status codes send a Location header.\"] #[doc = \"\"]\n    #[doc = \" Beside redirect response, messages with 201 (Created) status also\"] #[doc =\n    \" include the Location header. It indicates the URL to the newly created\"] #[doc =\n    \" resource.\"] #[doc = \"\"] #[doc =\n    \" Location and Content-Location are different: Location indicates the\"] #[doc =\n    \" target of a redirection (or the URL of a newly created resource), while\"] #[doc =\n    \" Content-Location indicates the direct URL to use to access the resource\"] #[doc =\n    \" when content negotiation happened, without the need of further content\"] #[doc =\n    \" negotiation. Location is a header associated with the response, while\"] #[doc =\n    \" Content-Location is associated with the entity returned.\"] (Location, LOCATION,\n    b\"location\"); #[doc =\n    \" Indicates the max number of intermediaries the request should be sent\"] #[doc =\n    \" through.\"] (MaxForwards, MAX_FORWARDS, b\"max-forwards\"); #[doc =\n    \" Indicates where a fetch originates from.\"] #[doc = \"\"] #[doc =\n    \" It doesn't include any path information, but only the server name. It is\"] #[doc =\n    \" sent with CORS requests, as well as with POST requests. It is similar to\"] #[doc =\n    \" the Referer header, but, unlike this header, it doesn't disclose the\"] #[doc =\n    \" whole path.\"] (Origin, ORIGIN, b\"origin\"); #[doc =\n    \" HTTP/1.0 header usually used for backwards compatibility.\"] #[doc = \"\"] #[doc =\n    \" The Pragma HTTP/1.0 general header is an implementation-specific header\"] #[doc =\n    \" that may have various effects along the request-response chain. It is\"] #[doc =\n    \" used for backwards compatibility with HTTP/1.0 caches where the\"] #[doc =\n    \" Cache-Control HTTP/1.1 header is not yet present.\"] (Pragma, PRAGMA, b\"pragma\");\n    #[doc = \" Defines the authentication method that should be used to gain access to\"]\n    #[doc = \" a proxy.\"] #[doc = \"\"] #[doc =\n    \" Unlike `www-authenticate`, the `proxy-authenticate` header field applies\"] #[doc =\n    \" only to the next outbound client on the response chain. This is because\"] #[doc =\n    \" only the client that chose a given proxy is likely to have the\"] #[doc =\n    \" credentials necessary for authentication. However, when multiple proxies\"] #[doc =\n    \" are used within the same administrative domain, such as office and\"] #[doc =\n    \" regional caching proxies within a large corporate network, it is common\"] #[doc =\n    \" for credentials to be generated by the user agent and passed through the\"] #[doc =\n    \" hierarchy until consumed. Hence, in such a configuration, it will appear\"] #[doc =\n    \" as if Proxy-Authenticate is being forwarded because each proxy will send\"] #[doc =\n    \" the same challenge set.\"] #[doc = \"\"] #[doc =\n    \" The `proxy-authenticate` header is sent along with a `407 Proxy\"] #[doc =\n    \" Authentication Required`.\"] (ProxyAuthenticate, PROXY_AUTHENTICATE,\n    b\"proxy-authenticate\"); #[doc =\n    \" Contains the credentials to authenticate a user agent to a proxy server.\"] #[doc =\n    \"\"] #[doc = \" This header is usually included after the server has responded with a\"]\n    #[doc = \" 407 Proxy Authentication Required status and the Proxy-Authenticate\"] #[doc\n    = \" header.\"] (ProxyAuthorization, PROXY_AUTHORIZATION, b\"proxy-authorization\");\n    #[doc = \" Associates a specific cryptographic public key with a certain server.\"]\n    #[doc = \"\"] #[doc =\n    \" This decreases the risk of MITM attacks with forged certificates. If one\"] #[doc =\n    \" or several keys are pinned and none of them are used by the server, the\"] #[doc =\n    \" browser will not accept the response as legitimate, and will not display\"] #[doc =\n    \" it.\"] (PublicKeyPins, PUBLIC_KEY_PINS, b\"public-key-pins\"); #[doc =\n    \" Sends reports of pinning violation to the report-uri specified in the\"] #[doc =\n    \" header.\"] #[doc = \"\"] #[doc =\n    \" Unlike `Public-Key-Pins`, this header still allows browsers to connect\"] #[doc =\n    \" to the server if the pinning is violated.\"] (PublicKeyPinsReportOnly,\n    PUBLIC_KEY_PINS_REPORT_ONLY, b\"public-key-pins-report-only\"); #[doc =\n    \" Indicates the part of a document that the server should return.\"] #[doc = \"\"] #[doc\n    = \" Several parts can be requested with one Range header at once, and the\"] #[doc =\n    \" server may send back these ranges in a multipart document. If the server\"] #[doc =\n    \" sends back ranges, it uses the 206 Partial Content for the response. If\"] #[doc =\n    \" the ranges are invalid, the server returns the 416 Range Not Satisfiable\"] #[doc =\n    \" error. The server can also ignore the Range header and return the whole\"] #[doc =\n    \" document with a 200 status code.\"] (Range, RANGE, b\"range\"); #[doc =\n    \" Contains the address of the previous web page from which a link to the\"] #[doc =\n    \" currently requested page was followed.\"] #[doc = \"\"] #[doc =\n    \" The Referer header allows servers to identify where people are visiting\"] #[doc =\n    \" them from and may use that data for analytics, logging, or optimized\"] #[doc =\n    \" caching, for example.\"] (Referer, REFERER, b\"referer\"); #[doc =\n    \" Governs which referrer information should be included with requests\"] #[doc =\n    \" made.\"] (ReferrerPolicy, REFERRER_POLICY, b\"referrer-policy\"); #[doc =\n    \" Informs the web browser that the current page or frame should be\"] #[doc =\n    \" refreshed.\"] (Refresh, REFRESH, b\"refresh\"); #[doc =\n    \" The Retry-After response HTTP header indicates how long the user agent\"] #[doc =\n    \" should wait before making a follow-up request. There are two main cases\"] #[doc =\n    \" this header is used:\"] #[doc = \"\"] #[doc =\n    \" * When sent with a 503 (Service Unavailable) response, it indicates how\"] #[doc =\n    \" long the service is expected to be unavailable.\"] #[doc = \"\"] #[doc =\n    \" * When sent with a redirect response, such as 301 (Moved Permanently),\"] #[doc =\n    \" it indicates the minimum time that the user agent is asked to wait\"] #[doc =\n    \" before issuing the redirected request.\"] (RetryAfter, RETRY_AFTER, b\"retry-after\");\n    #[doc = \" The |Sec-WebSocket-Accept| header field is used in the WebSocket\"] #[doc =\n    \" opening handshake. It is sent from the server to the client to\"] #[doc =\n    \" confirm that the server is willing to initiate the WebSocket\"] #[doc =\n    \" connection.\"] (SecWebSocketAccept, SEC_WEBSOCKET_ACCEPT, b\"sec-websocket-accept\");\n    #[doc = \" The |Sec-WebSocket-Extensions| header field is used in the WebSocket\"]\n    #[doc = \" opening handshake. It is initially sent from the client to the\"] #[doc =\n    \" server, and then subsequently sent from the server to the client, to\"] #[doc =\n    \" agree on a set of protocol-level extensions to use for the duration\"] #[doc =\n    \" of the connection.\"] (SecWebSocketExtensions, SEC_WEBSOCKET_EXTENSIONS,\n    b\"sec-websocket-extensions\"); #[doc =\n    \" The |Sec-WebSocket-Key| header field is used in the WebSocket opening\"] #[doc =\n    \" handshake. It is sent from the client to the server to provide part\"] #[doc =\n    \" of the information used by the server to prove that it received a\"] #[doc =\n    \" valid WebSocket opening handshake. This helps ensure that the server\"] #[doc =\n    \" does not accept connections from non-WebSocket clients (e.g., HTTP\"] #[doc =\n    \" clients) that are being abused to send data to unsuspecting WebSocket\"] #[doc =\n    \" servers.\"] (SecWebSocketKey, SEC_WEBSOCKET_KEY, b\"sec-websocket-key\"); #[doc =\n    \" The |Sec-WebSocket-Protocol| header field is used in the WebSocket\"] #[doc =\n    \" opening handshake. It is sent from the client to the server and back\"] #[doc =\n    \" from the server to the client to confirm the subprotocol of the\"] #[doc =\n    \" connection.  This enables scripts to both select a subprotocol and be\"] #[doc =\n    \" sure that the server agreed to serve that subprotocol.\"] (SecWebSocketProtocol,\n    SEC_WEBSOCKET_PROTOCOL, b\"sec-websocket-protocol\"); #[doc =\n    \" The |Sec-WebSocket-Version| header field is used in the WebSocket\"] #[doc =\n    \" opening handshake.  It is sent from the client to the server to\"] #[doc =\n    \" indicate the protocol version of the connection.  This enables\"] #[doc =\n    \" servers to correctly interpret the opening handshake and subsequent\"] #[doc =\n    \" data being sent from the data, and close the connection if the server\"] #[doc =\n    \" cannot interpret that data in a safe manner.\"] (SecWebSocketVersion,\n    SEC_WEBSOCKET_VERSION, b\"sec-websocket-version\"); #[doc =\n    \" Contains information about the software used by the origin server to\"] #[doc =\n    \" handle the request.\"] #[doc = \"\"] #[doc =\n    \" Overly long and detailed Server values should be avoided as they\"] #[doc =\n    \" potentially reveal internal implementation details that might make it\"] #[doc =\n    \" (slightly) easier for attackers to find and exploit known security\"] #[doc =\n    \" holes.\"] (Server, SERVER, b\"server\"); #[doc =\n    \" Used to send cookies from the server to the user agent.\"] (SetCookie, SET_COOKIE,\n    b\"set-cookie\"); #[doc =\n    \" Tells the client to communicate with HTTPS instead of using HTTP.\"]\n    (StrictTransportSecurity, STRICT_TRANSPORT_SECURITY, b\"strict-transport-security\");\n    #[doc = \" Informs the server of transfer encodings willing to be accepted as part\"]\n    #[doc = \" of the response.\"] #[doc = \"\"] #[doc =\n    \" See also the Transfer-Encoding response header for more details on\"] #[doc =\n    \" transfer encodings. Note that chunked is always acceptable for HTTP/1.1\"] #[doc =\n    \" recipients and you that don't have to specify \\\"chunked\\\" using the TE\"] #[doc =\n    \" header. However, it is useful for setting if the client is accepting\"] #[doc =\n    \" trailer fields in a chunked transfer coding using the \\\"trailers\\\" value.\"] (Te,\n    TE, b\"te\"); #[doc =\n    \" Allows the sender to include additional fields at the end of chunked\"] #[doc =\n    \" messages.\"] (Trailer, TRAILER, b\"trailer\"); #[doc =\n    \" Specifies the form of encoding used to safely transfer the entity to the\"] #[doc =\n    \" client.\"] #[doc = \"\"] #[doc =\n    \" `transfer-encoding` is a hop-by-hop header, that is applying to a\"] #[doc =\n    \" message between two nodes, not to a resource itself. Each segment of a\"] #[doc =\n    \" multi-node connection can use different `transfer-encoding` values. If\"] #[doc =\n    \" you want to compress data over the whole connection, use the end-to-end\"] #[doc =\n    \" header `content-encoding` header instead.\"] #[doc = \"\"] #[doc =\n    \" When present on a response to a `HEAD` request that has no body, it\"] #[doc =\n    \" indicates the value that would have applied to the corresponding `GET`\"] #[doc =\n    \" message.\"] (TransferEncoding, TRANSFER_ENCODING, b\"transfer-encoding\"); #[doc =\n    \" Contains a string that allows identifying the requesting client's\"] #[doc =\n    \" software.\"] (UserAgent, USER_AGENT, b\"user-agent\"); #[doc =\n    \" Used as part of the exchange to upgrade the protocol.\"] (Upgrade, UPGRADE,\n    b\"upgrade\"); #[doc =\n    \" Sends a signal to the server expressing the clientâ€™s preference for an\"] #[doc =\n    \" encrypted and authenticated response.\"] (UpgradeInsecureRequests,\n    UPGRADE_INSECURE_REQUESTS, b\"upgrade-insecure-requests\"); #[doc =\n    \" Determines how to match future requests with cached responses.\"] #[doc = \"\"] #[doc\n    = \" The `vary` HTTP response header determines how to match future request\"] #[doc =\n    \" headers to decide whether a cached response can be used rather than\"] #[doc =\n    \" requesting a fresh one from the origin server. It is used by the server\"] #[doc =\n    \" to indicate which headers it used when selecting a representation of a\"] #[doc =\n    \" resource in a content negotiation algorithm.\"] #[doc = \"\"] #[doc =\n    \" The `vary` header should be set on a 304 Not Modified response exactly\"] #[doc =\n    \" like it would have been set on an equivalent 200 OK response.\"] (Vary, VARY,\n    b\"vary\"); #[doc = \" Added by proxies to track routing.\"] #[doc = \"\"] #[doc =\n    \" The `via` general header is added by proxies, both forward and reverse\"] #[doc =\n    \" proxies, and can appear in the request headers and the response headers.\"] #[doc =\n    \" It is used for tracking message forwards, avoiding request loops, and\"] #[doc =\n    \" identifying the protocol capabilities of senders along the\"] #[doc =\n    \" request/response chain.\"] (Via, VIA, b\"via\"); #[doc =\n    \" General HTTP header contains information about possible problems with\"] #[doc =\n    \" the status of the message.\"] #[doc = \"\"] #[doc =\n    \" More than one `warning` header may appear in a response. Warning header\"] #[doc =\n    \" fields can in general be applied to any message, however some warn-codes\"] #[doc =\n    \" are specific to caches and can only be applied to response messages.\"] (Warning,\n    WARNING, b\"warning\"); #[doc =\n    \" Defines the authentication method that should be used to gain access to\"] #[doc =\n    \" a resource.\"] (WwwAuthenticate, WWW_AUTHENTICATE, b\"www-authenticate\"); #[doc =\n    \" Marker used by the server to indicate that the MIME types advertised in\"] #[doc =\n    \" the `content-type` headers should not be changed and be followed.\"] #[doc = \"\"]\n    #[doc = \" This allows to opt-out of MIME type sniffing, or, in other words, it is\"]\n    #[doc = \" a way to say that the webmasters knew what they were doing.\"] #[doc = \"\"]\n    #[doc = \" This header was introduced by Microsoft in IE 8 as a way for webmasters\"]\n    #[doc = \" to block content sniffing that was happening and could transform\"] #[doc =\n    \" non-executable MIME types into executable MIME types. Since then, other\"] #[doc =\n    \" browsers have introduced it, even if their MIME sniffing algorithms were\"] #[doc =\n    \" less aggressive.\"] #[doc = \"\"] #[doc =\n    \" Site security testers usually expect this header to be set.\"] (XContentTypeOptions,\n    X_CONTENT_TYPE_OPTIONS, b\"x-content-type-options\"); #[doc =\n    \" Controls DNS prefetching.\"] #[doc = \"\"] #[doc =\n    \" The `x-dns-prefetch-control` HTTP response header controls DNS\"] #[doc =\n    \" prefetching, a feature by which browsers proactively perform domain name\"] #[doc =\n    \" resolution on both links that the user may choose to follow as well as\"] #[doc =\n    \" URLs for items referenced by the document, including images, CSS,\"] #[doc =\n    \" JavaScript, and so forth.\"] #[doc = \"\"] #[doc =\n    \" This prefetching is performed in the background, so that the DNS is\"] #[doc =\n    \" likely to have been resolved by the time the referenced items are\"] #[doc =\n    \" needed. This reduces latency when the user clicks a link.\"] (XDnsPrefetchControl,\n    X_DNS_PREFETCH_CONTROL, b\"x-dns-prefetch-control\"); #[doc =\n    \" Indicates whether or not a browser should be allowed to render a page in\"] #[doc =\n    \" a frame.\"] #[doc = \"\"] #[doc =\n    \" Sites can use this to avoid clickjacking attacks, by ensuring that their\"] #[doc =\n    \" content is not embedded into other sites.\"] #[doc = \"\"] #[doc =\n    \" The added security is only provided if the user accessing the document\"] #[doc =\n    \" is using a browser supporting `x-frame-options`.\"] (XFrameOptions, X_FRAME_OPTIONS,\n    b\"x-frame-options\"); #[doc =\n    \" Stop pages from loading when an XSS attack is detected.\"] #[doc = \"\"] #[doc =\n    \" The HTTP X-XSS-Protection response header is a feature of Internet\"] #[doc =\n    \" Explorer, Chrome and Safari that stops pages from loading when they\"] #[doc =\n    \" detect reflected cross-site scripting (XSS) attacks. Although these\"] #[doc =\n    \" protections are largely unnecessary in modern browsers when sites\"] #[doc =\n    \" implement a strong Content-Security-Policy that disables the use of\"] #[doc =\n    \" inline JavaScript ('unsafe-inline'), they can still provide protections\"] #[doc =\n    \" for users of older web browsers that don't yet support CSP.\"] (XXssProtection,\n    X_XSS_PROTECTION, b\"x-xss-protection\");\n}\n#[derive(Clone, Eq, PartialEq, Hash)]\npub struct HeaderName {\n    inner: Repr<Custom>,\n}\n#[derive(Debug, Clone, Eq, PartialEq)]\nstruct Custom(ByteStr);\n#[derive(Debug, Clone, Eq, PartialEq, Hash)]\nenum Repr<T> {\n    Standard(StandardHeader),\n    Custom(T),\n}\nimpl fmt::Display for HeaderName {\n    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self.as_str(), fmt)\n    }\n}\nimpl HeaderName {\n    pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {}\n    pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {}\n    #[allow(unconditional_panic)]\n    pub const fn from_static(src: &'static str) -> HeaderName {}\n    #[inline]\n    pub fn as_str(&self) -> &str {\n        match self.inner {\n            Repr::Standard(v) => v.as_str(),\n            Repr::Custom(ref v) => &v.0,\n        }\n    }\n    pub(super) fn into_bytes(self) -> Bytes {}\n}\n\nThe function to be tested is presented as follows:\nfn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n    fmt::Display::fmt(self.as_str(), fmt)\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}