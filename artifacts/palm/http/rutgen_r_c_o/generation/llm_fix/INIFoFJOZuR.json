{
  "name": "http::method::method::Method::from_bytes",
  "name_with_impl": "http::method::{impl#0}::from_bytes",
  "mod_info": {
    "name": "method",
    "loc": "src/lib.rs:173:1:173:16"
  },
  "visible": true,
  "loc": "src/method.rs:98:5:135:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src.len() matches 0 is true\n",
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src.len() matches _ is true\n",
        "// constraint: src.len() <= InlineExtension::MAX is true, with bound src.len() == InlineExtension::MAX\n"
      ],
      "input_infer": "0, 3, 4, 5, 6, 7, InlineExtension::MAX, InlineExtension::MAX + 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"\");",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = from_bytes(b\"\");",
                  "    assert_eq!(result.err().unwrap(), InvalidMethod::new());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"\");",
                  "    let result = from_bytes(b\"\");",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"\");",
                  "   let result = Method::from_bytes(b\"\");",
                  "   assert_eq!(result.err().unwrap(), InvalidMethod::new());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `method::InvalidMethod`\n   --> src/method.rs:513:4\n    |\n513 |    assert_eq!(result.err().unwrap(), InvalidMethod::new());\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    method::InvalidMethod\n    |    method::InvalidMethod\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"GET\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   use crate::method::from_bytes; // Import the correct function",
                  "   let result = from_bytes(b\"GET\");",
                  "   assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"GET\");",
                  "    let result = from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0432]: unresolved import `crate::method::from_bytes`\n   --> src/method.rs:511:8\n    |\n511 |    use crate::method::from_bytes; // Import the correct function\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^ no `from_bytes` in `method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0432`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"GET\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"GET\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"POST\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"POST\");",
                  "    let result = from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"POST\");",
                  "    let result = from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"POST\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"POST\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"POST\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"POST\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"HEAD\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"HEAD\");",
                  "    let result = from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"HEAD\");",
                  "    let result = from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"HEAD\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"HEAD\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"HEAD\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"HEAD\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"PATCH\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"PATCH\");",
                  "    let result = from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"PATCH\");",
                  "    let result = from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"PATCH\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"PATCH\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"PATCH\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"PATCH\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"TRACE\");",
                "}"
              ],
              "oracles": [
                [
                  "    let src = b\"TRACE\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::TRACE));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::DELETE));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::GET));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::POST));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::HEAD));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::OPTIONS));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::CONNECT));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::PUT));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::PATCH));"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    let src = b\"INVALID\";",
                  "    assert!(from_bytes(src).is_err());"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    let src = b\"INVALID\";",
                  "    let src = b\"\";",
                  "    assert!(from_bytes(src).is_err());"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    let src = b\"INVALID\";",
                  "    let src = b\"\";",
                  "    let src = b\"AB\";",
                  "    assert!(from_bytes(src).is_err());"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    let src = b\"INVALID\";",
                  "    let src = b\"\";",
                  "    let src = b\"AB\";",
                  "    let src = &[b'A'; InlineExtension::MAX + 1];",
                  "    assert!(from_bytes(src).is_err());"
                ],
                [
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    let src = b\"INVALID\";",
                  "    let src = b\"\";",
                  "    let src = b\"AB\";",
                  "    let src = &[b'A'; InlineExtension::MAX + 1];",
                  "    let src = &[b'A'; InlineExtension::MAX];",
                  "    assert!(matches!(from_bytes(src), Ok(Method::ExtensionInline(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"TRACE\");  ",
                  "   let src = b\"TRACE\";  ",
                  "   assert_eq!(Method::from_bytes(src), Ok(Method::TRACE));  ",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"TRACE\");",
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::DELETE));",
                  "}"
                ],
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"TRACE\");",
                  "   let src = b\"TRACE\";",
                  "   let src = b\"DELETE\";",
                  "   let src = b\"GET\";",
                  "   assert_eq!(Method::from_bytes(src), Ok(Method::GET));",
                  "}"
                ],
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"TRACE\");",
                  "   let src = b\"TRACE\";",
                  "   let src = b\"DELETE\";",
                  "   let src = b\"GET\";",
                  "   let src = b\"POST\";",
                  "   assert_eq!(Method::from_bytes(src), Ok(Method::POST));",
                  "}"
                ],
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"TRACE\");",
                  "   let src = b\"TRACE\";",
                  "   let src = b\"DELETE\";",
                  "   let src = b\"GET\";",
                  "   let src = b\"POST\";",
                  "   let src = b\"HEAD\";",
                  "   assert_eq!(Method::from_bytes(src), Ok(Method::HEAD));",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"TRACE\");",
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::OPTIONS));",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"TRACE\");",
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    assert_eq!(from_bytes(src), Ok(Method::CONNECT));",
                  "}"
                ],
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"TRACE\");",
                  "   let src = b\"TRACE\";",
                  "   let src = b\"DELETE\";",
                  "   let src = b\"GET\";",
                  "   let src = b\"POST\";",
                  "   let src = b\"HEAD\";",
                  "   let src = b\"OPTIONS\";",
                  "   let src = b\"CONNECT\";",
                  "   let src = b\"PUT\";",
                  "   assert_eq!(Method::from_bytes(src), Ok(Method::PUT));",
                  "}"
                ],
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"TRACE\");",
                  "   let src = b\"TRACE\";",
                  "   let src = b\"DELETE\";",
                  "   let src = b\"GET\";",
                  "   let src = b\"POST\";",
                  "   let src = b\"HEAD\";",
                  "   let src = b\"OPTIONS\";",
                  "   let src = b\"CONNECT\";",
                  "   let src = b\"PUT\";",
                  "   let src = b\"PATCH\";",
                  "   assert_eq!(Method::from_bytes(src), Ok(Method::PATCH));",
                  "}"
                ],
                [
                  "{",
                  "   let methods = [",
                  "       b\"TRACE\",",
                  "       b\"DELETE\",",
                  "       b\"GET\",",
                  "       b\"POST\",",
                  "       b\"HEAD\",",
                  "       b\"OPTIONS\",",
                  "       b\"CONNECT\",",
                  "       b\"PUT\",",
                  "       b\"PATCH\",",
                  "       b\"INVALID\",",
                  "   ];",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"TRACE\");",
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    let src = b\"INVALID\";",
                  "    let src = b\"\";",
                  "    assert!(from_bytes(src).is_err());",
                  "}"
                ],
                [
                  "{",
                  "   let srcs = [  ",
                  "       b\"TRACE\",  ",
                  "       b\"DELETE\",  ",
                  "       b\"GET\",  ",
                  "       b\"POST\",  ",
                  "       b\"HEAD\",  ",
                  "       b\"OPTIONS\",  ",
                  "       b\"CONNECT\",  ",
                  "       b\"PUT\",  ",
                  "       b\"PATCH\",  ",
                  "       b\"INVALID\",  ",
                  "       b\"\",  ",
                  "       b\"AB\",  ",
                  "   ];  ",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"TRACE\");",
                  "    let src = b\"TRACE\";",
                  "    let src = b\"DELETE\";",
                  "    let src = b\"GET\";",
                  "    let src = b\"POST\";",
                  "    let src = b\"HEAD\";",
                  "    let src = b\"OPTIONS\";",
                  "    let src = b\"CONNECT\";",
                  "    let src = b\"PUT\";",
                  "    let src = b\"PATCH\";",
                  "    let src = b\"INVALID\";",
                  "    let src = b\"\";",
                  "    let src = b\"AB\";",
                  "    let src = &[b'A'; InlineExtension::MAX + 1];",
                  "    assert!(from_bytes(src).is_err());",
                  "}"
                ],
                [
                  "{",
                  "   let _ = Method::from_bytes(b\"TRACE\");",
                  "   let src = b\"TRACE\";",
                  "   let src = b\"DELETE\";",
                  "   let src = b\"GET\";",
                  "   let src = b\"POST\";",
                  "   let src = b\"HEAD\";",
                  "   let src = b\"OPTIONS\";",
                  "   let src = b\"CONNECT\";",
                  "   let src = b\"PUT\";",
                  "   let src = b\"PATCH\";",
                  "   let src = b\"INVALID\";",
                  "   let src = b\"\";",
                  "   let src = b\"AB\";",
                  "   let src = &[b'A'; InlineExtension::MAX + 1];",
                  "   let src = &[b'A'; InlineExtension::MAX];",
                  "   assert!(matches!(Method::from_bytes(src), Ok(Method::ExtensionInline(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:513:4\n    |\n513 |    assert_eq!(Method::from_bytes(src), Ok(Method::TRACE));  \n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"TRACE\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:514:16\n    |\n514 |     assert_eq!(from_bytes(src), Ok(Method::DELETE));\n    |                ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:4\n    |\n515 |    assert_eq!(Method::from_bytes(src), Ok(Method::GET));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:516:4\n    |\n516 |    assert_eq!(Method::from_bytes(src), Ok(Method::POST));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:517:4\n    |\n517 |    assert_eq!(Method::from_bytes(src), Ok(Method::HEAD));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"TRACE\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:518:16\n    |\n518 |     assert_eq!(from_bytes(src), Ok(Method::OPTIONS));\n    |                ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"TRACE\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:519:16\n    |\n519 |     assert_eq!(from_bytes(src), Ok(Method::CONNECT));\n    |                ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:520:4\n    |\n520 |    assert_eq!(Method::from_bytes(src), Ok(Method::PUT));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:521:4\n    |\n521 |    assert_eq!(Method::from_bytes(src), Ok(Method::PATCH));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:513:8\n    |\n513 |        b\"DELETE\",\n    |        ^^^^^^^^^ expected an array with a fixed size of 5 elements, found one with 6 elements\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"TRACE\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:523:13\n    |\n523 |     assert!(from_bytes(src).is_err());\n    |             ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:513:8\n    |\n513 |        b\"DELETE\",  \n    |        ^^^^^^^^^ expected an array with a fixed size of 5 elements, found one with 6 elements\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"TRACE\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:525:13\n    |\n525 |     assert!(from_bytes(src).is_err());\n    |             ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionInline` found for struct `method::Method` in the current scope\n   --> src/method.rs:526:57\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionInline` not found for this struct\n...\n526 |    assert!(matches!(Method::from_bytes(src), Ok(Method::ExtensionInline(_))));\n    |                                                         ^^^^^^^^^^^^^^^ associated item not found in `Method`\n    |\nhelp: there is an associated function `extension_inline` with a similar name\n   --> src/method.rs:137:5\n    |\n137 |     fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"DELETE\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"DELETE\");",
                  "    let result = from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"DELETE\");",
                  "    let result = from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"DELETE\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"DELETE\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"DELETE\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"DELETE\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"OPTIONS\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"OPTIONS\");",
                  "    let result = from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"OPTIONS\");",
                  "    let result = from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"OPTIONS\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"OPTIONS\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"OPTIONS\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"OPTIONS\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"CONNECT\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"CONNECT\");",
                  "    let result = from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"CONNECT\");",
                  "    let result = from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"CONNECT\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"CONNECT\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"CONNECT\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"CONNECT\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let _ = from_bytes(b\"INVALID\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = from_bytes(b\"INVALID\");",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = from_bytes(b\"INVALID\");",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let _ = from_bytes(b\"INVALID\");",
                  "    let result = from_bytes(b\"INVALID\");",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let _ = from_bytes(b\"INVALID\");",
                  "    let result = from_bytes(b\"INVALID\");",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"INVALID\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"INVALID\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:511:13\n    |\n511 |     let _ = from_bytes(b\"INVALID\");\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:18\n    |\n512 |     let result = from_bytes(b\"INVALID\");\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let inline_data = vec![b'A'; InlineExtension::MAX];",
                "    let _ = from_bytes(&inline_data);",
                "}"
              ],
              "oracles": [
                [
                  "    let inline_data = vec![b'A'; InlineExtension::MAX];",
                  "    assert_eq!(from_bytes(&inline_data).is_ok(), true);"
                ],
                [
                  "    let inline_data = vec![b'A'; InlineExtension::MAX];",
                  "    assert!(matches!(from_bytes(&inline_data), Ok(Method::ExtensionInline(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let inline_data = vec![b'A'; InlineExtension::MAX];",
                  "    let _ = from_bytes(&inline_data);",
                  "    let inline_data = vec![b'A'; InlineExtension::MAX];",
                  "    assert_eq!(from_bytes(&inline_data).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let inline_data = vec![b'A'; InlineExtension::MAX];",
                  "    let _ = from_bytes(&inline_data);",
                  "    let inline_data = vec![b'A'; InlineExtension::MAX];",
                  "   assert!(matches!(from_bytes(&inline_data), Ok(Method(ExtensionInline(_)))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:13\n    |\n512 |     let _ = from_bytes(&inline_data);\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:514:16\n    |\n514 |     assert_eq!(from_bytes(&inline_data).is_ok(), true);\n    |                ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:13\n    |\n512 |     let _ = from_bytes(&inline_data);\n    |             ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:514:21\n    |\n514 |    assert!(matches!(from_bytes(&inline_data), Ok(Method(ExtensionInline(_)))));\n    |                     ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                "    let _ = from_bytes(&long_data);",
                "}"
              ],
              "oracles": [
                [
                  "    let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = from_bytes(&long_data);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = from_bytes(&long_data);",
                  "    assert!(matches!(result.unwrap(), Method::ExtensionAllocated(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "   let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                  "   let _ = Method::from_bytes(&long_data);",
                  "   let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = from_bytes(&long_data);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "   let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                  "   let _ = from_bytes(&long_data);",
                  "   let long_data = vec![b'A'; InlineExtension::MAX + 1];",
                  "   let result = from_bytes(&long_data);",
                  "   assert!(matches!(result.unwrap(), Method(ExtensionAllocated(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:515:18\n    |\n515 |     let result = from_bytes(&long_data);\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:12\n    |\n512 |    let _ = from_bytes(&long_data);\n    |            ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:514:17\n    |\n514 |    let result = from_bytes(&long_data);\n    |                 ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src.len() matches 0 is true\n",
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src.len() matches _ is true\n",
        "// constraint: src.len() <= InlineExtension::MAX is false\n",
        "// constraint: AllocatedExtension::new(src)? is Err/None\n"
      ],
      "input_infer": "0, 3, 4, 5, 6, 7, >InlineExtension::MAX, AllocatedExtension::new(src) != Ok\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"\";",
                  "    assert!(_is_err(Method::from_bytes(input)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::GET)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::PUT)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::POST)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::HEAD)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::PATCH)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::TRACE)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::DELETE)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::OPTIONS)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::CONNECT)));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    assert!(Method::from_bytes(input).is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let input: &[u8] = b\"TOOLONG\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    assert!(_is_err(Method::from_bytes(input)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::GET)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "   assert_eq!(Method::from_bytes(input), Ok(Method(Method::PUT.0)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "   assert_eq!(Method::from_bytes(input), Ok(Method::POST));  ",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::HEAD)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::PATCH)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::TRACE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::DELETE));  ",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::OPTIONS)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::CONNECT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    assert!(Method::from_bytes(input).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let input: &[u8] = b\"TOOLONG\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `_is_err` in this scope\n   --> src/method.rs:514:13\n    |\n514 |     assert!(_is_err(Method::from_bytes(input)));\n    |             ^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:515:53\n    |\n515 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::GET)));\n    |                                              ------ ^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                                              |\n    |                                              arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::GET)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:516:4\n    |\n516 |    assert_eq!(Method::from_bytes(input), Ok(Method(Method::PUT.0)));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:517:4\n    |\n517 |    assert_eq!(Method::from_bytes(input), Ok(Method::POST));  \n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:518:53\n    |\n518 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::HEAD)));\n    |                                              ------ ^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                                              |\n    |                                              arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:518:5\n    |\n518 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::HEAD)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:519:53\n    |\n519 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::PATCH)));\n    |                                              ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                                              |\n    |                                              arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:519:5\n    |\n519 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::PATCH)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:520:53\n    |\n520 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::TRACE)));\n    |                                              ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                                              |\n    |                                              arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:520:5\n    |\n520 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::TRACE)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:521:59\n    |\n521 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::DELETE));  \n    |                                                    ------ ^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                                                    |\n    |                                                    arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:522:53\n    |\n522 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::OPTIONS)));\n    |                                              ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                                              |\n    |                                              arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:522:5\n    |\n522 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::OPTIONS)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:523:53\n    |\n523 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::CONNECT)));\n    |                                              ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                                              |\n    |                                              arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:523:5\n    |\n523 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::CONNECT)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"GET\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Get)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Put)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Post)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Head)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Patch)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Trace)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Delete)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Options)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Connect)));"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"ABCDEF\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"ABCDEF\";",
                  "    let input: &[u8] = b\"LONGINVALIDMETHODNAME\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method::GET));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Put)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "   assert_eq!(Method::from_bytes(input), Ok(Method::POST));",
                  "}"
                ],
                [
                  "{",
                  "   let input: &[u8] = b\"GET\";",
                  "   let _ = Method::from_bytes(input);",
                  "   let input: &[u8] = b\"GET\";",
                  "   let input: &[u8] = b\"PUT\";",
                  "   let input: &[u8] = b\"POST\";",
                  "   let input: &[u8] = b\"HEAD\";",
                  "   assert_eq!(Method::from_bytes(input), Ok(Method(Inner::Head)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Patch)));",
                  "}"
                ],
                [
                  "{",
                  "   let input: &[u8] = b\"GET\";",
                  "   let _ = Method::from_bytes(input);",
                  "   let input: &[u8] = b\"GET\";",
                  "   let input: &[u8] = b\"PUT\";",
                  "   let input: &[u8] = b\"POST\";",
                  "   let input: &[u8] = b\"HEAD\";",
                  "   let input: &[u8] = b\"PATCH\";",
                  "   let input: &[u8] = b\"TRACE\";",
                  "   assert_eq!(Method::from_bytes(input), Ok(Method(Inner::Trace)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Delete)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Options)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input), Ok(Method(Method::Connect)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"ABCDEF\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"ABCDEF\";",
                  "    let input: &[u8] = b\"LONGINVALIDMETHODNAME\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:514:5\n    |\n514 |     assert_eq!(Method::from_bytes(input), Ok(Method::GET));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Put` found for struct `method::Method` in the current scope\n   --> src/method.rs:515:61\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Put` not found for this struct\n...\n515 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Put)));\n    |                                                             ^^^ associated item not found in `Method`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Put)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:516:4\n    |\n516 |    assert_eq!(Method::from_bytes(input), Ok(Method::POST));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:517:4\n    |\n517 |    assert_eq!(Method::from_bytes(input), Ok(Method(Inner::Head)));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Patch` found for struct `method::Method` in the current scope\n   --> src/method.rs:518:61\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Patch` not found for this struct\n...\n518 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Patch)));\n    |                                                             ^^^^^ associated item not found in `Method`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:518:5\n    |\n518 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Patch)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:519:4\n    |\n519 |    assert_eq!(Method::from_bytes(input), Ok(Method(Inner::Trace)));\n    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |    |\n    |    std::result::Result<method::Method, InvalidMethod>\n    |    std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Delete` found for struct `method::Method` in the current scope\n   --> src/method.rs:520:61\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Delete` not found for this struct\n...\n520 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Delete)));\n    |                                                             ^^^^^^ associated item not found in `Method`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:520:5\n    |\n520 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Delete)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Options` found for struct `method::Method` in the current scope\n   --> src/method.rs:521:61\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Options` not found for this struct\n...\n521 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Options)));\n    |                                                             ^^^^^^^ associated item not found in `Method`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:521:5\n    |\n521 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Options)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Connect` found for struct `method::Method` in the current scope\n   --> src/method.rs:522:61\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Connect` not found for this struct\n...\n522 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Connect)));\n    |                                                             ^^^^^^^ associated item not found in `Method`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:522:5\n    |\n522 |     assert_eq!(Method::from_bytes(input), Ok(Method(Method::Connect)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"POST\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"HEAD\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::HEAD);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::HEAD);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"PATCH\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHODNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"TRACE\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(_method, Method::TRACE);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::PATCH);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::POST);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::HEAD);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::GET);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::PUT);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::DELETE);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::OPTIONS);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::CONNECT);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, false);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert!(matches!(_method, Method::ExtensionInline(_)));"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHOD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHOD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert!(matches!(_method, Method::ExtensionAllocated(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(_method, Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_method, Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, false);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert!(matches!(_method, Method::ExtensionInline(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHOD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert_eq!(_is_ok, true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"UNKNOWN\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGMETHOD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    assert!(matches!(_method, Method::ExtensionAllocated(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:514:16\n    |\n514 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:514:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n514 |     assert_eq!(_method, Method::TRACE);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:516:16\n    |\n516 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:516:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n516 |     assert_eq!(_method, Method::PATCH);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:518:16\n    |\n518 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:518:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n518 |     assert_eq!(_method, Method::POST);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:520:16\n    |\n520 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:520:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n520 |     assert_eq!(_method, Method::HEAD);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:522:16\n    |\n522 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:522:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n522 |     assert_eq!(_method, Method::GET);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:524:16\n    |\n524 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:524:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n524 |     assert_eq!(_method, Method::PUT);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:526:16\n    |\n526 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:526:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n526 |     assert_eq!(_method, Method::DELETE);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:528:16\n    |\n528 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:528:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n528 |     assert_eq!(_method, Method::OPTIONS);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:530:16\n    |\n530 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:530:16\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n530 |     assert_eq!(_method, Method::CONNECT);\n    |                ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:532:16\n    |\n532 |     assert_eq!(_is_ok, false);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:534:16\n    |\n534 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:534:22\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n534 |     assert!(matches!(_method, Method::ExtensionInline(_)));\n    |                      ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionInline` found for struct `method::Method` in the current scope\n   --> src/method.rs:534:39\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionInline` not found for this struct\n...\n534 |     assert!(matches!(_method, Method::ExtensionInline(_)));\n    |                                       ^^^^^^^^^^^^^^^ associated item not found in `Method`\n    |\nhelp: there is an associated function `extension_inline` with a similar name\n   --> src/method.rs:137:5\n    |\n137 |     fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_is_ok` in this scope\n   --> src/method.rs:536:16\n    |\n536 |     assert_eq!(_is_ok, true);\n    |                ^^^^^^ not found in this scope\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0425]: cannot find value `_method` in this scope\n   --> src/method.rs:536:22\n    |\n45  | pub struct Method(Inner);\n    | ------------------------- similarly named tuple struct `Method` defined here\n...\n536 |     assert!(matches!(_method, Method::ExtensionAllocated(_)));\n    |                      ^^^^^^^ help: a tuple struct with a similar name exists: `Method`\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionAllocated` found for struct `method::Method` in the current scope\n   --> src/method.rs:536:39\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionAllocated` not found for this struct\n...\n536 |     assert!(matches!(_method, Method::ExtensionAllocated(_)));\n    |                                       ^^^^^^^^^^^^^^^^^^ associated item not found in `Method`\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"DELETE\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"OPTIONS\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::CONNECT);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PATCH);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::TRACE);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::POST);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::HEAD);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::GET);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PUT);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::DELETE);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    assert_eq!(Method::from_bytes(input).is_err(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionInline(_)))));"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionInline(_)))));"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    let input: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9];",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    let input: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9];",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionAllocated(_)))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    assert_eq!(Method::from_bytes(input).is_err(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionInline(_)))));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionInline(_)))));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    let input: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9];",
                  "    assert_eq!(Method::from_bytes(input).is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"UNKNOWNMETHOD\";",
                  "    let input: &[u8] = &[1, 2, 3];",
                  "    let input: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8, 9];",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionAllocated(_)))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"CONNECT\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Get));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Post));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Patch));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Delete));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Options));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Connect));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Head));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Trace));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Put));"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"LONGERTHANMAX\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Get));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Post));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Patch));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Delete));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Options));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Connect));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Head));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Trace));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Put));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let input: &[u8] = b\"LONGERTHANMAX\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Get` found for struct `method::Method` in the current scope\n   --> src/method.rs:515:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Get` not found for this struct\n...\n515 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Get));\n    |                                                                   ^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Post` found for struct `method::Method` in the current scope\n   --> src/method.rs:516:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Post` not found for this struct\n...\n516 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Post));\n    |                                                                   ^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Patch` found for struct `method::Method` in the current scope\n   --> src/method.rs:517:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Patch` not found for this struct\n...\n517 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Patch));\n    |                                                                   ^^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Delete` found for struct `method::Method` in the current scope\n   --> src/method.rs:518:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Delete` not found for this struct\n...\n518 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Delete));\n    |                                                                   ^^^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Options` found for struct `method::Method` in the current scope\n   --> src/method.rs:519:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Options` not found for this struct\n...\n519 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Options));\n    |                                                                   ^^^^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Connect` found for struct `method::Method` in the current scope\n   --> src/method.rs:520:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Connect` not found for this struct\n...\n520 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Connect));\n    |                                                                   ^^^^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Head` found for struct `method::Method` in the current scope\n   --> src/method.rs:521:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Head` not found for this struct\n...\n521 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Head));\n    |                                                                   ^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Trace` found for struct `method::Method` in the current scope\n   --> src/method.rs:522:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Trace` not found for this struct\n...\n522 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Trace));\n    |                                                                   ^^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Put` found for struct `method::Method` in the current scope\n   --> src/method.rs:523:67\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Put` not found for this struct\n...\n523 |     assert_eq!(Method::from_bytes(input).unwrap(), Method(Method::Put));\n    |                                                                   ^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"VALIDEXT\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"VALIDEXT\";",
                  "    assert!(Method::from_bytes(input).is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"VALIDEXT\";",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionInline(_)))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"VALIDEXT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"VALIDEXT\";",
                  "    assert!(Method::from_bytes(input).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"VALIDEXT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"VALIDEXT\";",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method(Inner::ExtensionInline(_)))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                "    let _ = Method::from_bytes(long_input);",
                "}"
              ],
              "oracles": [
                [
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    assert!(Method::from_bytes(long_input).is_err());"
                ],
                [
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    assert!(Method::from_bytes(long_input).is_err());"
                ],
                [
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    assert!(Method::from_bytes(long_input).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    let _ = Method::from_bytes(long_input);",
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    assert!(Method::from_bytes(long_input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    let _ = Method::from_bytes(long_input);",
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    assert!(Method::from_bytes(long_input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    let _ = Method::from_bytes(long_input);",
                  "    let long_input: &[u8] = b\"THIS_IS_A_VERY_LONG_EXTENSION_STRING\";",
                  "    assert!(Method::from_bytes(long_input).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"INVALID\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"\";",
                  "    assert_eq!(Method::from_bytes(input).is_err(), true);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::GET);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PUT);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::POST);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::HEAD);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PATCH);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::TRACE);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::DELETE);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::CONNECT);"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = &[255; 17];",
                  "    assert_eq!(Method::from_bytes(input).is_err(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    assert_eq!(Method::from_bytes(input).is_err(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[255; 16]; // Example of a byte array that might trigger Err",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let input: &[u8] = b\"GET\";",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let input: &[u8] = &[255; 17];",
                  "    assert_eq!(Method::from_bytes(input).is_err(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src.len() matches 0 is true\n",
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src.len() matches _ is true\n",
        "// constraint: src.len() <= InlineExtension::MAX is false\n",
        "// constraint: AllocatedExtension::new(src)? is Ok/Some\n",
        "// expected return value/type: Ok(Method(ExtensionAllocated(allocated)))\n"
      ],
      "input_infer": "0, 3, 4, 5, 6, 7, InlineExtension::MAX + 1, AllocatedExtension::new(src)? = Ok\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(&[]);",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    assert_eq!(result.err().unwrap()._priv, ());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ],
                [
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"NON_STANDARD_METHOD\");",
                  "    assert!(result.is_ok()); // Assumed to be valid inline extension as per the description."
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    assert_eq!(result.err().unwrap()._priv, ());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(&[]);",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"NON_STANDARD_METHOD\");",
                  "    assert!(result.is_ok()); // Assumed to be valid inline extension as per the description.",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"GET\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    assert!(result.is_ok()); // Assuming InlineExtension handling for unknown methods."
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"PATCHing\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"PATCHing\");",
                  "    let result = Method::from_bytes(b\"Headers\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"PATCHing\");",
                  "    let result = Method::from_bytes(b\"Headers\");",
                  "    let long_input = &[b'a'; InlineExtension::MAX + 1]; // Exceeds max inline length",
                  "    let result = Method::from_bytes(long_input);",
                  "    assert!(result.is_ok()); // Assuming AllocatedExtension handling for long input."
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    assert!(result.is_ok()); // Assuming InlineExtension handling for unknown methods.",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"PATCHing\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"PATCHing\");",
                  "    let result = Method::from_bytes(b\"Headers\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"unknown\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"PATCHing\");",
                  "    let result = Method::from_bytes(b\"Headers\");",
                  "    let long_input = &[b'a'; InlineExtension::MAX + 1]; // Exceeds max inline length",
                  "    let result = Method::from_bytes(long_input);",
                  "    assert!(result.is_ok()); // Assuming AllocatedExtension handling for long input.",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"POST\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"UNKNOWN\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"UNKNOWN\");",
                  "    assert_eq!(result.unwrap(), Method::extension_inline(b\"UNKNOWN\").unwrap());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"UNKNOWN\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    let result = Method::from_bytes(b\"UNKNOWN\");",
                  "    assert_eq!(result.unwrap(), Method::extension_inline(b\"UNKNOWN\").unwrap());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"PATCH\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"TRACE\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"DELETE\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"OPTIONS\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"OPTIONS\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    let result = Method::from_bytes(b\"TRACE\");",
                  "    let result = Method::from_bytes(b\"GET\");",
                  "    let result = Method::from_bytes(b\"PUT\");",
                  "    let result = Method::from_bytes(b\"POST\");",
                  "    let result = Method::from_bytes(b\"HEAD\");",
                  "    let result = Method::from_bytes(b\"DELETE\");",
                  "    let result = Method::from_bytes(b\"\");",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"CONNECT\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    let result = Method::from_bytes(b\"CONNECT\");",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"XYZ\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    assert!(matches!(result, Ok(Method::ExtensionInline(_))));"
                ],
                [
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    assert_eq!(result.as_ref().unwrap().as_str(), \"XYZ\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    assert!(matches!(result, Ok(Method::ExtensionInline(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    let result = Method::from_bytes(b\"XYZ\");",
                  "    assert_eq!(result.as_ref().unwrap().as_str(), \"XYZ\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionInline` found for struct `method::Method` in the current scope\n   --> src/method.rs:513:41\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionInline` not found for this struct\n...\n513 |     assert!(matches!(result, Ok(Method::ExtensionInline(_))));\n    |                                         ^^^^^^^^^^^^^^^ associated item not found in `Method`\n    |\nhelp: there is an associated function `extension_inline` with a similar name\n   --> src/method.rs:137:5\n    |\n137 |     fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                true,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"XYZW\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let method = result.unwrap();",
                  "    assert_eq!(method.as_str(), \"XYZW\");"
                ],
                [
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let method = result.unwrap();",
                  "    assert!(method.is_safe());"
                ],
                [
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let method = result.unwrap();",
                  "    assert!(method.is_idempotent());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let method = result.unwrap();",
                  "    assert_eq!(method.as_str(), \"XYZW\");",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let method = result.unwrap();",
                  "    assert!(method.is_safe());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let result = Method::from_bytes(b\"XYZW\");",
                  "    let method = result.unwrap();",
                  "    assert!(method.is_idempotent());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"XYZYZ\");",
                "}"
              ],
              "oracles": [
                [
                  "    let src = b\"XYZYZ\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let src = b\"XYZYZ\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(matches!(result.unwrap(), Method::ExtensionInline(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZYZ\");",
                  "    let src = b\"XYZYZ\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZYZ\");",
                  "    let src = b\"XYZYZ\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(matches!(result.unwrap(), Method::ExtensionInline(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionInline` found for struct `method::Method` in the current scope\n   --> src/method.rs:514:47\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionInline` not found for this struct\n...\n514 |     assert!(matches!(result.unwrap(), Method::ExtensionInline(_)));\n    |                                               ^^^^^^^^^^^^^^^ associated item not found in `Method`\n    |\nhelp: there is an associated function `extension_inline` with a similar name\n   --> src/method.rs:137:5\n    |\n137 |     fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"XYZABC\");",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"XYZABC\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"XYZABC\");",
                  "    let method = result.unwrap();",
                  "    assert!(matches!(method, Method(Inner::ExtensionAllocated(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZABC\");",
                  "    let result = Method::from_bytes(b\"XYZABC\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZABC\");",
                  "    let result = Method::from_bytes(b\"XYZABC\");",
                  "    let method = result.unwrap();",
                  "    assert!(matches!(method, Method(Inner::ExtensionAllocated(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let result = Method::from_bytes(b\"XYZABCDE\");",
                "}"
              ],
              "oracles": [
                [
                  "    let allocated = AllocatedExtension::new(b\"XYZABCDE\").unwrap();",
                  "    let expected = Ok(Method::ExtensionAllocated(allocated));",
                  "    assert_eq!(result, expected);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let result = Method::from_bytes(b\"XYZABCDE\");",
                  "    let allocated = AllocatedExtension::new(b\"XYZABCDE\").unwrap();",
                  "    let expected = Ok(Method::ExtensionAllocated(allocated));",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionAllocated` found for struct `method::Method` in the current scope\n   --> src/method.rs:513:31\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionAllocated` not found for this struct\n...\n513 |     let expected = Ok(Method::ExtensionAllocated(allocated));\n    |                               ^^^^^^^^^^^^^^^^^^ associated item not found in `Method`\n    |\nnote: if you're trying to build a new `method::Method` consider using one of the following associated functions:\n      method::Method::from_bytes\n      method::Method::extension_inline\n   --> src/method.rs:98:5\n    |\n98  |     pub fn from_bytes(src: &[u8]) -> Result<Method, InvalidMethod> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n137 |     fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let oversized_input: Vec<u8> = vec![b'A'; InlineExtension::MAX + 1];",
                "    let result = Method::from_bytes(&oversized_input);",
                "}"
              ],
              "oracles": [
                [
                  "    let oversized_input: Vec<u8> = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = Method::from_bytes(&oversized_input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let oversized_input: Vec<u8> = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = Method::from_bytes(&oversized_input);",
                  "    assert!(matches!(result, Ok(Method(ExtensionAllocated(_)))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let oversized_input: Vec<u8> = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = Method::from_bytes(&oversized_input);",
                  "    let oversized_input: Vec<u8> = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = Method::from_bytes(&oversized_input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let oversized_input: Vec<u8> = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = Method::from_bytes(&oversized_input);",
                  "    let oversized_input: Vec<u8> = vec![b'A'; InlineExtension::MAX + 1];",
                  "    let result = Method::from_bytes(&oversized_input);",
                  "    assert!(matches!(result, Ok(Method(ExtensionAllocated(_)))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src matches b\"OPTIONS\" is true\n",
        "// constraint: src matches b\"CONNECT\" is true\n",
        "// expected return value/type: Ok(Method(Connect))\n"
      ],
      "input_infer": "src.len() == 7 and src equals b\"OPTIONS\", src.len() == 7 and src equals b\"CONNECT\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"OPTIONS\";",
                "    from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"OPTIONS\";",
                  "    let expected = Ok(Method::OPTIONS);",
                  "    assert_eq!(from_bytes(input), expected);"
                ],
                [
                  "    let input = b\"OPTIONS\";",
                  "    let expected = Ok(Method::OPTIONS);",
                  "    let input = b\"CONNECT\";",
                  "    let expected = Ok(Method::CONNECT);",
                  "    assert_eq!(from_bytes(input), expected);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let expected = Ok(Method::OPTIONS);",
                  "    assert_eq!(from_bytes(input), expected);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let expected = Ok(Method::OPTIONS);",
                  "    let input = b\"CONNECT\";",
                  "    let expected = Ok(Method::CONNECT);",
                  "    assert_eq!(from_bytes(input), expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:5\n    |\n512 |     from_bytes(input);\n    |     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:515:16\n    |\n515 |     assert_eq!(from_bytes(input), expected);\n    |                ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:5\n    |\n512 |     from_bytes(input);\n    |     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:517:16\n    |\n517 |     assert_eq!(from_bytes(input), expected);\n    |                ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"CONNECT\";",
                "    from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"CONNECT\";",
                  "    let result = from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"CONNECT\";",
                  "    let result = from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"CONNECT\";",
                  "    from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"CONNECT\";",
                  "    from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:503:8\n    |\n503 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:5\n    |\n512 |     from_bytes(input);\n    |     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:514:18\n    |\n514 |     let result = from_bytes(input);\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 15 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 15 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:512:5\n    |\n512 |     from_bytes(input);\n    |     ^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `from_bytes` in this scope\n   --> src/method.rs:514:18\n    |\n514 |     let result = from_bytes(input);\n    |                  ^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 17,
      "prompt_conds": [
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src matches b\"OPTIONS\" is true\n",
        "// constraint: src matches _ is true\n"
      ],
      "input_infer": "src.len() = 7, src = b\"OPTIONS\", src.len() > 7, src = b\"INVALID\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"OPTIONS\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"INVALID\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.unwrap_err().is::<InvalidMethod>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.unwrap_err().is::<InvalidMethod>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is` found for struct `method::InvalidMethod` in the current scope\n   --> src/method.rs:515:33\n    |\n48  | pub struct InvalidMethod {\n    | ------------------------ method `is` not found for this struct\n...\n515 |     assert!(result.unwrap_err().is::<InvalidMethod>());\n    |                                 ^^ method not found in `InvalidMethod`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = &[];",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = &[];",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    assert!(result.unwrap_err().is_instance_of::<InvalidMethod>());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.unwrap_err().is_instance_of::<InvalidMethod>());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.unwrap().is_instance_of::<Method>());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    assert!(result.unwrap_err().is_instance_of::<InvalidMethod>());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.unwrap_err().is_instance_of::<InvalidMethod>());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = &[];",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = &[];",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.unwrap().is_instance_of::<Method>());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_instance_of` found for struct `method::InvalidMethod` in the current scope\n   --> src/method.rs:514:33\n    |\n48  | pub struct InvalidMethod {\n    | ------------------------ method `is_instance_of` not found for this struct\n...\n514 |     assert!(result.unwrap_err().is_instance_of::<InvalidMethod>());\n    |                                 ^^^^^^^^^^^^^^ method not found in `InvalidMethod`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_instance_of` found for struct `method::InvalidMethod` in the current scope\n   --> src/method.rs:532:33\n    |\n48  | pub struct InvalidMethod {\n    | ------------------------ method `is_instance_of` not found for this struct\n...\n532 |     assert!(result.unwrap_err().is_instance_of::<InvalidMethod>());\n    |                                 ^^^^^^^^^^^^^^ method not found in `InvalidMethod`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_instance_of` found for struct `method::Method` in the current scope\n   --> src/method.rs:534:29\n    |\n45  | pub struct Method(Inner);\n    | ----------------- method `is_instance_of` not found for this struct\n...\n534 |     assert!(result.unwrap().is_instance_of::<Method>());\n    |                             ^^^^^^^^^^^^^^ method not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                true,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TOOLONG\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"TOOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"TOOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap()._priv, ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TOOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TOOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap()._priv, ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TOOLONGTOLONG\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"TOOLONGTOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"TOOLONGTOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TOOLONGTOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOOLONGTOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TOOLONGTOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOOLONGTOLONG\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 18,
      "prompt_conds": [
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src matches b\"OPTIONS\" is true\n",
        "// constraint: src matches b\"OPTIONS\" is true\n",
        "// expected return value/type: Ok(Method(Options))\n"
      ],
      "input_infer": "Test input ranges: [b\"OPTIONS\"]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"OPTIONS\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"A long method name\"; // it should trigger allocation due to length > 7",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"A long method name\";",
                  "    let expected_result = Methos::ExtensionAllocated(AllocatedExtension::new(input).unwrap());",
                  "    assert_eq!(result, expected_result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"A long method name\"; // it should trigger allocation due to length > 7",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"A long method name\";",
                  "    let expected_result = Methos::ExtensionAllocated(AllocatedExtension::new(input).unwrap());",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `Methos`\n   --> src/method.rs:514:27\n    |\n514 |     let expected_result = Methos::ExtensionAllocated(AllocatedExtension::new(input).unwrap());\n    |                           ^^^^^^\n    |                           |\n    |                           use of undeclared type `Methos`\n    |                           help: a struct with a similar name exists: `Method`\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"\"; // should trigger InvalidMethod due to empty input",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap()._priv, ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"\"; // should trigger InvalidMethod due to empty input",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\"; // should trigger InvalidMethod due to empty input",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap()._priv, ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"GET\"; // should return Ok(Method(Get))",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::GET)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PUT)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::POST)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::HEAD)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PATCH)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::TRACE)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::DELETE)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::OPTIONS)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::CONNECT)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = &[b'A'; 8];",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::GET)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PUT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::POST)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::HEAD)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PATCH)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::TRACE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::DELETE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::OPTIONS)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::CONNECT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\"; // should return Ok(Method(Get))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = &[b'A'; 8];",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:515:34\n    |\n515 |     assert_eq!(result, Ok(Method(Method::GET)));\n    |                           ------ ^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result, Ok(Method(Method::GET)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:517:34\n    |\n517 |     assert_eq!(result, Ok(Method(Method::PUT)));\n    |                           ------ ^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:517:5\n    |\n517 |     assert_eq!(result, Ok(Method(Method::PUT)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:519:34\n    |\n519 |     assert_eq!(result, Ok(Method(Method::POST)));\n    |                           ------ ^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:519:5\n    |\n519 |     assert_eq!(result, Ok(Method(Method::POST)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:521:34\n    |\n521 |     assert_eq!(result, Ok(Method(Method::HEAD)));\n    |                           ------ ^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:521:5\n    |\n521 |     assert_eq!(result, Ok(Method(Method::HEAD)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:523:34\n    |\n523 |     assert_eq!(result, Ok(Method(Method::PATCH)));\n    |                           ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:523:5\n    |\n523 |     assert_eq!(result, Ok(Method(Method::PATCH)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:525:34\n    |\n525 |     assert_eq!(result, Ok(Method(Method::TRACE)));\n    |                           ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:525:5\n    |\n525 |     assert_eq!(result, Ok(Method(Method::TRACE)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:527:34\n    |\n527 |     assert_eq!(result, Ok(Method(Method::DELETE)));\n    |                           ------ ^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:527:5\n    |\n527 |     assert_eq!(result, Ok(Method(Method::DELETE)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:529:34\n    |\n529 |     assert_eq!(result, Ok(Method(Method::OPTIONS)));\n    |                           ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:529:5\n    |\n529 |     assert_eq!(result, Ok(Method(Method::OPTIONS)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:531:34\n    |\n531 |     assert_eq!(result, Ok(Method(Method::CONNECT)));\n    |                           ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:531:5\n    |\n531 |     assert_eq!(result, Ok(Method(Method::CONNECT)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"POST\"; // should return Ok(Method(Post))",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"POST\"; // should return Ok(Method(Post))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"POST\"; // should return Ok(Method(Post))",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"INVALID\"; // should trigger inline extension",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionInline(_)))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"INVALID\"; // should trigger inline extension",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"INVALID\"; // should trigger inline extension",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionInline(_)))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 19,
      "prompt_conds": [
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src.len() matches 7 is true\n",
        "// constraint: src matches b\"OPTIONS\" is false\n"
      ],
      "input_infer": "src.len() == 7 and src matches b\"CONNECT\" or src matches any other 7-byte array\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"CONNECT\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"CONNECT\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result, Ok(Method(Connect)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"CONNECT\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result, Ok(Method(Connect)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(_result, Ok(Method(Connect)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"EXAMPLE\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"EXAMPLE\";",
                  "    assert!(_result.is_err());"
                ],
                [
                  "    let input = b\"EXAMPLE\";",
                  "    assert_eq!(_result.err().unwrap()._priv, ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"EXAMPLE\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"EXAMPLE\";",
                  "    assert!(_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"EXAMPLE\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"EXAMPLE\";",
                  "    assert_eq!(_result.err().unwrap()._priv, ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TESTING\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"TESTING\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_err());"
                ],
                [
                  "    let input = b\"TESTING\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result.err().unwrap(), InvalidMethod::new());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TESTING\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"TESTING\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TESTING\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"TESTING\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result.err().unwrap(), InvalidMethod::new());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `method::InvalidMethod`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(_result.err().unwrap(), InvalidMethod::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     method::InvalidMethod\n    |     method::InvalidMethod\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"REQUEST\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"REQUEST\";",
                  "    let expected_output = Err(InvalidMethod::new());",
                  "    assert_eq!(_result, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"REQUEST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"REQUEST\";",
                  "    let expected_output = Err(InvalidMethod::new());",
                  "    assert_eq!(_result, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, method::InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(_result, expected_output);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, method::InvalidMethod>\n    |     std::result::Result<method::Method, method::InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"GETMETHOD\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"GETMETHOD\";",
                  "    assert!(matches!(_result, Err(_)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    assert!(matches!(_result, Err(_)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    assert!(matches!(_result, Err(_)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    assert!(matches!(_result, Ok(Method::GET)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    assert!(matches!(_result, Ok(Method::PUT)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    assert!(matches!(_result, Ok(Method::POST)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    assert!(matches!(_result, Ok(Method::HEAD)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    let input = b\"PATCH\";",
                  "    assert!(matches!(_result, Ok(Method::PATCH)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    let input = b\"PATCH\";",
                  "    let input = b\"TRACE\";",
                  "    assert!(matches!(_result, Ok(Method::TRACE)));"
                ],
                [
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    let input = b\"PATCH\";",
                  "    let input = b\"TRACE\";",
                  "    let input = b\"DELETE\";",
                  "    assert!(matches!(_result, Ok(Method::DELETE)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    assert!(matches!(_result, Err(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    assert!(matches!(_result, Err(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    assert!(matches!(_result, Err(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    assert!(matches!(_result, Ok(Method::GET)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    assert!(matches!(_result, Ok(Method::PUT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    assert!(matches!(_result, Ok(Method::POST)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    assert!(matches!(_result, Ok(Method::HEAD)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    let input = b\"PATCH\";",
                  "    assert!(matches!(_result, Ok(Method::PATCH)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    let input = b\"PATCH\";",
                  "    let input = b\"TRACE\";",
                  "    assert!(matches!(_result, Ok(Method::TRACE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GETMETHOD\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"GETMETHOD\";",
                  "    let input = b\"OPTIONS\";",
                  "    let input = b\"CONNECT\";",
                  "    let input = b\"GET\";",
                  "    let input = b\"PUT\";",
                  "    let input = b\"POST\";",
                  "    let input = b\"HEAD\";",
                  "    let input = b\"PATCH\";",
                  "    let input = b\"TRACE\";",
                  "    let input = b\"DELETE\";",
                  "    assert!(matches!(_result, Ok(Method::DELETE)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"CONNECTA\"; // 8 bytes, should use extension allocation",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"CONNECTA\"; // 8 bytes, should use extension allocation",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"CONNECTA\"; // 8 bytes, should use extension allocation",
                  "    let result = Method::from_bytes(input);",
                  "    assert_matches!(result, Ok(Method(ExtensionAllocated(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"CONNECTA\"; // 8 bytes, should use extension allocation",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"CONNECTA\"; // 8 bytes, should use extension allocation",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"CONNECTA\"; // 8 bytes, should use extension allocation",
                  "    let _result = Method::from_bytes(input);",
                  "    let input = b\"CONNECTA\"; // 8 bytes, should use extension allocation",
                  "    let result = Method::from_bytes(input);",
                  "    assert_matches!(result, Ok(Method(ExtensionAllocated(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: cannot find macro `assert_matches` in this scope\n   --> src/method.rs:515:5\n    |\n515 |     assert_matches!(result, Ok(Method(ExtensionAllocated(_))));\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n503 +    use std::assert_matches::assert_matches;\n    |\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 25,
      "prompt_conds": [
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src matches b\"DELETE\" is true\n",
        "// constraint: src matches _ is true\n"
      ],
      "input_infer": "6 bytes: b\"DELETE\" or any other 6-byte array\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"DELETE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let method = result.unwrap();",
                  "    assert_eq!(method, Method::DELETE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let method = result.unwrap();",
                  "    assert_eq!(method, Method::DELETE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"XYZABC\"; // valid 6-byte input not matching DELETE",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"XYZABC\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"XYZABC\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.as_ref().unwrap().is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"XYZABC\"; // valid 6-byte input not matching DELETE",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"XYZABC\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"XYZABC\"; // valid 6-byte input not matching DELETE",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"XYZABC\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.as_ref().unwrap().is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `is_err` found for reference `&method::Method` in the current scope\n   --> src/method.rs:515:38\n    |\n515 |     assert!(result.as_ref().unwrap().is_err());\n    |             ------ --------          ^^^^^^ method not found in `&Method`\n    |             |      |\n    |             |      method `is_err` is available on `std::result::Result<&method::Method, &InvalidMethod>`\n    |             method `is_err` is available on `&std::result::Result<method::Method, InvalidMethod>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"TEST\"; // invalid length for 6 that is not DELETE",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"TEST\";",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"TEST\";",
                  "    assert!(matches!(result, Err(_)));"
                ],
                [
                  "    let input: &[u8] = b\"TEST\";",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"TEST\"; // invalid length for 6 that is not DELETE",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TEST\";",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TEST\"; // invalid length for 6 that is not DELETE",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TEST\";",
                  "    assert!(matches!(result, Err(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TEST\"; // invalid length for 6 that is not DELETE",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TEST\";",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"XXYYZZ\"; // another valid 6-byte length for extension inline",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"XXYYZZ\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"XXYYZZ\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionInline(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"XXYYZZ\"; // another valid 6-byte length for extension inline",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"XXYYZZ\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"XXYYZZ\"; // another valid 6-byte length for extension inline",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"XXYYZZ\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionInline(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: mismatched closing delimiter: `}`\n   --> src/method.rs:515:12\n    |\n510 | {\n    | - closing delimiter possibly meant for this\n...\n515 |     assert!(matches!(result, Ok(Method(Inner::ExtensionInline(_))));\n    |            ^ unclosed delimiter\n516 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `http` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 26,
      "prompt_conds": [
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src matches b\"DELETE\" is true\n",
        "// constraint: src matches b\"DELETE\" is true\n",
        "// expected return value/type: Ok(Method(Delete))\n"
      ],
      "input_infer": "6 <= src.len() <= InlineExtension::MAX, src == b\"DELETE\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"DELETE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"DELETE\\042\"; // Input length exceeding 6 but allowed due to MAX constraints",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"DELETE\\042\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"DELETE\\042\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\\042\"; // Input length exceeding 6 but allowed due to MAX constraints",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\\042\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"DELETE\\042\"; // Input length exceeding 6 but allowed due to MAX constraints",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\\042\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 27,
      "prompt_conds": [
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src.len() matches 6 is true\n",
        "// constraint: src matches b\"DELETE\" is false\n"
      ],
      "input_infer": "src.len() in 1..6 and src.len() in 8..InlineExtension::MAX\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"GET\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"PUT\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"POST\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"HEAD\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(_?.is_ok(), true);"
                ],
                [
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(_?.as_str(), \"HEAD\");"
                ],
                [
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(_?.clone(), Method::HEAD);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(_?.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(_?.as_str(), \"HEAD\");",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"HEAD\";",
                  "    assert_eq!(_?.clone(), Method::HEAD);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: no rules expected the token `_`\n   --> src/method.rs:514:16\n    |\n514 |     assert_eq!(_?.is_ok(), true);\n    |                ^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$left:expr`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:37:6\n    |\n37  |     ($left:expr, $right:expr $(,)?) => {\n    |      ^^^^^^^^^^\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: no rules expected the token `_`\n   --> src/method.rs:514:16\n    |\n514 |     assert_eq!(_?.as_str(), \"HEAD\");\n    |                ^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$left:expr`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:37:6\n    |\n37  |     ($left:expr, $right:expr $(,)?) => {\n    |      ^^^^^^^^^^\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: no rules expected the token `_`\n   --> src/method.rs:514:16\n    |\n514 |     assert_eq!(_?.clone(), Method::HEAD);\n    |                ^ no rules expected this token in macro call\n    |\nnote: while trying to match meta-variable `$left:expr`\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/macros/mod.rs:37:6\n    |\n37  |     ($left:expr, $right:expr $(,)?) => {\n    |      ^^^^^^^^^^\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"PATCH\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"TRACE\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method(Method::Trace));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method(Method::Trace));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Trace` found for struct `method::Method` in the current scope\n   --> src/method.rs:515:48\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Trace` not found for this struct\n...\n515 |     assert_eq!(result.unwrap(), Method(Method::Trace));\n    |                                                ^^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"NOTDE\"; // A 6-byte input that is not \"DELETE\"",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"NOTDE\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input: &[u8] = b\"NOTDE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap_err(), InvalidMethod::new());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"NOTDE\"; // A 6-byte input that is not \"DELETE\"",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"NOTDE\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"NOTDE\"; // A 6-byte input that is not \"DELETE\"",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"NOTDE\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap_err(), InvalidMethod::new());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `method::InvalidMethod`\n   --> src/method.rs:514:5\n    |\n514 |     assert_eq!(Method::from_bytes(input).unwrap_err(), InvalidMethod::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     method::InvalidMethod\n    |     method::InvalidMethod\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"OPTIONS\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"CONNECT\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert!(Method::from_bytes(input).is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert_eq!(method, Method::CONNECT);"
                ],
                [
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert!(method.is_safe());"
                ],
                [
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert!(method.is_idempotent());"
                ],
                [
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert_eq!(method.as_str(), \"CONNECT\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    assert!(Method::from_bytes(input).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert_eq!(method, Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert!(method.is_safe());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert!(method.is_idempotent());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"CONNECT\";",
                  "    let method = Method::from_bytes(input).unwrap();",
                  "    assert_eq!(method.as_str(), \"CONNECT\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"EXTRA_LENGTH_METHOD\"; // A method longer than 7 bytes",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"EXTRA_LENGTH_METHOD\";",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method::ExtensionAllocated(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"EXTRA_LENGTH_METHOD\"; // A method longer than 7 bytes",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"EXTRA_LENGTH_METHOD\";",
                  "    assert!(matches!(Method::from_bytes(input), Ok(Method::ExtensionAllocated(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionAllocated` found for struct `method::Method` in the current scope\n   --> src/method.rs:514:60\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionAllocated` not found for this struct\n...\n514 |     assert!(matches!(Method::from_bytes(input), Ok(Method::ExtensionAllocated(_))));\n    |                                                            ^^^^^^^^^^^^^^^^^^ associated item not found in `Method`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"LONGNAME\"; // 8-byte input",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"LONGNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"LONGNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionAllocated(_)))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"LONGNAME\"; // 8-byte input",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"LONGNAME\"; // 8-byte input",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"LONGNAME\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionAllocated(_)))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 33,
      "prompt_conds": [
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src matches b\"PATCH\" is true\n",
        "// constraint: src matches b\"TRACE\" is true\n",
        "// expected return value/type: Ok(Method(Trace))\n"
      ],
      "input_infer": "[src.len() = 5, src = b\"PATCH\", src = b\"TRACE\"]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PATCH\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::from_bytes(b\"PATCH\").unwrap());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::from_bytes(b\"PATCH\").unwrap());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TRACE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 37,
      "prompt_conds": [
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src matches b\"PATCH\" is true\n",
        "// constraint: src matches _ is true\n"
      ],
      "input_infer": "5 <= src.len() <= InlineExtension::MAX and src matches b\"PATCH\" or src matches any other sequence of 5 bytes except b\"PATCH\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PATCH\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TRACE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"ABCDE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.err().is_some());"
                ],
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.err().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"\\xFF\\xFF\\xFF\\xFF\\xFF\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"\\xFF\\xFF\\xFF\\xFF\\xFF\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\\xFF\\xFF\\xFF\\xFF\\xFF\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result.unwrap(), Method::ExtensionInline(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"\\xFF\\xFF\\xFF\\xFF\\xFF\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\\xFF\\xFF\\xFF\\xFF\\xFF\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\\xFF\\xFF\\xFF\\xFF\\xFF\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\\xFF\\xFF\\xFF\\xFF\\xFF\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result.unwrap(), Method::ExtensionInline(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `ExtensionInline` found for struct `method::Method` in the current scope\n   --> src/method.rs:515:47\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `ExtensionInline` not found for this struct\n...\n515 |     assert!(matches!(result.unwrap(), Method::ExtensionInline(_)));\n    |                                               ^^^^^^^^^^^^^^^ associated item not found in `Method`\n    |\nhelp: there is an associated function `extension_inline` with a similar name\n   --> src/method.rs:137:5\n    |\n137 |     fn extension_inline(src: &[u8]) -> Result<Method, InvalidMethod> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 38,
      "prompt_conds": [
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src matches b\"PATCH\" is true\n",
        "// constraint: src matches b\"PATCH\" is true\n",
        "// expected return value/type: Ok(Method(Patch))\n"
      ],
      "input_infer": "src.len() = 5 and src = b\"PATCH\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PATCH\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Patch)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Patch)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result, Ok(Method(Patch)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err()._priv, ());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err()._priv, ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err()._priv, ());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::TRACE);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::DELETE);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err()._priv, ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"GET\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::GET)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PUT)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::POST)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::HEAD)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PATCH)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::TRACE)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::DELETE)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::OPTIONS)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::CONNECT)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOOLONGHTTPMETHOD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::GET)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PUT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::POST)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::HEAD)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PATCH)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::TRACE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::DELETE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::OPTIONS)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::CONNECT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOOLONGHTTPMETHOD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:515:34\n    |\n515 |     assert_eq!(result, Ok(Method(Method::GET)));\n    |                           ------ ^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result, Ok(Method(Method::GET)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:517:34\n    |\n517 |     assert_eq!(result, Ok(Method(Method::PUT)));\n    |                           ------ ^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:517:5\n    |\n517 |     assert_eq!(result, Ok(Method(Method::PUT)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:519:34\n    |\n519 |     assert_eq!(result, Ok(Method(Method::POST)));\n    |                           ------ ^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:519:5\n    |\n519 |     assert_eq!(result, Ok(Method(Method::POST)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:521:34\n    |\n521 |     assert_eq!(result, Ok(Method(Method::HEAD)));\n    |                           ------ ^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:521:5\n    |\n521 |     assert_eq!(result, Ok(Method(Method::HEAD)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:523:34\n    |\n523 |     assert_eq!(result, Ok(Method(Method::PATCH)));\n    |                           ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:523:5\n    |\n523 |     assert_eq!(result, Ok(Method(Method::PATCH)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:525:34\n    |\n525 |     assert_eq!(result, Ok(Method(Method::TRACE)));\n    |                           ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:525:5\n    |\n525 |     assert_eq!(result, Ok(Method(Method::TRACE)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:527:34\n    |\n527 |     assert_eq!(result, Ok(Method(Method::DELETE)));\n    |                           ------ ^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:527:5\n    |\n527 |     assert_eq!(result, Ok(Method(Method::DELETE)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:529:34\n    |\n529 |     assert_eq!(result, Ok(Method(Method::OPTIONS)));\n    |                           ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:529:5\n    |\n529 |     assert_eq!(result, Ok(Method(Method::OPTIONS)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:531:34\n    |\n531 |     assert_eq!(result, Ok(Method(Method::CONNECT)));\n    |                           ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:531:5\n    |\n531 |     assert_eq!(result, Ok(Method(Method::CONNECT)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"POST\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"HEAD\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err().to_string(), \"Invalid HTTP method\");"
                ],
                [
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err().to_string(), \"Invalid HTTP method\");",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PUT\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::GET)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PUT)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PATCH)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::TRACE)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::HEAD)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::OPTIONS)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::CONNECT)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::DELETE)));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::GET)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PUT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::PATCH)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::TRACE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::HEAD)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::OPTIONS)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::CONNECT)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::DELETE)));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"UNKNOWN\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:515:34\n    |\n515 |     assert_eq!(result, Ok(Method(Method::GET)));\n    |                           ------ ^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result, Ok(Method(Method::GET)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:517:34\n    |\n517 |     assert_eq!(result, Ok(Method(Method::PUT)));\n    |                           ------ ^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:517:5\n    |\n517 |     assert_eq!(result, Ok(Method(Method::PUT)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:519:34\n    |\n519 |     assert_eq!(result, Ok(Method(Method::PATCH)));\n    |                           ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:519:5\n    |\n519 |     assert_eq!(result, Ok(Method(Method::PATCH)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:521:34\n    |\n521 |     assert_eq!(result, Ok(Method(Method::TRACE)));\n    |                           ------ ^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:521:5\n    |\n521 |     assert_eq!(result, Ok(Method(Method::TRACE)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:527:34\n    |\n527 |     assert_eq!(result, Ok(Method(Method::HEAD)));\n    |                           ------ ^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:527:5\n    |\n527 |     assert_eq!(result, Ok(Method(Method::HEAD)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:529:34\n    |\n529 |     assert_eq!(result, Ok(Method(Method::OPTIONS)));\n    |                           ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:529:5\n    |\n529 |     assert_eq!(result, Ok(Method(Method::OPTIONS)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:531:34\n    |\n531 |     assert_eq!(result, Ok(Method(Method::CONNECT)));\n    |                           ------ ^^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:531:5\n    |\n531 |     assert_eq!(result, Ok(Method(Method::CONNECT)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:533:34\n    |\n533 |     assert_eq!(result, Ok(Method(Method::DELETE)));\n    |                           ------ ^^^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                           |\n    |                           arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:533:5\n    |\n533 |     assert_eq!(result, Ok(Method(Method::DELETE)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                false,
                false,
                true,
                true,
                true,
                true,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"DELETE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TRACE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"CONNECT\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"OPTIONS\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PATCH\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"EXT-NAME\"; // Assuming EXT-NAME is a valid inline extension",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"EXT-NAME\"; // Assuming EXT-NAME is a valid inline extension",
                  "    let result = Method::from_bytes(input);",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"EXT-NAME\"; // Assuming EXT-NAME is a valid inline extension",
                  "    let result = Method::from_bytes(input);",
                  "    let result = Method::from_bytes(b\"PATCH\");",
                  "    assert_eq!(result.unwrap(), Method::PATCH);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let input = b\"TOO-LONG-EXTENSION\"; // Exceeds InlineExtension::MAX",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"TOO-LONG-EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"TOO-LONG-EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TOO-LONG-EXTENSION\"; // Exceeds InlineExtension::MAX",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOO-LONG-EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TOO-LONG-EXTENSION\"; // Exceeds InlineExtension::MAX",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TOO-LONG-EXTENSION\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"ALLOCATED-EXT\"; // Presumed to be valid for allocated method",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"ALLOCATED-EXT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"ALLOCATED-EXT\";",
                  "    let result = Method::from_bytes(input);",
                  "    if let Ok(method) = result {",
                  "    assert_eq!(method, Method::ExtensionAllocated(AllocatedExtension::new(input).unwrap()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"ALLOCATED-EXT\"; // Presumed to be valid for allocated method",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"ALLOCATED-EXT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ALLOCATED-EXT\"; // Presumed to be valid for allocated method",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"ALLOCATED-EXT\";",
                  "    let result = Method::from_bytes(input);",
                  "    if let Ok(method) = result {",
                  "    assert_eq!(method, Method::ExtensionAllocated(AllocatedExtension::new(input).unwrap()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: this file contains an unclosed delimiter\n   --> src/method.rs:518:3\n    |\n502 | mod llmtests {\n    |              - unclosed delimiter\n...\n518 | }\n    |   ^\n\nerror: could not compile `http` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 39,
      "prompt_conds": [
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src.len() matches 5 is true\n",
        "// constraint: src matches b\"PATCH\" is false\n"
      ],
      "input_infer": "4 < len(src) < 7 and src not equal to b\"PATCH\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"HELLO\"; // len is 5, does not match PATCH",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"HELLO\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input = b\"HELLO\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap_err().to_string(), \"InvalidMethod\");"
                ],
                [
                  "    let input = b\"HELLO\";",
                  "    assert!(matches!(Method::from_bytes(input), Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"HELLO\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"HELLO\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"HELLO\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"HELLO\";",
                  "    assert_eq!(Method::from_bytes(input).unwrap_err().to_string(), \"InvalidMethod\");",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"HELLO\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"HELLO\";",
                  "    assert!(matches!(Method::from_bytes(input), Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TESTS\"; // len is 5, does not match PATCH",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"TESTS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"TESTS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionInline(_)))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TESTS\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"TESTS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TESTS\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"TESTS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Ok(Method(Inner::ExtensionInline(_)))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap().as_str(), \"ABCDE\");"
                ],
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(!result.unwrap().is_safe());"
                ],
                [
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(!result.unwrap().is_idempotent());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap().as_str(), \"ABCDE\");",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(!result.unwrap().is_safe());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(!result.unwrap().is_idempotent());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"ABCDE\";",
                  "    assert!(Method::from_bytes(input).is_err());"
                ],
                [
                  "    let input = b\"ABCDE\";",
                  "    assert!(matches!(Method::from_bytes(input), Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    assert!(Method::from_bytes(input).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"ABCDE\"; // len is 5, does not match PATCH",
                  "    let _ = Method::from_bytes(input);",
                  "    let input = b\"ABCDE\";",
                  "    assert!(matches!(Method::from_bytes(input), Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 44,
      "prompt_conds": [
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src matches b\"POST\" is true\n",
        "// constraint: src matches b\"HEAD\" is true\n",
        "// expected return value/type: Ok(Method(Head))\n"
      ],
      "input_infer": "4 <= src.len() <= 4, src == {b\"POST\", b\"HEAD\"}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"POST\";",
                "    let method = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"POST\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert!(method.is_ok());"
                ],
                [
                  "    let input = b\"POST\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert_eq!(method.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"POST\";",
                  "    let method = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert!(method.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"POST\";",
                  "    let method = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert_eq!(method.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"HEAD\";",
                "    let method = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"HEAD\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert!(method.is_ok());"
                ],
                [
                  "    let input = b\"HEAD\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert_eq!(method.unwrap(), Method::HEAD);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let method = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert!(method.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let method = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let method = Method::from_bytes(input);",
                  "    assert_eq!(method.unwrap(), Method::HEAD);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 47,
      "prompt_conds": [
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src matches b\"POST\" is true\n",
        "// constraint: src matches _ is true\n"
      ],
      "input_infer": "src.len() = 4, src = b\"POST\", src = b\"XXXX\" (where XXXX can be any 4-byte array that does not match \"POST\")\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = b\"POST\";",
                "    let _ = Method::from_bytes(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let src = b\"POST\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"POST\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = b\"XXXX\";",
                "    let _ = Method::from_bytes(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let src = b\"XXXX\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let src = b\"XXXX\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap_err()._priv, ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let src = b\"XXXX\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"XXXX\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"XXXX\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"XXXX\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap_err()._priv, ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = b\"\";",
                "    let _ = Method::from_bytes(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.err().unwrap(), InvalidMethod::new());"
                ],
                [
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ],
                [
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"HEAD\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"HEAD\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let src = b\"\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.err().unwrap(), InvalidMethod::new());",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"HEAD\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"POST\";",
                  "    let result = Method::from_bytes(src);",
                  "    let src = b\"HEAD\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `method::InvalidMethod`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result.err().unwrap(), InvalidMethod::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     method::InvalidMethod\n    |     method::InvalidMethod\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                true,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = b\"TOOLONGEXAMPLE\";",
                "    let _ = Method::from_bytes(src);",
                "}"
              ],
              "oracles": [
                [
                  "    let src = b\"TOOLONGEXAMPLE\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let src = b\"TOOLONGEXAMPLE\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let src = b\"TOOLONGEXAMPLE\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"TOOLONGEXAMPLE\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let src = b\"TOOLONGEXAMPLE\";",
                  "    let _ = Method::from_bytes(src);",
                  "    let src = b\"TOOLONGEXAMPLE\";",
                  "    let result = Method::from_bytes(src);",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 48,
      "prompt_conds": [
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src matches b\"POST\" is true\n",
        "// constraint: src matches b\"POST\" is true\n",
        "// expected return value/type: Ok(Method(Post))\n"
      ],
      "input_infer": "4..4, b\"POST\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"POST\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result, Ok(Method(Method::POST)));"
                ],
                [
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result, Ok(Method(Method::POST)));",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> src/method.rs:515:35\n    |\n515 |     assert_eq!(_result, Ok(Method(Method::POST)));\n    |                            ------ ^^^^^^^^^^^^ expected `Inner`, found `Method`\n    |                            |\n    |                            arguments to this struct are incorrect\n    |\nnote: tuple struct defined here\n   --> src/method.rs:45:12\n    |\n45  | pub struct Method(Inner);\n    |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(_result, Ok(Method(Method::POST)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"POS\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"POS\";",
                  "    assert!(_result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"POS\";",
                  "    assert_eq!(_result.unwrap_err().to_string(), \"Invalid HTTP method\");"
                ],
                [
                  "    let input: &[u8] = b\"POS\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"POS\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"POS\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POS\";",
                  "    assert!(_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"POS\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POS\";",
                  "    assert_eq!(_result.unwrap_err().to_string(), \"Invalid HTTP method\");",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"POS\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POS\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"POS\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"POS\";",
                  "    let input: &[u8] = b\"POST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"TEST\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"TEST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_err());"
                ],
                [
                  "    let input: &[u8] = b\"TEST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result.err(), Some(InvalidMethod::new()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"TEST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TEST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert!(_result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"TEST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"TEST\";",
                  "    let _result = Method::from_bytes(input);",
                  "    assert_eq!(_result.err(), Some(InvalidMethod::new()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<method::InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(_result.err(), Some(InvalidMethod::new()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<method::InvalidMethod>\n    |     Option<method::InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 49,
      "prompt_conds": [
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src.len() matches 4 is true\n",
        "// constraint: src matches b\"POST\" is false\n"
      ],
      "input_infer": "src.len() in [0, 4], src = [b\"HEAD\", b\"TEST\", b\"XXXX\", b\"ABCD\"]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input1 = b\"HEAD\";",
                "    let _ = Method::from_bytes(input1);",
                "    ",
                "    let input2 = b\"TEST\";",
                "    let _ = Method::from_bytes(input2);",
                "    ",
                "    let input3 = b\"XXXX\";",
                "    let _ = Method::from_bytes(input3);",
                "    ",
                "    let input4 = b\"ABCD\";",
                "    let _ = Method::from_bytes(input4);",
                "}"
              ],
              "oracles": [
                [
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    assert!(result1.is_ok());"
                ],
                [
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    assert_eq!(result1.unwrap(), Method::HEAD);"
                ],
                [
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    let input2 = b\"TEST\";",
                  "    let result2 = Method::from_bytes(input2);",
                  "    assert!(result2.is_err());"
                ],
                [
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    let input2 = b\"TEST\";",
                  "    let result2 = Method::from_bytes(input2);",
                  "    let input3 = b\"XXXX\";",
                  "    let result3 = Method::from_bytes(input3);",
                  "    assert!(result3.is_err());"
                ],
                [
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    let input2 = b\"TEST\";",
                  "    let result2 = Method::from_bytes(input2);",
                  "    let input3 = b\"XXXX\";",
                  "    let result3 = Method::from_bytes(input3);",
                  "    let input4 = b\"ABCD\";",
                  "    let result4 = Method::from_bytes(input4);",
                  "    assert!(result4.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input1 = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input1);",
                  "    ",
                  "    let input2 = b\"TEST\";",
                  "    let _ = Method::from_bytes(input2);",
                  "    ",
                  "    let input3 = b\"XXXX\";",
                  "    let _ = Method::from_bytes(input3);",
                  "    ",
                  "    let input4 = b\"ABCD\";",
                  "    let _ = Method::from_bytes(input4);",
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    assert!(result1.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input1 = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input1);",
                  "    ",
                  "    let input2 = b\"TEST\";",
                  "    let _ = Method::from_bytes(input2);",
                  "    ",
                  "    let input3 = b\"XXXX\";",
                  "    let _ = Method::from_bytes(input3);",
                  "    ",
                  "    let input4 = b\"ABCD\";",
                  "    let _ = Method::from_bytes(input4);",
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    assert_eq!(result1.unwrap(), Method::HEAD);",
                  "}"
                ],
                [
                  "{",
                  "    let input1 = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input1);",
                  "    ",
                  "    let input2 = b\"TEST\";",
                  "    let _ = Method::from_bytes(input2);",
                  "    ",
                  "    let input3 = b\"XXXX\";",
                  "    let _ = Method::from_bytes(input3);",
                  "    ",
                  "    let input4 = b\"ABCD\";",
                  "    let _ = Method::from_bytes(input4);",
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    let input2 = b\"TEST\";",
                  "    let result2 = Method::from_bytes(input2);",
                  "    assert!(result2.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input1 = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input1);",
                  "    ",
                  "    let input2 = b\"TEST\";",
                  "    let _ = Method::from_bytes(input2);",
                  "    ",
                  "    let input3 = b\"XXXX\";",
                  "    let _ = Method::from_bytes(input3);",
                  "    ",
                  "    let input4 = b\"ABCD\";",
                  "    let _ = Method::from_bytes(input4);",
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    let input2 = b\"TEST\";",
                  "    let result2 = Method::from_bytes(input2);",
                  "    let input3 = b\"XXXX\";",
                  "    let result3 = Method::from_bytes(input3);",
                  "    assert!(result3.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input1 = b\"HEAD\";",
                  "    let _ = Method::from_bytes(input1);",
                  "    ",
                  "    let input2 = b\"TEST\";",
                  "    let _ = Method::from_bytes(input2);",
                  "    ",
                  "    let input3 = b\"XXXX\";",
                  "    let _ = Method::from_bytes(input3);",
                  "    ",
                  "    let input4 = b\"ABCD\";",
                  "    let _ = Method::from_bytes(input4);",
                  "    let input1 = b\"HEAD\";",
                  "    let result1 = Method::from_bytes(input1);",
                  "    let input2 = b\"TEST\";",
                  "    let result2 = Method::from_bytes(input2);",
                  "    let input3 = b\"XXXX\";",
                  "    let result3 = Method::from_bytes(input3);",
                  "    let input4 = b\"ABCD\";",
                  "    let result4 = Method::from_bytes(input4);",
                  "    assert!(result4.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 53,
      "prompt_conds": [
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src matches b\"GET\" is true\n",
        "// constraint: src matches b\"PUT\" is true\n",
        "// expected return value/type: Ok(Method(Put))\n"
      ],
      "input_infer": "[3, 3]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"GET\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PUT\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 55,
      "prompt_conds": [
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src matches b\"GET\" is true\n",
        "// constraint: src matches _ is true\n"
      ],
      "input_infer": "len: 3, src: [b\"GET\"], [b\"PUT\"], [b\"ABC\"]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"GET\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"GET\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"PUT\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"ABC\";",
                "    let _ = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ],
                [
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"ABC\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"ABC\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"ABC\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"ABC\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"ABC\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ],
                [
                  "{",
                  "    let input: &[u8] = b\"ABC\";",
                  "    let _ = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"ABC\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 56,
      "prompt_conds": [
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src matches b\"GET\" is true\n",
        "// constraint: src matches b\"GET\" is true\n",
        "// expected return value/type: Ok(Method(Get))\n"
      ],
      "input_infer": "3, b\"GET\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"GET\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method::GET));"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_matches!(result, Ok(Method::GET));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method::GET));",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_matches!(result, Ok(Method::GET));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result, Ok(Method::GET));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror: cannot find macro `assert_matches` in this scope\n   --> src/method.rs:515:5\n    |\n515 |     assert_matches!(result, Ok(Method::GET));\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n503 +    use std::assert_matches::assert_matches;\n    |\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PUT\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PUT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::PUT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err(), InvalidMethod::new());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap_err(), InvalidMethod::new());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"GET\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::GET);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `method::InvalidMethod`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result.unwrap_err(), InvalidMethod::new());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     method::InvalidMethod\n    |     method::InvalidMethod\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                true,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"INVALID\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"INVALID\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"POST\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"POST\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::POST);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"HEAD\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"HEAD\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::HEAD);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"PATCH\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::Patch)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"PATCH\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Ok(Method(Method::Patch)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Patch` found for struct `method::Method` in the current scope\n   --> src/method.rs:515:42\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Patch` not found for this struct\n...\n515 |     assert_eq!(result, Ok(Method(Method::Patch)));\n    |                                          ^^^^^ associated item not found in `Method`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result, Ok(Method(Method::Patch)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"TRACE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(InvalidMethod)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"TRACE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(matches!(result, Err(InvalidMethod)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"DELETE\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.is_ok(), false);"
                ],
                [
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Err(InvalidMethod::new()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.is_ok(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"DELETE\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result, Err(InvalidMethod::new()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, method::InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(result, Err(InvalidMethod::new()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, method::InvalidMethod>\n    |     std::result::Result<method::Method, method::InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"OPTIONS\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"OPTIONS\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::OPTIONS);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"CONNECT\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"CONNECT\";",
                  "    let result = Method::from_bytes(input);",
                  "    assert_eq!(result.unwrap(), Method::CONNECT);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input = b\"EXTRA\";",
                "    let result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input = b\"EXTRA\";",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let input = b\"EXTRA\";",
                  "    assert!(result.err().is_some());"
                ],
                [
                  "    let input = b\"EXTRA\";",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input = b\"EXTRA\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"EXTRA\";",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"EXTRA\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"EXTRA\";",
                  "    assert!(result.err().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let input = b\"EXTRA\";",
                  "    let result = Method::from_bytes(input);",
                  "    let input = b\"EXTRA\";",
                  "    assert_eq!(result.err().unwrap().to_string(), \"Invalid HTTP method\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 57,
      "prompt_conds": [
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src.len() matches 3 is true\n",
        "// constraint: src matches b\"GET\" is false\n"
      ],
      "input_infer": "src.len() == 3 and src not equal to b\"GET\" and src equal to b\"PUT\" and src equal to b\"XYZ\"\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input1 = b\"PUT\";",
                "    let _ = Method::from_bytes(input1);",
                "",
                "    let input2 = b\"XYZ\";",
                "    let _ = Method::from_bytes(input2);",
                "}"
              ],
              "oracles": [
                [
                  "    let input1 = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input1), Ok(Method(Method::Put)));"
                ],
                [
                  "    let input1 = b\"PUT\";",
                  "    let input2 = b\"XYZ\";",
                  "    assert!(Method::from_bytes(input2).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input1 = b\"PUT\";",
                  "    let _ = Method::from_bytes(input1);",
                  "",
                  "    let input2 = b\"XYZ\";",
                  "    let _ = Method::from_bytes(input2);",
                  "    let input1 = b\"PUT\";",
                  "    assert_eq!(Method::from_bytes(input1), Ok(Method(Method::Put)));",
                  "}"
                ],
                [
                  "{",
                  "    let input1 = b\"PUT\";",
                  "    let _ = Method::from_bytes(input1);",
                  "",
                  "    let input2 = b\"XYZ\";",
                  "    let _ = Method::from_bytes(input2);",
                  "    let input1 = b\"PUT\";",
                  "    let input2 = b\"XYZ\";",
                  "    assert!(Method::from_bytes(input2).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no associated item named `Put` found for struct `method::Method` in the current scope\n   --> src/method.rs:517:62\n    |\n45  | pub struct Method(Inner);\n    | ----------------- associated item `Put` not found for this struct\n...\n517 |     assert_eq!(Method::from_bytes(input1), Ok(Method(Method::Put)));\n    |                                                              ^^^ associated item not found in `Method`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, InvalidMethod>`\n   --> src/method.rs:517:5\n    |\n517 |     assert_eq!(Method::from_bytes(input1), Ok(Method(Method::Put)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, InvalidMethod>\n    |     std::result::Result<method::Method, InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nSome errors have detailed explanations: E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 2 previous errors; 14 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 58,
      "prompt_conds": [
        "// constraint: src.len() matches 0 is true\n",
        "// constraint: src.len() matches 0 is true\n",
        "// expected return value/type: Err(InvalidMethod::new())\n"
      ],
      "input_infer": "0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &[u8] = b\"\";",
                "    let _result = Method::from_bytes(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &[u8] = b\"\";",
                  "    let expected = Err(InvalidMethod::new());",
                  "    assert_eq!(_result, expected);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let _result = Method::from_bytes(input);",
                  "    let input: &[u8] = b\"\";",
                  "    let expected = Err(InvalidMethod::new());",
                  "    assert_eq!(_result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<method::Method, method::InvalidMethod>`\n   --> src/method.rs:515:5\n    |\n515 |     assert_eq!(_result, expected);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<method::Method, method::InvalidMethod>\n    |     std::result::Result<method::Method, method::InvalidMethod>\n    |\nnote: an implementation of `PartialEq` might be missing for `method::InvalidMethod`\n   --> src/method.rs:48:1\n    |\n48  | pub struct InvalidMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `method::InvalidMethod` with `#[derive(PartialEq)]`\n    |\n48  + #[derive(PartialEq)]\n49  | pub struct InvalidMethod {\n    |\n\nFor more information about this error, try `rustc --explain E0369`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 1 previous error; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}