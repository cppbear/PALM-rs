{
  "name": "http::request::<request::Request<T> as std::fmt::Debug>::fmt",
  "name_with_impl": "http::request::{impl#3}::fmt",
  "mod_info": {
    "name": "request",
    "loc": "src/lib.rs:174:1:174:17"
  },
  "visible": true,
  "loc": "src/request.rs:697:5:706:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "Test input ranges: body type: T can be any type; method: valid HTTP methods (GET, POST, PUT, DELETE, etc.); uri: valid URIs with various schemes and paths; version: valid HTTP versions (HTTP/1.0, HTTP/1.1, HTTP/2); headers: valid header structures with various combinations and sizes; extensions: optional, can be empty or populated.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let method = Method(Inner::GET);",
                "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                "    let version = Version(Http::HTTP_1_1);",
                "    let headers = HeaderMap::<HeaderValue>::default();",
                "    let extensions = Extensions::default();",
                "    let body = \"body content\";",
                "",
                "    let request = Request::new(body);",
                "    request.head = Parts {",
                "        method,",
                "        uri,",
                "        version,",
                "        headers,",
                "        extensions,",
                "        _priv: (),",
                "    };",
                "",
                "    let _ = format!(\"{:?}\", request);",
                "}"
              ],
              "oracles": [
                [
                  "    let method = Method(Inner::GET);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "    let output = format!(\"{:?}\", request);",
                  "    assert!(output.contains(\"method: GET\"));"
                ],
                [
                  "    let method = Method(Inner::GET);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "    let output = format!(\"{:?}\", request);",
                  "    assert!(output.contains(\"uri: http://example.com/path\"));"
                ],
                [
                  "    let method = Method(Inner::GET);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "    let output = format!(\"{:?}\", request);",
                  "    assert!(output.contains(\"version: HTTP/1.1\"));"
                ],
                [
                  "    let method = Method(Inner::GET);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "    let output = format!(\"{:?}\", request);",
                  "    assert!(output.contains(\"headers: {}\"));"
                ],
                [
                  "    let method = Method(Inner::GET);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "    let output = format!(\"{:?}\", request);",
                  "    assert!(output.contains(\"body: body content\"));"
                ]
              ],
              "codes": [
                [
                  "{",
                  " let method = Method::GET;  ",
                  " use crate::uri::{Scheme, Authority}; // Import Scheme and Authority to resolve the error  ",
                  " let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  ",
                  " let version = Version(Http::HTTP_1_1);  ",
                  " let headers = HeaderMap::<HeaderValue>::default();  ",
                  " let extensions = Extensions::default();  ",
                  " let body = \"body content\";  ",
                  "",
                  " let request = Request::new(body);  ",
                  " request.head = Parts {  ",
                  "     method,  ",
                  "     uri,  ",
                  "     version,  ",
                  "     headers,  ",
                  "     extensions,  ",
                  "     _priv: (),  ",
                  " };  ",
                  " ",
                  "  let _ = format!(\"{:?}\", request);  ",
                  "  let method = Method::GET;  ",
                  "   let version = Version(Http::HTTP_1_1);  ",
                  "   let headers = HeaderMap::<HeaderValue>::default();  ",
                  "   let extensions = Extensions::default();  ",
                  "   let body = \"body content\";  ",
                  "   let request = Request::new(body);  ",
                  "   request.head = Parts { method, uri, version, headers, extensions, _priv: (), };  ",
                  "   let output = format!(\"{:?}\", request);  ",
                  "   assert!(output.contains(\"method: GET\"));  ",
                  "}"
                ],
                [
                  "{",
                  "   use crate::uri::{Authority, Scheme};  ",
                  "   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  ",
                  "   let version = Version(Http::HTTP_1_1);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"body content\";",
                  "",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  "",
                  "   let _ = format!(\"{:?}\", request);",
                  "   let method = Method(Inner::GET);",
                  "   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "   let version = Version(Http::HTTP_1_1);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"body content\";",
                  "   let request = Request::new(body);",
                  "   request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "   let output = format!(\"{:?}\", request);",
                  "   assert!(output.contains(\"uri: http://example.com/path\"));",
                  "}"
                ],
                [
                  "{",
                  "   use crate::uri::Scheme; // Import the Scheme type",
                  "   use crate::uri::Authority; // Import the Authority type",
                  "  let method = Method::GET;",
                  "  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"body content\";",
                  "",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "        uri,",
                  "        version,",
                  "        headers,",
                  "        extensions,",
                  "        _priv: (),",
                  "    };",
                  "",
                  "    let _ = format!(\"{:?}\", request);",
                  "    let method = Method(Inner::GET);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "    let output = format!(\"{:?}\", request);",
                  "    assert!(output.contains(\"version: HTTP/1.1\"));",
                  "}"
                ],
                [
                  "{",
                  " let method = Method::GET;  ",
                  " use crate::uri::{Authority, Scheme};  ",
                  " let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "  let version = Version(Http::HTTP_1_1);",
                  "   let version = Version(Http::HTTP_1_1);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"body content\";",
                  " ",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  " ",
                  "   let _ = format!(\"{:?}\", request);",
                  "   let method = Method::GET;",
                  "   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "   let version = Version(Http::HTTP_1_1);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"body content\";",
                  "   let request = Request::new(body);",
                  "   request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "   let output = format!(\"{:?}\", request);",
                  "   assert!(output.contains(\"headers: {}\"));",
                  "}"
                ],
                [
                  "  {",
                  "    let method = Method(crate::method::Inner::Get);",
                  "  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  ",
                  "   let version = Version(Http::HTTP_1_1);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"body content\";",
                  "",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  "",
                  "   let _ = format!(\"{:?}\", request);",
                  "   let method = Method(Inner::GET);",
                  "   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };",
                  "   let version = Version(Http::HTTP_1_1);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: (), };",
                  "    let output = format!(\"{:?}\", request);",
                  "    assert!(output.contains(\"body: body content\"));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:129\n     |\n1087 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:24\n     |\n1088 |  let version = Version(Http::HTTP_1_1);  \n     |                        ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:26\n     |\n1105 |    let version = Version(Http::HTTP_1_1);  \n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:26\n     |\n1087 |  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQu...\n     |                          ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:73\n     |\n1087 |  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQu...\n     |                                                                         ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  \n     |                                                                         ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:16\n     |\n1088 |  let version = Version(Http::HTTP_1_1);  \n     |                ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:18\n     |\n1105 |    let version = Version(Http::HTTP_1_1);  \n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |    let version = version(Http::HTTP_1_1);  \n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 7 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:131\n     |\n1086 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:26\n     |\n1087 |    let version = Version(Http::HTTP_1_1);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0425]: cannot find value `method` in this scope\n    --> src/request.rs:1094:8\n     |\n1094 |        method,\n     |        ^^^^^^ not found in this scope\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1103:17\n     |\n1103 |    let method = Method(Inner::GET);\n     |                 ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1103:24\n     |\n1103 |    let method = Method(Inner::GET);\n     |                        ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:131\n     |\n1104 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:26\n     |\n1105 |    let version = Version(Http::HTTP_1_1);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:28\n     |\n1086 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                            ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:75\n     |\n1086 | ...::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) ...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  \n     |                                                                           ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:18\n     |\n1087 |    let version = Version(Http::HTTP_1_1);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:28\n     |\n1104 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                            ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:75\n     |\n1104 | ...::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                                                           ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:18\n     |\n1105 |    let version = Version(Http::HTTP_1_1);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |    let version = version(Http::HTTP_1_1);\n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 13 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1088:130\n     |\n1088 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0425]: cannot find value `version` in this scope\n    --> src/request.rs:1097:9\n     |\n1097 |         version,\n     |         ^^^^^^^ not found in this scope\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1104:18\n     |\n1104 |     let method = Method(Inner::GET);\n     |                  ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\nhelp: a local variable with a similar name exists\n     |\n1104 |     let method = method(Inner::GET);\n     |                  ~~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1104:25\n     |\n1104 |     let method = Method(Inner::GET);\n     |                         ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1105:132\n     |\n1105 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1106:27\n     |\n1106 |     let version = Version(Http::HTTP_1_1);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1088:27\n     |\n1088 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQ...\n     |                           ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1088:74\n     |\n1088 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQ...\n     |                                                                          ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1088 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                                                          ~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1105:29\n     |\n1105 |     let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAn...\n     |                             ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1105:76\n     |\n1105 | ...::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1105 |     let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                                                            ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1106:19\n     |\n1106 |     let version = Version(Http::HTTP_1_1);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 11 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:129\n     |\n1087 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:25\n     |\n1088 |   let version = Version(Http::HTTP_1_1);\n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1089:26\n     |\n1089 |    let version = Version(Http::HTTP_1_1);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1106:131\n     |\n1106 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1107:26\n     |\n1107 |    let version = Version(Http::HTTP_1_1);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:26\n     |\n1087 |  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQu...\n     |                          ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:73\n     |\n1087 |  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQu...\n     |                                                                         ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                                                         ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:17\n     |\n1088 |   let version = Version(Http::HTTP_1_1);\n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1089:18\n     |\n1089 |    let version = Version(Http::HTTP_1_1);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1089 |    let version = version(Http::HTTP_1_1);\n     |                  ~~~~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1106:28\n     |\n1106 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                            ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1106:75\n     |\n1106 | ...::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1106 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                                                           ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1107:18\n     |\n1107 |    let version = Version(Http::HTTP_1_1);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1107 |    let version = version(Http::HTTP_1_1);\n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 12 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1085:18\n     |\n1085 |     let method = Method(crate::method::Inner::Get);\n     |                  ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:154\n     |\n1086 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:26\n     |\n1087 |    let version = Version(Http::HTTP_1_1);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1103:17\n     |\n1103 |    let method = Method(Inner::GET);\n     |                 ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\nhelp: a local variable with a similar name exists\n     |\n1103 |    let method = method(Inner::GET);\n     |                 ~~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1103:24\n     |\n1103 |    let method = Method(Inner::GET);\n     |                        ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Authority`\n    --> src/request.rs:1104:76\n     |\n1104 |    let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: ...\n     |                                                                            ^^^^^^^^^ use of undeclared type `Authority`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::Authority;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:143\n     |\n1104 | ...ple.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:26\n     |\n1105 |    let version = Version(Http::HTTP_1_1);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0603]: enum `Inner` is private\n    --> src/request.rs:1085:40\n     |\n1085 |     let method = Method(crate::method::Inner::Get);\n     |                                        ^^^^^  --- unit variant `Get` is not publicly re-exported\n     |                                        |\n     |                                        private enum\n     |\nnote: the enum `Inner` is defined here\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:27\n     |\n1086 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from_str(\"example.com\").unwrap()), path_...\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:98\n     |\n1086 | ...hority: Some(crate::uri::Authority::from_str(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) ...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from(\"example.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/path\").unwrap()) };  \n     |                                                                                                  ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:18\n     |\n1087 |    let version = Version(Http::HTTP_1_1);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:28\n     |\n1104 |    let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from_str(\"example.com\").unwrap()), path_and_query: ...\n     |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:18\n     |\n1105 |    let version = Version(Http::HTTP_1_1);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |    let version = version(Http::HTTP_1_1);\n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599, E0603.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 14 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let method = Method(Inner::POST);",
                "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                "    let version = Version(Http::HTTP_2);",
                "    let headers = HeaderMap::<HeaderValue>::default();",
                "    let extensions = Extensions::default();",
                "    let body = \"post body content\";",
                "",
                "    let request = Request::new(body);",
                "    request.head = Parts {",
                "        method,",
                "        uri,",
                "        version,",
                "        headers,",
                "        extensions,",
                "        _priv: (),",
                "    };",
                "",
                "    let _ = format!(\"{:?}\", request);",
                "}"
              ],
              "oracles": [
                [
                  "    let method = Method(Inner::POST);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "    let version = Version(Http::HTTP_2);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"post body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"method: POST\"), true);"
                ],
                [
                  "    let method = Method(Inner::POST);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "    let version = Version(Http::HTTP_2);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"post body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"uri: https://secure.com/submit\"), true);"
                ],
                [
                  "    let method = Method(Inner::POST);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "    let version = Version(Http::HTTP_2);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"post body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"version: HTTP/2\"), true);"
                ],
                [
                  "    let method = Method(Inner::POST);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "    let version = Version(Http::HTTP_2);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"post body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"headers: {}\"), true);"
                ],
                [
                  "    let method = Method(Inner::POST);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "    let version = Version(Http::HTTP_2);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = \"post body content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"body: post body content\"), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "  use crate::uri::{Scheme, Authority}; // Import Authority here  ",
                  "  let method = Method(Method::POST.0);  ",
                  "  let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  ",
                  "   let version = Version(Http::HTTP_2);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"post body content\";",
                  "",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  "",
                  "   let _ = format!(\"{:?}\", request);",
                  "   let method = Method(Method::POST.0);",
                  "   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "   let version = Version(Http::HTTP_2);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"post body content\";",
                  "   let request = Request::new(body);",
                  "   request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "   assert_eq!(format!(\"{:?}\", request).contains(\"method: POST\"), true);",
                  "}"
                ],
                [
                  "  {  ",
                  "  use crate::uri::Authority;  ",
                  "  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  ",
                  "   let version = Version(Http::HTTP_2);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"post body content\";",
                  "",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  "",
                  "   let _ = format!(\"{:?}\", request);",
                  "   let method = Method(Inner::POST);",
                  "   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "   let version = Version(Http::HTTP_2);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"post body content\";",
                  "   let request = Request::new(body);",
                  "   request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "   assert_eq!(format!(\"{:?}\", request).contains(\"uri: https://secure.com/submit\"), true);",
                  "}"
                ],
                [
                  "{",
                  " use crate::uri::Authority; // Import Authority here",
                  " let method = Method(crate::method::Inner::POST);  ",
                  " let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  ",
                  " let version = Version(Http::HTTP_2);  ",
                  " let headers = HeaderMap::<HeaderValue>::default();  ",
                  " let extensions = Extensions::default();  ",
                  " let body = \"post body content\";  ",
                  "",
                  " let request = Request::new(body);  ",
                  " request.head = Parts {  ",
                  "     method,  ",
                  "     uri,  ",
                  "     version,  ",
                  "     headers,  ",
                  "     extensions,  ",
                  "     _priv: (),  ",
                  " };  ",
                  "",
                  "  let method = Method(crate::method::Inner::POST);  ",
                  "  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  ",
                  "  let version = Version(Http::HTTP_2);  ",
                  "  let headers = HeaderMap::<HeaderValue>::default();  ",
                  "  let extensions = Extensions::default();  ",
                  "  let body = \"post body content\";  ",
                  "  let request = Request::new(body);  ",
                  "  request.head = Parts { method, uri, version, headers, extensions, _priv: () };  ",
                  "  assert_eq!(format!(\"{:?}\", request).contains(\"version: HTTP/2\"), true);  ",
                  "}"
                ],
                [
                  "{",
                  "   let method = Method::POST;",
                  "   use crate::uri::{Authority, Scheme};  // Import both Authority and Scheme",
                  "   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "   let version = Version(Http::HTTP_2);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"post body content\";",
                  "",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  "",
                  "   let _ = format!(\"{:?}\", request);",
                  "   let method = Method::POST;",
                  "   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "   let version = Version(Http::HTTP_2);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = \"post body content\";",
                  "   let request = Request::new(body);",
                  "   request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "   assert_eq!(format!(\"{:?}\", request).contains(\"headers: {}\"), true);",
                  "}"
                ],
                [
                  "{",
                  "   use crate::uri::Scheme; // Added import for Scheme",
                  "  let method = Method::POST;  // Using the public constant instead of instantiating directly",
                  "  let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "  let version = Version(Http::HTTP_2);",
                  "  let headers = HeaderMap::<HeaderValue>::default();",
                  "  let extensions = Extensions::default();",
                  "  let body = \"post body content\";",
                  "",
                  "  let request = Request::new(body);",
                  "  request.head = Parts {",
                  "      method,  // This has now been set using the public constant",
                  "      uri,",
                  "      version,",
                  "      headers,",
                  "      extensions,",
                  "      _priv: (),",
                  "  };",
                  "",
                  "  let _ = format!(\"{:?}\", request);",
                  "  let method = Method::POST; // Using the public constant instead of instantiating directly",
                  "  let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };",
                  "  let version = Version(Http::HTTP_2);",
                  "  let headers = HeaderMap::<HeaderValue>::default();",
                  "  let extensions = Extensions::default();",
                  "  let body = \"post body content\";",
                  "  let request = Request::new(body);",
                  "  request.head = Parts { method, uri, version, headers, extensions, _priv: () };",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1086:16\n     |\n1086 |   let method = Method(Method::POST.0);  \n     |                ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:130\n     |\n1087 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:26\n     |\n1088 |    let version = Version(Http::HTTP_2);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1104:17\n     |\n1104 |    let method = Method(Method::POST.0);\n     |                 ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\nhelp: a local variable with a similar name exists\n     |\n1104 |    let method = method(Method::POST.0);\n     |                 ~~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1105:131\n     |\n1105 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1106:26\n     |\n1106 |    let version = Version(Http::HTTP_2);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0616]: field `0` of struct `method::Method` is private\n    --> src/request.rs:1086:36\n     |\n1086 |   let method = Method(Method::POST.0);  \n     |                                    ^ private field\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:27\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQ...\n     |                           ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:75\n     |\n1087 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap())...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                                                           ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:18\n     |\n1088 |    let version = Version(Http::HTTP_2);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0616]: field `0` of struct `method::Method` is private\n    --> src/request.rs:1104:37\n     |\n1104 |    let method = Method(Method::POST.0);\n     |                                     ^ private field\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1105:28\n     |\n1105 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                            ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1105:76\n     |\n1105 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1105 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                                                            ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1106:18\n     |\n1106 |    let version = Version(Http::HTTP_2);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1106 |    let version = version(Http::HTTP_2);\n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 14 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:142\n     |\n1086 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:26\n     |\n1087 |    let version = Version(Http::HTTP_2);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0425]: cannot find value `method` in this scope\n    --> src/request.rs:1094:8\n     |\n1094 |        method,\n     |        ^^^^^^ not found in this scope\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1103:17\n     |\n1103 |    let method = Method(Inner::POST);\n     |                 ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1103:24\n     |\n1103 |    let method = Method(Inner::POST);\n     |                        ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:143\n     |\n1104 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:26\n     |\n1105 |    let version = Version(Http::HTTP_2);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:27\n     |\n1086 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: S...\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:87\n     |\n1086 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap())...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                                                                       ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:18\n     |\n1087 |    let version = Version(Http::HTTP_2);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:28\n     |\n1104 |    let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: ...\n     |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:88\n     |\n1104 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |    let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                                                                        ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:18\n     |\n1105 |    let version = Version(Http::HTTP_2);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |    let version = version(Http::HTTP_2);\n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 13 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1086:15\n     |\n1086 |  let method = Method(crate::method::Inner::POST);  \n     |               ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:141\n     |\n1087 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:24\n     |\n1088 |  let version = Version(Http::HTTP_2);  \n     |                        ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1103:16\n     |\n1103 |   let method = Method(crate::method::Inner::POST);  \n     |                ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\nhelp: a local variable with a similar name exists\n     |\n1103 |   let method = method(crate::method::Inner::POST);  \n     |                ~~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:142\n     |\n1104 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:25\n     |\n1105 |   let version = Version(Http::HTTP_2);  \n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0603]: enum `Inner` is private\n    --> src/request.rs:1086:37\n     |\n1086 |  let method = Method(crate::method::Inner::POST);  \n     |                                     ^^^^^ private enum\n     |\nnote: the enum `Inner` is defined here\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^\n\nerror[E0603]: enum `Inner` is private\n    --> src/request.rs:1103:38\n     |\n1103 |   let method = Method(crate::method::Inner::POST);  \n     |                                      ^^^^^ private enum\n     |\nnote: the enum `Inner` is defined here\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no variant or associated item named `POST` found for enum `Inner` in the current scope\n    --> src/request.rs:1086:44\n     |\n1086 |  let method = Method(crate::method::Inner::POST);  \n     |                                            ^^^^ variant or associated item not found in `Inner`\n     |\n    ::: src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ---------- variant or associated item `POST` not found for this enum\n     |\nhelp: there is a variant with a similar name\n     |\n1086 |  let method = Method(crate::method::Inner::Post;  \n     |                                            ~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:26\n     |\n1087 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: So...\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:86\n     |\n1087 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap())...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                                                                      ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:16\n     |\n1088 |  let version = Version(Http::HTTP_2);  \n     |                ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0599]: no variant or associated item named `POST` found for enum `Inner` in the current scope\n    --> src/request.rs:1103:45\n     |\n1103 |   let method = Method(crate::method::Inner::POST);  \n     |                                             ^^^^ variant or associated item not found in `Inner`\n     |\n    ::: src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ---------- variant or associated item `POST` not found for this enum\n     |\nhelp: there is a variant with a similar name\n     |\n1103 |   let method = Method(crate::method::Inner::Post;  \n     |                                             ~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:27\n     |\n1104 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: S...\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:87\n     |\n1104 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap())...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };  \n     |                                                                                       ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:17\n     |\n1105 |   let version = Version(Http::HTTP_2);  \n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |   let version = version(Http::HTTP_2);  \n     |                 ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599, E0603.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 16 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:131\n     |\n1087 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:26\n     |\n1088 |    let version = Version(Http::HTTP_2);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1105:131\n     |\n1105 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1106:26\n     |\n1106 |    let version = Version(Http::HTTP_2);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:28\n     |\n1087 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                            ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:76\n     |\n1087 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                                                            ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:18\n     |\n1088 |    let version = Version(Http::HTTP_2);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1105:28\n     |\n1105 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                            ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1105:76\n     |\n1105 | ...:HTTPS), authority: Some(Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1105 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                                                            ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1106:18\n     |\n1106 |    let version = Version(Http::HTTP_2);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1106 |    let version = version(Http::HTTP_2);\n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:142\n     |\n1087 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:25\n     |\n1088 |   let version = Version(Http::HTTP_2);\n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1105:142\n     |\n1105 | ...ure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1106:25\n     |\n1106 |   let version = Version(Http::HTTP_2);\n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:27\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"secure.com\").unwrap()), path_and_query: S...\n     |                           ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:87\n     |\n1087 | ...hority: Some(crate::uri::Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                                                                       ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:17\n     |\n1088 |   let version = Version(Http::HTTP_2);\n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1105:27\n     |\n1105 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"secure.com\").unwrap()), path_and_query: S...\n     |                           ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1105:87\n     |\n1105 | ...hority: Some(crate::uri::Authority::from_str(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1105 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from(\"secure.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/submit\").unwrap()) };\n     |                                                                                       ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1106:17\n     |\n1106 |   let version = Version(Http::HTTP_2);\n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1106 |   let version = version(Http::HTTP_2);\n     |                 ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let method = Method(Inner::PUT);",
                "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                "    let version = Version(Http::HTTP_1_0);",
                "    let headers = HeaderMap::<HeaderValue>::default();",
                "    let extensions = Extensions::default();",
                "    let body = ();",
                "",
                "    let request = Request::new(body);",
                "    request.head = Parts {",
                "        method,",
                "        uri,",
                "        version,",
                "        headers,",
                "        extensions,",
                "        _priv: (),",
                "    };",
                "",
                "    let _ = format!(\"{:?}\", request);",
                "}"
              ],
              "oracles": [
                [
                  "    let method = Method(Inner::PUT);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "    assert_eq!(request.method(), &method);"
                ],
                [
                  "    let method = Method(Inner::PUT);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "    assert_eq!(request.uri(), &uri);"
                ],
                [
                  "    let method = Method(Inner::PUT);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "    assert_eq!(request.version(), version);"
                ],
                [
                  "    let method = Method(Inner::PUT);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "    assert_eq!(request.headers(), &headers);"
                ],
                [
                  "    let method = Method(Inner::PUT);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "    assert_eq!(request.body(), &body);"
                ]
              ],
              "codes": [
                [
                  "{  ",
                  "  use crate::uri::Scheme;  ",
                  "  use crate::uri::Authority;  ",
                  "  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  ",
                  "   let version = Version(Http::HTTP_1_0);  ",
                  "   let headers = HeaderMap::<HeaderValue>::default();  ",
                  "   let extensions = Extensions::default();  ",
                  "   let body = ();  ",
                  " ",
                  "   let request = Request::new(body);  ",
                  "   request.head = Parts {  ",
                  "       method,  ",
                  "       uri,  ",
                  "       version,  ",
                  "       headers,  ",
                  "       extensions,  ",
                  "       _priv: (),  ",
                  "   };  ",
                  " ",
                  "   let _ = format!(\"{:?}\", request);  ",
                  "   let method = Method(Inner::PUT);  ",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "    assert_eq!(request.method(), &method);",
                  "}"
                ],
                [
                  "{  ",
                  "  use crate::uri::Authority; // Import Authority struct  ",
                  "  let method = Method(Method::Inner::PUT);  ",
                  "  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "  let version = Version(Http::HTTP_1_0);",
                  "  let headers = HeaderMap::<HeaderValue>::default();",
                  "  let extensions = Extensions::default();",
                  "  let body = ();",
                  "",
                  "  let request = Request::new(body);",
                  "  request.head = Parts {",
                  "      method,",
                  "      uri,",
                  "      version,",
                  "      headers,",
                  "      extensions,",
                  "      _priv: (),",
                  "  };",
                  "",
                  "  let _ = format!(\"{:?}\", request);",
                  "  let method = Method(Inner::PUT);",
                  "  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "  let version = Version(Http::HTTP_1_0);",
                  "  let headers = HeaderMap::<HeaderValue>::default();",
                  "  let extensions = Extensions::default();",
                  "  let body = ();",
                  "}"
                ],
                [
                  "{",
                  "  use crate::uri::{Scheme, Authority}; // Added import for Authority",
                  " let method = Method(Method::PUT.0);",
                  "  let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "   let version = Version(Http::HTTP_1_0);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = ();",
                  "",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  "",
                  "   let _ = format!(\"{:?}\", request);",
                  "   let method = Method(Inner::PUT);",
                  "   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "   let version = Version(Http::HTTP_1_0);",
                  "   let headers = HeaderMap::<HeaderValue>::default();",
                  "   let extensions = Extensions::default();",
                  "   let body = ();",
                  "   assert_eq!(request.version(), version);",
                  "}"
                ],
                [
                  "  {  ",
                  "     use crate::uri::{Scheme, Authority};  ",
                  "     let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  ",
                  "     let version = Version(Http::HTTP_1_0);  ",
                  "     let headers = HeaderMap::<HeaderValue>::default();  ",
                  "     let extensions = Extensions::default();  ",
                  "     let body = ();  ",
                  "",
                  "     let request = Request::new(body);  ",
                  "     request.head = Parts {  ",
                  "         method,  ",
                  "         uri,  ",
                  "         version,  ",
                  "         headers,  ",
                  "         extensions,  ",
                  "         _priv: (),  ",
                  "     };  ",
                  "",
                  "     let _ = format!(\"{:?}\", request);  ",
                  "     let method = Method(Inner::PUT);  ",
                  "     let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  ",
                  "     let version = Version(Http::HTTP_1_0);  ",
                  "     let headers = HeaderMap::<HeaderValue>::default();  ",
                  "     let extensions = Extensions::default();  ",
                  "     let body = ();  ",
                  "     assert_eq!(request.headers(), &headers);  ",
                  "}"
                ],
                [
                  "{",
                  "    let method = Method::PUT; ",
                  "    let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "        method,",
                  "        uri,",
                  "        version,",
                  "        headers,",
                  "        extensions,",
                  "        _priv: (),",
                  "    };",
                  "",
                  "    let _ = format!(\"{:?}\", request);",
                  "    let method = Method::PUT; ",
                  "    let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_0);",
                  "    let headers = HeaderMap::<HeaderValue>::default();",
                  "    let extensions = Extensions::default();",
                  "    let body = ();",
                  "    assert_eq!(request.body(), &body);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:128\n     |\n1087 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:26\n     |\n1088 |    let version = Version(Http::HTTP_1_0);  \n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0425]: cannot find value `method` in this scope\n    --> src/request.rs:1095:8\n     |\n1095 |        method,  \n     |        ^^^^^^ not found in this scope\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1104:17\n     |\n1104 |    let method = Method(Inner::PUT);  \n     |                 ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1104:24\n     |\n1104 |    let method = Method(Inner::PUT);  \n     |                        ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:27\n     |\n1105 |     let version = Version(Http::HTTP_1_0);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:27\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQue...\n     |                           ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:74\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQue...\n     |                                                                          ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                                                          ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:18\n     |\n1088 |    let version = Version(Http::HTTP_1_0);  \n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:19\n     |\n1105 |     let version = Version(Http::HTTP_1_0);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |     let version = version(Http::HTTP_1_0);\n     |                   ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1086:16\n     |\n1086 |   let method = Method(Method::Inner::PUT);  \n     |                ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:140\n     |\n1087 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:25\n     |\n1088 |   let version = Version(Http::HTTP_1_0);\n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1104:16\n     |\n1104 |   let method = Method(Inner::PUT);\n     |                ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\nhelp: a local variable with a similar name exists\n     |\n1104 |   let method = method(Inner::PUT);\n     |                ~~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1104:23\n     |\n1104 |   let method = Method(Inner::PUT);\n     |                       ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1105:140\n     |\n1105 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1106:25\n     |\n1106 |   let version = Version(Http::HTTP_1_0);\n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0223]: ambiguous associated type\n    --> src/request.rs:1086:23\n     |\n1086 |   let method = Method(Method::Inner::PUT);  \n     |                       ^^^^^^^^^^^^^\n     |\nhelp: if there were a trait named `Example` with associated type `Inner` implemented for `method::Method`, you could use the fully-qualified path\n     |\n1086 |   let method = Method(<method::Method as Example>::Inner::PUT);  \n     |                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:27\n     |\n1087 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Som...\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:86\n     |\n1087 | ...::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                                                                      ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:17\n     |\n1088 |   let version = Version(Http::HTTP_1_0);\n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1105:27\n     |\n1105 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Som...\n     |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1105:86\n     |\n1105 | ...::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1105 |   let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                                                                      ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1106:17\n     |\n1106 |   let version = Version(Http::HTTP_1_0);\n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1106 |   let version = version(Http::HTTP_1_0);\n     |                 ~~~~~~~\n\nSome errors have detailed explanations: E0223, E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0223`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 14 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1086:15\n     |\n1086 |  let method = Method(Method::PUT.0);\n     |               ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1087:128\n     |\n1087 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1088:26\n     |\n1088 |    let version = Version(Http::HTTP_1_0);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1104:17\n     |\n1104 |    let method = Method(Inner::PUT);\n     |                 ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\nhelp: a local variable with a similar name exists\n     |\n1104 |    let method = method(Inner::PUT);\n     |                 ~~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1104:24\n     |\n1104 |    let method = Method(Inner::PUT);\n     |                        ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1105:129\n     |\n1105 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1106:26\n     |\n1106 |    let version = Version(Http::HTTP_1_0);\n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0616]: field `0` of struct `method::Method` is private\n    --> src/request.rs:1086:34\n     |\n1086 |  let method = Method(Method::PUT.0);\n     |                                  ^ private field\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1087:27\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQue...\n     |                           ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1087:74\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQue...\n     |                                                                          ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1087 |   let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                                                          ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1088:18\n     |\n1088 |    let version = Version(Http::HTTP_1_0);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1105:28\n     |\n1105 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQu...\n     |                            ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1105:75\n     |\n1105 | ...::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1105 |    let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                                                           ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1106:18\n     |\n1106 |    let version = Version(Http::HTTP_1_0);\n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1106 |    let version = version(Http::HTTP_1_0);\n     |                  ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 14 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:131\n     |\n1086 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:28\n     |\n1087 |      let version = Version(Http::HTTP_1_0);  \n     |                            ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0425]: cannot find value `method` in this scope\n    --> src/request.rs:1094:10\n     |\n1094 |          method,  \n     |          ^^^^^^ not found in this scope\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1103:19\n     |\n1103 |      let method = Method(Inner::PUT);  \n     |                   ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1103:26\n     |\n1103 |      let method = Method(Inner::PUT);  \n     |                          ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:131\n     |\n1104 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:28\n     |\n1105 |      let version = Version(Http::HTTP_1_0);  \n     |                            ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:30\n     |\n1086 |      let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                              ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:77\n     |\n1086 | ...::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |      let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                                                             ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:20\n     |\n1087 |      let version = Version(Http::HTTP_1_0);  \n     |                    ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:30\n     |\n1104 |      let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAnd...\n     |                              ^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:77\n     |\n1104 | ...::HTTP), authority: Some(Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |      let uri = Uri { scheme: Some(Scheme::HTTP), authority: Some(Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };  \n     |                                                                             ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:20\n     |\n1105 |      let version = Version(Http::HTTP_1_0);  \n     |                    ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |      let version = version(Http::HTTP_1_0);  \n     |                    ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 13 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:154\n     |\n1086 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:27\n     |\n1087 |     let version = Version(Http::HTTP_1_0);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:154\n     |\n1104 | ...pty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:27\n     |\n1105 |     let version = Version(Http::HTTP_1_0);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:29\n     |\n1086 |     let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from_str(\"empty.com\").unwrap()), path_...\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:100\n     |\n1086 | ...hority: Some(crate::uri::Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |     let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                                                                                    ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:19\n     |\n1087 |     let version = Version(Http::HTTP_1_0);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:29\n     |\n1104 |     let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from_str(\"empty.com\").unwrap()), path_...\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:100\n     |\n1104 | ...hority: Some(crate::uri::Authority::from_str(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |     let uri = Uri { scheme: Some(crate::uri::Scheme::HTTP), authority: Some(crate::uri::Authority::from(\"empty.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/\").unwrap()) };\n     |                                                                                                    ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:19\n     |\n1105 |     let version = Version(Http::HTTP_1_0);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |     let version = version(Http::HTTP_1_0);\n     |                   ~~~~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 10 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let method = Method(Inner::DELETE);",
                "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                "    let version = Version(Http::HTTP_1_1);",
                "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                "    let extensions = Extensions::default();",
                "    let body = \"delete content\";",
                "",
                "    let request = Request::new(body);",
                "    request.head = Parts {",
                "        method,",
                "        uri,",
                "        version,",
                "        headers,",
                "        extensions,",
                "        _priv: (),",
                "    };",
                "",
                "    let _ = format!(\"{:?}\", request);",
                "}"
              ],
              "oracles": [
                [
                  "    let method = Method(Inner::DELETE);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"method: DELETE\"), true);"
                ],
                [
                  "    let method = Method(Inner::DELETE);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"uri: https://large-headers.com/data\"), true);"
                ],
                [
                  "    let method = Method(Inner::DELETE);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"version: HTTP/1.1\"), true);"
                ],
                [
                  "    let method = Method(Inner::DELETE);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"headers: \"), true);"
                ],
                [
                  "    let method = Method(Inner::DELETE);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"body: delete content\"), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  " let method = Method::DELETE;  ",
                  " let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  ",
                  " let version = Version(Http::HTTP_1_1);  ",
                  " let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  ",
                  " let extensions = Extensions::default();  ",
                  " let body = \"delete content\";  ",
                  "",
                  " let request = Request::new(body);  ",
                  " request.head = Parts {  ",
                  "     method,  ",
                  "     uri,  ",
                  "     version,  ",
                  "     headers,  ",
                  "     extensions,  ",
                  "     _priv: (),  ",
                  " };  ",
                  "",
                  " let _ = format!(\"{:?}\", request);  ",
                  " let method = Method::DELETE;  ",
                  " let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  ",
                  " let version = Version(Http::HTTP_1_1);  ",
                  " let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  ",
                  " let extensions = Extensions::default();  ",
                  " let body = \"delete content\";  ",
                  " let request = Request::new(body);  ",
                  " request.head = Parts {  ",
                  "     method,  ",
                  "     uri,  ",
                  "     version,  ",
                  "     headers,  ",
                  "     extensions,  ",
                  "     _priv: (),  ",
                  " };  ",
                  " assert_eq!(format!(\"{:?}\", request).contains(\"method: DELETE\"), true);",
                  "}"
                ],
                [
                  "{",
                  "  use crate::uri::{Scheme, Authority}; // Added import for Scheme and Authority  ",
                  "  let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  ",
                  "   let version = Version(Http::HTTP_1_1);  ",
                  "   let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  ",
                  "   let extensions = Extensions::default();  ",
                  "   let body = \"delete content\";  ",
                  " ",
                  "   let request = Request::new(body);  ",
                  "   request.head = Parts {  ",
                  "       method,  ",
                  "       uri,  ",
                  "       version,  ",
                  "       headers,  ",
                  "       extensions,  ",
                  "       _priv: (),  ",
                  "   };  ",
                  " ",
                  "   let _ = format!(\"{:?}\", request);  ",
                  "   let method = Method(Inner::DELETE);  ",
                  "   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  ",
                  "   let version = Version(Http::HTTP_1_1);  ",
                  "   let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  ",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"uri: https://large-headers.com/data\"), true);",
                  "}"
                ],
                [
                  "{",
                  "  use crate::uri::{Authority, Scheme}; // Added import for Authority and Scheme",
                  "  let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "        method,",
                  "        uri,",
                  "        version,",
                  "        headers,",
                  "        extensions,",
                  "        _priv: (),",
                  "    };",
                  "",
                  "    let _ = format!(\"{:?}\", request);",
                  "    let method = Method(Inner::DELETE);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"version: HTTP/1.1\"), true);",
                  "}"
                ],
                [
                  "{",
                  " let method = Method(Method::DELETE.0);  ",
                  "  use crate::uri::Authority;  ",
                  "  use crate::uri::Scheme; ",
                  "   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  ",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "        method,",
                  "        uri,",
                  "        version,",
                  "        headers,",
                  "        extensions,",
                  "        _priv: (),",
                  "    };",
                  "",
                  "    let _ = format!(\"{:?}\", request);",
                  "    let method = Method(Inner::DELETE);",
                  "    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "    let version = Version(Http::HTTP_1_1);",
                  "    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "    let extensions = Extensions::default();",
                  "    let body = \"delete content\";",
                  "    let request = Request::new(body);",
                  "    request.head = Parts {",
                  "    method,",
                  "    uri,",
                  "    version,",
                  "    headers,",
                  "    extensions,",
                  "    _priv: (),",
                  "    };",
                  "    assert_eq!(format!(\"{:?}\", request).contains(\"headers: \"), true);",
                  "}"
                ],
                [
                  "{",
                  " let method = Method::DELETE;",
                  " let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "  let version = Version(Http::HTTP_1_1);",
                  "  let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "  let extensions = Extensions::default();",
                  "  let body = \"delete content\";",
                  "  ",
                  "  let request = Request::new(body);",
                  "  request.head = Parts {",
                  "      method,",
                  "      uri,",
                  "      version,",
                  "      headers,",
                  "      extensions,",
                  "      _priv: (),",
                  "  };",
                  "  ",
                  "  let _ = format!(\"{:?}\", request);",
                  "  let method = Method::DELETE;",
                  "  let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };",
                  "  let version = Version(Http::HTTP_1_1);",
                  "  let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));",
                  "   let extensions = Extensions::default();",
                  "   let body = \"delete content\";",
                  "   let request = Request::new(body);",
                  "   request.head = Parts {",
                  "       method,",
                  "       uri,",
                  "       version,",
                  "       headers,",
                  "       extensions,",
                  "       _priv: (),",
                  "   };",
                  "   assert_eq!(format!(\"{:?}\", request).contains(\"body: delete content\"), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:160\n     |\n1086 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:24\n     |\n1087 |  let version = Version(Http::HTTP_1_1);  \n     |                        ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Authority`\n    --> src/request.rs:1104:75\n     |\n1104 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_qu...\n     |                                                                           ^^^^^^^^^ use of undeclared type `Authority`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::Authority;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:148\n     |\n1104 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:24\n     |\n1105 |  let version = Version(Http::HTTP_1_1);  \n     |                        ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:26\n     |\n1086 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()),...\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:98\n     |\n1086 | ...hority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(crate::uri::Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                                                                                  ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:16\n     |\n1087 |  let version = Version(Http::HTTP_1_1);  \n     |                ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1088:42\n     |\n1088 |  let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), H...\n     |                                          ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1088:83\n     |\n1088 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1088 |  let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                                                                   ~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:26\n     |\n1104 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_qu...\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:16\n     |\n1105 |  let version = Version(Http::HTTP_1_1);  \n     |                ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |  let version = version(Http::HTTP_1_1);  \n     |                ~~~~~~~\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1106:42\n     |\n1106 |  let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), H...\n     |                                          ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1106:83\n     |\n1106 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1106 |  let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                                                                   ~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 14 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:137\n     |\n1086 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:26\n     |\n1087 |    let version = Version(Http::HTTP_1_1);  \n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0425]: cannot find value `method` in this scope\n    --> src/request.rs:1094:8\n     |\n1094 |        method,  \n     |        ^^^^^^ not found in this scope\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1103:17\n     |\n1103 |    let method = Method(Inner::DELETE);  \n     |                 ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1103:24\n     |\n1103 |    let method = Method(Inner::DELETE);  \n     |                        ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:138\n     |\n1104 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:26\n     |\n1105 |    let version = Version(Http::HTTP_1_1);  \n     |                          ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:27\n     |\n1086 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(P...\n     |                           ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:75\n     |\n1086 | ...:HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                                                           ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:18\n     |\n1087 |    let version = Version(Http::HTTP_1_1);  \n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1088:44\n     |\n1088 |    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(),...\n     |                                            ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1088:85\n     |\n1088 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1088 |    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                                                                     ~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:28\n     |\n1104 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(...\n     |                            ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:76\n     |\n1104 | ...:HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                                                            ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:18\n     |\n1105 |    let version = Version(Http::HTTP_1_1);  \n     |                  ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |    let version = version(Http::HTTP_1_1);  \n     |                  ~~~~~~~\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1106:44\n     |\n1106 |    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(),...\n     |                                            ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1106:85\n     |\n1106 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1106 |    let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));  \n     |                                                                                     ~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 17 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:137\n     |\n1086 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:27\n     |\n1087 |     let version = Version(Http::HTTP_1_1);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0425]: cannot find value `method` in this scope\n    --> src/request.rs:1094:9\n     |\n1094 |         method,\n     |         ^^^^^^ not found in this scope\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1103:18\n     |\n1103 |     let method = Method(Inner::DELETE);\n     |                  ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1103:25\n     |\n1103 |     let method = Method(Inner::DELETE);\n     |                         ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:139\n     |\n1104 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:27\n     |\n1105 |     let version = Version(Http::HTTP_1_1);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:27\n     |\n1086 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(P...\n     |                           ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:75\n     |\n1086 | ...:HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                                                           ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:19\n     |\n1087 |     let version = Version(Http::HTTP_1_1);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1088:45\n     |\n1088 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap()...\n     |                                             ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1088:86\n     |\n1088 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1088 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                                                                      ~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1104:29\n     |\n1104 |     let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some...\n     |                             ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:77\n     |\n1104 | ...:HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |     let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                                                             ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:19\n     |\n1105 |     let version = Version(Http::HTTP_1_1);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |     let version = version(Http::HTTP_1_1);\n     |                   ~~~~~~~\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1106:45\n     |\n1106 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap()...\n     |                                             ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1106:86\n     |\n1106 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1106 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                                                                      ~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 17 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1085:15\n     |\n1085 |  let method = Method(Method::DELETE.0);  \n     |               ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1088:138\n     |\n1088 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1089:27\n     |\n1089 |     let version = Version(Http::HTTP_1_1);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:18\n     |\n1105 |     let method = Method(Inner::DELETE);\n     |                  ^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/method.rs:45:19\n     |\n45   | pub struct Method(Inner);\n     |                   ^^^^^ private field\nnote: tuple variant `crate::error::ErrorKind::Method` exists but is inaccessible\n    --> src/error.rs:26:5\n     |\n26   |     Method(method::InvalidMethod),\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\nhelp: consider making the field publicly accessible\n    -->  src/method.rs:45:19\n     |\n45   | pub struct Method(pub Inner);\n     |                   +++\nhelp: a local variable with a similar name exists\n     |\n1105 |     let method = method(Inner::DELETE);\n     |                  ~~~~~~\n\nerror[E0433]: failed to resolve: use of undeclared type `Inner`\n    --> src/request.rs:1105:25\n     |\n1105 |     let method = Method(Inner::DELETE);\n     |                         ^^^^^ use of undeclared type `Inner`\n     |\nnote: enum `crate::method::Inner` exists but is inaccessible\n    --> src/method.rs:53:1\n     |\n53   | enum Inner {\n     | ^^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1106:139\n     |\n1106 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1107:27\n     |\n1107 |     let version = Version(Http::HTTP_1_1);\n     |                           ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0616]: field `0` of struct `method::Method` is private\n    --> src/request.rs:1085:37\n     |\n1085 |  let method = Method(Method::DELETE.0);  \n     |                                     ^ private field\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1088:28\n     |\n1088 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(...\n     |                            ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1088:76\n     |\n1088 | ...:HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1088 |    let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };  \n     |                                                                            ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1089:19\n     |\n1089 |     let version = Version(Http::HTTP_1_1);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1090:45\n     |\n1090 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap()...\n     |                                             ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1090:86\n     |\n1090 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1090 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                                                                      ~~~~\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1106:29\n     |\n1106 |     let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some...\n     |                             ^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1106:77\n     |\n1106 | ...:HTTPS), authority: Some(Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1106 |     let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                                                             ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1107:19\n     |\n1107 |     let version = Version(Http::HTTP_1_1);\n     |                   ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1107 |     let version = version(Http::HTTP_1_1);\n     |                   ~~~~~~~\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1108:45\n     |\n1108 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap()...\n     |                                             ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1108:86\n     |\n1108 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1108 |     let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                                                                      ~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599, E0616.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 18 previous errors; 14 warnings emitted\n"
                },
                {
                  "Err": "   Compiling http v1.3.1 (/home/abezbm/rust-utgen-test-crates-new/http)\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1086:160\n     |\n1086 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1087:25\n     |\n1087 |   let version = Version(Http::HTTP_1_1);\n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nerror[E0433]: failed to resolve: use of undeclared type `Scheme`\n    --> src/request.rs:1104:32\n     |\n1104 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()), path_and_q...\n     |                                ^^^^^^ use of undeclared type `Scheme`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::Scheme;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathAndQuery`\n    --> src/request.rs:1104:149\n     |\n1104 | ...ers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                              ^^^^^^^^^^^^ use of undeclared type `PathAndQuery`\n     |\nhelp: consider importing this struct through its public re-export\n     |\n1077 +    use crate::uri::PathAndQuery;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Http`\n    --> src/request.rs:1105:25\n     |\n1105 |   let version = Version(Http::HTTP_1_1);\n     |                         ^^^^ use of undeclared type `Http`\n     |\nnote: enum `crate::version::Http` exists but is inaccessible\n    --> src/version.rs:46:1\n     |\n46   | enum Http {\n     | ^^^^^^^^^ not accessible\n\nwarning: unused import: `self::StandardHeader::Vary`\n    --> src/header/name.rs:1676:9\n     |\n1676 |     use self::StandardHeader::Vary;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:481:9\n    |\n481 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::map::HeaderMap`\n   --> src/header/value.rs:482:9\n    |\n482 |     use crate::header::map::HeaderMap;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:483:9\n    |\n483 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/header/value.rs:568:9\n    |\n568 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `crate::header::name`\n   --> src/header/value.rs:569:9\n    |\n569 |     use crate::header::name;\n    |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/method.rs:424:9\n    |\n424 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n    --> src/request.rs:1063:9\n     |\n1063 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/response.rs:776:9\n    |\n776 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/authority.rs:533:9\n    |\n533 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/builder.rs:165:9\n    |\n165 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/uri/port.rs:115:9\n    |\n115 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/error.rs:143:9\n    |\n143 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> src/lib.rs:197:9\n    |\n197 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> src/request.rs:1086:26\n     |\n1086 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()),...\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Scheme`, found `Option<Scheme>`\n     |\n     = note: expected struct `scheme::Scheme`\n                  found enum `Option<scheme::Scheme>`\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1086:98\n     |\n1086 | ...hority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1086 |  let uri = Uri { scheme: Some(crate::uri::Scheme::HTTPS), authority: Some(crate::uri::Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                                                                                  ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1087:17\n     |\n1087 |   let version = Version(Http::HTTP_1_1);\n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1088:43\n     |\n1088 |   let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), ...\n     |                                           ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1088:84\n     |\n1088 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1088 |   let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                                                                    ~~~~\n\nerror[E0599]: no function or associated item named `from_str` found for struct `Authority` in the current scope\n    --> src/request.rs:1104:87\n     |\n1104 | ...hority: Some(crate::uri::Authority::from_str(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwr...\n     |                                        ^^^^^^^^ function or associated item not found in `Authority`\n     |\n    ::: src/uri/authority.rs:13:1\n     |\n13   | pub struct Authority {\n     | -------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `Authority` consider using one of the following associated functions:\n      Authority::from_static\n      Authority::from_maybe_shared\n    --> src/uri/authority.rs:48:5\n     |\n48   |       pub fn from_static(src: &'static str) -> Self {\n     |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n57   | /     pub fn from_maybe_shared<T>(src: T) -> Result<Self, InvalidUri>\n58   | |     where\n59   | |         T: AsRef<[u8]> + 'static,\n     | |_________________________________^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1104 |   let uri = Uri { scheme: Some(Scheme::HTTPS), authority: Some(crate::uri::Authority::from(\"large-headers.com\").unwrap()), path_and_query: Some(PathAndQuery::from_str(\"/data\").unwrap()) };\n     |                                                                                       ~~~~\n\nerror[E0423]: cannot initialize a tuple struct which contains private fields\n    --> src/request.rs:1105:17\n     |\n1105 |   let version = Version(Http::HTTP_1_1);\n     |                 ^^^^^^^\n     |\nnote: constructor is not visible here due to private fields\n    --> src/version.rs:26:20\n     |\n26   | pub struct Version(Http);\n     |                    ^^^^ private field\nhelp: consider making the field publicly accessible\n    -->  src/version.rs:26:20\n     |\n26   | pub struct Version(pub Http);\n     |                    +++\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n     |\n1105 |   let version = version(Http::HTTP_1_1);\n     |                 ~~~~~~~\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `map::HeaderMap` in the current scope\n    --> src/request.rs:1106:43\n     |\n1106 |   let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), ...\n     |                                           ^^^^^^^^^ function or associated item not found in `HeaderMap`\n     |\n    ::: src/header/map.rs:45:1\n     |\n45   | pub struct HeaderMap<T = HeaderValue> {\n     | ------------------------------------- function or associated item `from_iter` not found for this struct\n     |\nnote: if you're trying to build a new `map::HeaderMap` consider using one of the following associated functions:\n      map::HeaderMap::new\n      map::HeaderMap::<T>::with_capacity\n      map::HeaderMap::<T>::try_with_capacity\n    --> src/header/map.rs:448:5\n     |\n448  |     pub fn new() -> Self {\n     |     ^^^^^^^^^^^^^^^^^^^^\n...\n476  |     pub fn with_capacity(capacity: usize) -> HeaderMap<T> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n502  |     pub fn try_with_capacity(capacity: usize) -> Result<HeaderMap<T>, MaxSizeReached> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromIterator` which provides `from_iter` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::iter::FromIterator;\n     |\n\nerror[E0599]: no function or associated item named `from_str` found for struct `name::HeaderName` in the current scope\n    --> src/request.rs:1106:84\n     |\n1106 | ...iter((0..1000).map(|i| (HeaderName::from_str(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                        ^^^^^^^^ function or associated item not found in `HeaderName`\n     |\n    ::: src/header/name.rs:33:1\n     |\n33   | pub struct HeaderName {\n     | --------------------- function or associated item `from_str` not found for this struct\n     |\nnote: if you're trying to build a new `name::HeaderName` consider using one of the following associated functions:\n      name::HeaderName::from_bytes\n      name::HeaderName::from_lowercase\n      name::HeaderName::from_static\n    --> src/header/name.rs:1115:5\n     |\n1115 |     pub fn from_bytes(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1169 |     pub fn from_lowercase(src: &[u8]) -> Result<HeaderName, InvalidHeaderName> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n1256 |     pub const fn from_static(src: &'static str) -> HeaderName {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `FromStr` which provides `from_str` is implemented but not in scope; perhaps you want to import it\n     |\n1077 +    use std::str::FromStr;\n     |\nhelp: there is an associated function `from` with a similar name\n     |\n1106 |   let headers = HeaderMap::<HeaderValue>::from_iter((0..1000).map(|i| (HeaderName::from(&format!(\"X-Custom-Header-{}\", i)).unwrap(), HeaderValue::from_str(\"value\").unwrap())));\n     |                                                                                    ~~~~\n\nSome errors have detailed explanations: E0308, E0423, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `http` (lib test) generated 14 warnings\nerror: could not compile `http` (lib test) due to 14 previous errors; 14 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}