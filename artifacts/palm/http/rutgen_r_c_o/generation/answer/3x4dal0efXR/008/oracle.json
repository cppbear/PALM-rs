[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(16);",
          "    header_map.entries.push(Bucket {",
          "        hash: HashValue(0),",
          "        key: HeaderName::from_static(\"Key1\"),",
          "        value: HeaderValue::from_static(\"Value1\"),",
          "        links: None,",
          "    });",
          "    header_map.danger.set_green();",
          "    header_map.try_reserve_one().unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(0),",
            "    key: HeaderName::from_static(\"Key1\"),",
            "    value: HeaderValue::from_static(\"Value1\"),",
            "    links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    let expected_entries_len = 1;",
            "    let expected_capacity = usable_capacity(16);",
            "    header_map.try_reserve_one().unwrap();",
            "    assert_eq!(header_map.entries.len(), expected_entries_len);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(0),",
            "    key: HeaderName::from_static(\"Key1\"),",
            "    value: HeaderValue::from_static(\"Value1\"),",
            "    links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    let expected_entries_len = 1;",
            "    let expected_capacity = usable_capacity(16);",
            "    header_map.try_reserve_one().unwrap();",
            "    assert_eq!(header_map.capacity(), expected_capacity);"
          ],
          [
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(0),",
            "    key: HeaderName::from_static(\"Key1\"),",
            "    value: HeaderValue::from_static(\"Value1\"),",
            "    links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    let expected_entries_len = 1;",
            "    let expected_capacity = usable_capacity(16);",
            "    header_map.try_reserve_one().unwrap();",
            "    assert!(header_map.danger.is_green());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "        hash: HashValue(0),",
            "        key: HeaderName::from_static(\"Key1\"),",
            "        value: HeaderValue::from_static(\"Value1\"),",
            "        links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(0),",
            "    key: HeaderName::from_static(\"Key1\"),",
            "    value: HeaderValue::from_static(\"Value1\"),",
            "    links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    let expected_entries_len = 1;",
            "    let expected_capacity = usable_capacity(16);",
            "    header_map.try_reserve_one().unwrap();",
            "    assert_eq!(header_map.entries.len(), expected_entries_len);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "        hash: HashValue(0),",
            "        key: HeaderName::from_static(\"Key1\"),",
            "        value: HeaderValue::from_static(\"Value1\"),",
            "        links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(0),",
            "    key: HeaderName::from_static(\"Key1\"),",
            "    value: HeaderValue::from_static(\"Value1\"),",
            "    links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    let expected_entries_len = 1;",
            "    let expected_capacity = usable_capacity(16);",
            "    header_map.try_reserve_one().unwrap();",
            "    assert_eq!(header_map.capacity(), expected_capacity);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "        hash: HashValue(0),",
            "        key: HeaderName::from_static(\"Key1\"),",
            "        value: HeaderValue::from_static(\"Value1\"),",
            "        links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let mut header_map = HeaderMap::with_capacity(16);",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(0),",
            "    key: HeaderName::from_static(\"Key1\"),",
            "    value: HeaderValue::from_static(\"Value1\"),",
            "    links: None,",
            "    });",
            "    header_map.danger.set_green();",
            "    let expected_entries_len = 1;",
            "    let expected_capacity = usable_capacity(16);",
            "    header_map.try_reserve_one().unwrap();",
            "    assert!(header_map.danger.is_green());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(32);",
          "    for i in 0..15 {",
          "        header_map.entries.push(Bucket {",
          "            hash: HashValue(i),",
          "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
          "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
          "            links: None,",
          "        });",
          "    }",
          "    header_map.danger.set_green();",
          "    header_map.try_reserve_one().unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.entries.len(), initial_len);"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), initial_capacity);"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.danger.is_green());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(32);",
            "    for i in 0..15 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(32);",
            "    for i in 0..15 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.entries.len(), initial_len);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(32);",
            "    for i in 0..15 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), initial_capacity);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(32);",
            "    for i in 0..15 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(32);",
            "    let initial_len = 15;",
            "    let initial_capacity = 32;",
            "    header_map.entries.push(Bucket { hash: HashValue(0), key: HeaderName::from_static(\"Key0\"), value: HeaderValue::from_static(\"Value0\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(1), key: HeaderName::from_static(\"Key1\"), value: HeaderValue::from_static(\"Value1\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(2), key: HeaderName::from_static(\"Key2\"), value: HeaderValue::from_static(\"Value2\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(3), key: HeaderName::from_static(\"Key3\"), value: HeaderValue::from_static(\"Value3\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(4), key: HeaderName::from_static(\"Key4\"), value: HeaderValue::from_static(\"Value4\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(5), key: HeaderName::from_static(\"Key5\"), value: HeaderValue::from_static(\"Value5\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(6), key: HeaderName::from_static(\"Key6\"), value: HeaderValue::from_static(\"Value6\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(7), key: HeaderName::from_static(\"Key7\"), value: HeaderValue::from_static(\"Value7\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(8), key: HeaderName::from_static(\"Key8\"), value: HeaderValue::from_static(\"Value8\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(9), key: HeaderName::from_static(\"Key9\"), value: HeaderValue::from_static(\"Value9\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(10), key: HeaderName::from_static(\"Key10\"), value: HeaderValue::from_static(\"Value10\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(11), key: HeaderName::from_static(\"Key11\"), value: HeaderValue::from_static(\"Value11\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(12), key: HeaderName::from_static(\"Key12\"), value: HeaderValue::from_static(\"Value12\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(13), key: HeaderName::from_static(\"Key13\"), value: HeaderValue::from_static(\"Value13\"), links: None });",
            "    header_map.entries.push(Bucket { hash: HashValue(14), key: HeaderName::from_static(\"Key14\"), value: HeaderValue::from_static(\"Value14\"), links: None });",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.danger.is_green());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(64);",
          "    for i in 0..31 {",
          "        header_map.entries.push(Bucket {",
          "            hash: HashValue(i),",
          "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
          "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
          "            links: None,",
          "        });",
          "    }",
          "    header_map.danger.set_green();",
          "    header_map.try_reserve_one().unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 128);"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.len(), 31);"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.danger.is_green());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 128);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.len(), 31);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(64);",
            "    for i in 0..31 {",
            "    header_map.entries.push(Bucket {",
            "    hash: HashValue(i),",
            "    key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "    value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "    links: None,",
            "    });",
            "    }",
            "    header_map.danger.set_green();",
            "    let result = header_map.try_reserve_one();",
            "    assert!(header_map.danger.is_green());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(128);",
          "    for i in 0..63 {",
          "        header_map.entries.push(Bucket {",
          "            hash: HashValue(i),",
          "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
          "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
          "            links: None,",
          "        });",
          "    }",
          "    header_map.danger.set_green();",
          "    header_map.try_reserve_one().unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.indices.len(), initial_capacity);"
          ],
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.entries.len(), initial_length);"
          ],
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.danger.is_yellow(), false);"
          ],
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.danger.is_green(), true);"
          ],
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert!(header_map.try_grow(new_capacity).is_ok());"
          ],
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.indices.len(), new_capacity);"
          ],
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.entries.len(), initial_length);"
          ],
          [
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.danger.is_green(), true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.indices.len(), initial_capacity);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.entries.len(), initial_length);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.danger.is_yellow(), false);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.danger.is_green(), true);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert!(header_map.try_grow(new_capacity).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.indices.len(), new_capacity);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.entries.len(), initial_length);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(128);",
            "    for i in 0..63 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let initial_length = header_map.entries.len();",
            "    let initial_capacity = header_map.capacity();",
            "    let new_capacity = initial_capacity * 2;",
            "    assert_eq!(header_map.danger.is_green(), true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map = HeaderMap::with_capacity(256);",
          "    for i in 0..127 {",
          "        header_map.entries.push(Bucket {",
          "            hash: HashValue(i),",
          "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
          "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
          "            links: None,",
          "        });",
          "    }",
          "    header_map.danger.set_green();",
          "    header_map.try_reserve_one().unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let header_map = HeaderMap::with_capacity(256);",
            "    assert_eq!(header_map.entries.len(), 127);"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(256);",
            "    assert!(header_map.danger.is_green());"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(256);",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(256);",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.entries.len(), 127);"
          ],
          [
            "    let header_map = HeaderMap::with_capacity(256);",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 256);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    for i in 0..127 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(256);",
            "    assert_eq!(header_map.entries.len(), 127);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    for i in 0..127 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(256);",
            "    assert!(header_map.danger.is_green());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    for i in 0..127 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(256);",
            "    let result = header_map.try_reserve_one();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    for i in 0..127 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(256);",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.entries.len(), 127);",
            "}"
          ],
          [
            "{",
            "    let mut header_map = HeaderMap::with_capacity(256);",
            "    for i in 0..127 {",
            "        header_map.entries.push(Bucket {",
            "            hash: HashValue(i),",
            "            key: HeaderName::from_static(&format!(\"Key{}\", i)),",
            "            value: HeaderValue::from_static(&format!(\"Value{}\", i)),",
            "            links: None,",
            "        });",
            "    }",
            "    header_map.danger.set_green();",
            "    header_map.try_reserve_one().unwrap();",
            "    let header_map = HeaderMap::with_capacity(256);",
            "    let result = header_map.try_reserve_one();",
            "    assert_eq!(header_map.capacity(), 256);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]