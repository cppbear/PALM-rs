[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let method = Method(\"GET\".into());",
          "    let uri = Uri {",
          "        scheme: Scheme(\"http\".into()),",
          "        authority: Authority(\"example.com\".into()),",
          "        path_and_query: PathAndQuery(\"/path?query\".into()),",
          "    };",
          "    let version = Version(Http(\"HTTP/1.1\".into()));",
          "    let headers = HeaderMap {",
          "        mask: Size::default(),",
          "        indices: Box::new([]),",
          "        entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
          "        extra_values: vec![],",
          "        danger: Danger::default(),",
          "    };",
          "    let extensions = Extensions::default();",
          "    ",
          "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
          "    let _ = fmt::format(&parts);",
          "}"
        ],
        "oracles": [
          [
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"Parts\"));"
          ],
          [
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"method: GET\"));"
          ],
          [
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"uri: http://example.com/path?query\"));"
          ],
          [
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"version: HTTP/1.1\"));"
          ],
          [
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"headers: Content-Type: application/json\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"Parts\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"method: GET\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"uri: http://example.com/path?query\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"version: HTTP/1.1\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"GET\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/path?query\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Content-Type\".into()), value: HeaderValue { inner: Bytes::from(\"application/json\"), is_sensitive: false } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let result = fmt::format(&parts);",
            "    assert!(result.contains(\"headers: Content-Type: application/json\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let method = Method(\"POST\".into());",
          "    let uri = Uri {",
          "        scheme: Scheme(\"https\".into()),",
          "        authority: Authority(\"example.org\".into()),",
          "        path_and_query: PathAndQuery(\"/api/data\".into()),",
          "    };",
          "    let version = Version(Http(\"HTTP/2\".into()));",
          "    let headers = HeaderMap {",
          "        mask: Size::default(),",
          "        indices: Box::new([]),",
          "        entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
          "        extra_values: vec![],",
          "        danger: Danger::default(),",
          "    };",
          "    let extensions = Extensions::default();",
          "    ",
          "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
          "    let _ = fmt::format(&parts);",
          "}"
        ],
        "oracles": [
          [
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"POST\"));"
          ],
          [
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"https\"));"
          ],
          [
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"HTTP/2\"));"
          ],
          [
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"Authorization\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"example.org\".into()),",
            "        path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"POST\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"example.org\".into()),",
            "        path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"https\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"example.org\".into()),",
            "        path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"HTTP/2\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"example.org\".into()),",
            "        path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"POST\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"https\".into()),",
            "    authority: Authority(\"example.org\".into()),",
            "    path_and_query: PathAndQuery(\"/api/data\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/2\".into()));",
            "    let headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: vec![Bucket { key: HeaderName(\"Authorization\".into()), value: HeaderValue { inner: Bytes::from(\"Bearer token\"), is_sensitive: true } }],",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts { method, uri, version, headers, extensions: Extensions::default(), _priv: () };",
            "    assert!(fmt::format(&parts).contains(\"Authorization\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let method = Method(\"DELETE\".into());",
          "    let uri = Uri {",
          "        scheme: Scheme(\"http\".into()),",
          "        authority: Authority(\"api.example.com\".into()),",
          "        path_and_query: PathAndQuery(\"/resource/1\".into()),",
          "    };",
          "    let version = Version(Http(\"HTTP/1.0\".into()));",
          "    let mut headers = HeaderMap {",
          "        mask: Size::default(),",
          "        indices: Box::new([]),",
          "        entries: Vec::with_capacity(100),",
          "        extra_values: vec![],",
          "        danger: Danger::default(),",
          "    };",
          "    ",
          "    for i in 0..100 {",
          "        headers.entries.push(Bucket {",
          "            key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
          "            value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
          "        });",
          "    }",
          "",
          "    let extensions = Extensions::default();",
          "    ",
          "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
          "    let _ = fmt::format(&parts);",
          "}"
        ],
        "oracles": [
          [
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"method: DELETE\"));"
          ],
          [
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"uri: http://api.example.com/resource/1\"));"
          ],
          [
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"version: HTTP/1.0\"));"
          ],
          [
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"headers:\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"api.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: Vec::with_capacity(100),",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    ",
            "    for i in 0..100 {",
            "        headers.entries.push(Bucket {",
            "            key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "            value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "        });",
            "    }",
            "",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"method: DELETE\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"api.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: Vec::with_capacity(100),",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    ",
            "    for i in 0..100 {",
            "        headers.entries.push(Bucket {",
            "            key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "            value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "        });",
            "    }",
            "",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"uri: http://api.example.com/resource/1\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"api.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: Vec::with_capacity(100),",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    ",
            "    for i in 0..100 {",
            "        headers.entries.push(Bucket {",
            "            key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "            value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "        });",
            "    }",
            "",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"version: HTTP/1.0\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"http\".into()),",
            "        authority: Authority(\"api.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: Vec::with_capacity(100),",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    ",
            "    for i in 0..100 {",
            "        headers.entries.push(Bucket {",
            "            key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "            value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "        });",
            "    }",
            "",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"DELETE\".into());",
            "    let uri = Uri {",
            "    scheme: Scheme(\"http\".into()),",
            "    authority: Authority(\"api.example.com\".into()),",
            "    path_and_query: PathAndQuery(\"/resource/1\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.0\".into()));",
            "    let mut headers = HeaderMap {",
            "    mask: Size::default(),",
            "    indices: Box::new([]),",
            "    entries: Vec::with_capacity(100),",
            "    extra_values: vec![],",
            "    danger: Danger::default(),",
            "    };",
            "    for i in 0..100 {",
            "    headers.entries.push(Bucket {",
            "    key: HeaderName(format!(\"X-Custom-Header-{}\", i).into()),",
            "    value: HeaderValue { inner: Bytes::from(\"value\"), is_sensitive: false },",
            "    });",
            "    }",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let formatted = fmt::format(&parts);",
            "    assert!(formatted.contains(\"headers:\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let method = Method(\"OPTIONS\".into());",
          "    let uri = Uri {",
          "        scheme: Scheme(\"https\".into()),",
          "        authority: Authority(\"secure.example.com\".into()),",
          "        path_and_query: PathAndQuery(\"/status\".into()),",
          "    };",
          "    let version = Version(Http(\"HTTP/1.1\".into()));",
          "    let headers = HeaderMap {",
          "        mask: Size::default(),",
          "        indices: Box::new([]),",
          "        entries: vec![],",
          "        extra_values: vec![],",
          "        danger: Danger::default(),",
          "    };",
          "    let extensions = Extensions::default();",
          "    ",
          "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
          "    let _ = fmt::format(&parts);",
          "}"
        ],
        "oracles": [
          [
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert_eq!(output.to_string(), \"Parts { method: OPTIONS, uri: https://secure.example.com/status, version: HTTP/1.1, headers: {} }\");"
          ],
          [
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"method: OPTIONS\"));"
          ],
          [
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"uri: https://secure.example.com/status\"));"
          ],
          [
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"version: HTTP/1.1\"));"
          ],
          [
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"headers: {}\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"secure.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/status\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert_eq!(output.to_string(), \"Parts { method: OPTIONS, uri: https://secure.example.com/status, version: HTTP/1.1, headers: {} }\");",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"secure.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/status\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"method: OPTIONS\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"secure.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/status\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"uri: https://secure.example.com/status\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"secure.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/status\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"version: HTTP/1.1\"));",
            "}"
          ],
          [
            "{",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri {",
            "        scheme: Scheme(\"https\".into()),",
            "        authority: Authority(\"secure.example.com\".into()),",
            "        path_and_query: PathAndQuery(\"/status\".into()),",
            "    };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap {",
            "        mask: Size::default(),",
            "        indices: Box::new([]),",
            "        entries: vec![],",
            "        extra_values: vec![],",
            "        danger: Danger::default(),",
            "    };",
            "    let extensions = Extensions::default();",
            "    ",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let _ = fmt::format(&parts);",
            "    let method = Method(\"OPTIONS\".into());",
            "    let uri = Uri { scheme: Scheme(\"https\".into()), authority: Authority(\"secure.example.com\".into()), path_and_query: PathAndQuery(\"/status\".into()), };",
            "    let version = Version(Http(\"HTTP/1.1\".into()));",
            "    let headers = HeaderMap { mask: Size::default(), indices: Box::new([]), entries: vec![], extra_values: vec![], danger: Danger::default(), };",
            "    let extensions = Extensions::default();",
            "    let parts = Parts { method, uri, version, headers, extensions, _priv: () };",
            "    let output = fmt::format(&parts);",
            "    assert!(output.contains(\"headers: {}\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]