[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
          "    let hash = HashValue(1);",
          "    let key = HeaderName { inner: Repr::custom() };",
          "    let value = 42;",
          "    header_map.try_insert_entry(hash, key, value).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries.len(), 1);"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries[0].hash, hash);"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries[0].key, key);"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries[0].value, value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries[0].hash, hash);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries[0].key, key);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(10);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    header_map.try_insert_entry(hash, key, value).unwrap();",
            "    assert_eq!(header_map.entries[0].value, value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32767);",
          "    let hash = HashValue(1);",
          "    let key = HeaderName { inner: Repr::custom() };",
          "    let value = 42;",
          "    for i in 0..32767 {",
          "        header_map.try_insert_entry(HashValue(i as u16), key.clone(), value).unwrap();",
          "    }",
          "    ",
          "    let err = header_map.try_insert_entry(hash, key, value);",
          "    assert!(err.is_err());",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32767);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    for i in 0..32767 {",
            "    header_map.try_insert_entry(HashValue(i as u16), key.clone(), value).unwrap();",
            "    }",
            "    assert_eq!(header_map.entries.len(), 32767);"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32767);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    for i in 0..32767 {",
            "    header_map.try_insert_entry(HashValue(i as u16), key.clone(), value).unwrap();",
            "    }",
            "    let err = header_map.try_insert_entry(hash, key, value);",
            "    assert!(err.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32767);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    for i in 0..32767 {",
            "        header_map.try_insert_entry(HashValue(i as u16), key.clone(), value).unwrap();",
            "    }",
            "    ",
            "    let err = header_map.try_insert_entry(hash, key, value);",
            "    assert!(err.is_err());",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32767);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    for i in 0..32767 {",
            "    header_map.try_insert_entry(HashValue(i as u16), key.clone(), value).unwrap();",
            "    }",
            "    assert_eq!(header_map.entries.len(), 32767);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32767);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    for i in 0..32767 {",
            "        header_map.try_insert_entry(HashValue(i as u16), key.clone(), value).unwrap();",
            "    }",
            "    ",
            "    let err = header_map.try_insert_entry(hash, key, value);",
            "    assert!(err.is_err());",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32767);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = 42;",
            "    for i in 0..32767 {",
            "    header_map.try_insert_entry(HashValue(i as u16), key.clone(), value).unwrap();",
            "    }",
            "    let err = header_map.try_insert_entry(hash, key, value);",
            "    assert!(err.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
          "    for i in 0..15 {",
          "        let hash = HashValue(i as u16);",
          "        let key = HeaderName { inner: Repr::custom() };",
          "        let value = i * 10;",
          "        header_map.try_insert_entry(hash, key, value).unwrap();",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    assert_eq!(header_map.try_insert_entry(hash, key, value), Ok(()));"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    }",
            "    assert_eq!(header_map.len(), 15);"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    }",
            "    assert!(!header_map.is_empty());"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    }",
            "    assert_eq!(header_map.capacity(), 15);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "        let hash = HashValue(i as u16);",
            "        let key = HeaderName { inner: Repr::custom() };",
            "        let value = i * 10;",
            "        header_map.try_insert_entry(hash, key, value).unwrap();",
            "    }",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    assert_eq!(header_map.try_insert_entry(hash, key, value), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "        let hash = HashValue(i as u16);",
            "        let key = HeaderName { inner: Repr::custom() };",
            "        let value = i * 10;",
            "        header_map.try_insert_entry(hash, key, value).unwrap();",
            "    }",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    }",
            "    assert_eq!(header_map.len(), 15);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "        let hash = HashValue(i as u16);",
            "        let key = HeaderName { inner: Repr::custom() };",
            "        let value = i * 10;",
            "        header_map.try_insert_entry(hash, key, value).unwrap();",
            "    }",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    }",
            "    assert!(!header_map.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "        let hash = HashValue(i as u16);",
            "        let key = HeaderName { inner: Repr::custom() };",
            "        let value = i * 10;",
            "        header_map.try_insert_entry(hash, key, value).unwrap();",
            "    }",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(15);",
            "    for i in 0..15 {",
            "    let hash = HashValue(i as u16);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let value = i * 10;",
            "    }",
            "    assert_eq!(header_map.capacity(), 15);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
          "    let hash = HashValue(100);",
          "    let key = HeaderName { inner: Repr::custom() };",
          "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
          "",
          "    for value in values {",
          "        header_map.try_insert_entry(hash, key.clone(), value).unwrap();",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "    assert_eq!(header_map.len(), 0);"
          ],
          [
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "    for value in values {",
            "    assert!(header_map.try_insert_entry(hash, key.clone(), value).is_ok());"
          ],
          [
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "    for value in values {",
            "    }",
            "    assert_eq!(header_map.len(), values.len());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "",
            "    for value in values {",
            "        header_map.try_insert_entry(hash, key.clone(), value).unwrap();",
            "    }",
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "    assert_eq!(header_map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "",
            "    for value in values {",
            "        header_map.try_insert_entry(hash, key.clone(), value).unwrap();",
            "    }",
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "    for value in values {",
            "    assert!(header_map.try_insert_entry(hash, key.clone(), value).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "",
            "    for value in values {",
            "        header_map.try_insert_entry(hash, key.clone(), value).unwrap();",
            "    }",
            "    let mut header_map: HeaderMap<String> = HeaderMap::with_capacity(5);",
            "    let hash = HashValue(100);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let values = vec![\"value1\".to_string(), \"value2\".to_string(), \"value3\".to_string()];",
            "    for value in values {",
            "    }",
            "    assert_eq!(header_map.len(), values.len());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
          "    let hash = HashValue(1);",
          "    let key = HeaderName { inner: Repr::custom() };",
          "",
          "    for i in 0..32768 {",
          "        if i < 32767 {",
          "            header_map.try_insert_entry(HashValue(i as u16), key.clone(), i).unwrap();",
          "        } else {",
          "            let err = header_map.try_insert_entry(hash, key.clone(), i);",
          "            assert!(err.is_err());",
          "        }",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let result = header_map.try_insert_entry(HashValue(32767), key.clone(), 32767);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let result = header_map.try_insert_entry(HashValue(32767), key.clone(), 32767);",
            "    assert_eq!(header_map.entries.len(), 32768);"
          ],
          [
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let result = header_map.try_insert_entry(HashValue(32767), key.clone(), 32767);",
            "    assert!(header_map.entries.len() > 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "",
            "    for i in 0..32768 {",
            "        if i < 32767 {",
            "            header_map.try_insert_entry(HashValue(i as u16), key.clone(), i).unwrap();",
            "        } else {",
            "            let err = header_map.try_insert_entry(hash, key.clone(), i);",
            "            assert!(err.is_err());",
            "        }",
            "    }",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let result = header_map.try_insert_entry(HashValue(32767), key.clone(), 32767);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "",
            "    for i in 0..32768 {",
            "        if i < 32767 {",
            "            header_map.try_insert_entry(HashValue(i as u16), key.clone(), i).unwrap();",
            "        } else {",
            "            let err = header_map.try_insert_entry(hash, key.clone(), i);",
            "            assert!(err.is_err());",
            "        }",
            "    }",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let result = header_map.try_insert_entry(HashValue(32767), key.clone(), 32767);",
            "    assert_eq!(header_map.entries.len(), 32768);",
            "}"
          ],
          [
            "{",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "",
            "    for i in 0..32768 {",
            "        if i < 32767 {",
            "            header_map.try_insert_entry(HashValue(i as u16), key.clone(), i).unwrap();",
            "        } else {",
            "            let err = header_map.try_insert_entry(hash, key.clone(), i);",
            "            assert!(err.is_err());",
            "        }",
            "    }",
            "    let mut header_map: HeaderMap<u32> = HeaderMap::with_capacity(32768);",
            "    let hash = HashValue(1);",
            "    let key = HeaderName { inner: Repr::custom() };",
            "    let result = header_map.try_insert_entry(HashValue(32767), key.clone(), 32767);",
            "    assert!(header_map.entries.len() > 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]