[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[should_panic]",
      "fn test_try_insert_entry_when_map_reaches_max_size() {",
      "    let mut map = HeaderMap::with_capacity(1);",
      "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
      "    let value_1 = \"value1\".parse().unwrap();",
      "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
      "    let value_2 = \"value2\".parse().unwrap();",
      "    ",
      "    if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() {",
      "        let _ = v.try_insert_entry(value_1).unwrap();",
      "    }",
      "    ",
      "    if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() {",
      "        let _ = v.try_insert_entry(value_2).unwrap(); // This will panic if map is at max size",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(10);",
          "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
          "    let value = \"test-value\".parse().unwrap();",
          "    ",
          "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
          "        let e = v.try_insert_entry(value).unwrap();",
          "        e.insert(\"new-value\".parse().unwrap());",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    assert_eq!(map.len(), 0);"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    assert!(matches!(entry_1, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    assert_eq!(map.len(), 1);"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    assert!(matches!(entry_2, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    assert!(std::panic::catch_unwind(|| {"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
            "    }).is_err());",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
            "    let value = \"test-value\".parse().unwrap();",
            "    let entry = map.try_entry(\"test-key\").unwrap();",
            "    assert!(matches!(entry, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
            "    }).is_err());",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
            "    let value = \"test-value\".parse().unwrap();",
            "    let entry = map.try_entry(\"test-key\").unwrap();",
            "    let e = entry.try_insert_entry(value).unwrap();",
            "    assert_eq!(map.len(), 1);"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
            "    }).is_err());",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
            "    let value = \"test-value\".parse().unwrap();",
            "    let entry = map.try_entry(\"test-key\").unwrap();",
            "    let e = entry.try_insert_entry(value).unwrap();",
            "    assert_eq!(e.key(), &key);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    assert_eq!(map.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    assert!(matches!(entry_1, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    assert_eq!(map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    assert!(matches!(entry_2, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    assert!(std::panic::catch_unwind(|| {",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
            "    }).is_err());",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
            "    let value = \"test-value\".parse().unwrap();",
            "    let entry = map.try_entry(\"test-key\").unwrap();",
            "    assert!(matches!(entry, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
            "    }).is_err());",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
            "    let value = \"test-value\".parse().unwrap();",
            "    let entry = map.try_entry(\"test-key\").unwrap();",
            "    let e = entry.try_insert_entry(value).unwrap();",
            "    assert_eq!(map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) }; ",
            "    let value = \"test-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"test-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let _ = entry_2.try_insert_entry(value_2).unwrap();",
            "    }).is_err());",
            "    let mut map = HeaderMap::with_capacity(10);",
            "    let key = HeaderName { inner: Repr::new(\"test-key\".to_string()) };",
            "    let value = \"test-value\".parse().unwrap();",
            "    let entry = map.try_entry(\"test-key\").unwrap();",
            "    let e = entry.try_insert_entry(value).unwrap();",
            "    assert_eq!(e.key(), &key);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(1);",
          "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
          "    let value = \"long-value\".repeat(10).parse().unwrap();",
          "    ",
          "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
          "        let e = v.try_insert_entry(value).unwrap();",
          "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    assert!(map.try_entry(\"key1\").is_ok());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    assert!(vacant_entry_1.try_insert_entry(value_1).is_ok());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    assert!(map.try_entry(\"key2\").is_ok());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    assert!(vacant_entry_2.try_insert_entry(value_2).is_err());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    assert!(map.try_entry(\"long-key\".repeat(10)).is_ok());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
            "    assert!(vacant_entry.try_insert_entry(value).is_ok());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
            "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
            "    assert_eq!(occupied_entry.map[occupied_entry.index], \"another-value\".repeat(10).parse().unwrap());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    assert!(map.try_entry(\"key1\").is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    assert!(vacant_entry_1.try_insert_entry(value_1).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    assert!(map.try_entry(\"key2\").is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    assert!(vacant_entry_2.try_insert_entry(value_2).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    assert!(map.try_entry(\"long-key\".repeat(10)).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
            "    assert!(vacant_entry.try_insert_entry(value).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"another-value\".repeat(10).parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let vacant_entry_1 = if let Entry::Vacant(v) = map.try_entry(\"key1\").unwrap() { v } else { panic!() };",
            "    let vacant_entry_2 = if let Entry::Vacant(v) = map.try_entry(\"key2\").unwrap() { v } else { panic!() };",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key = HeaderName { inner: Repr::new(\"long-key\".repeat(10).to_string()) };",
            "    let value = \"long-value\".repeat(10).parse().unwrap();",
            "    let vacant_entry = if let Entry::Vacant(v) = map.try_entry(\"long-key\".repeat(10)).unwrap() { v } else { panic!() };",
            "    let occupied_entry = vacant_entry.try_insert_entry(value).unwrap();",
            "    assert_eq!(occupied_entry.map[occupied_entry.index], \"another-value\".repeat(10).parse().unwrap());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(0);",
          "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
          "    let value = \"value\".parse().unwrap();",
          "    ",
          "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
          "        let e = v.try_insert_entry(value).unwrap();",
          "        e.insert(\"updated-value\".parse().unwrap());",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    assert!(matches!(entry_1, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    assert!(matches!(entry_2, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let result = entry_2.try_insert_entry(value_2);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let result = entry_2.try_insert_entry(value_2);",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
            "    assert!(matches!(entry, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let result = entry_2.try_insert_entry(value_2);",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
            "    let e = entry.try_insert_entry(value).unwrap();",
            "    let updated_value = \"updated-value\".parse().unwrap();",
            "    let old_value = e.insert(updated_value);",
            "    assert_eq!(old_value, &value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"updated-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    assert!(matches!(entry_1, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"updated-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    assert!(matches!(entry_2, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"updated-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let result = entry_2.try_insert_entry(value_2);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"updated-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let result = entry_2.try_insert_entry(value_2);",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
            "    assert!(matches!(entry, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"initial-capacity-key\").unwrap() {",
            "        let e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"updated-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let entry_1 = map.try_entry(\"key1\").unwrap();",
            "    let _ = entry_1.try_insert_entry(value_1).unwrap();",
            "    let entry_2 = map.try_entry(\"key2\").unwrap();",
            "    let result = entry_2.try_insert_entry(value_2);",
            "    let mut map = HeaderMap::with_capacity(0);",
            "    let key = HeaderName { inner: Repr::new(\"initial-capacity-key\".to_string()) };",
            "    let value = \"value\".parse().unwrap();",
            "    let entry = map.try_entry(\"initial-capacity-key\").unwrap();",
            "    let e = entry.try_insert_entry(value).unwrap();",
            "    let updated_value = \"updated-value\".parse().unwrap();",
            "    let old_value = e.insert(updated_value);",
            "    assert_eq!(old_value, &value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::with_capacity(32768);",
          "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
          "    let value = \"max-value\".parse().unwrap();",
          "    ",
          "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
          "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
          "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    assert!(result_1.is_ok());"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    assert_eq!(map.len(), 1);"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    assert!(result_2.is_err());"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    assert_eq!(map.len(), 1);"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    assert!(result_entry.is_ok());"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    assert!(occupied_entry.is_ok());"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    let e = occupied_entry.unwrap();",
            "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
            "    assert!(result_insert.is_ok());"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    let e = occupied_entry.unwrap();",
            "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
            "    assert_eq!(map.len(), 1);"
          ],
          [
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    let e = occupied_entry.unwrap();",
            "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
            "    let inserted_value = e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    assert_eq!(inserted_value, \"new-value\".parse().unwrap());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    assert!(result_1.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    assert_eq!(map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    assert!(result_2.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    assert_eq!(map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    assert!(result_entry.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    assert!(occupied_entry.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    let e = occupied_entry.unwrap();",
            "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
            "    assert!(result_insert.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    let e = occupied_entry.unwrap();",
            "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
            "    assert_eq!(map.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    ",
            "    if let Entry::Vacant(v) = map.try_entry(\"max-capacity-key\").unwrap().try_insert_entry(value) {",
            "        let e = v.try_insert_entry(\"new-value\".parse().unwrap()).unwrap();",
            "        e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    }",
            "    let map = HeaderMap::with_capacity(1);",
            "    let key_1 = HeaderName { inner: Repr::new(\"key1\".to_string()) };",
            "    let value_1 = \"value1\".parse().unwrap();",
            "    let key_2 = HeaderName { inner: Repr::new(\"key2\".to_string()) };",
            "    let value_2 = \"value2\".parse().unwrap();",
            "    let result_1 = map.try_entry(\"key1\").unwrap().try_insert_entry(value_1);",
            "    let result_2 = map.try_entry(\"key2\").unwrap().try_insert_entry(value_2);",
            "    let map = HeaderMap::with_capacity(32768);",
            "    let key = HeaderName { inner: Repr::new(\"max-capacity-key\".to_string()) };",
            "    let value = \"max-value\".parse().unwrap();",
            "    let result_entry = map.try_entry(\"max-capacity-key\").unwrap();",
            "    let occupied_entry = result_entry.try_insert_entry(value);",
            "    let e = occupied_entry.unwrap();",
            "    let result_insert = e.try_insert_entry(\"new-value\".parse().unwrap());",
            "    let inserted_value = e.insert(\"value-at-max-capacity\".parse().unwrap());",
            "    assert_eq!(inserted_value, \"new-value\".parse().unwrap());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]