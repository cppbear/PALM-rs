[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::new();",
          "    let key = HeaderName { inner: Repr::Custom };",
          "    let value = \"valid-value\".parse().unwrap();",
          "",
          "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
          "        let mut e = v.try_insert_entry(value).unwrap();",
          "        e.insert(\"new-value\".parse().unwrap());",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"valid-value\".parse().unwrap();",
            "    let entry = map.try_entry(key).unwrap();",
            "    assert!(matches!(entry, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"valid-value\".parse().unwrap();",
            "    let entry = map.try_entry(key).unwrap();",
            "    let mut e = entry.try_insert_entry(value).unwrap();",
            "    let new_value = \"new-value\".parse().unwrap();",
            "    e.insert(new_value);",
            "    assert_eq!(map[key], new_value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"valid-value\".parse().unwrap();",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"valid-value\".parse().unwrap();",
            "    let entry = map.try_entry(key).unwrap();",
            "    assert!(matches!(entry, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"valid-value\".parse().unwrap();",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e = v.try_insert_entry(value).unwrap();",
            "        e.insert(\"new-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value = \"valid-value\".parse().unwrap();",
            "    let entry = map.try_entry(key).unwrap();",
            "    let mut e = entry.try_insert_entry(value).unwrap();",
            "    let new_value = \"new-value\".parse().unwrap();",
            "    e.insert(new_value);",
            "    assert_eq!(map[key], new_value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::new();",
          "    let key = HeaderName { inner: Repr::Custom };",
          "    let value_short = \"val\".parse().unwrap();",
          "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
          "",
          "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
          "        let mut e_short = v.try_insert_entry(value_short).unwrap();",
          "        e_short.insert(\"short-value\".parse().unwrap());",
          "    }",
          "",
          "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
          "        let mut e_long = v.try_insert_entry(value_long).unwrap();",
          "        e_long.insert(\"long-value\".parse().unwrap());",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    assert!(matches!(entry_short, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    let mut e_short = match entry_short {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_short).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_short.insert(\"short-value\".parse().unwrap());",
            "    assert_eq!(map[key], \"short-value\");"
          ],
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    let mut e_short = match entry_short {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_short).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_short.insert(\"short-value\".parse().unwrap());",
            "    let entry_long = map.try_entry(key).unwrap();",
            "    assert!(matches!(entry_long, Entry::Vacant(_)));"
          ],
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    let mut e_short = match entry_short {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_short).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_short.insert(\"short-value\".parse().unwrap());",
            "    let entry_long = map.try_entry(key).unwrap();",
            "    let mut e_long = match entry_long {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_long).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_long.insert(\"long-value\".parse().unwrap());",
            "    assert_eq!(map[key], \"long-value\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_short = v.try_insert_entry(value_short).unwrap();",
            "        e_short.insert(\"short-value\".parse().unwrap());",
            "    }",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_long = v.try_insert_entry(value_long).unwrap();",
            "        e_long.insert(\"long-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    assert!(matches!(entry_short, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_short = v.try_insert_entry(value_short).unwrap();",
            "        e_short.insert(\"short-value\".parse().unwrap());",
            "    }",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_long = v.try_insert_entry(value_long).unwrap();",
            "        e_long.insert(\"long-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    let mut e_short = match entry_short {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_short).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_short.insert(\"short-value\".parse().unwrap());",
            "    assert_eq!(map[key], \"short-value\");",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_short = v.try_insert_entry(value_short).unwrap();",
            "        e_short.insert(\"short-value\".parse().unwrap());",
            "    }",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_long = v.try_insert_entry(value_long).unwrap();",
            "        e_long.insert(\"long-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    let mut e_short = match entry_short {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_short).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_short.insert(\"short-value\".parse().unwrap());",
            "    let entry_long = map.try_entry(key).unwrap();",
            "    assert!(matches!(entry_long, Entry::Vacant(_)));",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_short = v.try_insert_entry(value_short).unwrap();",
            "        e_short.insert(\"short-value\".parse().unwrap());",
            "    }",
            "",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "        let mut e_long = v.try_insert_entry(value_long).unwrap();",
            "        e_long.insert(\"long-value\".parse().unwrap());",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    let value_short = \"val\".parse().unwrap();",
            "    let value_long = \"this-is-a-really-long-value\".parse().unwrap();",
            "    let entry_short = map.try_entry(key).unwrap();",
            "    let mut e_short = match entry_short {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_short).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_short.insert(\"short-value\".parse().unwrap());",
            "    let entry_long = map.try_entry(key).unwrap();",
            "    let mut e_long = match entry_long {",
            "    Entry::Vacant(v) => v.try_insert_entry(value_long).unwrap(),",
            "    _ => unreachable!()",
            "    };",
            "    e_long.insert(\"long-value\".parse().unwrap());",
            "    assert_eq!(map[key], \"long-value\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic(expected = \"size overflows MAX_SIZE\")]"
        ],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::new();",
          "    let key = HeaderName { inner: Repr::Custom };",
          "",
          "    for i in 0..=MAX_SIZE {",
          "        let value = format!(\"value{}\", i).parse().unwrap();",
          "        if let Entry::Vacant(v) = map.try_entry(key.clone()).unwrap() {",
          "            let _ = v.try_insert_entry(value);",
          "        }",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    for i in 0..=MAX_SIZE {",
            "    let value = format!(\"value{}\", i).parse().unwrap();",
            "    assert!(if let Entry::Vacant(v) = map.try_entry(key.clone()).unwrap() {"
          ],
          [
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    for i in 0..=MAX_SIZE {",
            "    let value = format!(\"value{}\", i).parse().unwrap();",
            "    v.try_insert_entry(value).is_ok()",
            "    } else {",
            "    true",
            "    });",
            "    }",
            "    assert!(map.try_entry(key.clone()).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "",
            "    for i in 0..=MAX_SIZE {",
            "        let value = format!(\"value{}\", i).parse().unwrap();",
            "        if let Entry::Vacant(v) = map.try_entry(key.clone()).unwrap() {",
            "            let _ = v.try_insert_entry(value);",
            "        }",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    for i in 0..=MAX_SIZE {",
            "    let value = format!(\"value{}\", i).parse().unwrap();",
            "    assert!(if let Entry::Vacant(v) = map.try_entry(key.clone()).unwrap() {",
            "}"
          ],
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "",
            "    for i in 0..=MAX_SIZE {",
            "        let value = format!(\"value{}\", i).parse().unwrap();",
            "        if let Entry::Vacant(v) = map.try_entry(key.clone()).unwrap() {",
            "            let _ = v.try_insert_entry(value);",
            "        }",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let key = HeaderName { inner: Repr::Custom };",
            "    for i in 0..=MAX_SIZE {",
            "    let value = format!(\"value{}\", i).parse().unwrap();",
            "    v.try_insert_entry(value).is_ok()",
            "    } else {",
            "    true",
            "    });",
            "    }",
            "    assert!(map.try_entry(key.clone()).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map = HeaderMap::new();",
          "    let keys: Vec<HeaderName> = (0..10)",
          "        .map(|i| HeaderName { inner: Repr::Custom })",
          "        .collect();",
          "    ",
          "    for key in keys {",
          "        let value = format!(\"value-{}\", key.hash()).parse().unwrap();",
          "        if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
          "            let mut e = v.try_insert_entry(value).unwrap();",
          "            e.insert(\"updated-value\".parse().unwrap());",
          "        }",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut map = HeaderMap::new();",
            "    let keys: Vec<HeaderName> = (0..10)",
            "    .map(|i| HeaderName { inner: Repr::Custom })",
            "    .collect();",
            "    for key in keys {",
            "    let value = format!(\"value-{}\", key.hash()).parse().unwrap();",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "    let mut e = v.try_insert_entry(value).unwrap();",
            "    e.insert(\"updated-value\".parse().unwrap());",
            "    }",
            "    }",
            "    for key in keys {",
            "    let value = format!(\"value-{}\", key.hash());",
            "    assert_eq!(map[key], value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map = HeaderMap::new();",
            "    let keys: Vec<HeaderName> = (0..10)",
            "        .map(|i| HeaderName { inner: Repr::Custom })",
            "        .collect();",
            "    ",
            "    for key in keys {",
            "        let value = format!(\"value-{}\", key.hash()).parse().unwrap();",
            "        if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "            let mut e = v.try_insert_entry(value).unwrap();",
            "            e.insert(\"updated-value\".parse().unwrap());",
            "        }",
            "    }",
            "    let mut map = HeaderMap::new();",
            "    let keys: Vec<HeaderName> = (0..10)",
            "    .map(|i| HeaderName { inner: Repr::Custom })",
            "    .collect();",
            "    for key in keys {",
            "    let value = format!(\"value-{}\", key.hash()).parse().unwrap();",
            "    if let Entry::Vacant(v) = map.try_entry(key).unwrap() {",
            "    let mut e = v.try_insert_entry(value).unwrap();",
            "    e.insert(\"updated-value\".parse().unwrap());",
            "    }",
            "    }",
            "    for key in keys {",
            "    let value = format!(\"value-{}\", key.hash());",
            "    assert_eq!(map[key], value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]