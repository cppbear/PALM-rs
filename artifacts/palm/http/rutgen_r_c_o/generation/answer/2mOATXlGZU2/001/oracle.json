[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone)]",
      "struct TestHeaderName(String);",
      "",
      "impl HdrName for TestHeaderName {",
      "    fn as_str(&self) -> &str {",
      "        &self.0",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
          "        mask: 256,",
          "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
          "        entries: vec![Bucket { hash: 0, key: HeaderName::from(\"test-key\"), value: HeaderValue::from(\"test-value\"), links: None }],",
          "        extra_values: vec![],",
          "        danger: Danger::Green,",
          "    };",
          "    ",
          "    let key = TestHeaderName(\"test-key\".to_string());",
          "    let value = map.index(key);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 256, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 0, key: HeaderName::from(\"test-key\"), value: HeaderValue::from(\"test-value\"), links: None }], extra_values: vec![], danger: Danger::Green, };",
            "    let key = TestHeaderName(\"test-key\".to_string());",
            "    let value = map.index(key);",
            "    assert_eq!(value, &HeaderValue::from(\"test-value\"));"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 256, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 0, key: HeaderName::from(\"test-key\"), value: HeaderValue::from(\"test-value\"), links: None }], extra_values: vec![], danger: Danger::Green, };",
            "    let key = TestHeaderName(\"test-key\".to_string());",
            "    let value = map.index(key);",
            "    assert!(std::panic::catch_unwind(|| { map.index(TestHeaderName(\"non-existent-key\".to_string())); }).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
            "        mask: 256,",
            "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
            "        entries: vec![Bucket { hash: 0, key: HeaderName::from(\"test-key\"), value: HeaderValue::from(\"test-value\"), links: None }],",
            "        extra_values: vec![],",
            "        danger: Danger::Green,",
            "    };",
            "    ",
            "    let key = TestHeaderName(\"test-key\".to_string());",
            "    let value = map.index(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 256, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 0, key: HeaderName::from(\"test-key\"), value: HeaderValue::from(\"test-value\"), links: None }], extra_values: vec![], danger: Danger::Green, };",
            "    let key = TestHeaderName(\"test-key\".to_string());",
            "    let value = map.index(key);",
            "    assert_eq!(value, &HeaderValue::from(\"test-value\"));",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
            "        mask: 256,",
            "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
            "        entries: vec![Bucket { hash: 0, key: HeaderName::from(\"test-key\"), value: HeaderValue::from(\"test-value\"), links: None }],",
            "        extra_values: vec![],",
            "        danger: Danger::Green,",
            "    };",
            "    ",
            "    let key = TestHeaderName(\"test-key\".to_string());",
            "    let value = map.index(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 256, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 0, key: HeaderName::from(\"test-key\"), value: HeaderValue::from(\"test-value\"), links: None }], extra_values: vec![], danger: Danger::Green, };",
            "    let key = TestHeaderName(\"test-key\".to_string());",
            "    let value = map.index(key);",
            "    assert!(std::panic::catch_unwind(|| { map.index(TestHeaderName(\"non-existent-key\".to_string())); }).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
          "        mask: 512,",
          "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
          "        entries: vec![Bucket { hash: 1, key: HeaderName::from(\"another-key\"), value: HeaderValue::from(\"another-value\"), links: None }],",
          "        extra_values: vec![],",
          "        danger: Danger::Yellow,",
          "    };",
          "    ",
          "    let key = TestHeaderName(\"another-key\".to_string());",
          "    let value = map.index(key);",
          "}"
        ],
        "oracles": [
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 512, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 1, key: HeaderName::from(\"another-key\"), value: HeaderValue::from(\"another-value\"), links: None }], extra_values: vec![], danger: Danger::Yellow };",
            "    let key = TestHeaderName(\"another-key\".to_string());",
            "    let value = map.index(key);",
            "    assert_eq!(value, &HeaderValue::from(\"another-value\"));"
          ],
          [
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 512, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 1, key: HeaderName::from(\"another-key\"), value: HeaderValue::from(\"another-value\"), links: None }], extra_values: vec![], danger: Danger::Yellow };",
            "    let key = TestHeaderName(\"another-key\".to_string());",
            "    let value = map.index(key);",
            "    assert!(std::panic::catch_unwind(|| { map.index(TestHeaderName(\"nonexistent-key\".to_string())); }).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
            "        mask: 512,",
            "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
            "        entries: vec![Bucket { hash: 1, key: HeaderName::from(\"another-key\"), value: HeaderValue::from(\"another-value\"), links: None }],",
            "        extra_values: vec![],",
            "        danger: Danger::Yellow,",
            "    };",
            "    ",
            "    let key = TestHeaderName(\"another-key\".to_string());",
            "    let value = map.index(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 512, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 1, key: HeaderName::from(\"another-key\"), value: HeaderValue::from(\"another-value\"), links: None }], extra_values: vec![], danger: Danger::Yellow };",
            "    let key = TestHeaderName(\"another-key\".to_string());",
            "    let value = map.index(key);",
            "    assert_eq!(value, &HeaderValue::from(\"another-value\"));",
            "}"
          ],
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
            "        mask: 512,",
            "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
            "        entries: vec![Bucket { hash: 1, key: HeaderName::from(\"another-key\"), value: HeaderValue::from(\"another-value\"), links: None }],",
            "        extra_values: vec![],",
            "        danger: Danger::Yellow,",
            "    };",
            "    ",
            "    let key = TestHeaderName(\"another-key\".to_string());",
            "    let value = map.index(key);",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap { mask: 512, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 1, key: HeaderName::from(\"another-key\"), value: HeaderValue::from(\"another-value\"), links: None }], extra_values: vec![], danger: Danger::Yellow };",
            "    let key = TestHeaderName(\"another-key\".to_string());",
            "    let value = map.index(key);",
            "    assert!(std::panic::catch_unwind(|| { map.index(TestHeaderName(\"nonexistent-key\".to_string())); }).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
          "        mask: 1024,",
          "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
          "        entries: vec![Bucket { hash: 2, key: HeaderName::from(\"different-key\"), value: HeaderValue::from(\"different-value\"), links: None }],",
          "        extra_values: vec![],",
          "        danger: Danger::Red(RandomState::new()),",
          "    };",
          "    ",
          "    let key = TestHeaderName(\"different-key\".to_string());",
          "    let value = map.index(key);",
          "}"
        ],
        "oracles": [
          [
            "    let map: HeaderMap<HeaderValue> = HeaderMap { mask: 1024, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 2, key: HeaderName::from(\"different-key\"), value: HeaderValue::from(\"different-value\"), links: None }], extra_values: vec![], danger: Danger::Red(RandomState::new()), };",
            "    let key = TestHeaderName(\"different-key\".to_string());",
            "    let value = map.index(key);",
            "    assert_eq!(value, &HeaderValue::from(\"different-value\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut map: HeaderMap<HeaderValue> = HeaderMap {",
            "        mask: 1024,",
            "        indices: Box::from([Pos { index: 0, hash: 0 }]),",
            "        entries: vec![Bucket { hash: 2, key: HeaderName::from(\"different-key\"), value: HeaderValue::from(\"different-value\"), links: None }],",
            "        extra_values: vec![],",
            "        danger: Danger::Red(RandomState::new()),",
            "    };",
            "    ",
            "    let key = TestHeaderName(\"different-key\".to_string());",
            "    let value = map.index(key);",
            "    let map: HeaderMap<HeaderValue> = HeaderMap { mask: 1024, indices: Box::from([Pos { index: 0, hash: 0 }]), entries: vec![Bucket { hash: 2, key: HeaderName::from(\"different-key\"), value: HeaderValue::from(\"different-value\"), links: None }], extra_values: vec![], danger: Danger::Red(RandomState::new()), };",
            "    let key = TestHeaderName(\"different-key\".to_string());",
            "    let value = map.index(key);",
            "    assert_eq!(value, &HeaderValue::from(\"different-value\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]