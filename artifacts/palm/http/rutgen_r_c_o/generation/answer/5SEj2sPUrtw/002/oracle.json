[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"\");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = \"\".as_bytes();",
            "    let i = 0;",
            "    assert!(i < bytes.len() == false);"
          ],
          [
            "    let bytes = \"\".as_bytes();",
            "    let i = 0;",
            "    assert!(is_visible_ascii(bytes[i]) == false);"
          ],
          [
            "    let bytes = \"\".as_bytes();",
            "    let i = 0;",
            "    let expected = HeaderValue { inner: Bytes::from_static(bytes), is_sensitive: false };",
            "    assert_eq!(val, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"\");",
            "    let bytes = \"\".as_bytes();",
            "    let i = 0;",
            "    assert!(i < bytes.len() == false);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"\");",
            "    let bytes = \"\".as_bytes();",
            "    let i = 0;",
            "    assert!(is_visible_ascii(bytes[i]) == false);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"\");",
            "    let bytes = \"\".as_bytes();",
            "    let i = 0;",
            "    let expected = HeaderValue { inner: Bytes::from_static(bytes), is_sensitive: false };",
            "    assert_eq!(val, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"hello\");",
          "}"
        ],
        "oracles": [
          [
            "    let val = HeaderValue::from_static(\"hello\");",
            "    assert_eq!(val.inner.as_ref(), b\"hello\");"
          ],
          [
            "    let val = HeaderValue::from_static(\"hello\");",
            "    assert_eq!(val.is_sensitive, false);"
          ],
          [
            "    let val = HeaderValue::from_static(\"hello\");",
            "    assert!(std::panic::catch_unwind(|| { HeaderValue::from_static(\"жsome value\"); }).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\");",
            "    let val = HeaderValue::from_static(\"hello\");",
            "    assert_eq!(val.inner.as_ref(), b\"hello\");",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\");",
            "    let val = HeaderValue::from_static(\"hello\");",
            "    assert_eq!(val.is_sensitive, false);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\");",
            "    let val = HeaderValue::from_static(\"hello\");",
            "    assert!(std::panic::catch_unwind(|| { HeaderValue::from_static(\"жsome value\"); }).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"hello\\x7f\");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(is_visible, false);"
          ],
          [
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert!(std::panic::catch_unwind(|| { HeaderValue::from_static(\"hello\\x7f\"); }).is_err());"
          ],
          [
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert!(std::panic::catch_unwind(|| { HeaderValue::from_static(\"hello\"); }).is_ok());"
          ],
          [
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(HeaderValue::from_static(\"hello\").inner, Bytes::from_static(bytes));"
          ],
          [
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(HeaderValue::from_static(\"hello\").is_sensitive, false);"
          ],
          [
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(HeaderValue::from_static(\"hello\\x7f\").inner, Bytes::from_static(bytes));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x7f\");",
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(is_visible, false);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x7f\");",
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert!(std::panic::catch_unwind(|| { HeaderValue::from_static(\"hello\\x7f\"); }).is_err());",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x7f\");",
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert!(std::panic::catch_unwind(|| { HeaderValue::from_static(\"hello\"); }).is_ok());",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x7f\");",
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(HeaderValue::from_static(\"hello\").inner, Bytes::from_static(bytes));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x7f\");",
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(HeaderValue::from_static(\"hello\").is_sensitive, false);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x7f\");",
            "    let bytes = b\"hello\\x7f\";",
            "    let is_visible = is_visible_ascii(bytes[5]);",
            "    assert_eq!(HeaderValue::from_static(\"hello\\x7f\").inner, Bytes::from_static(bytes));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"hello\\x1f\");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert_eq!(bytes.len(), 7);"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(!is_visible_ascii(bytes[6]));"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[0]));"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[1]));"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[2]));"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[3]));"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[4]));"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[5]));"
          ],
          [
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(panic::catch_unwind(|| HeaderValue::from_static(\"hello\\x1f\")).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert_eq!(bytes.len(), 7);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(!is_visible_ascii(bytes[6]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[0]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[1]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[2]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[3]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[4]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(is_visible_ascii(bytes[5]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello\\x1f\");",
            "    let bytes = \"hello\\x1f\".as_bytes();",
            "    assert!(panic::catch_unwind(|| HeaderValue::from_static(\"hello\\x1f\")).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"hello ват\");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = \"hello ват\".as_bytes();",
            "    let i = 0;",
            "    assert!(i < bytes.len());"
          ],
          [
            "    let bytes = \"hello ват\".as_bytes();",
            "    let i = 0;",
            "    assert!(!is_visible_ascii(bytes[i]));"
          ],
          [
            "    let bytes = \"hello ват\".as_bytes();",
            "    let i = 0;",
            "    assert_eq!(HeaderValue::from_static(\"hello ват\"), HeaderValue { inner: Bytes::from_static(bytes), is_sensitive: false });"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello ват\");",
            "    let bytes = \"hello ват\".as_bytes();",
            "    let i = 0;",
            "    assert!(i < bytes.len());",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello ват\");",
            "    let bytes = \"hello ват\".as_bytes();",
            "    let i = 0;",
            "    assert!(!is_visible_ascii(bytes[i]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"hello ват\");",
            "    let bytes = \"hello ват\".as_bytes();",
            "    let i = 0;",
            "    assert_eq!(HeaderValue::from_static(\"hello ват\"), HeaderValue { inner: Bytes::from_static(bytes), is_sensitive: false });",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"valid\\t\");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = \"valid\\t\".as_bytes();",
            "    let is_sensitive = false;",
            "    let expected_header_value = HeaderValue { inner: Bytes::from_static(bytes), is_sensitive };",
            "    assert_eq!(val, expected_header_value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"valid\\t\");",
            "    let bytes = \"valid\\t\".as_bytes();",
            "    let is_sensitive = false;",
            "    let expected_header_value = HeaderValue { inner: Bytes::from_static(bytes), is_sensitive };",
            "    assert_eq!(val, expected_header_value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\" \");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = \" \".as_bytes();",
            "    assert_eq!(bytes.len(), 1);"
          ],
          [
            "    let bytes = \" \".as_bytes();",
            "    assert!(is_visible_ascii(bytes[0]));"
          ],
          [
            "    let bytes = \" \".as_bytes();",
            "    assert_eq!(val.inner, Bytes::from_static(bytes));"
          ],
          [
            "    let bytes = \" \".as_bytes();",
            "    assert!(!val.is_sensitive);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\" \");",
            "    let bytes = \" \".as_bytes();",
            "    assert_eq!(bytes.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\" \");",
            "    let bytes = \" \".as_bytes();",
            "    assert!(is_visible_ascii(bytes[0]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\" \");",
            "    let bytes = \" \".as_bytes();",
            "    assert_eq!(val.inner, Bytes::from_static(bytes));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\" \");",
            "    let bytes = \" \".as_bytes();",
            "    assert!(!val.is_sensitive);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"visible\");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = \"visible\".as_bytes();",
            "    assert_eq!(bytes.len(), 7);"
          ],
          [
            "    let bytes = \"visible\".as_bytes();",
            "    for &b in bytes.iter() {",
            "    assert!(is_visible_ascii(b));"
          ],
          [
            "    let bytes = \"visible\".as_bytes();",
            "    for &b in bytes.iter() {",
            "    }",
            "    let expected_value = HeaderValue {",
            "    inner: Bytes::from_static(bytes),",
            "    is_sensitive: false,",
            "    };",
            "    assert_eq!(val, expected_value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"visible\");",
            "    let bytes = \"visible\".as_bytes();",
            "    assert_eq!(bytes.len(), 7);",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"visible\");",
            "    let bytes = \"visible\".as_bytes();",
            "    for &b in bytes.iter() {",
            "    assert!(is_visible_ascii(b));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"visible\");",
            "    let bytes = \"visible\".as_bytes();",
            "    for &b in bytes.iter() {",
            "    }",
            "    let expected_value = HeaderValue {",
            "    inner: Bytes::from_static(bytes),",
            "    is_sensitive: false,",
            "    };",
            "    assert_eq!(val, expected_value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let val = HeaderValue::from_static(\"invalid\\x08\");",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = \"invalid\\x08\".as_bytes();",
            "    let i = 0;",
            "    assert!(i < bytes.len());"
          ],
          [
            "    let bytes = \"invalid\\x08\".as_bytes();",
            "    let i = 0;",
            "    assert!(!is_visible_ascii(bytes[i]));"
          ],
          [
            "    let bytes = \"invalid\\x08\".as_bytes();",
            "    let i = 0;",
            "    let _result = std::panic::catch_unwind(|| {",
            "    HeaderValue::from_static(\"invalid\\x08\");",
            "    });",
            "    assert!(_result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let val = HeaderValue::from_static(\"invalid\\x08\");",
            "    let bytes = \"invalid\\x08\".as_bytes();",
            "    let i = 0;",
            "    assert!(i < bytes.len());",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"invalid\\x08\");",
            "    let bytes = \"invalid\\x08\".as_bytes();",
            "    let i = 0;",
            "    assert!(!is_visible_ascii(bytes[i]));",
            "}"
          ],
          [
            "{",
            "    let val = HeaderValue::from_static(\"invalid\\x08\");",
            "    let bytes = \"invalid\\x08\".as_bytes();",
            "    let i = 0;",
            "    let _result = std::panic::catch_unwind(|| {",
            "    HeaderValue::from_static(\"invalid\\x08\");",
            "    });",
            "    assert!(_result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]