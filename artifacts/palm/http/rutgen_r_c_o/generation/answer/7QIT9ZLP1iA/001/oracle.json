[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
          "    let version = Version(Http::default());",
          "    let headers = HeaderMap::<HeaderValue> {",
          "        mask: Size(0),",
          "        indices: Box::new([Pos(0)]),",
          "        entries: Vec::with_capacity(0),",
          "        extra_values: Vec::with_capacity(0),",
          "        danger: Danger::default(),",
          "    };",
          "    let parts = Parts {",
          "        status,",
          "        version,",
          "        headers,",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let _ = format!(\"{:?}\", parts);",
          "}"
        ],
        "oracles": [
          [
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(\"Parts\"));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(&format!(\"status: {:?}\", status)));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(&format!(\"version: {:?}\", version)));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(&format!(\"headers: {:?}\", headers)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(\"Parts\"));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(&format!(\"status: {:?}\", status)));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(&format!(\"version: {:?}\", version)));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(1).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    let formatted = format!(\"{:?}\", parts);",
            "    assert!(formatted.contains(&format!(\"headers: {:?}\", headers)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let status = StatusCode(NonZeroU16::new(600).unwrap());",
          "    let version = Version(Http::new(2, 0));",
          "    let headers = HeaderMap::<HeaderValue> {",
          "        mask: Size(100),",
          "        indices: Box::new([Pos(10)]),",
          "        entries: Vec::with_capacity(50),",
          "        extra_values: Vec::with_capacity(50),",
          "        danger: Danger::default(),",
          "    };",
          "    let parts = Parts {",
          "        status,",
          "        version,",
          "        headers,",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let _ = format!(\"{:?}\", parts);",
          "}"
        ],
        "oracles": [
          [
            "    let status = StatusCode(NonZeroU16::new(600).unwrap());",
            "    let version = Version(Http::new(2, 0));",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(100),",
            "    indices: Box::new([Pos(10)]),",
            "    entries: Vec::with_capacity(50),",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts), \"Parts { status: StatusCode(600), version: Version(2.0), headers: HeaderMap(...) }\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(600).unwrap());",
            "    let version = Version(Http::new(2, 0));",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(100),",
            "        indices: Box::new([Pos(10)]),",
            "        entries: Vec::with_capacity(50),",
            "        extra_values: Vec::with_capacity(50),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(600).unwrap());",
            "    let version = Version(Http::new(2, 0));",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(100),",
            "    indices: Box::new([Pos(10)]),",
            "    entries: Vec::with_capacity(50),",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts), \"Parts { status: StatusCode(600), version: Version(2.0), headers: HeaderMap(...) }\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
          "    let version = Version(Http::default());",
          "    let mut entries = Vec::with_capacity(50);",
          "    for _ in 0..50 {",
          "        entries.push(Bucket::<HeaderValue>::default());",
          "    }",
          "    let headers = HeaderMap::<HeaderValue> {",
          "        mask: Size(50),",
          "        indices: Box::new([Pos(0)]),",
          "        entries,",
          "        extra_values: Vec::with_capacity(50),",
          "        danger: Danger::default(),",
          "    };",
          "    let parts = Parts {",
          "        status,",
          "        version,",
          "        headers,",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let _ = format!(\"{:?}\", parts);",
          "}"
        ],
        "oracles": [
          [
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.status, StatusCode(NonZeroU16::new(200).unwrap()));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.version, Version(Http::default()));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.headers.mask, Size(50));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.headers.indices, Box::new([Pos(0)]));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.headers.entries.len(), 50);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "        entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(50),",
            "        indices: Box::new([Pos(0)]),",
            "        entries,",
            "        extra_values: Vec::with_capacity(50),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.status, StatusCode(NonZeroU16::new(200).unwrap()));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "        entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(50),",
            "        indices: Box::new([Pos(0)]),",
            "        entries,",
            "        extra_values: Vec::with_capacity(50),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.version, Version(Http::default()));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "        entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(50),",
            "        indices: Box::new([Pos(0)]),",
            "        entries,",
            "        extra_values: Vec::with_capacity(50),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.headers.mask, Size(50));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "        entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(50),",
            "        indices: Box::new([Pos(0)]),",
            "        entries,",
            "        extra_values: Vec::with_capacity(50),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.headers.indices, Box::new([Pos(0)]));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "        entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(50),",
            "        indices: Box::new([Pos(0)]),",
            "        entries,",
            "        extra_values: Vec::with_capacity(50),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(200).unwrap());",
            "    let version = Version(Http::default());",
            "    let mut entries = Vec::with_capacity(50);",
            "    for _ in 0..50 {",
            "    entries.push(Bucket::<HeaderValue>::default());",
            "    }",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(50),",
            "    indices: Box::new([Pos(0)]),",
            "    entries,",
            "    extra_values: Vec::with_capacity(50),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(parts.headers.entries.len(), 50);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
          "    let version = Version(Http::default());",
          "    let headers = HeaderMap::<HeaderValue> {",
          "        mask: Size(0),",
          "        indices: Box::new([Pos(0)]),",
          "        entries: Vec::with_capacity(0),",
          "        extra_values: Vec::with_capacity(0),",
          "        danger: Danger::default(),",
          "    };",
          "    let parts = Parts {",
          "        status,",
          "        version,",
          "        headers,",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let _ = format!(\"{:?}\", parts);",
          "}"
        ],
        "oracles": [
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    assert_eq!(status, StatusCode(NonZeroU16::new(404).unwrap()));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    assert_eq!(version, Version(Http::default()));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    assert_eq!(headers.mask, Size(0));"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    assert!(headers.entries.is_empty());"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"status\"), true);"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"version\"), true);"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"headers\"), true);"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"extensions\"), false);"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"_priv\"), false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    assert_eq!(status, StatusCode(NonZeroU16::new(404).unwrap()));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    assert_eq!(version, Version(Http::default()));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    assert_eq!(headers.mask, Size(0));",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    assert!(headers.entries.is_empty());",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"status\"), true);",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"version\"), true);",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"headers\"), true);",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"extensions\"), false);",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "        mask: Size(0),",
            "        indices: Box::new([Pos(0)]),",
            "        entries: Vec::with_capacity(0),",
            "        extra_values: Vec::with_capacity(0),",
            "        danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(404).unwrap());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue> {",
            "    mask: Size(0),",
            "    indices: Box::new([Pos(0)]),",
            "    entries: Vec::with_capacity(0),",
            "    extra_values: Vec::with_capacity(0),",
            "    danger: Danger::default(),",
            "    };",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"_priv\"), false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let status = StatusCode(NonZeroU16::new(0).unwrap_err()); // Invalid status",
          "    let version = Version(Http::default());",
          "    let headers = HeaderMap::<HeaderValue>::default();",
          "    let parts = Parts {",
          "        status,",
          "        version,",
          "        headers,",
          "        extensions: Extensions::default(),",
          "        _priv: (),",
          "    };",
          "    let _ = format!(\"{:?}\", parts);",
          "}"
        ],
        "oracles": [
          [
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"status: \"), true);"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"version: \"), true);"
          ],
          [
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"headers: \"), true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err()); // Invalid status",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"status: \"), true);",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err()); // Invalid status",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"version: \"), true);",
            "}"
          ],
          [
            "{",
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err()); // Invalid status",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "        status,",
            "        version,",
            "        headers,",
            "        extensions: Extensions::default(),",
            "        _priv: (),",
            "    };",
            "    let _ = format!(\"{:?}\", parts);",
            "    let status = StatusCode(NonZeroU16::new(0).unwrap_err());",
            "    let version = Version(Http::default());",
            "    let headers = HeaderMap::<HeaderValue>::default();",
            "    let parts = Parts {",
            "    status,",
            "    version,",
            "    headers,",
            "    extensions: Extensions::default(),",
            "    _priv: (),",
            "    };",
            "    assert_eq!(format!(\"{:?}\", parts).contains(\"headers: \"), true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]