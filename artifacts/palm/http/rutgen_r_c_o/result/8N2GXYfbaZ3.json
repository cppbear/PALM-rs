{"function_name":"http::uri::authority::<uri::authority::Authority as std::convert::TryFrom<&'a [u8]>>::try_from","tests":18,"tests_lines":[7,7,7,8,7,8,8,7,7,7,7,7,7,7,7,7,7,7],"oracles":8,"oracles_compiled":8,"oracles_compiled_rate":100.0,"tests_compiled":9,"tests_compiled_rate":50.0,"oracles_run":8,"oracles_passed":5,"oracles_passed_rate":62.5,"tests_run":9,"tests_passed":6,"tests_passed_rate":66.66666666666666,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[432,433,434,435,436,437,438],"codes_lines_covered":[[["{","    let input: &[u8] = b\"\";","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = b\"\";","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"valid_data\";","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = b\"valid_data\";","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_ok());","}"],[]],[["{","    let input: Vec<u8> = vec![0u8; 8192]; // 8192 bytes of zeroes","    let _ = Authority::try_from(input);","    let input: Vec<u8> = vec![0u8; 8192];","    let result = Authority::try_from(input);","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = &[255; 10]; // Multiple instances of maximum u8 value","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[255; 10];","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_err());","}"],[]],[["{","    let input: &[u8] = &[128, 129, 130, 131, 132]; // Non-ASCII byte values","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[128, 129, 130, 131, 132];","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_err());","}"],[]],[["{","    let input: &[u8] = &[1]; // single byte input","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[1]; // single byte input","    let authority_result = Authority::try_from(input.to_vec());","    assert!(authority_result.is_err());","}"],[]],[["{","    let input: &[u8] = &[1, 2]; // two byte input","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[1, 2]; // two byte input","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let result = Authority::try_from(input.to_vec());","    assert_eq!(result.is_err(), true); // expects an error due to invalid input bytes","}"],[]],[["{","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let result = Authority::try_from(input.to_vec());","    assert!(result.err().is_some()); // expects an error to be present in the result","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let input: &[u8] = b\"\";","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = b\"\";","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"valid_data\";","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = b\"valid_data\";","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_ok());","}"],[]],[["{","    let input: Vec<u8> = vec![0u8; 8192]; // 8192 bytes of zeroes","    let _ = Authority::try_from(input);","    let input: Vec<u8> = vec![0u8; 8192];","    let result = Authority::try_from(input);","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = &[255; 10]; // Multiple instances of maximum u8 value","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[255; 10];","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_err());","}"],[]],[["{","    let input: &[u8] = &[128, 129, 130, 131, 132]; // Non-ASCII byte values","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[128, 129, 130, 131, 132];","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_err());","}"],[]],[["{","    let input: &[u8] = &[1]; // single byte input","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[1]; // single byte input","    let authority_result = Authority::try_from(input.to_vec());","    assert!(authority_result.is_err());","}"],[]],[["{","    let input: &[u8] = &[1, 2]; // two byte input","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[1, 2]; // two byte input","    let result = Authority::try_from(input.to_vec());","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let result = Authority::try_from(input.to_vec());","    assert_eq!(result.is_err(), true); // expects an error due to invalid input bytes","}"],[]],[["{","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let _ = Authority::try_from(input.to_vec());","    let input: &[u8] = &[255, 0, 1]; // three byte input with edge values","    let result = Authority::try_from(input.to_vec());","    assert!(result.err().is_some()); // expects an error to be present in the result","}"],[]]]}