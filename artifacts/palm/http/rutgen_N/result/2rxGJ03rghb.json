{"function_name":"http::uri::<uri::Uri as std::hash::Hash>::hash","tests":2,"tests_lines":[70,70],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":17,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":6,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1097,1098,1099,1100,1101,1102,1103,1104,1106,1107,1108,1110,1112,1113,1114,1115,1116],"codes_lines_covered":[[["{","    use std::collections::hash_map::DefaultHasher;","    use std::hash::{Hasher, Hash};","","    struct Scheme {","        inner: Option<String>,","    }","","    impl Hash for Scheme {","        fn hash<H: Hasher>(&self, state: &mut H) {","            if let Some(ref inner) = self.inner {","                inner.hash(state);","            }","        }","    }","","    struct Uri {","        scheme: Scheme,","        authority: Option<String>,","        path: String,","        query: Option<String>,","    }","","    impl Uri {","        fn authority(&self) -> Option<&String> {","            self.authority.as_ref()","        }","","        fn path(&self) -> &String {","            &self.path","        }","","        fn query(&self) -> Option<&String> {","            self.query.as_ref()","        }","","        fn hash<H>(&self, state: &mut H)","        where","            H: Hasher,","        {","            if !self.scheme.inner.is_none() {","                self.scheme.hash(state);","                state.write_u8(0xff);","            }","","            if let Some(auth) = self.authority() {","                auth.hash(state);","            }","","            Hash::hash_slice(self.path().as_bytes(), state);","","            if let Some(query) = self.query() {","                b'?'.hash(state);","                Hash::hash_slice(query.as_bytes(), state);","            }","        }","    }","","    let mut hasher = DefaultHasher::new();","    let uri = Uri {","        scheme: Scheme { inner: Some(\"http\".to_string()) },","        authority: None,","        path: \"/path/to/resource\".to_string(),","        query: Some(\"param=value\".to_string()),","    };","","    uri.hash(&mut hasher);","    let result = hasher.finish();","    assert_ne!(result, 0);","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","    use std::hash::{Hasher, Hash};","","    struct Scheme {","        inner: Option<String>,","    }","","    impl Hash for Scheme {","        fn hash<H: Hasher>(&self, state: &mut H) {","            if let Some(ref inner) = self.inner {","                inner.hash(state);","            }","        }","    }","","    struct Uri {","        scheme: Scheme,","        authority: Option<String>,","        path: String,","        query: Option<String>,","    }","","    impl Uri {","        fn authority(&self) -> Option<&String> {","            self.authority.as_ref()","        }","","        fn path(&self) -> &String {","            &self.path","        }","","        fn query(&self) -> Option<&String> {","            self.query.as_ref()","        }","","        fn hash<H>(&self, state: &mut H)","        where","            H: Hasher,","        {","            if !self.scheme.inner.is_none() {","                self.scheme.hash(state);","                state.write_u8(0xff);","            }","","            if let Some(auth) = self.authority() {","                auth.hash(state);","            }","","            Hash::hash_slice(self.path().as_bytes(), state);","","            if let Some(query) = self.query() {","                b'?'.hash(state);","                Hash::hash_slice(query.as_bytes(), state);","            }","        }","    }","","    let mut hasher = DefaultHasher::new();","    let uri = Uri {","        scheme: Scheme { inner: None },","        authority: None,","        path: \"/path/to/resource\".to_string(),","        query: None,","    };","","    uri.hash(&mut hasher);","    let result = hasher.finish();","    assert_ne!(result, 0);","}"],[]]],"codes_branches":[{"start_line":1101,"start_column":12,"end_line":1101,"end_column":40,"positive":false,"negative":false},{"start_line":1106,"start_column":16,"end_line":1106,"end_column":26,"positive":false,"negative":false},{"start_line":1112,"start_column":16,"end_line":1112,"end_column":27,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    use std::collections::hash_map::DefaultHasher;","    use std::hash::{Hasher, Hash};","","    struct Scheme {","        inner: Option<String>,","    }","","    impl Hash for Scheme {","        fn hash<H: Hasher>(&self, state: &mut H) {","            if let Some(ref inner) = self.inner {","                inner.hash(state);","            }","        }","    }","","    struct Uri {","        scheme: Scheme,","        authority: Option<String>,","        path: String,","        query: Option<String>,","    }","","    impl Uri {","        fn authority(&self) -> Option<&String> {","            self.authority.as_ref()","        }","","        fn path(&self) -> &String {","            &self.path","        }","","        fn query(&self) -> Option<&String> {","            self.query.as_ref()","        }","","        fn hash<H>(&self, state: &mut H)","        where","            H: Hasher,","        {","            if !self.scheme.inner.is_none() {","                self.scheme.hash(state);","                state.write_u8(0xff);","            }","","            if let Some(auth) = self.authority() {","                auth.hash(state);","            }","","            Hash::hash_slice(self.path().as_bytes(), state);","","            if let Some(query) = self.query() {","                b'?'.hash(state);","                Hash::hash_slice(query.as_bytes(), state);","            }","        }","    }","","    let mut hasher = DefaultHasher::new();","    let uri = Uri {","        scheme: Scheme { inner: Some(\"http\".to_string()) },","        authority: None,","        path: \"/path/to/resource\".to_string(),","        query: Some(\"param=value\".to_string()),","    };","","    uri.hash(&mut hasher);","    let result = hasher.finish();","    assert_ne!(result, 0);","}"],[{"start_line":1101,"start_column":12,"end_line":1101,"end_column":40,"positive":false,"negative":false},{"start_line":1106,"start_column":16,"end_line":1106,"end_column":26,"positive":false,"negative":false},{"start_line":1112,"start_column":16,"end_line":1112,"end_column":27,"positive":false,"negative":false}]],[["{","    use std::collections::hash_map::DefaultHasher;","    use std::hash::{Hasher, Hash};","","    struct Scheme {","        inner: Option<String>,","    }","","    impl Hash for Scheme {","        fn hash<H: Hasher>(&self, state: &mut H) {","            if let Some(ref inner) = self.inner {","                inner.hash(state);","            }","        }","    }","","    struct Uri {","        scheme: Scheme,","        authority: Option<String>,","        path: String,","        query: Option<String>,","    }","","    impl Uri {","        fn authority(&self) -> Option<&String> {","            self.authority.as_ref()","        }","","        fn path(&self) -> &String {","            &self.path","        }","","        fn query(&self) -> Option<&String> {","            self.query.as_ref()","        }","","        fn hash<H>(&self, state: &mut H)","        where","            H: Hasher,","        {","            if !self.scheme.inner.is_none() {","                self.scheme.hash(state);","                state.write_u8(0xff);","            }","","            if let Some(auth) = self.authority() {","                auth.hash(state);","            }","","            Hash::hash_slice(self.path().as_bytes(), state);","","            if let Some(query) = self.query() {","                b'?'.hash(state);","                Hash::hash_slice(query.as_bytes(), state);","            }","        }","    }","","    let mut hasher = DefaultHasher::new();","    let uri = Uri {","        scheme: Scheme { inner: None },","        authority: None,","        path: \"/path/to/resource\".to_string(),","        query: None,","    };","","    uri.hash(&mut hasher);","    let result = hasher.finish();","    assert_ne!(result, 0);","}"],[{"start_line":1101,"start_column":12,"end_line":1101,"end_column":40,"positive":false,"negative":false},{"start_line":1106,"start_column":16,"end_line":1106,"end_column":26,"positive":false,"negative":false},{"start_line":1112,"start_column":16,"end_line":1112,"end_column":27,"positive":false,"negative":false}]]]}