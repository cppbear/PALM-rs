{"function_name":"http::uri::scheme::<uri::scheme::Scheme as std::hash::Hash>::hash","tests":5,"tests_lines":[9,9,9,13,12],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":2,"oracles_passed_rate":40.0,"tests_run":5,"tests_passed":2,"tests_passed_rate":40.0,"lines":14,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[168,169,170,171,172,173,174,175,176,177,178,179,180,183],"codes_lines_covered":[[["{","    use std::collections::hash_map::DefaultHasher;","","    let http = Http { inner: Scheme2::None };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    assert_eq!(result, 0); // No output for None case","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let http = Http { inner: Scheme2::Standard(Protocol::Http) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    assert_eq!(result, 1); // 1 for HTTP","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let http = Http { inner: Scheme2::Standard(Protocol::Https) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    assert_eq!(result, 2); // 2 for HTTPS","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let other_scheme = \"MyCustomScheme\".to_string();","    let http = Http { inner: Scheme2::Other(other_scheme.clone()) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    ","    // Length of \"MyCustomScheme\" is 13","    // Hash must consider the length first and then ascii lowercase of 'MyCustomScheme'","    assert!(result != 0); // Should produce a non-zero hash, can't specify exact value","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let other_scheme = \"\".to_string();","    let http = Http { inner: Scheme2::Other(other_scheme.clone()) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    ","    // Empty string should only consider its length","    assert!(result != 0); // Should produce a non-zero hash, can't specify exact value","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::collections::hash_map::DefaultHasher;","","    let http = Http { inner: Scheme2::None };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    assert_eq!(result, 0); // No output for None case","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let http = Http { inner: Scheme2::Standard(Protocol::Http) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    assert_eq!(result, 1); // 1 for HTTP","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let http = Http { inner: Scheme2::Standard(Protocol::Https) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    assert_eq!(result, 2); // 2 for HTTPS","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let other_scheme = \"MyCustomScheme\".to_string();","    let http = Http { inner: Scheme2::Other(other_scheme.clone()) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    ","    // Length of \"MyCustomScheme\" is 13","    // Hash must consider the length first and then ascii lowercase of 'MyCustomScheme'","    assert!(result != 0); // Should produce a non-zero hash, can't specify exact value","}"],[]],[["{","    use std::collections::hash_map::DefaultHasher;","","    let other_scheme = \"\".to_string();","    let http = Http { inner: Scheme2::Other(other_scheme.clone()) };","    let mut hasher = DefaultHasher::new();","    http.hash(&mut hasher);","    let result = hasher.finish();","    ","    // Empty string should only consider its length","    assert!(result != 0); // Should produce a non-zero hash, can't specify exact value","}"],[]]]}