{"function_name":"http::uri::path::uri::path::PathAndQuery::query","tests":2,"tests_lines":[37,37],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[255,256,257,259,260,262],"codes_lines_covered":[[["{","    struct PathAndQuery {","        query: usize,","        data: String,","    }","    ","    impl PathAndQuery {","        fn parse(input: &str) -> Result<Self, &'static str> {","            if let Some((path, query)) = input.split_once('?') {","                Ok(PathAndQuery {","                    query: path.len(),","                    data: format!(\"{}?{}\", path, query),","                })","            } else {","                Ok(PathAndQuery {","                    query: NONE,","                    data: input.to_string(),","                })","            }","        }","","        fn query(&self) -> Option<&str> {","            const NONE: usize = usize::MAX;","            if self.query == NONE {","                None","            } else {","                let i = self.query + 1;","                Some(&self.data[i..])","            }","        }","    }","    ","    const NONE: usize = usize::MAX;","","    let path_and_query: PathAndQuery = PathAndQuery::parse(\"/hello/world?key=value&foo=bar\").unwrap();","    assert_eq!(path_and_query.query(), Some(\"key=value&foo=bar\"));","}"],[]],[["{","    struct PathAndQuery {","        query: usize,","        data: String,","    }","","    impl PathAndQuery {","        fn parse(input: &str) -> Result<Self, &'static str> {","            if let Some((path, query)) = input.split_once('?') {","                Ok(PathAndQuery {","                    query: path.len(),","                    data: format!(\"{}?{}\", path, query),","                })","            } else {","                Ok(PathAndQuery {","                    query: NONE,","                    data: input.to_string(),","                })","            }","        }","","        fn query(&self) -> Option<&str> {","            const NONE: usize = usize::MAX;","            if self.query == NONE {","                None","            } else {","                let i = self.query + 1;","                Some(&self.data[i..])","            }","        }","    }","","    const NONE: usize = usize::MAX;","","    let path_and_query: PathAndQuery = PathAndQuery::parse(\"/hello/world\").unwrap();","    assert!(path_and_query.query().is_none());","}"],[]]],"codes_branches":[{"start_line":256,"start_column":12,"end_line":256,"end_column":30,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct PathAndQuery {","        query: usize,","        data: String,","    }","    ","    impl PathAndQuery {","        fn parse(input: &str) -> Result<Self, &'static str> {","            if let Some((path, query)) = input.split_once('?') {","                Ok(PathAndQuery {","                    query: path.len(),","                    data: format!(\"{}?{}\", path, query),","                })","            } else {","                Ok(PathAndQuery {","                    query: NONE,","                    data: input.to_string(),","                })","            }","        }","","        fn query(&self) -> Option<&str> {","            const NONE: usize = usize::MAX;","            if self.query == NONE {","                None","            } else {","                let i = self.query + 1;","                Some(&self.data[i..])","            }","        }","    }","    ","    const NONE: usize = usize::MAX;","","    let path_and_query: PathAndQuery = PathAndQuery::parse(\"/hello/world?key=value&foo=bar\").unwrap();","    assert_eq!(path_and_query.query(), Some(\"key=value&foo=bar\"));","}"],[{"start_line":256,"start_column":12,"end_line":256,"end_column":30,"positive":false,"negative":false}]],[["{","    struct PathAndQuery {","        query: usize,","        data: String,","    }","","    impl PathAndQuery {","        fn parse(input: &str) -> Result<Self, &'static str> {","            if let Some((path, query)) = input.split_once('?') {","                Ok(PathAndQuery {","                    query: path.len(),","                    data: format!(\"{}?{}\", path, query),","                })","            } else {","                Ok(PathAndQuery {","                    query: NONE,","                    data: input.to_string(),","                })","            }","        }","","        fn query(&self) -> Option<&str> {","            const NONE: usize = usize::MAX;","            if self.query == NONE {","                None","            } else {","                let i = self.query + 1;","                Some(&self.data[i..])","            }","        }","    }","","    const NONE: usize = usize::MAX;","","    let path_and_query: PathAndQuery = PathAndQuery::parse(\"/hello/world\").unwrap();","    assert!(path_and_query.query().is_none());","}"],[{"start_line":256,"start_column":12,"end_line":256,"end_column":30,"positive":false,"negative":false}]]]}