{"function_name":"http::header::map::header::map::VacantEntry<'a, T>::try_insert","tests":2,"tests_lines":[43,46],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[2747,2749,2750,2751,2753,2754],"codes_lines_covered":[[["{","    struct MockHeaderMap {","        entries: Vec<(String, String)>,","        max_size: usize,","    }","","    impl MockHeaderMap {","        fn new() -> Self {","            MockHeaderMap {","                entries: Vec::new(),","                max_size: 10,","            }","        }","","        fn try_insert(&mut self, key: &str, value: String) -> Result<usize, ()> {","            if self.entries.len() >= self.max_size {","                return Err(());","            }","            self.entries.push((key.to_string(), value));","            Ok(self.entries.len() - 1)","        }","    }","","    struct Entry<'a> {","        key: &'a str,","        map: &'a mut MockHeaderMap,","    }","","    impl<'a> Entry<'a> {","        fn try_insert(self, value: String) -> Result<&'a mut String, ()> {","            let index = self.map.try_insert(self.key, value)?;","            Ok(&mut self.map.entries[index].1)","        }","    }","","    let mut map = MockHeaderMap::new();","    let entry = Entry { key: \"x-hello\", map: &mut map };","","    let inserted_value = entry.try_insert(\"world\".to_string()).unwrap();","    assert_eq!(*inserted_value, \"world\");","    assert_eq!(map.entries.len(), 1);","    assert_eq!(map.entries[0].0, \"x-hello\");","}"],[]],[["{","    struct MockHeaderMap {","        entries: Vec<(String, String)>,","        max_size: usize,","    }","","    impl MockHeaderMap {","        fn new() -> Self {","            MockHeaderMap {","                entries: Vec::new(),","                max_size: 2,","            }","        }","","        fn try_insert(&mut self, key: &str, value: String) -> Result<usize, ()> {","            if self.entries.len() >= self.max_size {","                return Err(());","            }","            self.entries.push((key.to_string(), value));","            Ok(self.entries.len() - 1)","        }","    }","","    struct Entry<'a> {","        key: &'a str,","        map: &'a mut MockHeaderMap,","    }","","    impl<'a> Entry<'a> {","        fn try_insert(self, value: String) -> Result<&'a mut String, ()> {","            let index = self.map.try_insert(self.key, value)?;","            Ok(&mut self.map.entries[index].1)","        }","    }","","    let mut map = MockHeaderMap::new();","    let entry1 = Entry { key: \"x-hello\", map: &mut map };","    let _ = entry1.try_insert(\"world\".to_string()).unwrap();","    ","    let entry2 = Entry { key: \"x-foo\", map: &mut map };","    let _ = entry2.try_insert(\"bar\".to_string()).unwrap();","","    // This next insertion should panic due to max size being reached","    let entry3 = Entry { key: \"x-baz\", map: &mut map };","    let _ = entry3.try_insert(\"qux\".to_string()).unwrap();","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockHeaderMap {","        entries: Vec<(String, String)>,","        max_size: usize,","    }","","    impl MockHeaderMap {","        fn new() -> Self {","            MockHeaderMap {","                entries: Vec::new(),","                max_size: 10,","            }","        }","","        fn try_insert(&mut self, key: &str, value: String) -> Result<usize, ()> {","            if self.entries.len() >= self.max_size {","                return Err(());","            }","            self.entries.push((key.to_string(), value));","            Ok(self.entries.len() - 1)","        }","    }","","    struct Entry<'a> {","        key: &'a str,","        map: &'a mut MockHeaderMap,","    }","","    impl<'a> Entry<'a> {","        fn try_insert(self, value: String) -> Result<&'a mut String, ()> {","            let index = self.map.try_insert(self.key, value)?;","            Ok(&mut self.map.entries[index].1)","        }","    }","","    let mut map = MockHeaderMap::new();","    let entry = Entry { key: \"x-hello\", map: &mut map };","","    let inserted_value = entry.try_insert(\"world\".to_string()).unwrap();","    assert_eq!(*inserted_value, \"world\");","    assert_eq!(map.entries.len(), 1);","    assert_eq!(map.entries[0].0, \"x-hello\");","}"],[]],[["{","    struct MockHeaderMap {","        entries: Vec<(String, String)>,","        max_size: usize,","    }","","    impl MockHeaderMap {","        fn new() -> Self {","            MockHeaderMap {","                entries: Vec::new(),","                max_size: 2,","            }","        }","","        fn try_insert(&mut self, key: &str, value: String) -> Result<usize, ()> {","            if self.entries.len() >= self.max_size {","                return Err(());","            }","            self.entries.push((key.to_string(), value));","            Ok(self.entries.len() - 1)","        }","    }","","    struct Entry<'a> {","        key: &'a str,","        map: &'a mut MockHeaderMap,","    }","","    impl<'a> Entry<'a> {","        fn try_insert(self, value: String) -> Result<&'a mut String, ()> {","            let index = self.map.try_insert(self.key, value)?;","            Ok(&mut self.map.entries[index].1)","        }","    }","","    let mut map = MockHeaderMap::new();","    let entry1 = Entry { key: \"x-hello\", map: &mut map };","    let _ = entry1.try_insert(\"world\".to_string()).unwrap();","    ","    let entry2 = Entry { key: \"x-foo\", map: &mut map };","    let _ = entry2.try_insert(\"bar\".to_string()).unwrap();","","    // This next insertion should panic due to max size being reached","    let entry3 = Entry { key: \"x-baz\", map: &mut map };","    let _ = entry3.try_insert(\"qux\".to_string()).unwrap();","}"],[]]]}