{"function_name":"rand_core::block::<block::BlockRng64<R> as RngCore>::fill_bytes","tests":60,"tests_lines":[25,25,25,25,25,25,25,25,25,25,25,25,25,25,27,27,27,27,27,27,27,27,27,27,27,27,27,26,26,26,23,29,29,29,29,22,22,22,22,22,24,24,24,24,24,24,24,29,29,29,29,29,29,37,37,37,37,37,32,35],"oracles":15,"oracles_compiled":15,"oracles_compiled_rate":100.0,"tests_compiled":56,"tests_compiled_rate":93.33333333333333,"oracles_run":15,"oracles_passed":12,"oracles_passed_rate":80.0,"tests_run":56,"tests_passed":30,"tests_passed_rate":53.57142857142857,"lines":14,"lines_covered":14,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[382,383,384,385,386,387,388,389,391,392,393,394,395,397],"codes_lines_covered":[[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(rng.results, vec![1, 2, 3, 4]);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(rng.index, 0);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert!(!rng.half_used);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(dest[..8], [1, 0, 0, 0, 2, 0, 0, 0]);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(dest[8..16], [3, 0, 0, 0, 4, 0, 0, 0]);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(dest[16..32], [0; 16]);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert!(rng.results.len() >= 4);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert!(rng.index <= rng.results.len());","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(rng.index, 0);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(rng.half_used, false);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(&dest[0..16], &[10u8, 10u8, 10u8, 10u8, 20u8, 20u8, 20u8, 20u8]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(rng.index, 2);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert!(dest[16..].iter().all(|&x| x == 0));","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(results.len(), 2);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![0]); // Fill with one value","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0],","        index: 1, // Set index to exceed the available results","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 8]; // Dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0], index: 1, half_used: false, core: TestBlockRngCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest, [0, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![0]); // Fill with one value","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0],","        index: 1, // Set index to exceed the available results","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 8]; // Dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0], index: 1, half_used: false, core: TestBlockRngCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert_eq!(rng.index, 0);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![0]); // Fill with one value","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0],","        index: 1, // Set index to exceed the available results","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 8]; // Dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0], index: 1, half_used: false, core: TestBlockRngCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(rng.index, 0);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[32..40], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[40..48], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[48..56], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[56..64], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, _results: &mut Self::Results) {","            // No-op for generate","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest: [u8; 0] = []; // Empty dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    let mut dest: [u8; 0] = [];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 0);","}"],[382,383,384,385,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, _results: &mut Self::Results) {","            // No-op for generate","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest: [u8; 0] = []; // Empty dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    let mut dest: [u8; 0] = [];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[382,383,384,385,397]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, _results: &mut Self::Results) {","            // No-op for generate","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest: [u8; 0] = []; // Empty dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    let mut dest: [u8; 0] = [];","    rng.fill_bytes(&mut dest);","    assert!(dest.len() == 0);","}"],[382,383,384,385,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Minimum length","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; // Provide a deterministic output","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 8]; // Length for one u64","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 1], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[0..8], 1u64.to_le_bytes());","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[8..16], 2u64.to_le_bytes());","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 2);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(dest[0..8], expected_value);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(dest[8..16], expected_value);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(dest[16..24], expected_value);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(rng.index, 1);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert!(!rng.half_used);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 2], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 2], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 2], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 0);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[0..8], 3u64.to_le_bytes());","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[8..16], 4u64.to_le_bytes());","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 0);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(42);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: rng };","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 0);","}"],[382,383,384,385,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(42);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: rng };","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    assert!(block_rng.index == 1);","}"],[382,383,384,385,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(42);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: rng };","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    assert!(!block_rng.half_used);","}"],[382,383,384,385,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: TestRng };","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: TestRng };","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    assert!(block_rng.half_used == false);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: TestRng };","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    assert!(block_rng.index == 0);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest[0..8], 1u64.to_le_bytes());","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest[8..16], 2u64.to_le_bytes());","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest[16..24], 3u64.to_le_bytes());","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(block_rng.index, 0);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert!(!block_rng.half_used);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 { results, index: 3, half_used: false, core: rng };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(10);","            results.push(20);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 2];","    let mut block_rng = BlockRng64 {","        results,","        index: 2, // Exceeding the results size","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 16] = [0; 16]; // 2 * 8 = 16 bytes","    block_rng.fill_bytes(&mut dest);","    let mut test_rng = TestRng;","    let mut results = vec![0u64; 2];","    let mut block_rng = BlockRng64 {","    results,","    index: 2,","    half_used: false,","    core: test_rng,","    };","    let desired_output: [u8; 16] = [10, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];","    assert_eq!(dest, desired_output);","}"],[382,383,384,385,386,387,388,389,391,392,393,394,395,397]]],"codes_branches":[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(rng.results, vec![1, 2, 3, 4]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(rng.index, 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert!(!rng.half_used);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(dest[..8], [1, 0, 0, 0, 2, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(dest[8..16], [3, 0, 0, 0, 4, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert_eq!(dest[16..32], [0; 16]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert!(rng.results.len() >= 4);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![1, 2, 3, 4]); // Fill with four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 32]; // Dest buffer with size 32","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    assert!(rng.index <= rng.results.len());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(rng.index, 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(rng.half_used, false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(&dest[0..16], &[10u8, 10u8, 10u8, 10u8, 20u8, 20u8, 20u8, 20u8]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(rng.index, 2);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert!(dest[16..].iter().all(|&x| x == 0));","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![10, 20]); // Fill with two values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 2],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 40]; // Dest buffer with size 40","    rng.fill_bytes(&mut dest);","    let mut results = vec![10, 20];","    assert_eq!(results.len(), 2);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![0]); // Fill with one value","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0],","        index: 1, // Set index to exceed the available results","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 8]; // Dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0], index: 1, half_used: false, core: TestBlockRngCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest, [0, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![0]); // Fill with one value","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0],","        index: 1, // Set index to exceed the available results","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 8]; // Dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0], index: 1, half_used: false, core: TestBlockRngCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert_eq!(rng.index, 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestBlockRngCore;","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.extend(vec![0]); // Fill with one value","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0],","        index: 1, // Set index to exceed the available results","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 8]; // Dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0], index: 1, half_used: false, core: TestBlockRngCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(rng.index, 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[32..40], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[40..48], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[48..56], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            // Fill random values","            results.clear();","            results.extend(vec![100, 200, 300, 400]); // Four values","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest = [0u8; 64]; // Larger dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[56..64], vec![0, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, _results: &mut Self::Results) {","            // No-op for generate","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest: [u8; 0] = []; // Empty dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    let mut dest: [u8; 0] = [];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, _results: &mut Self::Results) {","            // No-op for generate","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest: [u8; 0] = []; // Empty dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    let mut dest: [u8; 0] = [];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct TestBlockRngCore;","","    impl BlockRngCore for TestBlockRngCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, _results: &mut Self::Results) {","            // No-op for generate","        }","    }","","    let mut rng = BlockRng64 {","        results: vec![0; 4],","        index: 0,","        half_used: false,","        core: TestBlockRngCore,","    };","","    let mut dest: [u8; 0] = []; // Empty dest buffer","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: vec![0; 4], index: 0, half_used: false, core: TestBlockRngCore };","    let mut dest: [u8; 0] = [];","    rng.fill_bytes(&mut dest);","    assert!(dest.len() == 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Minimum length","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; // Provide a deterministic output","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 8]; // Length for one u64","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 1], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 8];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[0..8], 1u64.to_le_bytes());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[8..16], 2u64.to_le_bytes());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 2);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s to fill","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 {","    results: [0; 2],","    index: 0,","    half_used: false,","    core: MockCore,","    };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(dest[0..8], expected_value);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(dest[8..16], expected_value);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(dest[16..24], expected_value);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert_eq!(rng.index, 1);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 1]; // Only one u64","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 1],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 24]; // More than one u64's worth","    rng.fill_bytes(&mut dest);","    let mut results = rng.results.as_mut();","    let expected_value = 1u64.to_le_bytes();","    assert!(!rng.half_used);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 2], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 2], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 1; ","            results[1] = 2; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 0,","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // 2 * 8 bytes","    rng.fill_bytes(&mut dest);","    let mut rng = BlockRng64 { results: [0; 2], index: 0, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[0..8], 3u64.to_le_bytes());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest[8..16], 4u64.to_le_bytes());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.index == 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = [u64; 2]; // Two u64s","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 3;","            results[1] = 4; ","        }","    }","","    let mut rng = BlockRng64 {","        results: [0; 2],","        index: 2, // Set index to exceed the length","        half_used: false,","        core: MockCore,","    };","    let mut dest = [0u8; 16]; // Size for two u64s","    rng.fill_bytes(&mut dest); ","    let mut rng = BlockRng64 { results: [0; 2], index: 2, half_used: false, core: MockCore };","    let mut dest = [0u8; 16];","    rng.fill_bytes(&mut dest);","    assert!(rng.half_used == false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(42);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: rng };","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(42);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: rng };","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    assert!(block_rng.index == 1);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(42);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: rng };","    let mut dest: [u8; 0] = [];","    block_rng.fill_bytes(&mut dest);","    assert!(!block_rng.half_used);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: TestRng };","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: TestRng };","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    assert!(block_rng.half_used == false);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    let mut results = vec![0u64; 1];","    let mut block_rng = BlockRng64 { results, index: 1, half_used: false, core: TestRng };","    let mut dest: [u8; 1] = [0];","    block_rng.fill_bytes(&mut dest);","    assert!(block_rng.index == 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest[0..8], 1u64.to_le_bytes());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest[8..16], 2u64.to_le_bytes());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest[16..24], 3u64.to_le_bytes());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(block_rng.index, 0);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","    results,","    index: 3,","    half_used: false,","    core: rng,","    };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert!(!block_rng.half_used);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(1);","            results.push(2);","            results.push(3);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 24] = [0; 24]; // 3 * 8 = 24 bytes","    block_rng.fill_bytes(&mut dest);","    let mut rng = TestRng;","    let mut results = vec![0u64; 3];","    let mut block_rng = BlockRng64 { results, index: 3, half_used: false, core: rng };","    let mut dest: [u8; 24] = [0; 24];","    block_rng.fill_bytes(&mut dest);","    assert_eq!(dest, [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]],[["{","    struct TestRng;","    impl BlockRngCore for TestRng {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            results.push(10);","            results.push(20);","        }","    }","","    let mut rng = TestRng;","    let mut results = vec![0u64; 2];","    let mut block_rng = BlockRng64 {","        results,","        index: 2, // Exceeding the results size","        half_used: false,","        core: rng,","    };","    ","    let mut dest: [u8; 16] = [0; 16]; // 2 * 8 = 16 bytes","    block_rng.fill_bytes(&mut dest);","    let mut test_rng = TestRng;","    let mut results = vec![0u64; 2];","    let mut block_rng = BlockRng64 {","    results,","    index: 2,","    half_used: false,","    core: test_rng,","    };","    let desired_output: [u8; 16] = [10, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];","    assert_eq!(dest, desired_output);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":true,"negative":false}]]]}