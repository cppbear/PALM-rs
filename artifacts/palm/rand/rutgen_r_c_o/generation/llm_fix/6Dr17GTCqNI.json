{
  "name": "rand_core::impls::fill_via_chunks",
  "name_with_impl": "rand_core::impls::fill_via_chunks",
  "mod_info": {
    "name": "impls",
    "loc": "rand_core/src/lib.rs:45:1:45:15"
  },
  "visible": true,
  "loc": "rand_core/src/impls.rs:78:1:101:2",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: dest.chunks_exact_mut(size) is \n",
        "// constraint: let Some(src) = src.next() is true\n",
        "// constraint: n > 0 is true\n",
        "// constraint: src.to_le_bytes().as_ref()[..n] is \n",
        "// constraint: dest.copy_from_slice(&src.to_le_bytes().as_ref()[..n]) is \n",
        "// expected return value/type: (num_chunks + 1, byte_len + n)\n"
      ],
      "input_infer": "Test input ranges: src: [T; 1..=N] where N >= 1, dest: [u8; size * (N + 1)] where size = core::mem::size_of::<T>()\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = [TestData { value: 1 }];",
                "    let mut dest = [0u8; 8];",
                "    let result = fill_via_chunks(&src, &mut dest);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(result, expected_result);"
                ],
                [
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(dest[0..4], [1, 0, 0, 0]);"
                ],
                [
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(dest[4..8], [0, 0, 0, 0]);"
                ],
                [
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(dest.len(), 8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }];",
                  "    let mut dest = [0u8; 8];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }];",
                  "    let mut dest = [0u8; 8];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(dest[0..4], [1, 0, 0, 0]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }];",
                  "    let mut dest = [0u8; 8];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(dest[4..8], [0, 0, 0, 0]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }];",
                  "    let mut dest = [0u8; 8];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let expected_result = (1, 4);",
                  "    assert_eq!(dest.len(), 8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                "    let mut dest = [0u8; 12];",
                "    let result = fill_via_chunks(&src, &mut dest);",
                "}"
              ],
              "oracles": [
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(size, 4);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(dest[0..4], [1, 0, 0, 0]);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(dest[4..8], [2, 0, 0, 0]);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(dest[8..12], [0, 0, 0, 0]);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(result.0, 2);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(result.1, 8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 12];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(size, 4);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 12];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(dest[0..4], [1, 0, 0, 0]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 12];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(dest[4..8], [2, 0, 0, 0]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 12];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(dest[8..12], [0, 0, 0, 0]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 12];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(result.0, 2);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 12];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    assert_eq!(result.1, 8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                "    let mut dest = [0u8; 16];",
                "    let result = fill_via_chunks(&src, &mut dest);",
                "}"
              ],
              "oracles": [
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(result.0, 4);"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(result.1, 12);"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(&dest[0..4], &1u32.to_le_bytes());"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(&dest[4..8], &2u32.to_le_bytes());"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(&dest[8..12], &3u32.to_le_bytes());"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[12], 0);"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[13], 0);"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[14], 0);"
                ],
                [
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[15], 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(result.0, 4);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(result.1, 12);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(&dest[0..4], &1u32.to_le_bytes());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(&dest[4..8], &2u32.to_le_bytes());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(&dest[8..12], &3u32.to_le_bytes());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[12], 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[13], 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[14], 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 16];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    assert_eq!(dest[15], 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                "    let mut dest = [0u8; 10];",
                "    let result = fill_via_chunks(&src, &mut dest);",
                "}"
              ],
              "oracles": [
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_num_chunks = src.len().min(dest.len() / size);",
                  "    let expected_byte_len = expected_num_chunks * size;",
                  "    let expected_return_value = (expected_num_chunks + 1, expected_byte_len + (dest.len() % size));",
                  "    assert_eq!(result, expected_return_value);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_num_chunks = src.len().min(dest.len() / size);",
                  "    let expected_byte_len = expected_num_chunks * size;",
                  "    let expected_return_value = (expected_num_chunks + 1, expected_byte_len + (dest.len() % size));",
                  "    assert_eq!(dest[..expected_byte_len], [1u8, 0, 0, 0, 2u8, 0, 0, 0]);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_num_chunks = src.len().min(dest.len() / size);",
                  "    let expected_byte_len = expected_num_chunks * size;",
                  "    let expected_return_value = (expected_num_chunks + 1, expected_byte_len + (dest.len() % size));",
                  "    assert_eq!(dest[expected_byte_len..], [0u8; 10 - expected_byte_len]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 10];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_num_chunks = src.len().min(dest.len() / size);",
                  "    let expected_byte_len = expected_num_chunks * size;",
                  "    let expected_return_value = (expected_num_chunks + 1, expected_byte_len + (dest.len() % size));",
                  "    assert_eq!(result, expected_return_value);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 10];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_num_chunks = src.len().min(dest.len() / size);",
                  "    let expected_byte_len = expected_num_chunks * size;",
                  "    let expected_return_value = (expected_num_chunks + 1, expected_byte_len + (dest.len() % size));",
                  "    assert_eq!(dest[..expected_byte_len], [1u8, 0, 0, 0, 2u8, 0, 0, 0]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 10];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_num_chunks = src.len().min(dest.len() / size);",
                  "    let expected_byte_len = expected_num_chunks * size;",
                  "    let expected_return_value = (expected_num_chunks + 1, expected_byte_len + (dest.len() % size));",
                  "    assert_eq!(dest[expected_byte_len..], [0u8; 10 - expected_byte_len]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling rand_core v0.9.3 (/home/utgen/workspace/rand/rand_core)\nerror[E0435]: attempt to use a non-constant value in a constant\n   --> rand_core/src/impls.rs:247:54\n    |\n247 |     assert_eq!(dest[expected_byte_len..], [0u8; 10 - expected_byte_len]);\n    |                                                      ^^^^^^^^^^^^^^^^^ non-constant value\n    |\nhelp: consider using `const` instead of `let`\n    |\n245 |     const expected_byte_len: /* Type */ = expected_num_chunks * size;\n    |     ~~~~~                  ++++++++++++\n\nwarning: unused imports: `BlockRng64` and `BlockRng`\n   --> rand_core/src/block.rs:428:24\n    |\n428 |     use crate::block::{BlockRng, BlockRng64, BlockRngCore};\n    |                        ^^^^^^^^  ^^^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `RngCore`\n   --> rand_core/src/block.rs:429:17\n    |\n429 |     use crate::{RngCore, SeedableRng};\n    |                 ^^^^^^^\n\nwarning: unused import: `super::*`\n   --> rand_core/src/impls.rs:176:9\n    |\n176 |     use super::*;\n    |         ^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0435`.\nwarning: `rand_core` (lib test) generated 3 warnings\nerror: could not compile `rand_core` (lib test) due to 1 previous error; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let src = [TestData { value: 1 }];",
                "    let mut dest = [0u8; 4];",
                "    let result = fill_via_chunks(&src, &mut dest);",
                "}"
              ],
              "oracles": [
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_byte_len = 4;",
                  "    let expected_num_chunks = 1;",
                  "    let expected_result = (expected_num_chunks + 1, expected_byte_len + 0);",
                  "    assert_eq!(result, expected_result);"
                ],
                [
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_byte_len = 4;",
                  "    let expected_num_chunks = 1;",
                  "    let expected_result = (expected_num_chunks + 1, expected_byte_len + 0);",
                  "    assert_eq!(dest, [1, 0, 0, 0]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }];",
                  "    let mut dest = [0u8; 4];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_byte_len = 4;",
                  "    let expected_num_chunks = 1;",
                  "    let expected_result = (expected_num_chunks + 1, expected_byte_len + 0);",
                  "    assert_eq!(result, expected_result);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Copy, Clone)]",
                  "struct TestData {",
                  "    value: u32,",
                  "}",
                  "",
                  "impl Observable for TestData {",
                  "    type Bytes = [u8; 4];",
                  "",
                  "    fn to_le_bytes(self) -> Self::Bytes {",
                  "        self.value.to_le_bytes()",
                  "    }",
                  "}",
                  "    let src = [TestData { value: 1 }];",
                  "    let mut dest = [0u8; 4];",
                  "    let result = fill_via_chunks(&src, &mut dest);",
                  "    let size = core::mem::size_of::<TestData>();",
                  "    let expected_byte_len = 4;",
                  "    let expected_num_chunks = 1;",
                  "    let expected_result = (expected_num_chunks + 1, expected_byte_len + 0);",
                  "    assert_eq!(dest, [1, 0, 0, 0]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: dest.chunks_exact_mut(size) is \n",
        "// constraint: let Some(src) = src.next() is true\n",
        "// constraint: n > 0 is false, with bound n == 0\n",
        "// expected return value/type: (num_chunks, byte_len)\n"
      ],
      "input_infer": "1 <= src.len() <= 1, dest.len() == 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Copy, Clone)]",
                "    struct TestType(u32);",
                "    ",
                "    impl Observable for TestType {",
                "        type Bytes = [u8; 4];",
                "        fn to_le_bytes(self) -> Self::Bytes {",
                "            self.0.to_le_bytes()",
                "        }",
                "    }",
                "    ",
                "    let src: &[TestType] = &[TestType(1)];",
                "    let mut dest: [u8; 0] = [];",
                "    let result = fill_via_chunks(src, &mut dest);",
                "}"
              ],
              "oracles": [
                [
                  "    let size = core::mem::size_of::<TestType>();",
                  "    let expected_num_chunks = 0;",
                  "    let expected_byte_len = 0;",
                  "    assert_eq!(result.0, expected_num_chunks);"
                ],
                [
                  "    let size = core::mem::size_of::<TestType>();",
                  "    let expected_num_chunks = 0;",
                  "    let expected_byte_len = 0;",
                  "    assert_eq!(result.1, expected_byte_len);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Copy, Clone)]",
                  "    struct TestType(u32);",
                  "    ",
                  "    impl Observable for TestType {",
                  "        type Bytes = [u8; 4];",
                  "        fn to_le_bytes(self) -> Self::Bytes {",
                  "            self.0.to_le_bytes()",
                  "        }",
                  "    }",
                  "    ",
                  "    let src: &[TestType] = &[TestType(1)];",
                  "    let mut dest: [u8; 0] = [];",
                  "    let result = fill_via_chunks(src, &mut dest);",
                  "    let size = core::mem::size_of::<TestType>();",
                  "    let expected_num_chunks = 0;",
                  "    let expected_byte_len = 0;",
                  "    assert_eq!(result.0, expected_num_chunks);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Copy, Clone)]",
                  "    struct TestType(u32);",
                  "    ",
                  "    impl Observable for TestType {",
                  "        type Bytes = [u8; 4];",
                  "        fn to_le_bytes(self) -> Self::Bytes {",
                  "            self.0.to_le_bytes()",
                  "        }",
                  "    }",
                  "    ",
                  "    let src: &[TestType] = &[TestType(1)];",
                  "    let mut dest: [u8; 0] = [];",
                  "    let result = fill_via_chunks(src, &mut dest);",
                  "    let size = core::mem::size_of::<TestType>();",
                  "    let expected_num_chunks = 0;",
                  "    let expected_byte_len = 0;",
                  "    assert_eq!(result.1, expected_byte_len);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Copy, Clone)]",
                "    struct TestType(u32);",
                "    ",
                "    impl Observable for TestType {",
                "        type Bytes = [u8; 4];",
                "        fn to_le_bytes(self) -> Self::Bytes {",
                "            self.0.to_le_bytes()",
                "        }",
                "    }",
                "    ",
                "    let src: &[TestType] = &[TestType(2)];",
                "    let mut dest: [u8; 0] = [];",
                "    let result = fill_via_chunks(src, &mut dest);",
                "}"
              ],
              "oracles": [
                [
                  "    let src: &[TestType] = &[TestType(2)];",
                  "    let mut dest: [u8; 0] = [];",
                  "    let result = fill_via_chunks(src, &mut dest);",
                  "    assert_eq!(result, (0, 0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Copy, Clone)]",
                  "    struct TestType(u32);",
                  "    ",
                  "    impl Observable for TestType {",
                  "        type Bytes = [u8; 4];",
                  "        fn to_le_bytes(self) -> Self::Bytes {",
                  "            self.0.to_le_bytes()",
                  "        }",
                  "    }",
                  "    ",
                  "    let src: &[TestType] = &[TestType(2)];",
                  "    let mut dest: [u8; 0] = [];",
                  "    let result = fill_via_chunks(src, &mut dest);",
                  "    let src: &[TestType] = &[TestType(2)];",
                  "    let mut dest: [u8; 0] = [];",
                  "    let result = fill_via_chunks(src, &mut dest);",
                  "    assert_eq!(result, (0, 0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}