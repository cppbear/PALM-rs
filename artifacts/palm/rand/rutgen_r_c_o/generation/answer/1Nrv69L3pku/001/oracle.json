[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for TestRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = TestRng { value: 0 };",
          "    let alphanumeric = Alphanumeric;",
          "    alphanumeric.sample(&mut rng); // var will be 0, which is less than RANGE",
          "",
          "    rng.value = 1;",
          "    alphanumeric.sample(&mut rng); // var will be 1, which is less than RANGE",
          "",
          "    rng.value = 61;",
          "    alphanumeric.sample(&mut rng); // var will be 61, which is less than RANGE",
          "}"
        ],
        "oracles": [
          [
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result, b'A'); // GEN_ASCII_STR_CHARSET[0 as usize]"
          ],
          [
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    rng.value = 1;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result, b'B'); // GEN_ASCII_STR_CHARSET[1 as usize]"
          ],
          [
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    rng.value = 1;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    rng.value = 61;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result, b'9'); // GEN_ASCII_STR_CHARSET[61 as usize]"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for TestRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 0, which is less than RANGE",
            "",
            "    rng.value = 1;",
            "    alphanumeric.sample(&mut rng); // var will be 1, which is less than RANGE",
            "",
            "    rng.value = 61;",
            "    alphanumeric.sample(&mut rng); // var will be 61, which is less than RANGE",
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result, b'A'); // GEN_ASCII_STR_CHARSET[0 as usize]",
            "}"
          ],
          [
            "{",
            "    struct TestRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for TestRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 0, which is less than RANGE",
            "",
            "    rng.value = 1;",
            "    alphanumeric.sample(&mut rng); // var will be 1, which is less than RANGE",
            "",
            "    rng.value = 61;",
            "    alphanumeric.sample(&mut rng); // var will be 61, which is less than RANGE",
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    rng.value = 1;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result, b'B'); // GEN_ASCII_STR_CHARSET[1 as usize]",
            "}"
          ],
          [
            "{",
            "    struct TestRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for TestRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 0, which is less than RANGE",
            "",
            "    rng.value = 1;",
            "    alphanumeric.sample(&mut rng); // var will be 1, which is less than RANGE",
            "",
            "    rng.value = 61;",
            "    alphanumeric.sample(&mut rng); // var will be 61, which is less than RANGE",
            "    let mut rng = TestRng { value: 0 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    rng.value = 1;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    rng.value = 61;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result, b'9'); // GEN_ASCII_STR_CHARSET[61 as usize]",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct EdgeRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for EdgeRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = EdgeRng { value: 62 };",
          "    let alphanumeric = Alphanumeric;",
          "    alphanumeric.sample(&mut rng); // var will be 62 (not returned since it's >= RANGE)",
          "",
          "    rng.value = 63;",
          "    alphanumeric.sample(&mut rng); // var will be 63 (not returned since it's >= RANGE)",
          "",
          "    rng.value = 31;",
          "    alphanumeric.sample(&mut rng); // var will be 31, which is less than RANGE",
          "}"
        ],
        "oracles": [
          [
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    assert!(result1 != GEN_ASCII_STR_CHARSET[62]);"
          ],
          [
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    assert!(result1 != GEN_ASCII_STR_CHARSET[63]);"
          ],
          [
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    rng.value = 63;",
            "    let result2 = alphanumeric.sample(&mut rng);",
            "    assert!(result2 != GEN_ASCII_STR_CHARSET[63]);"
          ],
          [
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    rng.value = 63;",
            "    let result2 = alphanumeric.sample(&mut rng);",
            "    rng.value = 31;",
            "    let result3 = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result3, GEN_ASCII_STR_CHARSET[31]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct EdgeRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for EdgeRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 62 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 63;",
            "    alphanumeric.sample(&mut rng); // var will be 63 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 31;",
            "    alphanumeric.sample(&mut rng); // var will be 31, which is less than RANGE",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    assert!(result1 != GEN_ASCII_STR_CHARSET[62]);",
            "}"
          ],
          [
            "{",
            "    struct EdgeRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for EdgeRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 62 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 63;",
            "    alphanumeric.sample(&mut rng); // var will be 63 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 31;",
            "    alphanumeric.sample(&mut rng); // var will be 31, which is less than RANGE",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    assert!(result1 != GEN_ASCII_STR_CHARSET[63]);",
            "}"
          ],
          [
            "{",
            "    struct EdgeRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for EdgeRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 62 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 63;",
            "    alphanumeric.sample(&mut rng); // var will be 63 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 31;",
            "    alphanumeric.sample(&mut rng); // var will be 31, which is less than RANGE",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    rng.value = 63;",
            "    let result2 = alphanumeric.sample(&mut rng);",
            "    assert!(result2 != GEN_ASCII_STR_CHARSET[63]);",
            "}"
          ],
          [
            "{",
            "    struct EdgeRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for EdgeRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 62 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 63;",
            "    alphanumeric.sample(&mut rng); // var will be 63 (not returned since it's >= RANGE)",
            "",
            "    rng.value = 31;",
            "    alphanumeric.sample(&mut rng); // var will be 31, which is less than RANGE",
            "    let mut rng = EdgeRng { value: 62 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result1 = alphanumeric.sample(&mut rng);",
            "    rng.value = 63;",
            "    let result2 = alphanumeric.sample(&mut rng);",
            "    rng.value = 31;",
            "    let result3 = alphanumeric.sample(&mut rng);",
            "    assert_eq!(result3, GEN_ASCII_STR_CHARSET[31]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct InvalidRng {",
          "        value: u32,",
          "    }",
          "",
          "    impl Rng for InvalidRng {",
          "        fn next_u32(&mut self) -> u32 {",
          "            self.value",
          "        }",
          "    }",
          "",
          "    let mut rng = InvalidRng { value: 64 };",
          "    let alphanumeric = Alphanumeric;",
          "    alphanumeric.sample(&mut rng); // var will be 64 (not returned since it's >= RANGE)",
          "}"
        ],
        "oracles": [
          [
            "    let mut rng = InvalidRng { value: 64 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert!(result >= 65 && result <= 90 || result >= 97 && result <= 122 || result >= 48 && result <= 57);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct InvalidRng {",
            "        value: u32,",
            "    }",
            "",
            "    impl Rng for InvalidRng {",
            "        fn next_u32(&mut self) -> u32 {",
            "            self.value",
            "        }",
            "    }",
            "",
            "    let mut rng = InvalidRng { value: 64 };",
            "    let alphanumeric = Alphanumeric;",
            "    alphanumeric.sample(&mut rng); // var will be 64 (not returned since it's >= RANGE)",
            "    let mut rng = InvalidRng { value: 64 };",
            "    let alphanumeric = Alphanumeric;",
            "    let result = alphanumeric.sample(&mut rng);",
            "    assert!(result >= 65 && result <= 90 || result >= 97 && result <= 122 || result >= 48 && result <= 57);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]