{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// rand_chacha/src/guts.rs\n// crate name is rand_chacha\nuse ppv_lite86::{dispatch, dispatch_light128};\npub use ppv_lite86::Machine;\nuse ppv_lite86::{\n    vec128_storage, ArithOps, BitOps32, LaneWords4, MultiLane, StoreBytes, Vec4, Vec4Ext,\n    Vector,\n};\npub(crate) const BLOCK: usize = 16;\npub(crate) const BLOCK64: u64 = BLOCK as u64;\nconst LOG2_BUFBLOCKS: u64 = 2;\nconst BUFBLOCKS: u64 = 1 << LOG2_BUFBLOCKS;\npub(crate) const BUFSZ64: u64 = BLOCK64 * BUFBLOCKS;\npub(crate) const BUFSZ: usize = BUFSZ64 as usize;\nconst STREAM_PARAM_NONCE: u32 = 1;\nconst STREAM_PARAM_BLOCK: u32 = 0;\ndispatch!(\n    m, Mach, { fn refill_wide(state : & mut ChaCha, drounds : u32, out : & mut [u32;\n    BUFSZ]) { refill_wide_impl(m, state, drounds, out); } }\n);\ndispatch!(\n    m, Mach, { fn refill_narrow_rounds(state : & mut ChaCha, drounds : u32) -> State <\n    vec128_storage > { let k : Mach::u32x4 = m.vec([0x6170_7865, 0x3320_646e,\n    0x7962_2d32, 0x6b20_6574]); let mut x = State { a : k, b : m.unpack(state.b), c : m\n    .unpack(state.c), d : m.unpack(state.d), }; for _ in 0..drounds { x = round(x); x =\n    undiagonalize(round(diagonalize(x))); } State { a : x.a.into(), b : x.b.into(), c : x\n    .c.into(), d : x.d.into(), } } }\n);\ndispatch_light128!(\n    m, Mach, { fn set_stream_param(state : & mut ChaCha, param : u32, value : u64) { let\n    d : Mach::u32x4 = m.unpack(state.d); state.d = d.insert((value >> 32) as u32, (param\n    << 1) | 1).insert(value as u32, param << 1).into(); } }\n);\ndispatch_light128!(\n    m, Mach, { fn get_stream_param(state : & ChaCha, param : u32) -> u64 { let d :\n    Mach::u32x4 = m.unpack(state.d); ((d.extract((param << 1) | 1) as u64) << 32) | d\n    .extract(param << 1) as u64 } }\n);\ndispatch_light128!(\n    m, Mach, { fn get_seed(state : & ChaCha) -> [u8; 32] { let b : Mach::u32x4 = m\n    .unpack(state.b); let c : Mach::u32x4 = m.unpack(state.c); let mut key = [0u8; 32]; b\n    .write_le(& mut key[..16]); c.write_le(& mut key[16..]); key } }\n);\ndispatch_light128!(\n    m, Mach, { fn init_chacha(key : & [u8; 32], nonce : & [u8]) -> ChaCha { let ctr_nonce\n    = [0, if nonce.len() == 12 { read_u32le(& nonce[0..4]) } else { 0 }, read_u32le(&\n    nonce[nonce.len() - 8..nonce.len() - 4]), read_u32le(& nonce[nonce.len() - 4..]),];\n    let key0 : Mach::u32x4 = m.read_le(& key[..16]); let key1 : Mach::u32x4 = m.read_le(&\n    key[16..]); ChaCha { b : key0.into(), c : key1.into(), d : ctr_nonce.into(), } } }\n);\ndispatch_light128!(\n    m, Mach, { fn init_chacha_x(key : & [u8; 32], nonce : & [u8; 24], rounds : u32) ->\n    ChaCha { let key0 : Mach::u32x4 = m.read_le(& key[..16]); let key1 : Mach::u32x4 = m\n    .read_le(& key[16..]); let nonce0 : Mach::u32x4 = m.read_le(& nonce[..16]); let mut\n    state = ChaCha { b : key0.into(), c : key1.into(), d : nonce0.into(), }; let x =\n    refill_narrow_rounds(& mut state, rounds); let ctr_nonce1 = [0, 0, read_u32le(&\n    nonce[16..20]), read_u32le(& nonce[20..24])]; state.b = x.a; state.c = x.d; state.d =\n    ctr_nonce1.into(); state } }\n);\n#[derive(Clone, PartialEq, Eq)]\npub struct ChaCha {\n    pub(crate) b: vec128_storage,\n    pub(crate) c: vec128_storage,\n    pub(crate) d: vec128_storage,\n}\n#[allow(clippy::many_single_char_names)]\n#[inline(always)]\nfn refill_wide_impl<Mach: Machine>(\n    m: Mach,\n    state: &mut ChaCha,\n    drounds: u32,\n    out: &mut [u32; BUFSZ],\n) {\n    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n    let b = m.unpack(state.b);\n    let c = m.unpack(state.c);\n    let mut x = State {\n        a: Mach::u32x4x4::from_lanes([k, k, k, k]),\n        b: Mach::u32x4x4::from_lanes([b, b, b, b]),\n        c: Mach::u32x4x4::from_lanes([c, c, c, c]),\n        d: d0123(m, state.d),\n    };\n    for _ in 0..drounds {\n        x = round(x);\n        x = undiagonalize(round(diagonalize(x)));\n    }\n    let kk = Mach::u32x4x4::from_lanes([k, k, k, k]);\n    let sb = m.unpack(state.b);\n    let sb = Mach::u32x4x4::from_lanes([sb, sb, sb, sb]);\n    let sc = m.unpack(state.c);\n    let sc = Mach::u32x4x4::from_lanes([sc, sc, sc, sc]);\n    let sd = d0123(m, state.d);\n    let results = Mach::u32x4x4::transpose4(x.a + kk, x.b + sb, x.c + sc, x.d + sd);\n    out[0..16].copy_from_slice(&results.0.to_scalars());\n    out[16..32].copy_from_slice(&results.1.to_scalars());\n    out[32..48].copy_from_slice(&results.2.to_scalars());\n    out[48..64].copy_from_slice(&results.3.to_scalars());\n    state.d = add_pos(m, sd.to_lanes()[0], 4).into();\n}\n#[inline(always)]\n#[cfg(target_endian = \"little\")]\nfn d0123<Mach: Machine>(m: Mach, d: vec128_storage) -> Mach::u32x4x4 {\n    let d0: Mach::u64x2 = m.unpack(d);\n    let incr = Mach::u64x2x4::from_lanes([\n        m.vec([0, 0]),\n        m.vec([1, 0]),\n        m.vec([2, 0]),\n        m.vec([3, 0]),\n    ]);\n    m.unpack((Mach::u64x2x4::from_lanes([d0, d0, d0, d0]) + incr).into())\n}\n#[inline(always)]\n#[cfg(target_endian = \"little\")]\nfn add_pos<Mach: Machine>(m: Mach, d: Mach::u32x4, i: u64) -> Mach::u32x4 {\n    let d0: Mach::u64x2 = m.unpack(d.into());\n    let incr = m.vec([i, 0]);\n    m.unpack((d0 + incr).into())\n}\n\nThe function to be tested is presented as follows:\nfn refill_wide_impl<Mach: Machine>(\n    m: Mach,\n    state: &mut ChaCha,\n    drounds: u32,\n    out: &mut [u32; BUFSZ],\n) {\n    let k = m.vec([0x6170_7865, 0x3320_646e, 0x7962_2d32, 0x6b20_6574]);\n    let b = m.unpack(state.b);\n    let c = m.unpack(state.c);\n    let mut x = State {\n        a: Mach::u32x4x4::from_lanes([k, k, k, k]),\n        b: Mach::u32x4x4::from_lanes([b, b, b, b]),\n        c: Mach::u32x4x4::from_lanes([c, c, c, c]),\n        d: d0123(m, state.d),\n    };\n    for _ in 0..drounds {\n        x = round(x);\n        x = undiagonalize(round(diagonalize(x)));\n    }\n    let kk = Mach::u32x4x4::from_lanes([k, k, k, k]);\n    let sb = m.unpack(state.b);\n    let sb = Mach::u32x4x4::from_lanes([sb, sb, sb, sb]);\n    let sc = m.unpack(state.c);\n    let sc = Mach::u32x4x4::from_lanes([sc, sc, sc, sc]);\n    let sd = d0123(m, state.d);\n    let results = Mach::u32x4x4::transpose4(x.a + kk, x.b + sb, x.c + sc, x.d + sd);\n    out[0..16].copy_from_slice(&results.0.to_scalars());\n    out[16..32].copy_from_slice(&results.1.to_scalars());\n    out[32..48].copy_from_slice(&results.2.to_scalars());\n    out[48..64].copy_from_slice(&results.3.to_scalars());\n    state.d = add_pos(m, sd.to_lanes()[0], 4).into();\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}