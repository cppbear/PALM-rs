{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/increasing_uniform.rs\n// crate name is rand\nuse crate::{Rng, RngCore};\npub(crate) struct IncreasingUniform<R: RngCore> {\n    pub rng: R,\n    n: u32,\n    chunk: u32,\n    chunk_remaining: u8,\n}\nimpl<R: RngCore> IncreasingUniform<R> {\n    pub fn new(rng: R, n: u32) -> Self {\n        let chunk_remaining = if n == 0 { 1 } else { 0 };\n        Self {\n            rng,\n            n,\n            chunk: 0,\n            chunk_remaining,\n        }\n    }\n    #[inline]\n    pub fn next_index(&mut self) -> usize {\n        let next_n = self.n + 1;\n        let next_chunk_remaining = self\n            .chunk_remaining\n            .checked_sub(1)\n            .unwrap_or_else(|| {\n                let (bound, remaining) = calculate_bound_u32(next_n);\n                self.chunk = self.rng.random_range(..bound);\n                remaining - 1\n            });\n        let result = if next_chunk_remaining == 0 {\n            self.chunk as usize\n        } else {\n            let r = self.chunk % next_n;\n            self.chunk /= next_n;\n            r as usize\n        };\n        self.chunk_remaining = next_chunk_remaining;\n        self.n = next_n;\n        result\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Returns a number in [0,n] and increments n by 1.\n/// Generates new random bits as needed\n/// Panics if `n >= u32::MAX`\npub fn next_index(&mut self) -> usize {\n    let next_n = self.n + 1;\n\n    // There's room for further optimisation here:\n    // random_range uses rejection sampling (or other method; see #1196) to avoid bias.\n    // When the initial sample is biased for range 0..bound\n    // it may still be viable to use for a smaller bound\n    // (especially if small biases are considered acceptable).\n\n    let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {\n        // If the chunk is empty, generate a new chunk\n        let (bound, remaining) = calculate_bound_u32(next_n);\n        // bound = (n + 1) * (n + 2) *..* (n + remaining)\n        self.chunk = self.rng.random_range(..bound);\n        // Chunk is a random number in\n        // [0, (n + 1) * (n + 2) *..* (n + remaining) )\n\n        remaining - 1\n    });\n\n    let result = if next_chunk_remaining == 0 {\n        // `chunk` is a random number in the range [0..n+1)\n        // Because `chunk_remaining` is about to be set to zero\n        // we do not need to clear the chunk here\n        self.chunk as usize\n    } else {\n        // `chunk` is a random number in a range that is a multiple of n+1\n        // so r will be a random number in [0..n+1)\n        let r = self.chunk % next_n;\n        self.chunk /= next_n;\n        r as usize\n    };\n\n    self.chunk_remaining = next_chunk_remaining;\n    self.n = next_n;\n    result\n}\n",
  "depend_pt": ""
}