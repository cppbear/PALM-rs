{"function_name":"rand_core::block::block::BlockRng<R>::generate_and_set","file_path":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core/src/block.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core","tests":24,"tests_lines":[26,26,25,25,26,26,25,25,25,29,29,29,30,30,29,29,29,29,31,31,31,31,30,33],"oracles":9,"oracles_compiled":7,"oracles_compiled_rate":77.77777777777779,"tests_compiled":16,"tests_compiled_rate":66.66666666666666,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":16,"tests_passed":16,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[177,178,179,180,181],"codes_lines_covered":[[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = i as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(0);","    let mut results = vec![0; 10];","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results, index: 0, core };","    block_rng.generate_and_set(0);","    assert_eq!(block_rng.index, 0);","}"],[177,178,179,180,181]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 1) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(5);","    let mut results = vec![0; 10];","    let expected_results = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];","    block_rng.core.generate(&mut results);","    assert_eq!(results, expected_results);","}"],[177,178,179,180,181]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 1) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(5);","    let mut results = vec![0; 10];","    let expected_results = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];","    block_rng.core.generate(&mut results);","    assert_eq!(block_rng.index(), 5);","}"],[177,178,179,180,181]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i * 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(9);","    let mut results = vec![0; 10];","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results, index: 0, core };","    block_rng.generate_and_set(9);","    assert_eq!(block_rng.index, 9);","}"],[177,178,179,180,181]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(10);","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results: vec![0; 10], index: 0, core };","    block_rng.generate_and_set(10);","    assert!(block_rng.index == 10);","}"],[177,178]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(10);","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results: vec![0; 10], index: 0, core };","    block_rng.generate_and_set(10);","    assert!(block_rng.results == vec![2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);","}"],[177,178]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(10);","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results: vec![0; 10], index: 0, core };","    block_rng.generate_and_set(10);","    assert!(block_rng.results.len() == 10);","}"],[177,178]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","    ","    struct DummyBlockRngCore {","        results: [u32; 1],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 1];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Setting an arbitrary value for testing","        }","    }","","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    assert_eq!(block_rng.index(), 0);","}"],[177,178,179,180,181]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","    ","    struct DummyBlockRngCore {","        results: [u32; 1],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 1];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Setting an arbitrary value for testing","        }","    }","","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    assert_eq!(block_rng.results.as_ref()[0], 42);","}"],[177,178,179,180,181]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 2],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; ","            results[1] = 84; ","        }","    }","","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(2);","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    assert!(block_rng.results.as_ref().len() == 2);","}"],[177,178]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 2],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; ","            results[1] = 84; ","        }","    }","","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(2);","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    assert!(block_rng.index() == 0);","}"],[177,178]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 2],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; ","            results[1] = 84; ","        }","    }","","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(2);","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    assert_eq!(block_rng.results.as_ref(), &[0, 0]);","}"],[177,178]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.results.as_ref()[0], 42);","}"],[177,178,179,180,181]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.results.as_ref()[1], 84);","}"],[177,178,179,180,181]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.results.as_ref()[2], 126);","}"],[177,178,179,180,181]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.index(), 1);","}"],[177,178,179,180,181]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = i as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(0);","    let mut results = vec![0; 10];","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results, index: 0, core };","    block_rng.generate_and_set(0);","    assert_eq!(block_rng.index, 0);","}"],[]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 1) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(5);","    let mut results = vec![0; 10];","    let expected_results = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];","    block_rng.core.generate(&mut results);","    assert_eq!(results, expected_results);","}"],[]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 1) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(5);","    let mut results = vec![0; 10];","    let expected_results = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];","    block_rng.core.generate(&mut results);","    assert_eq!(block_rng.index(), 5);","}"],[]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i * 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(9);","    let mut results = vec![0; 10];","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results, index: 0, core };","    block_rng.generate_and_set(9);","    assert_eq!(block_rng.index, 9);","}"],[]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(10);","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results: vec![0; 10], index: 0, core };","    block_rng.generate_and_set(10);","    assert!(block_rng.index == 10);","}"],[]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(10);","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results: vec![0; 10], index: 0, core };","    block_rng.generate_and_set(10);","    assert!(block_rng.results == vec![2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);","}"],[]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u32;","        type Results = Vec<u32>;","        fn generate(&mut self, results: &mut Self::Results) {","            for i in 0..results.len() {","                results[i] = (i + 2) as u32;","            }","        }","    }","","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> {","        results: vec![0; 10],","        index: 0,","        core,","    };","","    block_rng.generate_and_set(10);","    let core = MockCore;","    let mut block_rng = BlockRng::<MockCore> { results: vec![0; 10], index: 0, core };","    block_rng.generate_and_set(10);","    assert!(block_rng.results.len() == 10);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","    ","    struct DummyBlockRngCore {","        results: [u32; 1],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 1];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Setting an arbitrary value for testing","        }","    }","","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    assert_eq!(block_rng.index(), 0);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","    ","    struct DummyBlockRngCore {","        results: [u32; 1],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 1];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Setting an arbitrary value for testing","        }","    }","","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    let core = DummyBlockRngCore { results: [0; 1] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(0);","    assert_eq!(block_rng.results.as_ref()[0], 42);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 2],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; ","            results[1] = 84; ","        }","    }","","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(2);","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    assert!(block_rng.results.as_ref().len() == 2);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 2],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; ","            results[1] = 84; ","        }","    }","","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(2);","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    assert!(block_rng.index() == 0);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 2],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","        ","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; ","            results[1] = 84; ","        }","    }","","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(2);","    let core = DummyBlockRngCore { results: [0; 2] };","    let mut block_rng = BlockRng::new(core);","    assert_eq!(block_rng.results.as_ref(), &[0, 0]);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.results.as_ref()[0], 42);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.results.as_ref()[1], 84);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.results.as_ref()[2], 126);","}"],[]],[["{","    struct DummyRng;","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 { 0 }","        fn next_u64(&mut self) -> u64 { 0 }","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    struct DummyBlockRngCore {","        results: [u32; 3],","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42;","            results[1] = 84;","            results[2] = 126;","        }","    }","","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    let core = DummyBlockRngCore { results: [0; 3] };","    let mut block_rng = BlockRng::new(core);","    block_rng.generate_and_set(1);","    assert_eq!(block_rng.index(), 1);","}"],[]]]}