{"function_name":"rand_core::le::read_u32_into","file_path":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core/src/le.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core","tests":42,"tests_lines":[18,18,18,18,15,18,14,14,14,14,14,14,14,14,14,14,16,16,16,16,10,10,10,10,8,8,9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],"oracles":14,"oracles_compiled":11,"oracles_compiled_rate":78.57142857142857,"tests_compiled":36,"tests_compiled_rate":85.71428571428571,"oracles_run":11,"oracles_passed":11,"oracles_passed_rate":100.0,"tests_run":36,"tests_passed":32,"tests_passed_rate":88.88888888888889,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[24,25,26,27,28,29],"codes_lines_covered":[[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert!(src_len);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert_eq!(actual_first, expected_first);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert_eq!(actual_second, expected_second);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert!(dst.len() == 2);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert_eq!(src_len, 4 * dst_len);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src.chunks_exact(4).len() == dst.len());","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(dst[0] == 4);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(dst[1] == 8);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(dst[2] == 12);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src[0..4] == [4, 0, 0, 0]);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src[4..8] == [8, 0, 0, 0]);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src[8..12] == [12, 0, 0, 0]);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    assert!(dst.len() == 1);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    assert!(src.len() < 4 * dst.len());","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert!(dst.len() == 2);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert!(src.len() >= 4 * dst.len());","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert_eq!(dst[0], 4294967295);","}"],[24,25,26,27,28,29]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert_eq!(dst[1], 1);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert_eq!(dst, [1]);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert!(dst.len() == 1);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert!(src.len() >= 4 * dst.len());","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert!(src.chunks_exact(4).count() == 1);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    let src = [1u8];","    let mut dst = [0u32; 1];","    assert!(src.len() < 4 * dst.len());","}"],[24,25]],[["{","    let src = [1u8];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    let src = [1u8];","    let mut dst = [0u32; 1];","    assert!(dst[0] == 0u32);","}"],[24,25]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    assert_eq!(dst[0], 1);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst.len(), 2);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert!(src.len() >= 4 * dst.len());","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(src.chunks_exact(4).len(), 2);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[0], 1);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[1], 2);","}"],[24,25,26,27,28,29]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[0], 1);","}"],[24,25]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[1], 2);","}"],[24,25]],[["{","    let src: [u8; 2] = [1, 2]; // 2 bytes","    let mut dst: [u32; 1] = [0]; // 1 u32 requires 4 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 2] = [1, 2];","    let mut dst: [u32; 1] = [0];","    assert!(src.len() < 4 * dst.len());","}"],[24,25]],[["{","    let src: [u8; 1] = [1]; // 1 byte","    let mut dst: [u32; 2] = [0, 0]; // 2 u32 requires 8 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 1] = [1];","    let mut dst: [u32; 2] = [0, 0];","    assert!(src.len() < 4 * dst.len());","}"],[24,25]],[["{","    let src: [u8; 1] = [1]; // 1 byte","    let mut dst: [u32; 2] = [0, 0]; // 2 u32 requires 8 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 1] = [1];","    let mut dst: [u32; 2] = [0, 0];","    assert_eq!(dst, [0, 0]);","}"],[24,25]],[["{","    let src: [u8; 4] = [1, 2, 3, 4]; // 4 bytes","    let mut dst: [u32; 2] = [0, 0]; // 2 u32 requires 8 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 4] = [1, 2, 3, 4];","    let mut dst: [u32; 2] = [0, 0];","    assert!(src.len() < 4 * dst.len());","}"],[24,25]]],"codes_branches":[],"codes_branches_covered":[[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert!(src_len);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert_eq!(actual_first, expected_first);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert_eq!(actual_second, expected_second);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // 4 * 2 bytes, two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src_len = src.len() >= 4 * dst.len();","    let dst_len = dst.len();","    let expected_first = 1;","    let expected_second = 2;","    let actual_first = dst[0];","    let actual_second = dst[1];","    assert!(dst.len() == 2);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert_eq!(src_len, 4 * dst_len);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src.chunks_exact(4).len() == dst.len());","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(dst[0] == 4);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(dst[1] == 8);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(dst[2] == 12);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src[0..4] == [4, 0, 0, 0]);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src[4..8] == [8, 0, 0, 0]);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0]; // 4 * 3 bytes for three u32 values","    let mut dst: Vec<u32> = vec![0; 3];","    read_u32_into(&src, &mut dst);","    let src_len = src.len();","    let dst_len = dst.len();","    assert!(src[8..12] == [12, 0, 0, 0]);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    assert!(dst.len() == 1);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    assert!(src.len() < 4 * dst.len());","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert!(dst.len() == 2);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert!(src.len() >= 4 * dst.len());","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert_eq!(dst[0], 4294967295);","}"],[]],[["{","#[should_panic]","fn test_read_u32_into_insufficient_length() {","    let src: Vec<u8> = vec![1, 0, 0]; // 3 bytes, not enough for any u32","    let mut dst: Vec<u32> = vec![0; 1];","    read_u32_into(&src, &mut dst);","}","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1]; // Two u32 values","    let mut dst: Vec<u32> = vec![0; 2];","    read_u32_into(&src, &mut dst);","    let src: Vec<u8> = vec![1, 0, 0];","    let mut dst: Vec<u32> = vec![0; 1];","    let src: Vec<u8> = vec![255, 255, 255, 255, 0, 0, 0, 1];","    let mut dst: Vec<u32> = vec![0; 2];","    assert_eq!(dst[1], 1);","}"],[]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert_eq!(dst, [1]);","}"],[]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert!(dst.len() == 1);","}"],[]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert!(src.len() >= 4 * dst.len());","}"],[]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst: Vec<u32> = Vec::new();","    dst.resize(1, 0);","    read_u32_into(&src, &mut dst);","    assert!(src.chunks_exact(4).count() == 1);","}"],[]],[["{","    let src = [1u8];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    let src = [1u8];","    let mut dst = [0u32; 1];","    assert!(src.len() < 4 * dst.len());","}"],[]],[["{","    let src = [1u8];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    let src = [1u8];","    let mut dst = [0u32; 1];","    assert!(dst[0] == 0u32);","}"],[]],[["{","    let src = [1u8, 0, 0, 0];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0];","    let mut dst = [0u32; 1];","    read_u32_into(&src, &mut dst);","    assert_eq!(dst[0], 1);","}"],[]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst.len(), 2);","}"],[]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert!(src.len() >= 4 * dst.len());","}"],[]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(src.chunks_exact(4).len(), 2);","}"],[]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[0], 1);","}"],[]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[1], 2);","}"],[]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[0], 1);","}"],[]],[["{","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    read_u32_into(&src, &mut dst);","    let src = [1u8, 0, 0, 0, 2u8, 0, 0];","    let mut dst = [0u32; 2];","    assert_eq!(dst[1], 2);","}"],[]],[["{","    let src: [u8; 2] = [1, 2]; // 2 bytes","    let mut dst: [u32; 1] = [0]; // 1 u32 requires 4 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 2] = [1, 2];","    let mut dst: [u32; 1] = [0];","    assert!(src.len() < 4 * dst.len());","}"],[]],[["{","    let src: [u8; 1] = [1]; // 1 byte","    let mut dst: [u32; 2] = [0, 0]; // 2 u32 requires 8 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 1] = [1];","    let mut dst: [u32; 2] = [0, 0];","    assert!(src.len() < 4 * dst.len());","}"],[]],[["{","    let src: [u8; 1] = [1]; // 1 byte","    let mut dst: [u32; 2] = [0, 0]; // 2 u32 requires 8 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 1] = [1];","    let mut dst: [u32; 2] = [0, 0];","    assert_eq!(dst, [0, 0]);","}"],[]],[["{","    let src: [u8; 4] = [1, 2, 3, 4]; // 4 bytes","    let mut dst: [u32; 2] = [0, 0]; // 2 u32 requires 8 bytes","    read_u32_into(&src, &mut dst);","    let src: [u8; 4] = [1, 2, 3, 4];","    let mut dst: [u32; 2] = [0, 0];","    assert!(src.len() < 4 * dst.len());","}"],[]]]}