{"function_name":"rand_pcg::pcg64::<pcg64::Lcg64Xsh32 as rand_core::RngCore>::fill_bytes","file_path":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_pcg/src/pcg64.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_pcg","tests":12,"tests_lines":[9,9,9,9,9,9,9,9,9,9,9,8],"oracles":6,"oracles_compiled":5,"oracles_compiled_rate":83.33333333333334,"tests_compiled":11,"tests_compiled_rate":91.66666666666666,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":11,"tests_passed":8,"tests_passed_rate":72.72727272727273,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[161,162,163],"codes_lines_covered":[[["{","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    assert!(dest.len() == 1);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    assert!(dest[0] >= 0);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    assert!(dest[0] <= 255);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 10);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    assert_ne!(dest[0], dest[1]);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 100);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    assert_ne!(dest, [0u8; 100]);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 1_000);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    assert!(dest.iter().all(|&x| x >= 0 && x <= 255));","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1]; // Using the maximum length allowed for dest","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), u32::MAX as usize - 1);","}"],[161,162,163]],[["{","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1]; // Using the maximum length allowed for dest","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1];","    rng.fill_bytes(&mut dest);","    assert!(dest.iter().all(|&byte| byte == 0));","}"],[161,162,163]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    assert!(dest.len() == 1);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    assert!(dest[0] >= 0);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 0, increment: 0 };","    let mut dest = [0u8; 1];","    rng.fill_bytes(&mut dest);","    assert!(dest[0] <= 255);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 10);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 1, increment: 1 };","    let mut dest = [0u8; 10];","    rng.fill_bytes(&mut dest);","    assert_ne!(dest[0], dest[1]);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 100);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 100, increment: 50 };","    let mut dest = [0u8; 100];","    rng.fill_bytes(&mut dest);","    assert_ne!(dest, [0u8; 100]);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 1_000);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: 10_000, increment: 10_000 };","    let mut dest = [0u8; 1_000];","    rng.fill_bytes(&mut dest);","    assert!(dest.iter().all(|&x| x >= 0 && x <= 255));","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1]; // Using the maximum length allowed for dest","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1];","    rng.fill_bytes(&mut dest);","    assert_eq!(dest.len(), u32::MAX as usize - 1);","}"],[]],[["{","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1]; // Using the maximum length allowed for dest","    rng.fill_bytes(&mut dest);","    let mut rng = Lcg64Xsh32 { state: u64::MAX, increment: u64::MAX };","    let mut dest = vec![0u8; u32::MAX as usize - 1];","    rng.fill_bytes(&mut dest);","    assert!(dest.iter().all(|&byte| byte == 0));","}"],[]]]}