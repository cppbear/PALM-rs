{"function_name":"rand_core::block::block::BlockRng64<R>::reset","file_path":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core/src/block.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core","tests":10,"tests_lines":[20,20,22,22,22,22,25,25,25,25],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":6,"tests_compiled_rate":60.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[332,333,334,335],"codes_lines_covered":[[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = Vec::new();","    block_rng.reset();","    let mut block_rng = BlockRng64::new(DummyBlockRngCore);","    block_rng.results = Vec::new();","    assert_eq!(block_rng.index(), 0);","}"],[332,333,334,335]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = Vec::new();","    block_rng.reset();","    let mut block_rng = BlockRng64::new(DummyBlockRngCore);","    block_rng.results = Vec::new();","    assert!(!block_rng.half_used);","}"],[332,333,334,335]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = Vec::new();","    block_rng.reset();","    let mut block_rng = BlockRng64::new(DummyBlockRngCore);","    block_rng.results = Vec::new();","    block_rng.results.extend_from_slice(&[1, 2, 3, 4, 5]);","    block_rng.reset();","    assert!(!block_rng.half_used);","}"],[332,333,334,335]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    assert_eq!(block_rng.index(), 5);","}"],[332,333,334,335]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    assert!(!block_rng.half_used);","}"],[332,333,334,335]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.half_used = true;","    block_rng.reset();","    assert!(!block_rng.half_used);","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.half_used = true;","    block_rng.reset();","    assert!(!block_rng.half_used);","}"],[332,333,334,335]]],"codes_branches":[],"codes_branches_covered":[[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = Vec::new();","    block_rng.reset();","    let mut block_rng = BlockRng64::new(DummyBlockRngCore);","    block_rng.results = Vec::new();","    assert_eq!(block_rng.index(), 0);","}"],[]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = Vec::new();","    block_rng.reset();","    let mut block_rng = BlockRng64::new(DummyBlockRngCore);","    block_rng.results = Vec::new();","    assert!(!block_rng.half_used);","}"],[]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = Vec::new();","    block_rng.reset();","    let mut block_rng = BlockRng64::new(DummyBlockRngCore);","    block_rng.results = Vec::new();","    block_rng.results.extend_from_slice(&[1, 2, 3, 4, 5]);","    block_rng.reset();","    assert!(!block_rng.half_used);","}"],[]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    assert_eq!(block_rng.index(), 5);","}"],[]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.reset();","    assert!(!block_rng.half_used);","}"],[]],[["{","#[derive(Clone)]","struct DummyBlockRngCore;","","impl BlockRngCore for DummyBlockRngCore {","    type Item = u8;","    type Results = Vec<u8>;","    ","    fn generate(&mut self, results: &mut Self::Results) {","        results.extend_from_slice(&[1, 2, 3, 4, 5]);","    }","}","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.half_used = true;","    block_rng.reset();","    assert!(!block_rng.half_used);","    let mut rng = DummyBlockRngCore;","    let mut block_rng = BlockRng64::new(rng);","    block_rng.results = vec![1, 2, 3, 4, 5];","    block_rng.half_used = true;","    block_rng.reset();","    assert!(!block_rng.half_used);","}"],[]]]}