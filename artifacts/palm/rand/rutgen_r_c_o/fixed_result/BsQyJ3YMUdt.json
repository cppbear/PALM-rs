{"function_name":"rand_chacha::guts::read_u32le","file_path":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_chacha/src/guts.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_chacha","tests":18,"tests_lines":[11,13,11,13,11,13,11,13,12,15,7,7,6,7,7,6,6,6],"oracles":11,"oracles_compiled":11,"oracles_compiled_rate":100.0,"tests_compiled":16,"tests_compiled_rate":88.88888888888889,"oracles_run":11,"oracles_passed":8,"oracles_passed_rate":72.72727272727273,"tests_run":16,"tests_passed":13,"tests_passed_rate":81.25,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[243,244,245,246],"codes_lines_covered":[[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[0, 0, 0, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    assert!(std::panic::catch_unwind(|| read_u32le(input)).is_err());","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[0, 0, 0, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[0, 0, 0, 0];","    let output = read_u32le(input);","    assert_eq!(output, 0);","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 255, 255, 255];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    assert!(std::panic::catch_unwind(|| read_u32le(input)).is_err());","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 255, 255, 255];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[255, 255, 255, 255];","    let output = read_u32le(input);","    assert_eq!(output, 4294967295);","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[128, 128, 128, 128];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[128, 128, 128, 128];","    let output = read_u32le(input);","    assert_eq!(output, 2147483648);","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[1, 2, 3, 4];","    let output = read_u32le(input);","    let input_panic: &[u8] = &[1, 2, 3];","    assert!(std::panic::catch_unwind(|| read_u32le(input_panic)).is_err());","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[1, 2, 3, 4];","    let output = read_u32le(input);","    let input_panic: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[1, 2, 3, 4];","    let expected_output: u32 = 0x04030201;","    assert_eq!(read_u32le(input), expected_output);","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 0, 255, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let result = std::panic::catch_unwind(|| read_u32le(input));","    assert!(result.is_err());","}"],[243,244,245,246]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 0, 255, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let result = std::panic::catch_unwind(|| read_u32le(input));","    let input: &[u8] = &[255, 0, 255, 0];","    let expected_output: u32 = 0x00ff00ff;","    let output = read_u32le(input);","    assert_eq!(output, expected_output);","}"],[243,244,245,246]],[["{","    let xs = [0, 1, 2, 3];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2, 3];","    let result = read_u32le(&xs);","    assert_eq!(result, 50462976);","}"],[243,244,245,246]],[["{","    let xs = [255, 254, 253, 252];","    let _ = read_u32le(&xs);","    let xs = [255, 254, 253, 252];","    let result = read_u32le(&xs);","    assert_eq!(result, 0xFEFCFBFF);","}"],[243,244,245,246]],[["{","    let xs = [0, 0, 0, 0];","    let _ = read_u32le(&xs);","    let xs = [0, 0, 0, 0];","    assert_eq!(xs.len(), 4);","}"],[243,244,245,246]],[["{","    let xs = [0, 255, 255, 255];","    let _ = read_u32le(&xs);","    let xs = [0, 255, 255, 255];","    let result = read_u32le(&xs);","    assert_eq!(result, 0xFFFFFFFF);","}"],[243,244,245,246]],[["{","    let xs = [0, 1, 2];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2];","    assert_eq!(xs.len(), 4);","}"],[243,244]],[["{","    let xs = [0, 1, 2];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2];","    assert!(false);","}"],[243,244]],[["{","    let xs = [0, 1, 2, 3, 4];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2, 3, 4];","    assert!(std::panic::catch_unwind(|| read_u32le(&xs)).is_err());","}"],[243,244]]],"codes_branches":[],"codes_branches_covered":[[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[0, 0, 0, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    assert!(std::panic::catch_unwind(|| read_u32le(input)).is_err());","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[0, 0, 0, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[0, 0, 0, 0];","    let output = read_u32le(input);","    assert_eq!(output, 0);","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 255, 255, 255];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    assert!(std::panic::catch_unwind(|| read_u32le(input)).is_err());","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 255, 255, 255];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[255, 255, 255, 255];","    let output = read_u32le(input);","    assert_eq!(output, 4294967295);","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[128, 128, 128, 128];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[128, 128, 128, 128];","    let output = read_u32le(input);","    assert_eq!(output, 2147483648);","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[1, 2, 3, 4];","    let output = read_u32le(input);","    let input_panic: &[u8] = &[1, 2, 3];","    assert!(std::panic::catch_unwind(|| read_u32le(input_panic)).is_err());","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[1, 2, 3, 4];","    let output = read_u32le(input);","    let input_panic: &[u8] = &[1, 2, 3];","    let input: &[u8] = &[1, 2, 3, 4];","    let expected_output: u32 = 0x04030201;","    assert_eq!(read_u32le(input), expected_output);","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 0, 255, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let result = std::panic::catch_unwind(|| read_u32le(input));","    assert!(result.is_err());","}"],[]],[["{","#[should_panic]","fn test_read_u32le_panic_case() {","    let input: &[u8] = &[1, 2, 3]; // Not enough bytes","    let output = read_u32le(input);","}","    let input: &[u8] = &[255, 0, 255, 0];","    let output = read_u32le(input);","    let input: &[u8] = &[1, 2, 3];","    let result = std::panic::catch_unwind(|| read_u32le(input));","    let input: &[u8] = &[255, 0, 255, 0];","    let expected_output: u32 = 0x00ff00ff;","    let output = read_u32le(input);","    assert_eq!(output, expected_output);","}"],[]],[["{","    let xs = [0, 1, 2, 3];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2, 3];","    let result = read_u32le(&xs);","    assert_eq!(result, 50462976);","}"],[]],[["{","    let xs = [255, 254, 253, 252];","    let _ = read_u32le(&xs);","    let xs = [255, 254, 253, 252];","    let result = read_u32le(&xs);","    assert_eq!(result, 0xFEFCFBFF);","}"],[]],[["{","    let xs = [0, 0, 0, 0];","    let _ = read_u32le(&xs);","    let xs = [0, 0, 0, 0];","    assert_eq!(xs.len(), 4);","}"],[]],[["{","    let xs = [0, 255, 255, 255];","    let _ = read_u32le(&xs);","    let xs = [0, 255, 255, 255];","    let result = read_u32le(&xs);","    assert_eq!(result, 0xFFFFFFFF);","}"],[]],[["{","    let xs = [0, 1, 2];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2];","    assert_eq!(xs.len(), 4);","}"],[]],[["{","    let xs = [0, 1, 2];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2];","    assert!(false);","}"],[]],[["{","    let xs = [0, 1, 2, 3, 4];","    let _ = read_u32le(&xs);","    let xs = [0, 1, 2, 3, 4];","    assert!(std::panic::catch_unwind(|| read_u32le(&xs)).is_err());","}"],[]]]}