{"function_name":"rand_core::block::<block::BlockRng64<R> as RngCore>::next_u64","file_path":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core/src/block.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/rand/rand_core","tests":50,"tests_lines":[24,24,24,24,24,24,24,24,24,24,24,24,30,30,30,30,30,30,31,31,31,24,24,24,24,24,24,24,24,24,29,29,29,29,29,29,30,30,30,31,31,31,25,25,26,26,26,26,27,28],"oracles":9,"oracles_compiled":9,"oracles_compiled_rate":100.0,"tests_compiled":49,"tests_compiled_rate":98.0,"oracles_run":9,"oracles_passed":9,"oracles_passed_rate":100.0,"tests_run":49,"tests_passed":28,"tests_passed_rate":57.14285714285714,"lines":10,"lines_covered":10,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[369,370,371,372,373,375,376,377,378,379],"codes_lines_covered":[[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.results, vec![1, 2, 3, 4]);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 0);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.half_used, false);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 1);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 1);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 2);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 2);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 3);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 3);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 4);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 4);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert!(rng.half_used == false);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[10, 20, 30, 40, 50]);","        }","    }","    ","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","        results,","        index: 5,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","    results,","    index: 5,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let expected_value = 10;","    assert_eq!(rng.results[0], expected_value);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[10, 20, 30, 40, 50]);","        }","    }","    ","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","        results,","        index: 5,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","    results,","    index: 5,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let expected_value = 10;","    assert_eq!(rng.index, 1);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[10, 20, 30, 40, 50]);","        }","    }","    ","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","        results,","        index: 5,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","    results,","    index: 5,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let expected_value = 10;","    assert_eq!(rng.half_used, false);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.results, vec![100, 200]);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 0);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert!(rng.half_used == false);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let value = rng.next_u64();","    assert_eq!(value, 100);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let value = rng.next_u64();","    assert_eq!(rng.index, 1);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let value = rng.next_u64();","    assert!(rng.half_used == false);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 0);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.results, vec![5, 15, 25]);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.half_used, false);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 5);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 1);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 15);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 2);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 25);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 3);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[0]);","        }","    }","    ","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","    results,","    index: 1,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 1);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[0]);","        }","    }","    ","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","    results,","    index: 1,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert!(!rng.half_used);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    assert_eq!(block_rng.index, 0);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    assert_eq!(block_rng.results[0], 0);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    assert_eq!(block_rng.half_used, false);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    let value = block_rng.next_u64();","    assert_eq!(value, 42);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    let value = block_rng.next_u64();","    assert_eq!(block_rng.index, 1);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    let value = block_rng.next_u64();","    assert_eq!(block_rng.half_used, false);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4, 5]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 5],","        index: 0,","        half_used: false,","        core,","    };","","    for _ in 0..5 {","        let value = block_rng.next_u64();","    }","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 5], index: 0, half_used: false, core };","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    assert_eq!(block_rng.results, [1, 2, 3, 4, 5]);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4, 5]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 5],","        index: 0,","        half_used: false,","        core,","    };","","    for _ in 0..5 {","        let value = block_rng.next_u64();","    }","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 5], index: 0, half_used: false, core };","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    assert_eq!(block_rng.index, 5);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4, 5]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 5],","        index: 0,","        half_used: false,","        core,","    };","","    for _ in 0..5 {","        let value = block_rng.next_u64();","    }","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 5], index: 0, half_used: false, core };","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    assert_eq!(block_rng.half_used, false);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    assert_eq!(block_rng.results, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    assert_eq!(block_rng.index, 0);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert_eq!(value, 10);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert_eq!(block_rng.index, 1);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert!(!block_rng.half_used);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1000, 2000]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 2],","        index: 2,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Should call generate and return the first value","    let value2 = block_rng.next_u64(); // Should return the second value","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 2], index: 2, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    assert_eq!(block_rng.results, [1000, 2000]);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1000, 2000]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 2],","        index: 2,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Should call generate and return the first value","    let value2 = block_rng.next_u64(); // Should return the second value","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 2], index: 2, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert_eq!(value, 1000);","}"],[369,370,371,372,373,375,376,377,378,379]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1000, 2000]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 2],","        index: 2,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Should call generate and return the first value","    let value2 = block_rng.next_u64(); // Should return the second value","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 2], index: 2, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    let value2 = block_rng.next_u64();","    assert_eq!(value2, 2000);","}"],[369,370,371,372,373,375,376,377,378,379]]],"codes_branches":[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.results, vec![1, 2, 3, 4]);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 0);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.half_used, false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 2);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 2);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 3);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 3);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 4);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 4);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[1, 2, 3, 4]);","        }","    }","    ","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 {","        results,","        index: 4,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 4];","    let mut rng = BlockRng64 { results, index: 4, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert!(rng.half_used == false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[10, 20, 30, 40, 50]);","        }","    }","    ","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","        results,","        index: 5,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","    results,","    index: 5,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let expected_value = 10;","    assert_eq!(rng.results[0], expected_value);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[10, 20, 30, 40, 50]);","        }","    }","    ","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","        results,","        index: 5,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","    results,","    index: 5,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let expected_value = 10;","    assert_eq!(rng.index, 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[10, 20, 30, 40, 50]);","        }","    }","    ","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","        results,","        index: 5,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 5];","    let mut rng = BlockRng64 {","    results,","    index: 5,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let expected_value = 10;","    assert_eq!(rng.half_used, false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.results, vec![100, 200]);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 0);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert!(rng.half_used == false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let value = rng.next_u64();","    assert_eq!(value, 100);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let value = rng.next_u64();","    assert_eq!(rng.index, 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.push(100);","            results.push(200);","        }","    }","    ","    let mut results = vec![];","    let mut rng = BlockRng64 {","        results,","        index: 0,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![];","    let mut rng = BlockRng64 {","    results,","    index: 0,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    let value = rng.next_u64();","    assert!(rng.half_used == false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 0);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.results, vec![5, 15, 25]);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.half_used, false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 5);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 15);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 2);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.next_u64(), 25);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[5, 15, 25]);","        }","    }","    ","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 {","        results,","        index: 3,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 3];","    let mut rng = BlockRng64 { results, index: 3, half_used: false, core: MockCore };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 3);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[0]);","        }","    }","    ","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","    results,","    index: 1,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert_eq!(rng.index, 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct MockCore;","    impl BlockRngCore for MockCore {","        type Item = u64;","        type Results = Vec<u64>;","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend_from_slice(&[0]);","        }","    }","    ","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","        results,","        index: 1,","        half_used: false,","        core: MockCore,","    };","    ","    let _ = rng.next_u64();","    let mut results = vec![0; 1];","    let mut rng = BlockRng64 {","    results,","    index: 1,","    half_used: false,","    core: MockCore,","    };","    rng.core.generate(&mut rng.results);","    assert!(!rng.half_used);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":false}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    assert_eq!(block_rng.index, 0);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    assert_eq!(block_rng.results[0], 0);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    assert_eq!(block_rng.half_used, false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    let value = block_rng.next_u64();","    assert_eq!(value, 42);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    let value = block_rng.next_u64();","    assert_eq!(block_rng.index, 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 1];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = 42; // Arbitrary value","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 1],","        index: 0,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64();","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","    results: [0u64; 1],","    index: 0,","    half_used: false,","    core,","    };","    let value = block_rng.next_u64();","    assert_eq!(block_rng.half_used, false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4, 5]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 5],","        index: 0,","        half_used: false,","        core,","    };","","    for _ in 0..5 {","        let value = block_rng.next_u64();","    }","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 5], index: 0, half_used: false, core };","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    assert_eq!(block_rng.results, [1, 2, 3, 4, 5]);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4, 5]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 5],","        index: 0,","        half_used: false,","        core,","    };","","    for _ in 0..5 {","        let value = block_rng.next_u64();","    }","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 5], index: 0, half_used: false, core };","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    assert_eq!(block_rng.index, 5);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4, 5]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 5],","        index: 0,","        half_used: false,","        core,","    };","","    for _ in 0..5 {","        let value = block_rng.next_u64();","    }","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 5], index: 0, half_used: false, core };","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    block_rng.next_u64();","    assert_eq!(block_rng.half_used, false);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    assert_eq!(block_rng.results, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    assert_eq!(block_rng.index, 0);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert_eq!(value, 10);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert_eq!(block_rng.index, 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 10];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 10],","        index: 9,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Triggering the generation","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 10], index: 9, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert!(!block_rng.half_used);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1000, 2000]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 2],","        index: 2,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Should call generate and return the first value","    let value2 = block_rng.next_u64(); // Should return the second value","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 2], index: 2, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    assert_eq!(block_rng.results, [1000, 2000]);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1000, 2000]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 2],","        index: 2,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Should call generate and return the first value","    let value2 = block_rng.next_u64(); // Should return the second value","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 2], index: 2, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    assert_eq!(value, 1000);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]],[["{","    struct DummyCore;","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1000, 2000]); // Arbitrary values","        }","    }","","    let core = DummyCore;","    let mut block_rng = BlockRng64 {","        results: [0u64; 2],","        index: 2,","        half_used: false,","        core,","    };","","    let value = block_rng.next_u64(); // Should call generate and return the first value","    let value2 = block_rng.next_u64(); // Should return the second value","    let core = DummyCore;","    let mut block_rng = BlockRng64 { results: [0u64; 2], index: 2, half_used: false, core };","    block_rng.core.generate(&mut block_rng.results);","    let value = block_rng.next_u64();","    let value2 = block_rng.next_u64();","    assert_eq!(value2, 2000);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]]]}