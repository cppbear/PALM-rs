{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/seq/coin_flipper.rs\n// crate name is rand\nThe function to be tested is presented as follows:\n/// Returns true with a probability of n / d\n/// Uses an expected two bits of randomness\nfn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n    // Explanation:\n    // We are trying to return true with a probability of n / d\n    // If n >= d, we can just return true\n    // Otherwise there are two possibilities 2n < d and 2n >= d\n    // In either case we flip a coin.\n    // If 2n < d\n    //  If it comes up tails, return false\n    //  If it comes up heads, double n and start again\n    //  This is fair because (0.5 * 0) + (0.5 * 2n / d) = n / d and 2n is less than d\n    // (if 2n was greater than d we would effectively round it down to 1\n    // by returning true)\n    // If 2n >= d\n    //  If it comes up tails, set n to 2n - d and start again\n    //  If it comes up heads, return true\n    //  This is fair because (0.5 * 1) + (0.5 * (2n - d) / d) = n / d\n    //  Note that if 2n = d and the coin comes up tails, n will be set to 0\n    //  before restarting which is equivalent to returning false.\n\n    // As a performance optimization we can flip multiple coins at once\n    // This is efficient because we can use the `lzcnt` intrinsic\n    // We can check up to 32 flips at once but we only receive one bit of information\n    // - all heads or at least one tail.\n\n    // Let c be the number of coins to flip. 1 <= c <= 32\n    // If 2n < d, n * 2^c < d\n    // If the result is all heads, then set n to n * 2^c\n    // If there was at least one tail, return false\n    // If 2n >= d, the order of results matters so we flip one coin at a time so c = 1\n    // Ideally, c will be as high as possible within these constraints\n\n    while n < d {\n        // Find a good value for c by counting leading zeros\n        // This will either give the highest possible c, or 1 less than that\n        let c = n\n            .leading_zeros()\n            .saturating_sub(d.leading_zeros() + 1)\n            .clamp(1, 32);\n\n        if self.flip_c_heads(c) {\n            // All heads\n            // Set n to n * 2^c\n            // If 2n >= d, the while loop will exit and we will return `true`\n            // If n * 2^c > `usize::MAX` we always return `true` anyway\n            n = n.saturating_mul(2_usize.pow(c));\n        } else {\n            // At least one tail\n            if c == 1 {\n                // Calculate 2n - d.\n                // We need to use wrapping as 2n might be greater than `usize::MAX`\n                let next_n = n.wrapping_add(n).wrapping_sub(d);\n                if next_n == 0 || next_n > n {\n                    // This will happen if 2n < d\n                    return false;\n                }\n                n = next_n;\n            } else {\n                // c > 1 so 2n < d so we can return false\n                return false;\n            }\n        }\n    }\n    true\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}