{
  "name": "rand::distr::weighted::weighted_index::distr::weighted::weighted_index::WeightedIndex<X>::weights",
  "name_with_impl": "rand::distr::weighted::weighted_index::{impl#4}::weights",
  "mod_info": {
    "name": "distr::weighted::weighted_index",
    "loc": "src/distr/weighted/mod.rs:18:1:18:20"
  },
  "visible": true,
  "loc": "src/distr/weighted/weighted_index.rs:342:5:350:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: WeightedIndexIter {\n            weighted_index: self,\n            index: 0,\n        }\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct WeightedIndex {",
                  "        weights: Vec<u32>,",
                  "    }",
                  "",
                  "    impl WeightedIndex {",
                  "        fn new(weights: &[u32]) -> Result<Self, &'static str> {",
                  "            Ok(Self {",
                  "                weights: weights.to_vec(),",
                  "            })",
                  "        }",
                  "",
                  "        fn weights(&self) -> WeightedIndexIter {",
                  "            WeightedIndexIter {",
                  "                weighted_index: self,",
                  "                index: 0,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct WeightedIndexIter<'a> {",
                  "        weighted_index: &'a WeightedIndex,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'a> Iterator for WeightedIndexIter<'a> {",
                  "        type Item = &'a u32;",
                  "",
                  "        fn next(&mut self) -> Option<Self::Item> {",
                  "            if self.index < self.weighted_index.weights.len() {",
                  "                let weight = &self.weighted_index.weights[self.index];",
                  "                self.index += 1;",
                  "                Some(weight)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let weights = [1, 2, 3];",
                  "    let dist = WeightedIndex::new(&weights).unwrap();",
                  "    let collected_weights: Vec<_> = dist.weights().collect();",
                  "    assert_eq!(collected_weights, vec![&1, &2, &3]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct WeightedIndex {",
                  "        weights: Vec<u32>,",
                  "    }",
                  "",
                  "    impl WeightedIndex {",
                  "        fn new(weights: &[u32]) -> Result<Self, &'static str> {",
                  "            Ok(Self {",
                  "                weights: weights.to_vec(),",
                  "            })",
                  "        }",
                  "",
                  "        fn update_weights(&mut self, updates: &[(usize, &u32)]) -> Result<(), &'static str> {",
                  "            for &(index, new_weight) in updates {",
                  "                if index >= self.weights.len() {",
                  "                    return Err(\"Index out of bounds\");",
                  "                }",
                  "                self.weights[index] = *new_weight;",
                  "            }",
                  "            Ok(())",
                  "        }",
                  "",
                  "        fn weights(&self) -> WeightedIndexIter {",
                  "            WeightedIndexIter {",
                  "                weighted_index: self,",
                  "                index: 0,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct WeightedIndexIter<'a> {",
                  "        weighted_index: &'a WeightedIndex,",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl<'a> Iterator for WeightedIndexIter<'a> {",
                  "        type Item = &'a u32;",
                  "",
                  "        fn next(&mut self) -> Option<Self::Item> {",
                  "            if self.index < self.weighted_index.weights.len() {",
                  "                let weight = &self.weighted_index.weights[self.index];",
                  "                self.index += 1;",
                  "                Some(weight)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let weights = [1, 2, 3];",
                  "    let mut dist = WeightedIndex::new(&weights).unwrap();",
                  "    let collected_weights_before: Vec<_> = dist.weights().collect();",
                  "    assert_eq!(collected_weights_before, vec![&1, &2, &3]);",
                  "    ",
                  "    dist.update_weights(&[(0, &2)]).unwrap();",
                  "    let collected_weights_after: Vec<_> = dist.weights().collect();",
                  "    assert_eq!(collected_weights_after, vec![&2, &2, &3]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}