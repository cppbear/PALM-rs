{"function_name":"rand::rngs::thread::rngs::thread::ThreadRng::reseed","tests":2,"tests_lines":[41,29],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[103,104,105,106,107,108],"codes_lines_covered":[[["{","    struct TestRng {","        reseed_called: bool,","    }","","    impl TestRng {","        fn new() -> Self {","            Self {","                reseed_called: false,","            }","        }","","        fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            self.reseed_called = true;","            Ok(())","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<TestRng>,","    }","","    impl ThreadRng {","        fn new() -> Self {","            Self {","                rng: std::cell::UnsafeCell::new(TestRng::new()),","            }","        }","","        pub fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            let rng = unsafe { &mut *self.rng.get() };","            rng.reseed()","        }","    }","","    let mut thread_rng = ThreadRng::new();","    let result = thread_rng.reseed();","    ","    assert!(result.is_ok());","    assert!(unsafe { &*thread_rng.rng.get() }.reseed_called);","}"],[]],[["{","    struct TestRng;","","    impl TestRng {","        fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            panic!(\"Expected panic due to no mutable reference\");","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<TestRng>,","    }","","    impl ThreadRng {","        fn new() -> Self {","            Self {","                rng: std::cell::UnsafeCell::new(TestRng),","            }","        }","","        pub fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            let rng = unsafe { &mut *self.rng.get() };","            rng.reseed()","        }","    }","","    let mut thread_rng = ThreadRng::new();","    let _result = thread_rng.reseed(); // This will cause a panic","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestRng {","        reseed_called: bool,","    }","","    impl TestRng {","        fn new() -> Self {","            Self {","                reseed_called: false,","            }","        }","","        fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            self.reseed_called = true;","            Ok(())","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<TestRng>,","    }","","    impl ThreadRng {","        fn new() -> Self {","            Self {","                rng: std::cell::UnsafeCell::new(TestRng::new()),","            }","        }","","        pub fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            let rng = unsafe { &mut *self.rng.get() };","            rng.reseed()","        }","    }","","    let mut thread_rng = ThreadRng::new();","    let result = thread_rng.reseed();","    ","    assert!(result.is_ok());","    assert!(unsafe { &*thread_rng.rng.get() }.reseed_called);","}"],[]],[["{","    struct TestRng;","","    impl TestRng {","        fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            panic!(\"Expected panic due to no mutable reference\");","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<TestRng>,","    }","","    impl ThreadRng {","        fn new() -> Self {","            Self {","                rng: std::cell::UnsafeCell::new(TestRng),","            }","        }","","        pub fn reseed(&mut self) -> Result<(), rand_core::OsError> {","            let rng = unsafe { &mut *self.rng.get() };","            rng.reseed()","        }","    }","","    let mut thread_rng = ThreadRng::new();","    let _result = thread_rng.reseed(); // This will cause a panic","}"],[]]]}