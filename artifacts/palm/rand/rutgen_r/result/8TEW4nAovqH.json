{"function_name":"rand_core::impls::<u32 as impls::Observable>::to_le_bytes","tests":4,"tests_lines":[14,14,14,14],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[61,62,63],"codes_lines_covered":[[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU32(u32);","","    impl TestU32 {","        fn to_le_bytes(self) -> [u8; 4] {","            self.0.to_le_bytes()","        }","    }","","    let input = TestU32(0x12345678);","    let expected_output = [0x78, 0x56, 0x34, 0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]],[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU64(u64);","","    impl TestU64 {","        fn to_le_bytes(self) -> [u8; 8] {","            self.0.to_le_bytes()","        }","    }","","    let input = TestU64(0x1234567890abcdef);","    let expected_output = [0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]],[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU16(u16);","","    impl TestU16 {","        fn to_le_bytes(self) -> [u8; 2] {","            self.0.to_le_bytes()","        }","    }","","    let input = TestU16(0x1234);","    let expected_output = [0x34, 0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]],[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU8(u8);","","    impl TestU8 {","        fn to_le_bytes(self) -> [u8; 1] {","            [self.0]","        }","    }","","    let input = TestU8(0x12);","    let expected_output = [0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU32(u32);","","    impl TestU32 {","        fn to_le_bytes(self) -> [u8; 4] {","            self.0.to_le_bytes()","        }","    }","","    let input = TestU32(0x12345678);","    let expected_output = [0x78, 0x56, 0x34, 0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]],[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU64(u64);","","    impl TestU64 {","        fn to_le_bytes(self) -> [u8; 8] {","            self.0.to_le_bytes()","        }","    }","","    let input = TestU64(0x1234567890abcdef);","    let expected_output = [0xef, 0xcd, 0xab, 0x90, 0x78, 0x56, 0x34, 0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]],[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU16(u16);","","    impl TestU16 {","        fn to_le_bytes(self) -> [u8; 2] {","            self.0.to_le_bytes()","        }","    }","","    let input = TestU16(0x1234);","    let expected_output = [0x34, 0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]],[["{","    // Auxiliary struct to mimic the functionality of the trait.","    struct TestU8(u8);","","    impl TestU8 {","        fn to_le_bytes(self) -> [u8; 1] {","            [self.0]","        }","    }","","    let input = TestU8(0x12);","    let expected_output = [0x12];","    assert_eq!(input.to_le_bytes(), expected_output);","}"],[]]]}