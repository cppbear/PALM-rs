{"function_name":"rand::distr::bernoulli::distr::bernoulli::Bernoulli::p","tests":5,"tests_lines":[21,12,12,12,12],"oracles":5,"oracles_compiled":1,"oracles_compiled_rate":20.0,"tests_compiled":1,"tests_compiled_rate":20.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[144,145,146,148,150],"codes_lines_covered":[[["{","    const ALWAYS_TRUE: u32 = 1; // Assuming ALWAYS_TRUE is defined as 1 for this test","    const SCALE: u32 = 10; // Example scale for calculation","","    struct Bernoulli {","        p_int: u32,","    }","","    impl Bernoulli {","        pub fn p(&self) -> f64 {","            if self.p_int == ALWAYS_TRUE {","                1.0","            } else {","                (self.p_int as f64) / SCALE as f64","            }","        }","    }","","    let bernoulli = Bernoulli { p_int: ALWAYS_TRUE };","    assert_eq!(bernoulli.p(), 1.0);","}"],[]]],"codes_branches":[{"start_line":145,"start_column":12,"end_line":145,"end_column":37,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    const ALWAYS_TRUE: u32 = 1; // Assuming ALWAYS_TRUE is defined as 1 for this test","    const SCALE: u32 = 10; // Example scale for calculation","","    struct Bernoulli {","        p_int: u32,","    }","","    impl Bernoulli {","        pub fn p(&self) -> f64 {","            if self.p_int == ALWAYS_TRUE {","                1.0","            } else {","                (self.p_int as f64) / SCALE as f64","            }","        }","    }","","    let bernoulli = Bernoulli { p_int: ALWAYS_TRUE };","    assert_eq!(bernoulli.p(), 1.0);","}"],[{"start_line":145,"start_column":12,"end_line":145,"end_column":37,"positive":false,"negative":false}]]]}