{"function_name":"rand_pcg::pcg64::pcg64::Lcg64Xsh32::advance","tests":8,"tests_lines":[5,5,4,5,16,16,16,41],"oracles":8,"oracles_compiled":5,"oracles_compiled_rate":62.5,"tests_compiled":5,"tests_compiled_rate":62.5,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":5,"tests_passed":4,"tests_passed_rate":80.0,"lines":16,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77],"codes_lines_covered":[[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(1);","    assert!(rng.state != 42); // Ensure the state has been changed","}"],[]],[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(3);","    assert!(rng.state != 42); // Ensure the state is different after advancing","}"],[]],[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(0); // This should not panic as per the function's constraints but is a boundary case","}"],[]],[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(u64::MAX); // Testing with a large delta, ensuring it doesn't panic","    assert!(rng.state != 42); // Ensure the state has been changed","}"],[]],[["{","    struct RandomState {","        state: u64,","        increment: u64,","    }","","    const MULTIPLIER: u64 = 6364136223846793005; // Assuming a defined constant multiplier","","    impl RandomState {","        fn new(state: u64, increment: u64) -> Self {","            RandomState { state, increment }","        }","","        pub fn advance(&mut self, delta: u64) {","            let mut acc_mult: u64 = 1;","            let mut acc_plus: u64 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut random_state = RandomState::new(10, 5);","    let initial_state = random_state.state;","","    random_state.advance(0); // Testing the edge case where delta is 0","","    // Ensure that the state remains unchanged when delta is 0","    assert_eq!(random_state.state, initial_state);","}"],[]]],"codes_branches":[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(1);","    assert!(rng.state != 42); // Ensure the state has been changed","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(3);","    assert!(rng.state != 42); // Ensure the state is different after advancing","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(0); // This should not panic as per the function's constraints but is a boundary case","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Pcg64::new(42, 54);","    rng.advance(u64::MAX); // Testing with a large delta, ensuring it doesn't panic","    assert!(rng.state != 42); // Ensure the state has been changed","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    struct RandomState {","        state: u64,","        increment: u64,","    }","","    const MULTIPLIER: u64 = 6364136223846793005; // Assuming a defined constant multiplier","","    impl RandomState {","        fn new(state: u64, increment: u64) -> Self {","            RandomState { state, increment }","        }","","        pub fn advance(&mut self, delta: u64) {","            let mut acc_mult: u64 = 1;","            let mut acc_plus: u64 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut random_state = RandomState::new(10, 5);","    let initial_state = random_state.state;","","    random_state.advance(0); // Testing the edge case where delta is 0","","    // Ensure that the state remains unchanged when delta is 0","    assert_eq!(random_state.state, initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]]]}