{"function_name":"rand::distr::weighted::weighted_index::distr::weighted::weighted_index::WeightedIndex<X>::new","tests":25,"tests_lines":[5,5,5,5,5,22,14,18,18,20,20,20,5,6,6,6,6,44,4,24,4,24,6,6,6],"oracles":25,"oracles_compiled":4,"oracles_compiled_rate":16.0,"tests_compiled":4,"tests_compiled_rate":16.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":35,"lines_covered":33,"lines_coveraged_rate":94.28571428571428,"branches":8,"branches_covered":6,"branches_coverage_rate":75.0,"codes_lines":[99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,117,118,119,120,121,122,123,124,127,128,129,130,131,132,133,134,135,136,137],"codes_lines_covered":[[["{","    // Test when negative weights are present","    let weights = vec![1.0, -2.0];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::InvalidWeight));","}"],[99,100,101,102,103,104,105,106,107,108,109,111,112,113,114,117,118,137]],[["{","    // Test with NaN weight","    let weights = vec![1.0, f64::NAN];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::InvalidWeight));","}"],[99,100,101,102,103,104,105,106,107,108,109,111,112,113,114,117,118,137]],[["{","    // Test when the sum of weights is zero","    let weights = vec![0.0, 0.0, 0.0];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::InsufficientNonZero));","}"],[99,100,101,102,103,104,105,106,107,108,109,111,112,113,114,117,119,120,121,122,124,127,128,137]],[["{","    // Test for weights that would cause an overflow","    let weights = vec![f64::MAX, f64::MAX];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::Overflow));","}"],[99,100,101,102,103,104,105,106,107,108,109,111,112,113,114,117,119,120,121,122,124,127,129,130,131,132,133,134,135,136,137]]],"codes_branches":[{"start_line":109,"start_column":12,"end_line":109,"end_column":35,"positive":false,"negative":true},{"start_line":117,"start_column":16,"end_line":117,"end_column":38,"positive":true,"negative":true},{"start_line":122,"start_column":20,"end_line":122,"end_column":27,"positive":false,"negative":true},{"start_line":127,"start_column":12,"end_line":127,"end_column":32,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    // Test when negative weights are present","    let weights = vec![1.0, -2.0];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::InvalidWeight));","}"],[{"start_line":109,"start_column":12,"end_line":109,"end_column":35,"positive":false,"negative":true},{"start_line":117,"start_column":16,"end_line":117,"end_column":38,"positive":true,"negative":false},{"start_line":122,"start_column":20,"end_line":122,"end_column":27,"positive":false,"negative":false},{"start_line":127,"start_column":12,"end_line":127,"end_column":32,"positive":false,"negative":false}]],[["{","    // Test with NaN weight","    let weights = vec![1.0, f64::NAN];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::InvalidWeight));","}"],[{"start_line":109,"start_column":12,"end_line":109,"end_column":35,"positive":false,"negative":true},{"start_line":117,"start_column":16,"end_line":117,"end_column":38,"positive":true,"negative":false},{"start_line":122,"start_column":20,"end_line":122,"end_column":27,"positive":false,"negative":false},{"start_line":127,"start_column":12,"end_line":127,"end_column":32,"positive":false,"negative":false}]],[["{","    // Test when the sum of weights is zero","    let weights = vec![0.0, 0.0, 0.0];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::InsufficientNonZero));","}"],[{"start_line":109,"start_column":12,"end_line":109,"end_column":35,"positive":false,"negative":true},{"start_line":117,"start_column":16,"end_line":117,"end_column":38,"positive":false,"negative":true},{"start_line":122,"start_column":20,"end_line":122,"end_column":27,"positive":false,"negative":true},{"start_line":127,"start_column":12,"end_line":127,"end_column":32,"positive":true,"negative":false}]],[["{","    // Test for weights that would cause an overflow","    let weights = vec![f64::MAX, f64::MAX];","    let result: Result<WeightedIndex<f64>, Error> = WeightedIndex::new(weights);","    assert_eq!(result, Err(Error::Overflow));","}"],[{"start_line":109,"start_column":12,"end_line":109,"end_column":35,"positive":false,"negative":true},{"start_line":117,"start_column":16,"end_line":117,"end_column":38,"positive":false,"negative":true},{"start_line":122,"start_column":20,"end_line":122,"end_column":27,"positive":false,"negative":true},{"start_line":127,"start_column":12,"end_line":127,"end_column":32,"positive":false,"negative":true}]]]}