{"function_name":"rand_core::block::<block::BlockRng64<R> as RngCore>::fill_bytes","tests":10,"tests_lines":[7,5,8,7,6,71,56,68,8,8],"oracles":10,"oracles_compiled":8,"oracles_compiled_rate":80.0,"tests_compiled":8,"tests_compiled_rate":80.0,"oracles_run":8,"oracles_passed":2,"oracles_passed_rate":25.0,"tests_run":8,"tests_passed":2,"tests_passed_rate":25.0,"lines":14,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[382,383,384,385,386,387,388,389,391,392,393,394,395,397],"codes_lines_covered":[[["{","    let mut fill_bytes = FillBytes::new();","    let mut dest = vec![0; 10]; // A buffer of 10 bytes","    fill_bytes.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 10);","    assert_ne!(dest, vec![0; 10]); // Ensure some bytes were filled","}"],[]],[["{","    let mut fill_bytes = FillBytes::new();","    let mut dest = vec![0; 9]; // Dest is of smaller size","    fill_bytes.fill_bytes(&mut dest);","}"],[]],[["{","    let mut fill_bytes = FillBytes::new();","    fill_bytes.index = 8; // Set index equal to the size of results","    let mut dest = vec![0; 8];","    fill_bytes.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 8);","    assert_ne!(dest, vec![0; 8]); // Ensure some bytes were filled","}"],[]],[["{","    let mut fill_bytes = FillBytes::new();","    let mut dest = vec![0; 8];","    fill_bytes.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 8);","    assert_ne!(dest, vec![0; 8]); // Ensure some bytes were filled","}"],[]],[["{","    let mut fill_bytes = FillBytes::new();","    fill_bytes.results.clear(); // Make results empty","    let mut dest = vec![0; 5];","    fill_bytes.fill_bytes(&mut dest);","}"],[]],[["{","    struct CoreMock;","","    impl CoreMock {","        fn generate(&self, results: &mut Vec<u64>) {","            results.extend(vec![0u64; 10]); // Provide test data","        }","    }","","    struct RandCore {","        core: CoreMock,","        results: Vec<u64>,","        index: usize,","        half_used: bool,","    }","","    impl RandCore {","        fn new() -> Self {","            Self {","                core: CoreMock,","                results: vec![],","                index: 0,","                half_used: false,","            }","        }","","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            let mut read_len = 0;","            self.half_used = false;","            while read_len < dest.len() {","                if self.index >= self.results.len() {","                    self.core.generate(&mut self.results);","                    self.index = 0;","                }","","                let (consumed_u64, filled_u8) = fill_via_chunks(","                    &self.results[self.index..],","                    &mut dest[read_len..],","                );","","                self.index += consumed_u64;","                read_len += filled_u8;","            }","        }","    }","","    fn fill_via_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {","        let mut consumed = 0;","        let mut written = 0;","        for &value in src.iter().take(dest.len() / 8) {","            let bytes = value.to_le_bytes();","            for byte in &bytes {","                if written < dest.len() {","                    dest[written] = *byte;","                    written += 1;","                }","            }","            consumed += 1;","        }","        (consumed, written)","    }","","    let mut dest = vec![0u8; 80]; // Enough space to fill","    let mut rand_core = RandCore::new();","    rand_core.fill_bytes(&mut dest);","","    assert_eq!(dest.len(), 80);","    for byte in dest.iter() {","        assert!(*byte != 0); // Ensure that bytes were filled","    }","}"],[]],[["{","    struct CoreMock;","","    impl CoreMock {","        fn generate(&self, results: &mut Vec<u64>) {","            // No need to generate as dest is empty","        }","    }","","    struct RandCore {","        core: CoreMock,","        results: Vec<u64>,","        index: usize,","        half_used: bool,","    }","","    impl RandCore {","        fn new() -> Self {","            Self {","                core: CoreMock,","                results: vec![],","                index: 0,","                half_used: false,","            }","        }","","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            let mut read_len = 0;","            self.half_used = false;","            while read_len < dest.len() {","                if self.index >= self.results.len() {","                    self.core.generate(&mut self.results);","                    self.index = 0;","                }","","                let (consumed_u64, filled_u8) = fill_via_chunks(","                    &self.results[self.index..],","                    &mut dest[read_len..],","                );","","                self.index += consumed_u64;","                read_len += filled_u8;","            }","        }","    }","","    fn fill_via_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {","        (0, 0) // No bytes to fill as dest is empty","    }","","    let mut dest: Vec<u8> = vec![];","    let mut rand_core = RandCore::new();","    rand_core.fill_bytes(&mut dest);","","    assert!(dest.is_empty());","}"],[]],[["{","    struct CoreMock;","","    impl CoreMock {","        fn generate(&self, results: &mut Vec<u64>) {","            results.extend(vec![0u64; 10]);","        }","    }","","    struct RandCore {","        core: CoreMock,","        results: Vec<u64>,","        index: usize,","        half_used: bool,","    }","","    impl RandCore {","        fn new() -> Self {","            Self {","                core: CoreMock,","                results: vec![],","                index: 0,","                half_used: false,","            }","        }","","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            let mut read_len = 0;","            self.half_used = false;","            while read_len < dest.len() {","                if self.index >= self.results.len() {","                    self.core.generate(&mut self.results);","                    self.index = 0;","                }","","                let (consumed_u64, filled_u8) = fill_via_chunks(","                    &self.results[self.index..],","                    &mut dest[read_len..],","                );","","                self.index += consumed_u64;","                read_len += filled_u8;","            }","        }","    }","","    fn fill_via_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {","        let mut consumed = 0;","        let mut written = 0;","        for &value in src.iter() {","            let bytes = value.to_le_bytes();","            for byte in &bytes {","                if written < dest.len() {","                    dest[written] = *byte;","                    written += 1;","                } else {","                    panic!(\"Attempted to write past the end of the destination slice\");","                }","            }","            consumed += 1;","        }","        (consumed, written)","    }","","    let mut dest = vec![0u8; 5]; // Smaller than what will be produced","    let mut rand_core = RandCore::new();","    rand_core.fill_bytes(&mut dest);","}"],[]]],"codes_branches":[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut fill_bytes = FillBytes::new();","    let mut dest = vec![0; 10]; // A buffer of 10 bytes","    fill_bytes.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 10);","    assert_ne!(dest, vec![0; 10]); // Ensure some bytes were filled","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    let mut fill_bytes = FillBytes::new();","    let mut dest = vec![0; 9]; // Dest is of smaller size","    fill_bytes.fill_bytes(&mut dest);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    let mut fill_bytes = FillBytes::new();","    fill_bytes.index = 8; // Set index equal to the size of results","    let mut dest = vec![0; 8];","    fill_bytes.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 8);","    assert_ne!(dest, vec![0; 8]); // Ensure some bytes were filled","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    let mut fill_bytes = FillBytes::new();","    let mut dest = vec![0; 8];","    fill_bytes.fill_bytes(&mut dest);","    assert_eq!(dest.len(), 8);","    assert_ne!(dest, vec![0; 8]); // Ensure some bytes were filled","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    let mut fill_bytes = FillBytes::new();","    fill_bytes.results.clear(); // Make results empty","    let mut dest = vec![0; 5];","    fill_bytes.fill_bytes(&mut dest);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct CoreMock;","","    impl CoreMock {","        fn generate(&self, results: &mut Vec<u64>) {","            results.extend(vec![0u64; 10]); // Provide test data","        }","    }","","    struct RandCore {","        core: CoreMock,","        results: Vec<u64>,","        index: usize,","        half_used: bool,","    }","","    impl RandCore {","        fn new() -> Self {","            Self {","                core: CoreMock,","                results: vec![],","                index: 0,","                half_used: false,","            }","        }","","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            let mut read_len = 0;","            self.half_used = false;","            while read_len < dest.len() {","                if self.index >= self.results.len() {","                    self.core.generate(&mut self.results);","                    self.index = 0;","                }","","                let (consumed_u64, filled_u8) = fill_via_chunks(","                    &self.results[self.index..],","                    &mut dest[read_len..],","                );","","                self.index += consumed_u64;","                read_len += filled_u8;","            }","        }","    }","","    fn fill_via_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {","        let mut consumed = 0;","        let mut written = 0;","        for &value in src.iter().take(dest.len() / 8) {","            let bytes = value.to_le_bytes();","            for byte in &bytes {","                if written < dest.len() {","                    dest[written] = *byte;","                    written += 1;","                }","            }","            consumed += 1;","        }","        (consumed, written)","    }","","    let mut dest = vec![0u8; 80]; // Enough space to fill","    let mut rand_core = RandCore::new();","    rand_core.fill_bytes(&mut dest);","","    assert_eq!(dest.len(), 80);","    for byte in dest.iter() {","        assert!(*byte != 0); // Ensure that bytes were filled","    }","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct CoreMock;","","    impl CoreMock {","        fn generate(&self, results: &mut Vec<u64>) {","            // No need to generate as dest is empty","        }","    }","","    struct RandCore {","        core: CoreMock,","        results: Vec<u64>,","        index: usize,","        half_used: bool,","    }","","    impl RandCore {","        fn new() -> Self {","            Self {","                core: CoreMock,","                results: vec![],","                index: 0,","                half_used: false,","            }","        }","","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            let mut read_len = 0;","            self.half_used = false;","            while read_len < dest.len() {","                if self.index >= self.results.len() {","                    self.core.generate(&mut self.results);","                    self.index = 0;","                }","","                let (consumed_u64, filled_u8) = fill_via_chunks(","                    &self.results[self.index..],","                    &mut dest[read_len..],","                );","","                self.index += consumed_u64;","                read_len += filled_u8;","            }","        }","    }","","    fn fill_via_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {","        (0, 0) // No bytes to fill as dest is empty","    }","","    let mut dest: Vec<u8> = vec![];","    let mut rand_core = RandCore::new();","    rand_core.fill_bytes(&mut dest);","","    assert!(dest.is_empty());","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]],[["{","    struct CoreMock;","","    impl CoreMock {","        fn generate(&self, results: &mut Vec<u64>) {","            results.extend(vec![0u64; 10]);","        }","    }","","    struct RandCore {","        core: CoreMock,","        results: Vec<u64>,","        index: usize,","        half_used: bool,","    }","","    impl RandCore {","        fn new() -> Self {","            Self {","                core: CoreMock,","                results: vec![],","                index: 0,","                half_used: false,","            }","        }","","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            let mut read_len = 0;","            self.half_used = false;","            while read_len < dest.len() {","                if self.index >= self.results.len() {","                    self.core.generate(&mut self.results);","                    self.index = 0;","                }","","                let (consumed_u64, filled_u8) = fill_via_chunks(","                    &self.results[self.index..],","                    &mut dest[read_len..],","                );","","                self.index += consumed_u64;","                read_len += filled_u8;","            }","        }","    }","","    fn fill_via_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize) {","        let mut consumed = 0;","        let mut written = 0;","        for &value in src.iter() {","            let bytes = value.to_le_bytes();","            for byte in &bytes {","                if written < dest.len() {","                    dest[written] = *byte;","                    written += 1;","                } else {","                    panic!(\"Attempted to write past the end of the destination slice\");","                }","            }","            consumed += 1;","        }","        (consumed, written)","    }","","    let mut dest = vec![0u8; 5]; // Smaller than what will be produced","    let mut rand_core = RandCore::new();","    rand_core.fill_bytes(&mut dest);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":false},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]]]}