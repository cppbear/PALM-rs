{"function_name":"rand_pcg::pcg128::pcg128::Lcg128Xsl64::advance","tests":10,"tests_lines":[8,5,4,37,37,36,16,16,16,16],"oracles":10,"oracles_compiled":6,"oracles_compiled_rate":60.0,"tests_compiled":6,"tests_compiled_rate":60.0,"oracles_run":6,"oracles_passed":4,"oracles_passed_rate":66.66666666666666,"tests_run":6,"tests_passed":4,"tests_passed_rate":66.66666666666666,"lines":16,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77],"codes_lines_covered":[[["{","    let mut pcg = PcgState::new(42, 54);","    pcg.advance(1);","    assert!(pcg.state != 42); // Check that state has changed.","","    pcg.advance(3);","    assert!(pcg.state != 0); // Ensure state is valid after advancing with a larger delta.","}"],[]],[["{","    let mut pcg = PcgState::new(1, 2);","    pcg.advance(1_000_000_000_000);","    assert!(pcg.state != 1); // Check that state has changed from the initial value.","}"],[]],[["{","    let mut pcg = PcgState::new(10, 20);","    pcg.advance(0); // This should panic as the condition mdelta > 0 will not hold.","}"],[]],[["{","    struct Pcg {","        state: u128,","        increment: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl Pcg {","        pub fn new(state: u128, increment: u128) -> Self {","            Pcg { state, increment }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut rng = Pcg::new(1, 1);","    rng.advance(10);","    assert!(rng.state > 0); // Just an assertion that state advances","}"],[]],[["{","    struct Pcg {","        state: u128,","        increment: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl Pcg {","        pub fn new(state: u128, increment: u128) -> Self {","            Pcg { state, increment }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut rng = Pcg::new(5, 1);","    rng.advance(0);","    assert_eq!(rng.state, 5); // State should remain unchanged","}"],[]],[["{","    struct Pcg {","        state: u128,","        increment: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl Pcg {","        pub fn new(state: u128, increment: u128) -> Self {","            Pcg { state, increment }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut rng = Pcg::new(1, 1);","    rng.advance(u128::MAX); // This can create a panic depending on internal state","}"],[]]],"codes_branches":[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut pcg = PcgState::new(42, 54);","    pcg.advance(1);","    assert!(pcg.state != 42); // Check that state has changed.","","    pcg.advance(3);","    assert!(pcg.state != 0); // Ensure state is valid after advancing with a larger delta.","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut pcg = PcgState::new(1, 2);","    pcg.advance(1_000_000_000_000);","    assert!(pcg.state != 1); // Check that state has changed from the initial value.","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut pcg = PcgState::new(10, 20);","    pcg.advance(0); // This should panic as the condition mdelta > 0 will not hold.","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Pcg {","        state: u128,","        increment: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl Pcg {","        pub fn new(state: u128, increment: u128) -> Self {","            Pcg { state, increment }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut rng = Pcg::new(1, 1);","    rng.advance(10);","    assert!(rng.state > 0); // Just an assertion that state advances","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Pcg {","        state: u128,","        increment: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl Pcg {","        pub fn new(state: u128, increment: u128) -> Self {","            Pcg { state, increment }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut rng = Pcg::new(5, 1);","    rng.advance(0);","    assert_eq!(rng.state, 5); // State should remain unchanged","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Pcg {","        state: u128,","        increment: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl Pcg {","        pub fn new(state: u128, increment: u128) -> Self {","            Pcg { state, increment }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus = self.increment;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut rng = Pcg::new(1, 1);","    rng.advance(u128::MAX); // This can create a panic depending on internal state","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":false},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]]]}