{"function_name":"rand_pcg::pcg64::<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u64","tests":2,"tests_lines":[30,23],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[156,157,158],"codes_lines_covered":[[["{","    struct Pcg {","        state: u64,","    }","","    impl Pcg {","        fn new(seed: u64) -> Self {","            Pcg { state: seed }","        }","","        fn next_u64(&mut self) -> u64 {","            // Mock implementation of the actual function for testing purposes","            let result = (self.state * 48271) % 0x7fffffff;","            self.state = result;","            result","        }","    }","","    let mut rng = Pcg::new(123456);","","    // Testing for multiple calls to verify different states","    let output1 = rng.next_u64();","    assert!(output1 <= 0x7fffffff, \"Output should be within bounds\");","","    let output2 = rng.next_u64();","    assert!(output2 <= 0x7fffffff, \"Output should be within bounds\");","","    let output3 = rng.next_u64();","    assert!(output3 <= 0x7fffffff, \"Output should be within bounds\");","}"],[]],[["{","    struct Pcg {","        state: u64,","    }","","    impl Pcg {","        fn new(seed: u64) -> Self {","            Pcg { state: seed }","        }","","        fn next_u64(&mut self) -> u64 {","            if self.state == 0 {","                panic!(\"State cannot be zero\");","            }","            let result = (self.state * 48271) % 0x7fffffff;","            self.state = result;","            result","        }","    }","","    let mut rng = Pcg::new(0);","    rng.next_u64(); // Should panic here","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Pcg {","        state: u64,","    }","","    impl Pcg {","        fn new(seed: u64) -> Self {","            Pcg { state: seed }","        }","","        fn next_u64(&mut self) -> u64 {","            // Mock implementation of the actual function for testing purposes","            let result = (self.state * 48271) % 0x7fffffff;","            self.state = result;","            result","        }","    }","","    let mut rng = Pcg::new(123456);","","    // Testing for multiple calls to verify different states","    let output1 = rng.next_u64();","    assert!(output1 <= 0x7fffffff, \"Output should be within bounds\");","","    let output2 = rng.next_u64();","    assert!(output2 <= 0x7fffffff, \"Output should be within bounds\");","","    let output3 = rng.next_u64();","    assert!(output3 <= 0x7fffffff, \"Output should be within bounds\");","}"],[]],[["{","    struct Pcg {","        state: u64,","    }","","    impl Pcg {","        fn new(seed: u64) -> Self {","            Pcg { state: seed }","        }","","        fn next_u64(&mut self) -> u64 {","            if self.state == 0 {","                panic!(\"State cannot be zero\");","            }","            let result = (self.state * 48271) % 0x7fffffff;","            self.state = result;","            result","        }","    }","","    let mut rng = Pcg::new(0);","    rng.next_u64(); // Should panic here","}"],[]]]}