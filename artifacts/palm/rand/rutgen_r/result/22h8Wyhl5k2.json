{"function_name":"rand_pcg::pcg128::pcg128::Mcg128Xsl64::advance","tests":8,"tests_lines":[5,5,5,5,32,32,32,35],"oracles":8,"oracles_compiled":8,"oracles_compiled_rate":100.0,"tests_compiled":8,"tests_compiled_rate":100.0,"oracles_run":8,"oracles_passed":6,"oracles_passed_rate":75.0,"tests_run":8,"tests_passed":6,"tests_passed_rate":75.0,"lines":16,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[191,192,193,194,195,196,198,199,200,201,202,203,204,205,207,208],"codes_lines_covered":[[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(1);","    assert!(random_state.state > 12345); // state should change","}"],[]],[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(3);","    assert!(random_state.state > 12345); // state should change","}"],[]],[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(1);","    assert_ne!(random_state.state, 12345); // state must differ after advancing","}"],[]],[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(0); // Should not panic, state should remain the same","    assert_eq!(random_state.state, 12345);","}"],[]],[["{","    struct Pcg {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005; // Example constant","","    impl Pcg {","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut pcg = Pcg { state: 1 };","    pcg.advance(15); // 15 is odd (mdelta & 1) != 0, ensuring the condition is met","    assert!(pcg.state != 1); // Ensuring state has changed","}"],[]],[["{","    struct Pcg {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005; // Example constant","","    impl Pcg {","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut pcg = Pcg { state: 5 };","    pcg.advance(10); // 10 is even (mdelta & 1) == 0, testing the even case","    assert!(pcg.state != 5); // Ensuring state has changed","}"],[]],[["{","    struct Pcg {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005; // Example constant","","    impl Pcg {","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut pcg = Pcg { state: 42 };","    pcg.advance(0); // Testing the boundary case where mdelta == 0","    assert_eq!(pcg.state, 42); // State should remain unchanged","}"],[]],[["{","    struct PcgState {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl PcgState {","        fn new(state: u128) -> Self {","            PcgState { state }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut state = PcgState::new(42);","    state.advance(0); // This should trigger a panic due to the mdelta condition","}"],[]]],"codes_branches":[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(1);","    assert!(random_state.state > 12345); // state should change","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(3);","    assert!(random_state.state > 12345); // state should change","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(1);","    assert_ne!(random_state.state, 12345); // state must differ after advancing","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut random_state = RandomState::new(12345);","    random_state.advance(0); // Should not panic, state should remain the same","    assert_eq!(random_state.state, 12345);","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Pcg {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005; // Example constant","","    impl Pcg {","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut pcg = Pcg { state: 1 };","    pcg.advance(15); // 15 is odd (mdelta & 1) != 0, ensuring the condition is met","    assert!(pcg.state != 1); // Ensuring state has changed","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Pcg {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005; // Example constant","","    impl Pcg {","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut pcg = Pcg { state: 5 };","    pcg.advance(10); // 10 is even (mdelta & 1) == 0, testing the even case","    assert!(pcg.state != 5); // Ensuring state has changed","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]],[["{","    struct Pcg {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005; // Example constant","","    impl Pcg {","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut pcg = Pcg { state: 42 };","    pcg.advance(0); // Testing the boundary case where mdelta == 0","    assert_eq!(pcg.state, 42); // State should remain unchanged","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]],[["{","    struct PcgState {","        state: u128,","    }","","    const MULTIPLIER: u128 = 6364136223846793005;","","    impl PcgState {","        fn new(state: u128) -> Self {","            PcgState { state }","        }","","        pub fn advance(&mut self, delta: u128) {","            let mut acc_mult: u128 = 1;","            let mut acc_plus: u128 = 0;","            let mut cur_mult = MULTIPLIER;","            let mut cur_plus: u128 = 0;","            let mut mdelta = delta;","","            while mdelta > 0 {","                if (mdelta & 1) != 0 {","                    acc_mult = acc_mult.wrapping_mul(cur_mult);","                    acc_plus = acc_plus.wrapping_mul(cur_mult).wrapping_add(cur_plus);","                }","                cur_plus = cur_mult.wrapping_add(1).wrapping_mul(cur_plus);","                cur_mult = cur_mult.wrapping_mul(cur_mult);","                mdelta /= 2;","            }","            self.state = acc_mult.wrapping_mul(self.state).wrapping_add(acc_plus);","        }","    }","","    let mut state = PcgState::new(42);","    state.advance(0); // This should trigger a panic due to the mdelta condition","}"],[{"start_line":198,"start_column":15,"end_line":198,"end_column":25,"positive":false,"negative":false},{"start_line":199,"start_column":16,"end_line":199,"end_column":33,"positive":false,"negative":false}]]]}