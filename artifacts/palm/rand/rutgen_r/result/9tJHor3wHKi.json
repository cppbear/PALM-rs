{"function_name":"rand::distr::weighted::weighted_index::distr::weighted::weighted_index::WeightedIndex<X>::weight","tests":5,"tests_lines":[39,43,41,38,38],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":1,"oracles_passed_rate":20.0,"tests_run":5,"tests_passed":1,"tests_passed_rate":20.0,"lines":13,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[308,309,310,311,314,315,316,317,320,321,322,323,324],"codes_lines_covered":[[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        fn new(weights: &[u32]) -> Result<Self, ()> {","            let cumulative_weights: Vec<u32> = weights.iter().cloned().scan(0, |state, weight| {","                *state += weight;","                Some(*state)","            }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Ok(WeightedIndex {","                cumulative_weights,","                total_weight,","            })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2];","    let dist = WeightedIndex::new(&weights).unwrap();","    assert_eq!(dist.weight(3), None); // Test with index greater than length","}"],[]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[u32]) -> Result<Self, &'static str> {","            let total_weight = weights.iter().sum();","            let cumulative_weights = weights.iter().scan(0, |state, &x| {","                *state += x;","                Some(*state)","            }).collect();","            Ok(WeightedIndex {","                cumulative_weights,","                total_weight,","            })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use std::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2];","    let dist = WeightedIndex::new(&weights).unwrap();","    ","    assert_eq!(dist.weight(0), Some(0));","    assert_eq!(dist.weight(1), Some(1));","    assert_eq!(dist.weight(2), Some(2));","    assert_eq!(dist.weight(3), None);","}"],[]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<i32>,","        total_weight: i32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[i32]) -> Option<Self> {","            let cumulative_weights: Vec<i32> = weights.iter()","                .scan(0, |state, &x| {","                    *state += x;","                    Some(*state)","                }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(Self { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<i32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2, 3];","    let dist = WeightedIndex::new(&weights).unwrap();","","    assert_eq!(dist.weight(0), Some(0));","    assert_eq!(dist.weight(1), Some(1));","    assert_eq!(dist.weight(2), Some(2));","    assert_eq!(dist.weight(3), Some(3));","}"],[]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<i32>,","        total_weight: i32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[i32]) -> Option<Self> {","            let cumulative_weights: Vec<i32> = weights.iter()","                .scan(0, |state, &x| {","                    *state += x;","                    Some(*state)","                }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(Self { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<i32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [1, 2, 3];","    let dist = WeightedIndex::new(&weights).unwrap();","","    assert_eq!(dist.weight(3), None);","}"],[]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<i32>,","        total_weight: i32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[i32]) -> Option<Self> {","            let cumulative_weights: Vec<i32> = weights.iter()","                .scan(0, |state, &x| {","                    *state += x;","                    Some(*state)","                }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(Self { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<i32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2, 3, 4];","    let dist = WeightedIndex::new(&weights).unwrap();","","    assert_eq!(dist.weight(5), None);","}"],[]]],"codes_branches":[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        fn new(weights: &[u32]) -> Result<Self, ()> {","            let cumulative_weights: Vec<u32> = weights.iter().cloned().scan(0, |state, weight| {","                *state += weight;","                Some(*state)","            }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Ok(WeightedIndex {","                cumulative_weights,","                total_weight,","            })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2];","    let dist = WeightedIndex::new(&weights).unwrap();","    assert_eq!(dist.weight(3), None); // Test with index greater than length","}"],[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[u32]) -> Result<Self, &'static str> {","            let total_weight = weights.iter().sum();","            let cumulative_weights = weights.iter().scan(0, |state, &x| {","                *state += x;","                Some(*state)","            }).collect();","            Ok(WeightedIndex {","                cumulative_weights,","                total_weight,","            })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use std::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2];","    let dist = WeightedIndex::new(&weights).unwrap();","    ","    assert_eq!(dist.weight(0), Some(0));","    assert_eq!(dist.weight(1), Some(1));","    assert_eq!(dist.weight(2), Some(2));","    assert_eq!(dist.weight(3), None);","}"],[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<i32>,","        total_weight: i32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[i32]) -> Option<Self> {","            let cumulative_weights: Vec<i32> = weights.iter()","                .scan(0, |state, &x| {","                    *state += x;","                    Some(*state)","                }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(Self { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<i32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2, 3];","    let dist = WeightedIndex::new(&weights).unwrap();","","    assert_eq!(dist.weight(0), Some(0));","    assert_eq!(dist.weight(1), Some(1));","    assert_eq!(dist.weight(2), Some(2));","    assert_eq!(dist.weight(3), Some(3));","}"],[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<i32>,","        total_weight: i32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[i32]) -> Option<Self> {","            let cumulative_weights: Vec<i32> = weights.iter()","                .scan(0, |state, &x| {","                    *state += x;","                    Some(*state)","                }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(Self { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<i32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [1, 2, 3];","    let dist = WeightedIndex::new(&weights).unwrap();","","    assert_eq!(dist.weight(3), None);","}"],[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<i32>,","        total_weight: i32,","    }","","    impl WeightedIndex {","        pub fn new(weights: &[i32]) -> Option<Self> {","            let cumulative_weights: Vec<i32> = weights.iter()","                .scan(0, |state, &x| {","                    *state += x;","                    Some(*state)","                }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(Self { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<i32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2, 3, 4];","    let dist = WeightedIndex::new(&weights).unwrap();","","    assert_eq!(dist.weight(5), None);","}"],[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}]]]}