{
  "name": "rand::seq::increasing_uniform::seq::increasing_uniform::IncreasingUniform<R>::next_index",
  "name_with_impl": "rand::seq::increasing_uniform::{impl#0}::next_index",
  "mod_info": {
    "name": "seq::increasing_uniform",
    "loc": "src/seq/mod.rs:30:1:30:24"
  },
  "visible": true,
  "loc": "src/seq/increasing_uniform.rs:40:5:76:6",
  "doc": "/// Returns a number in [0,n] and increments n by 1.\n/// Generates new random bits as needed\n/// Panics if `n >= u32::MAX`\n",
  "code": [
    "pub fn next_index(&mut self) -> usize {",
    "    let next_n = self.n + 1;",
    "",
    "    // There's room for further optimisation here:",
    "    // random_range uses rejection sampling (or other method; see #1196) to avoid bias.",
    "    // When the initial sample is biased for range 0..bound",
    "    // it may still be viable to use for a smaller bound",
    "    // (especially if small biases are considered acceptable).",
    "",
    "    let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {",
    "        // If the chunk is empty, generate a new chunk",
    "        let (bound, remaining) = calculate_bound_u32(next_n);",
    "        // bound = (n + 1) * (n + 2) *..* (n + remaining)",
    "        self.chunk = self.rng.random_range(..bound);",
    "        // Chunk is a random number in",
    "        // [0, (n + 1) * (n + 2) *..* (n + remaining) )",
    "",
    "        remaining - 1",
    "    });",
    "",
    "    let result = if next_chunk_remaining == 0 {",
    "        // `chunk` is a random number in the range [0..n+1)",
    "        // Because `chunk_remaining` is about to be set to zero",
    "        // we do not need to clear the chunk here",
    "        self.chunk as usize",
    "    } else {",
    "        // `chunk` is a random number in a range that is a multiple of n+1",
    "        // so r will be a random number in [0..n+1)",
    "        let r = self.chunk % next_n;",
    "        self.chunk /= next_n;",
    "        r as usize",
    "    };",
    "",
    "    self.chunk_remaining = next_chunk_remaining;",
    "    self.n = next_n;",
    "    result",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "next_chunk_remaining == 0",
          "norm": "0 == next_chunk_remaining",
          "value": "false",
          "line": 60,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "result",
      "path": [
        0,
        1,
        2,
        3,
        4,
        8
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "next_chunk_remaining == 0",
          "norm": "0 == next_chunk_remaining",
          "value": "true",
          "line": 60,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "result",
      "path": [
        0,
        1,
        2,
        3,
        5,
        6,
        7,
        8
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}