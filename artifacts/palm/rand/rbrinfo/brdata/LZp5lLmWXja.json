{
  "name": "rand::seq::index_::sample",
  "name_with_impl": "rand::seq::index_::sample",
  "mod_info": {
    "name": "seq::index_",
    "loc": "src/seq/mod.rs:36:1:36:12"
  },
  "visible": true,
  "loc": "src/seq/index.rs:240:1:283:2",
  "doc": "/// Randomly sample exactly `amount` distinct indices from `0..length`, and\n/// return them in random order (fully shuffled).\n///\n/// This method is used internally by the slice sampling methods, but it can\n/// sometimes be useful to have the indices themselves so this is provided as\n/// an alternative.\n///\n/// The implementation used is not specified; we automatically select the\n/// fastest available algorithm for the `length` and `amount` parameters\n/// (based on detailed profiling on an Intel Haswell CPU). Roughly speaking,\n/// complexity is `O(amount)`, except that when `amount` is small, performance\n/// is closer to `O(amount^2)`, and when `length` is close to `amount` then\n/// `O(length)`.\n///\n/// Note that performance is significantly better over `u32` indices than over\n/// `u64` indices. Because of this we hide the underlying type behind an\n/// abstraction, `IndexVec`.\n///\n/// If an allocation-free `no_std` function is required, it is suggested\n/// to adapt the internal `sample_floyd` implementation.\n///\n/// Panics if `amount > length`.\n",
  "code": [
    "pub fn sample<R>(rng: &mut R, length: usize, amount: usize) -> IndexVec",
    "where",
    "    R: Rng + ?Sized,",
    "{",
    "    if amount > length {",
    "        panic!(\"`amount` of samples must be less than or equal to `length`\");",
    "    }",
    "    if length > (u32::MAX as usize) {",
    "        #[cfg(target_pointer_width = \"32\")]",
    "        unreachable!();",
    "",
    "        // We never want to use inplace here, but could use floyd's alg",
    "        // Lazy version: always use the cache alg.",
    "        #[cfg(target_pointer_width = \"64\")]",
    "        return sample_rejection(rng, length as u64, amount as u64);",
    "    }",
    "    let amount = amount as u32;",
    "    let length = length as u32;",
    "",
    "    // Choice of algorithm here depends on both length and amount. See:",
    "    // https://github.com/rust-random/rand/pull/479",
    "    // We do some calculations with f32. Accuracy is not very important.",
    "",
    "    if amount < 163 {",
    "        const C: [[f32; 2]; 2] = [[1.6, 8.0 / 45.0], [10.0, 70.0 / 9.0]];",
    "        let j = usize::from(length >= 500_000);",
    "        let amount_fp = amount as f32;",
    "        let m4 = C[0][j] * amount_fp;",
    "        // Short-cut: when amount < 12, floyd's is always faster",
    "        if amount > 11 && (length as f32) < (C[1][j] + m4) * amount_fp {",
    "            sample_inplace(rng, length, amount)",
    "        } else {",
    "            sample_floyd(rng, length, amount)",
    "        }",
    "    } else {",
    "        const C: [f32; 2] = [270.0, 330.0 / 9.0];",
    "        let j = usize::from(length >= 500_000);",
    "        if (length as f32) < C[j] * (amount as f32) {",
    "            sample_inplace(rng, length, amount)",
    "        } else {",
    "            sample_rejection(rng, length, amount)",
    "        }",
    "    }",
    "}"
  ],
  "size": {
    "chain": 7,
    "contra": 0,
    "min_set": 7
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "amount > length",
          "norm": null,
          "value": "true",
          "line": 244,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        31
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "amount > length",
          "norm": null,
          "value": "false",
          "line": 244,
          "bound": "amount == length",
          "may_panic": false
        },
        {
          "cond": "length > (u32::MAX as usize)",
          "norm": "(u32::MAX as usize) < length",
          "value": "true",
          "line": 247,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        4,
        6,
        30
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "amount > length",
          "norm": null,
          "value": "false",
          "line": 244,
          "bound": "amount == length",
          "may_panic": false
        },
        {
          "cond": "length > (u32::MAX as usize)",
          "norm": "(u32::MAX as usize) < length",
          "value": "false",
          "line": 247,
          "bound": "length == (u32::MAX as usize)",
          "may_panic": false
        },
        {
          "cond": "amount < 163",
          "norm": "163 > amount",
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "amount > 11",
          "norm": "11 < amount",
          "value": "true",
          "line": 269,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "(length as f32) < (C[1][j] + m4) * amount_fp",
          "norm": "(C[1][j] + m4) * amount_fp > (length as f32)",
          "value": "true",
          "line": 269,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        7,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        21,
        29,
        30
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "amount > length",
          "norm": null,
          "value": "false",
          "line": 244,
          "bound": "amount == length",
          "may_panic": false
        },
        {
          "cond": "length > (u32::MAX as usize)",
          "norm": "(u32::MAX as usize) < length",
          "value": "false",
          "line": 247,
          "bound": "length == (u32::MAX as usize)",
          "may_panic": false
        },
        {
          "cond": "amount < 163",
          "norm": "163 > amount",
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "amount > 11",
          "norm": "11 < amount",
          "value": "true",
          "line": 269,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "(length as f32) < (C[1][j] + m4) * amount_fp",
          "norm": "(C[1][j] + m4) * amount_fp > (length as f32)",
          "value": "false",
          "line": 269,
          "bound": "(length as f32) == (C[1][j] + m4) * amount_fp",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        7,
        9,
        10,
        11,
        12,
        13,
        14,
        17,
        19,
        20,
        21,
        29,
        30
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "amount > length",
          "norm": null,
          "value": "false",
          "line": 244,
          "bound": "amount == length",
          "may_panic": false
        },
        {
          "cond": "length > (u32::MAX as usize)",
          "norm": "(u32::MAX as usize) < length",
          "value": "false",
          "line": 247,
          "bound": "length == (u32::MAX as usize)",
          "may_panic": false
        },
        {
          "cond": "amount < 163",
          "norm": "163 > amount",
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "amount > 11",
          "norm": "11 < amount",
          "value": "false",
          "line": 269,
          "bound": "amount == 11",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        7,
        9,
        10,
        11,
        18,
        19,
        20,
        21,
        29,
        30
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "amount > length",
          "norm": null,
          "value": "false",
          "line": 244,
          "bound": "amount == length",
          "may_panic": false
        },
        {
          "cond": "length > (u32::MAX as usize)",
          "norm": "(u32::MAX as usize) < length",
          "value": "false",
          "line": 247,
          "bound": "length == (u32::MAX as usize)",
          "may_panic": false
        },
        {
          "cond": "amount < 163",
          "norm": "163 > amount",
          "value": "false",
          "line": 263,
          "bound": "amount == 163",
          "may_panic": false
        },
        {
          "cond": "(length as f32) < C[j] * (amount as f32)",
          "norm": null,
          "value": "true",
          "line": 277,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        8,
        22,
        23,
        24,
        25,
        28,
        29,
        30
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "amount > length",
          "norm": null,
          "value": "false",
          "line": 244,
          "bound": "amount == length",
          "may_panic": false
        },
        {
          "cond": "length > (u32::MAX as usize)",
          "norm": "(u32::MAX as usize) < length",
          "value": "false",
          "line": 247,
          "bound": "length == (u32::MAX as usize)",
          "may_panic": false
        },
        {
          "cond": "amount < 163",
          "norm": "163 > amount",
          "value": "false",
          "line": 263,
          "bound": "amount == 163",
          "may_panic": false
        },
        {
          "cond": "(length as f32) < C[j] * (amount as f32)",
          "norm": null,
          "value": "false",
          "line": 277,
          "bound": "(length as f32) == C[j] * (amount as f32)",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        3,
        5,
        8,
        22,
        23,
        26,
        27,
        28,
        29,
        30
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}