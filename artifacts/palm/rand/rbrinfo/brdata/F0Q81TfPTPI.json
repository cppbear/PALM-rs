{
  "name": "rand::seq::coin_flipper::seq::coin_flipper::CoinFlipper<R>::flip_c_heads",
  "name_with_impl": "rand::seq::coin_flipper::{impl#0}::flip_c_heads",
  "mod_info": {
    "name": "seq::coin_flipper",
    "loc": "src/seq/mod.rs:29:1:29:18"
  },
  "visible": false,
  "loc": "src/seq/coin_flipper.rs:119:5:159:6",
  "doc": "/// If the next `c` bits of randomness all represent heads, consume them, return true\n/// Otherwise return false and consume the number of heads plus one.\n/// Generates new bits of randomness when necessary (in 32 bit chunks)\n/// Has a 1 in 2 to the `c` chance of returning true\n/// `c` must be less than or equal to 32\n",
  "code": [
    "fn flip_c_heads(&mut self, mut c: u32) -> bool {",
    "    debug_assert!(c <= 32);",
    "    // Note that zeros on the left of the chunk represent heads.",
    "    // It needs to be this way round because zeros are filled in when left shifting",
    "    loop {",
    "        let zeros = self.chunk.leading_zeros();",
    "",
    "        if zeros < c {",
    "            // The happy path - we found a 1 and can return false",
    "            // Note that because a 1 bit was detected,",
    "            // We cannot have run out of random bits so we don't need to check",
    "",
    "            // First consume all of the bits read",
    "            // Using shl seems to give worse performance for size-hinted iterators",
    "            self.chunk = self.chunk.wrapping_shl(zeros + 1);",
    "",
    "            self.chunk_remaining = self.chunk_remaining.saturating_sub(zeros + 1);",
    "            return false;",
    "        } else {",
    "            // The number of zeros is larger than `c`",
    "            // There are two possibilities",
    "            if let Some(new_remaining) = self.chunk_remaining.checked_sub(c) {",
    "                // Those zeroes were all part of our random chunk,",
    "                // throw away `c` bits of randomness and return true",
    "                self.chunk_remaining = new_remaining;",
    "                self.chunk <<= c;",
    "                return true;",
    "            } else {",
    "                // Some of those zeroes were part of the random chunk",
    "                // and some were part of the space behind it",
    "                // We need to take into account only the zeroes that were random",
    "                c -= self.chunk_remaining;",
    "",
    "                // Generate a new chunk",
    "                self.chunk = self.rng.next_u32();",
    "                self.chunk_remaining = 32;",
    "                // Go back to start of loop",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "size": {
    "chain": 4,
    "contra": 1,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "c <= 32",
          "norm": "32 >= c",
          "value": "true",
          "line": 120,
          "bound": "c == 32",
          "may_panic": false
        },
        {
          "cond": "zeros < c",
          "norm": "c > zeros",
          "value": "true",
          "line": 126,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        22
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "c <= 32",
          "norm": "32 >= c",
          "value": "true",
          "line": 120,
          "bound": "c == 32",
          "may_panic": false
        },
        {
          "cond": "zeros < c",
          "norm": "c > zeros",
          "value": "false",
          "line": 126,
          "bound": "zeros == c",
          "may_panic": false
        },
        {
          "cond": "let Some(new_remaining) = self.chunk_remaining.checked_sub(c)",
          "norm": null,
          "value": "true",
          "line": 140,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "zeros < c",
          "norm": "c > zeros",
          "value": "true",
          "line": 126,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "false",
      "path": [
        0,
        1,
        2,
        5,
        6,
        7,
        8,
        14,
        15,
        19,
        20,
        21,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        22
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "c <= 32",
          "norm": "32 >= c",
          "value": "true",
          "line": 120,
          "bound": "c == 32",
          "may_panic": false
        },
        {
          "cond": "zeros < c",
          "norm": "c > zeros",
          "value": "false",
          "line": 126,
          "bound": "zeros == c",
          "may_panic": false
        },
        {
          "cond": "let Some(new_remaining) = self.chunk_remaining.checked_sub(c)",
          "norm": null,
          "value": "true",
          "line": 140,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "true",
      "path": [
        0,
        1,
        2,
        5,
        6,
        7,
        8,
        14,
        15,
        16,
        17,
        18,
        22
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "c <= 32",
          "norm": "32 >= c",
          "value": "false",
          "line": 120,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        3,
        23
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}