{
  "name": "rand::seq::slice::IndexedRandom::choose_weighted",
  "name_with_impl": "rand::seq::slice::IndexedRandom::choose_weighted",
  "mod_info": {
    "name": "seq::slice",
    "loc": "src/seq/mod.rs:32:1:32:11"
  },
  "visible": true,
  "loc": "src/seq/slice.rs:158:5:172:6",
  "doc": "/// Biased sampling for one element\n///\n/// Returns a reference to one element of the slice, sampled according\n/// to the provided weights. Returns `None` only if the slice is empty.\n///\n/// The specified function `weight` maps each item `x` to a relative\n/// likelihood `weight(x)`. The probability of each item being selected is\n/// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n///\n/// For slices of length `n`, complexity is `O(n)`.\n/// For more information about the underlying algorithm,\n/// see the [`WeightedIndex`] distribution.\n///\n/// See also [`choose_weighted_mut`].\n///\n/// # Example\n///\n/// ```\n/// use rand::prelude::*;\n///\n/// let choices = [('a', 2), ('b', 1), ('c', 1), ('d', 0)];\n/// let mut rng = rand::rng();\n/// // 50% chance to print 'a', 25% chance to print 'b', 25% chance to print 'c',\n/// // and 'd' will never be printed\n/// println!(\"{:?}\", choices.choose_weighted(&mut rng, |item| item.1).unwrap().0);\n/// ```\n/// [`choose`]: IndexedRandom::choose\n/// [`choose_weighted_mut`]: IndexedMutRandom::choose_weighted_mut\n/// [`WeightedIndex`]: crate::distr::weighted::WeightedIndex\n",
  "code": [
    "fn choose_weighted<R, F, B, X>(",
    "    &self,",
    "    rng: &mut R,",
    "    weight: F,",
    ") -> Result<&Self::Output, WeightError>",
    "where",
    "    R: Rng + ?Sized,",
    "    F: Fn(&Self::Output) -> B,",
    "    B: SampleBorrow<X>,",
    "    X: SampleUniform + Weight + PartialOrd<X>,",
    "{",
    "    use crate::distr::{weighted::WeightedIndex, Distribution};",
    "    let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;",
    "    Ok(&self[distr.sample(rng)])",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?",
          "norm": null,
          "value": "Err/None",
          "line": 170,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?",
          "norm": null,
          "value": "Ok/Some",
          "line": 170,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self[distr.sample(rng)]",
          "norm": null,
          "value": "",
          "line": 171,
          "bound": null,
          "may_panic": true
        }
      ],
      "ret": "Ok(&self[distr.sample(rng)])",
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        13,
        14,
        16
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}