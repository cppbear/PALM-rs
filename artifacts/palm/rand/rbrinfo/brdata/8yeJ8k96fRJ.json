{
  "name": "rand::seq::slice::IndexedMutRandom::choose_weighted_mut",
  "name_with_impl": "rand::seq::slice::IndexedMutRandom::choose_weighted_mut",
  "mod_info": {
    "name": "seq::slice",
    "loc": "src/seq/mod.rs:32:1:32:11"
  },
  "visible": true,
  "loc": "src/seq/slice.rs:276:5:291:6",
  "doc": "/// Biased sampling for one element (mut)\n///\n/// Returns a mutable reference to one element of the slice, sampled according\n/// to the provided weights. Returns `None` only if the slice is empty.\n///\n/// The specified function `weight` maps each item `x` to a relative\n/// likelihood `weight(x)`. The probability of each item being selected is\n/// therefore `weight(x) / s`, where `s` is the sum of all `weight(x)`.\n///\n/// For slices of length `n`, complexity is `O(n)`.\n/// For more information about the underlying algorithm,\n/// see the [`WeightedIndex`] distribution.\n///\n/// See also [`choose_weighted`].\n///\n/// [`choose_mut`]: IndexedMutRandom::choose_mut\n/// [`choose_weighted`]: IndexedRandom::choose_weighted\n/// [`WeightedIndex`]: crate::distr::weighted::WeightedIndex\n",
  "code": [
    "fn choose_weighted_mut<R, F, B, X>(",
    "    &mut self,",
    "    rng: &mut R,",
    "    weight: F,",
    ") -> Result<&mut Self::Output, WeightError>",
    "where",
    "    R: Rng + ?Sized,",
    "    F: Fn(&Self::Output) -> B,",
    "    B: SampleBorrow<X>,",
    "    X: SampleUniform + Weight + PartialOrd<X>,",
    "{",
    "    use crate::distr::{weighted::WeightedIndex, Distribution};",
    "    let distr = WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?;",
    "    let index = distr.sample(rng);",
    "    Ok(&mut self[index])",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?",
          "norm": null,
          "value": "Err/None",
          "line": 288,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        6,
        8,
        9,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "WeightedIndex::new((0..self.len()).map(|idx| weight(&self[idx])))?",
          "norm": null,
          "value": "Ok/Some",
          "line": 288,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self[index]",
          "norm": null,
          "value": "",
          "line": 290,
          "bound": null,
          "may_panic": true
        }
      ],
      "ret": "Ok(&mut self[index])",
      "path": [
        0,
        1,
        2,
        3,
        4,
        7,
        10,
        11,
        12,
        13,
        14,
        16
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}