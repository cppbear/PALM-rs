{"function_name":"rand::rngs::xoshiro256plusplus::<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u32","tests":2,"tests_lines":[40,39],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[70,71,72,73,74,75],"codes_lines_covered":[[["{","    struct Xoshiro256PlusPlusTest {","        s: [u64; 4],","    }","","    impl RngCore for Xoshiro256PlusPlusTest {","        #[inline]","        fn next_u32(&mut self) -> u32 {","            let val = self.next_u64();","            (val >> 32) as u32","        }","","        #[inline]","        fn next_u64(&mut self) -> u64 {","            let res = self","                .s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","            let t = self.s[1] << 17;","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","            self.s[2] ^= t;","            self.s[3] = self.s[3].rotate_left(45);","            res","        }","","        #[inline]","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    let mut rng = Xoshiro256PlusPlusTest { s: [0, 0, 0, 0] };","","    let output1 = rng.next_u32();","    let output2 = rng.next_u32();","","    assert!(output1 != output2);","}"],[]],[["{","    struct Xoshiro256PlusPlusTest {","        s: [u64; 4],","    }","","    impl RngCore for Xoshiro256PlusPlusTest {","        #[inline]","        fn next_u32(&mut self) -> u32 {","            let val = self.next_u64();","            (val >> 32) as u32","        }","","        #[inline]","        fn next_u64(&mut self) -> u64 {","            let res = self","                .s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","            let t = self.s[1] << 17;","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","            self.s[2] ^= t;","            self.s[3] = self.s[3].rotate_left(45);","            res","        }","","        #[inline]","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    let mut rng = Xoshiro256PlusPlusTest { s: [u64::MAX, u64::MAX, u64::MAX, u64::MAX] };","","    let output = rng.next_u32();","","    assert!(output <= u32::MAX);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Xoshiro256PlusPlusTest {","        s: [u64; 4],","    }","","    impl RngCore for Xoshiro256PlusPlusTest {","        #[inline]","        fn next_u32(&mut self) -> u32 {","            let val = self.next_u64();","            (val >> 32) as u32","        }","","        #[inline]","        fn next_u64(&mut self) -> u64 {","            let res = self","                .s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","            let t = self.s[1] << 17;","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","            self.s[2] ^= t;","            self.s[3] = self.s[3].rotate_left(45);","            res","        }","","        #[inline]","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    let mut rng = Xoshiro256PlusPlusTest { s: [0, 0, 0, 0] };","","    let output1 = rng.next_u32();","    let output2 = rng.next_u32();","","    assert!(output1 != output2);","}"],[]],[["{","    struct Xoshiro256PlusPlusTest {","        s: [u64; 4],","    }","","    impl RngCore for Xoshiro256PlusPlusTest {","        #[inline]","        fn next_u32(&mut self) -> u32 {","            let val = self.next_u64();","            (val >> 32) as u32","        }","","        #[inline]","        fn next_u64(&mut self) -> u64 {","            let res = self","                .s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","            let t = self.s[1] << 17;","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","            self.s[2] ^= t;","            self.s[3] = self.s[3].rotate_left(45);","            res","        }","","        #[inline]","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    let mut rng = Xoshiro256PlusPlusTest { s: [u64::MAX, u64::MAX, u64::MAX, u64::MAX] };","","    let output = rng.next_u32();","","    assert!(output <= u32::MAX);","}"],[]]]}