{"function_name":"rand_core::block::<block::BlockRng64<R> as RngCore>::next_u64","tests":2,"tests_lines":[27,27],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":10,"lines_covered":10,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[369,370,371,372,373,375,376,377,378,379],"codes_lines_covered":[[["{","    struct TestBlockRng;","","    impl BlockRngCore for TestBlockRng {","        type Item = u64;","        type Results = [u64; 4];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4]);","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: TestBlockRng,","    };","","    assert_eq!(rng.next_u64(), 1);","    assert_eq!(rng.next_u64(), 2);","    assert_eq!(rng.next_u64(), 3);","    assert_eq!(rng.next_u64(), 4);","    ","    // Check that generating again refills results","    assert_eq!(rng.next_u64(), 1);","}"],[369,370,373,375,376,377,378,379]],[["{","    struct TestBlockRng;","","    impl BlockRngCore for TestBlockRng {","        type Item = u64;","        type Results = [u64; 4];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40]);","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: TestBlockRng,","    };","","    for _ in 0..4 {","        rng.next_u64();","    }","    ","    // At this point, the index should have wrapped around","    // and the next call should refill the results","    assert_eq!(rng.next_u64(), 10);","}"],[369,370,371,372,373,375,376,377,378,379]]],"codes_branches":[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct TestBlockRng;","","    impl BlockRngCore for TestBlockRng {","        type Item = u64;","        type Results = [u64; 4];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[1, 2, 3, 4]);","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: TestBlockRng,","    };","","    assert_eq!(rng.next_u64(), 1);","    assert_eq!(rng.next_u64(), 2);","    assert_eq!(rng.next_u64(), 3);","    assert_eq!(rng.next_u64(), 4);","    ","    // Check that generating again refills results","    assert_eq!(rng.next_u64(), 1);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":false,"negative":true}]],[["{","    struct TestBlockRng;","","    impl BlockRngCore for TestBlockRng {","        type Item = u64;","        type Results = [u64; 4];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&[10, 20, 30, 40]);","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: TestBlockRng,","    };","","    for _ in 0..4 {","        rng.next_u64();","    }","    ","    // At this point, the index should have wrapped around","    // and the next call should refill the results","    assert_eq!(rng.next_u64(), 10);","}"],[{"start_line":370,"start_column":12,"end_line":370,"end_column":53,"positive":true,"negative":true}]]]}