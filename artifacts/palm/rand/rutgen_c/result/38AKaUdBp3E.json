{"function_name":"rand_core::block::<block::BlockRng64<R> as RngCore>::fill_bytes","tests":3,"tests_lines":[28,29,26],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":1,"oracles_passed_rate":33.33333333333333,"tests_run":3,"tests_passed":1,"tests_passed_rate":33.33333333333333,"lines":14,"lines_covered":12,"lines_coveraged_rate":85.71428571428571,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[382,383,384,385,386,387,388,389,391,392,393,394,395,397],"codes_lines_covered":[[["{","    struct DummyCore {","        count: u64,","    }","","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = self.count;","            results[1] = self.count + 1;","            self.count += 2;","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: DummyCore { count: 0 },","    };","","    let mut buffer = [0u8; 16];","    rng.fill_bytes(&mut buffer);","","    assert_eq!(&buffer, &[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]);","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct DummyCore {","        count: u64,","    }","","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = self.count;","            results[1] = self.count + 1;","            self.count += 2;","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: DummyCore { count: 0 },","    };","","    let mut buffer = [0u8; 10];","    rng.fill_bytes(&mut buffer);","","    assert_eq!(&buffer[..8], &[0, 0, 0, 0, 0, 0, 0, 0]);","    assert_eq!(&buffer[8..], &[1, 0]); // Partially filled with the second u64","}"],[382,383,384,385,386,389,391,392,393,394,395,397]],[["{","    struct DummyCore {","        count: u64,","    }","","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = self.count;","            results[1] = self.count + 1;","            self.count += 2;","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: DummyCore { count: 0 },","    };","","    let mut buffer: [u8; 0] = [];","    rng.fill_bytes(&mut buffer); // Should not panic, performing no operations","}"],[382,383,384,385,397]]],"codes_branches":[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    struct DummyCore {","        count: u64,","    }","","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = self.count;","            results[1] = self.count + 1;","            self.count += 2;","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: DummyCore { count: 0 },","    };","","    let mut buffer = [0u8; 16];","    rng.fill_bytes(&mut buffer);","","    assert_eq!(&buffer, &[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]);","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct DummyCore {","        count: u64,","    }","","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = self.count;","            results[1] = self.count + 1;","            self.count += 2;","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: DummyCore { count: 0 },","    };","","    let mut buffer = [0u8; 10];","    rng.fill_bytes(&mut buffer);","","    assert_eq!(&buffer[..8], &[0, 0, 0, 0, 0, 0, 0, 0]);","    assert_eq!(&buffer[8..], &[1, 0]); // Partially filled with the second u64","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":true,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":true}]],[["{","    struct DummyCore {","        count: u64,","    }","","    impl BlockRngCore for DummyCore {","        type Item = u64;","        type Results = [u64; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results[0] = self.count;","            results[1] = self.count + 1;","            self.count += 2;","        }","    }","","    let mut rng = BlockRng64 {","        results: Default::default(),","        index: 0,","        half_used: false,","        core: DummyCore { count: 0 },","    };","","    let mut buffer: [u8; 0] = [];","    rng.fill_bytes(&mut buffer); // Should not panic, performing no operations","}"],[{"start_line":385,"start_column":15,"end_line":385,"end_column":36,"positive":false,"negative":true},{"start_line":386,"start_column":16,"end_line":386,"end_column":57,"positive":false,"negative":false}]]]}