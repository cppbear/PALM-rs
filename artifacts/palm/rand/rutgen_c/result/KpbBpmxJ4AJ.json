{"function_name":"rand::rngs::xoshiro256plusplus::<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u64","tests":1,"tests_lines":[40],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":19,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96],"codes_lines_covered":[[["{","    struct TestRng {","        s: [u64; 4],","    }","","    impl RngCore for TestRng {","        fn next_u32(&mut self) -> u32 {","            0 // Implementing this method is not needed for the test","        }","","        fn next_u64(&mut self) -> u64 {","            let res = self.s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","","            let t = self.s[1] << 17;","","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","","            self.s[2] ^= t;","","            self.s[3] = self.s[3].rotate_left(45);","","            res","        }","","        fn fill_bytes(&mut self, _dst: &mut [u8]) {","            // Implementing this method is not needed for the test","        }","    }","","    let mut rng = TestRng { s: [0x1a2b3c4d5e6f7081, 0x1122334455667788, 0x99aabbccddeeff00, 0x2233445566778899] };","","    let result = rng.next_u64();","    assert_eq!(result, 0x60f0ec13550c2c2c); // Replace with the expected result based on the given state if known","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestRng {","        s: [u64; 4],","    }","","    impl RngCore for TestRng {","        fn next_u32(&mut self) -> u32 {","            0 // Implementing this method is not needed for the test","        }","","        fn next_u64(&mut self) -> u64 {","            let res = self.s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","","            let t = self.s[1] << 17;","","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","","            self.s[2] ^= t;","","            self.s[3] = self.s[3].rotate_left(45);","","            res","        }","","        fn fill_bytes(&mut self, _dst: &mut [u8]) {","            // Implementing this method is not needed for the test","        }","    }","","    let mut rng = TestRng { s: [0x1a2b3c4d5e6f7081, 0x1122334455667788, 0x99aabbccddeeff00, 0x2233445566778899] };","","    let result = rng.next_u64();","    assert_eq!(result, 0x60f0ec13550c2c2c); // Replace with the expected result based on the given state if known","}"],[]]]}