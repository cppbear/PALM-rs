{"function_name":"rand_core::block::<block::BlockRng<R> as RngCore>::fill_bytes","tests":4,"tests_lines":[25,25,25,25],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":1,"oracles_passed_rate":25.0,"tests_run":4,"tests_passed":1,"tests_passed_rate":25.0,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[222,223,224,225,226,227,228,229,230,231,232,234],"codes_lines_covered":[[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2, 3, 4, 5],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest = [0u8; 16];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]);","}"],[222,223,224,225,226,227,228,229,230,231,232]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest = [0u8; 16];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0]);","}"],[222,223,224,225,226,227,228,229,230,231,232]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2, 3],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest = [0u8; 12];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]);","}"],[222,223,224,225,226,227,228,229,230,231,232]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2, 3],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest: [u8; 0] = [];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[]);","}"],[222,223,224,234]]],"codes_branches":[{"start_line":224,"start_column":15,"end_line":224,"end_column":36,"positive":true,"negative":true},{"start_line":225,"start_column":16,"end_line":225,"end_column":57,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2, 3, 4, 5],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest = [0u8; 16];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]);","}"],[{"start_line":224,"start_column":15,"end_line":224,"end_column":36,"positive":true,"negative":false},{"start_line":225,"start_column":16,"end_line":225,"end_column":57,"positive":true,"negative":false}]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest = [0u8; 16];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0]);","}"],[{"start_line":224,"start_column":15,"end_line":224,"end_column":36,"positive":true,"negative":false},{"start_line":225,"start_column":16,"end_line":225,"end_column":57,"positive":true,"negative":false}]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2, 3],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest = [0u8; 12];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]);","}"],[{"start_line":224,"start_column":15,"end_line":224,"end_column":36,"positive":true,"negative":false},{"start_line":225,"start_column":16,"end_line":225,"end_column":57,"positive":true,"negative":false}]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.extend(self.results.clone());","        }","    }","","    let core = MockBlockRngCore {","        results: vec![1, 2, 3],","    };","    ","    let mut block_rng = BlockRng::new(core);","    let mut dest: [u8; 0] = [];","    ","    block_rng.fill_bytes(&mut dest);","    ","    assert_eq!(&dest, &[]);","}"],[{"start_line":224,"start_column":15,"end_line":224,"end_column":36,"positive":false,"negative":true},{"start_line":225,"start_column":16,"end_line":225,"end_column":57,"positive":false,"negative":false}]]]}