{"function_name":"rand_core::block::<block::BlockRng<R> as RngCore>::next_u64","tests":3,"tests_lines":[28,28,28],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":3,"tests_passed":0,"tests_passed_rate":0.0,"lines":20,"lines_covered":7,"lines_coveraged_rate":35.0,"branches":4,"branches_covered":1,"branches_coverage_rate":25.0,"codes_lines":[197,198,199,200,201,203,204,205,206,207,208,209,210,211,212,214,215,216,217,219],"codes_lines_covered":[[["{","    struct DummyBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for DummyBlockRngCore {","        fn default() -> Self {","            DummyBlockRngCore {","                results: vec![1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = DummyBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 0;","    let result = block_rng.next_u64();","    assert_eq!(result, 0x0000000200000001); // 0x00000002 << 32 | 0x00000001","}"],[197,198,203,204,205,206,210]],[["{","    struct DummyBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for DummyBlockRngCore {","        fn default() -> Self {","            DummyBlockRngCore {","                results: vec![1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = DummyBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 2; // Set index to end","    let result = block_rng.next_u64();","    assert_eq!(result, 0x0000000400000003); // 0x00000004 << 32 | 0x00000003","}"],[197,198,203,204,205,206,210]],[["{","    struct DummyBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for DummyBlockRngCore {","        fn default() -> Self {","            DummyBlockRngCore {","                results: vec![1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = DummyBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 5; // Set index beyond length","    let result = block_rng.next_u64();","    assert_eq!(result, 0x0000000400000001); // Should regenerate","}"],[197,198,203,204,205,206,210]]],"codes_branches":[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct DummyBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for DummyBlockRngCore {","        fn default() -> Self {","            DummyBlockRngCore {","                results: vec![1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = DummyBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 0;","    let result = block_rng.next_u64();","    assert_eq!(result, 0x0000000200000001); // 0x00000002 << 32 | 0x00000001","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct DummyBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for DummyBlockRngCore {","        fn default() -> Self {","            DummyBlockRngCore {","                results: vec![1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = DummyBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 2; // Set index to end","    let result = block_rng.next_u64();","    assert_eq!(result, 0x0000000400000003); // 0x00000004 << 32 | 0x00000003","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct DummyBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for DummyBlockRngCore {","        fn default() -> Self {","            DummyBlockRngCore {","                results: vec![1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for DummyBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = DummyBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 5; // Set index beyond length","    let result = block_rng.next_u64();","    assert_eq!(result, 0x0000000400000001); // Should regenerate","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]]]}