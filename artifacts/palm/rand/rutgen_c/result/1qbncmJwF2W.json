{"function_name":"rand_core::block::<block::BlockRng<R> as SeedableRng>::from_seed","tests":2,"tests_lines":[44,60],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[241,242,243],"codes_lines_covered":[[["{","    struct TestBlockRng;","","    impl SeedableRng for TestBlockRng {","        type Seed = [u8; 16];","","        fn from_seed(seed: Self::Seed) -> Self {","            TestBlockRng","        }","    }","","    struct TestResults([u32; 10]);","","    impl Default for TestResults {","        fn default() -> Self {","            TestResults([0; 10])","        }","    }","","    impl AsRef<[u32]> for TestResults {","        fn as_ref(&self) -> &[u32] {","            &self.0","        }","    }","","    impl AsMut<[u32]> for TestResults {","        fn as_mut(&mut self) -> &mut [u32] {","            &mut self.0","        }","    }","","    impl BlockRngCore for TestBlockRng {","        type Item = u32;","        type Results = TestResults;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.0.fill(42); // Just an arbitrary value for testing","        }","    }","","    let seed: [u8; 16] = [1; 16];","    let block_rng = BlockRng::<TestBlockRng>::from_seed(seed);","    assert_eq!(block_rng.index(), 0);","}"],[241,242,243]],[["{","    struct DummyRng;","","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 {","            1","        }","","        fn next_u64(&mut self) -> u64 {","            1","        }","","        fn fill_bytes(&mut self, dst: &mut [u8]) {","            dst.fill(1);","        }","    }","","    struct TestBlockRng;","","    impl SeedableRng for TestBlockRng {","        type Seed = [u8; 16];","","        fn from_seed(seed: Self::Seed) -> Self {","            TestBlockRng","        }","    }","","    struct TestResults([u32; 10]);","","    impl Default for TestResults {","        fn default() -> Self {","            TestResults([0; 10])","        }","    }","","    impl AsRef<[u32]> for TestResults {","        fn as_ref(&self) -> &[u32] {","            &self.0","        }","    }","","    impl AsMut<[u32]> for TestResults {","        fn as_mut(&mut self) -> &mut [u32] {","            &mut self.0","        }","    }","","    impl BlockRngCore for TestBlockRng {","        type Item = u32;","        type Results = TestResults;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.0.fill(42); // Just an arbitrary value for testing","        }","    }","","    let mut rng = DummyRng;","    let block_rng = BlockRng::<TestBlockRng>::from_rng(&mut rng);","    assert_eq!(block_rng.index(), 0);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestBlockRng;","","    impl SeedableRng for TestBlockRng {","        type Seed = [u8; 16];","","        fn from_seed(seed: Self::Seed) -> Self {","            TestBlockRng","        }","    }","","    struct TestResults([u32; 10]);","","    impl Default for TestResults {","        fn default() -> Self {","            TestResults([0; 10])","        }","    }","","    impl AsRef<[u32]> for TestResults {","        fn as_ref(&self) -> &[u32] {","            &self.0","        }","    }","","    impl AsMut<[u32]> for TestResults {","        fn as_mut(&mut self) -> &mut [u32] {","            &mut self.0","        }","    }","","    impl BlockRngCore for TestBlockRng {","        type Item = u32;","        type Results = TestResults;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.0.fill(42); // Just an arbitrary value for testing","        }","    }","","    let seed: [u8; 16] = [1; 16];","    let block_rng = BlockRng::<TestBlockRng>::from_seed(seed);","    assert_eq!(block_rng.index(), 0);","}"],[]],[["{","    struct DummyRng;","","    impl RngCore for DummyRng {","        fn next_u32(&mut self) -> u32 {","            1","        }","","        fn next_u64(&mut self) -> u64 {","            1","        }","","        fn fill_bytes(&mut self, dst: &mut [u8]) {","            dst.fill(1);","        }","    }","","    struct TestBlockRng;","","    impl SeedableRng for TestBlockRng {","        type Seed = [u8; 16];","","        fn from_seed(seed: Self::Seed) -> Self {","            TestBlockRng","        }","    }","","    struct TestResults([u32; 10]);","","    impl Default for TestResults {","        fn default() -> Self {","            TestResults([0; 10])","        }","    }","","    impl AsRef<[u32]> for TestResults {","        fn as_ref(&self) -> &[u32] {","            &self.0","        }","    }","","    impl AsMut<[u32]> for TestResults {","        fn as_mut(&mut self) -> &mut [u32] {","            &mut self.0","        }","    }","","    impl BlockRngCore for TestBlockRng {","        type Item = u32;","        type Results = TestResults;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.0.fill(42); // Just an arbitrary value for testing","        }","    }","","    let mut rng = DummyRng;","    let block_rng = BlockRng::<TestBlockRng>::from_rng(&mut rng);","    assert_eq!(block_rng.index(), 0);","}"],[]]]}