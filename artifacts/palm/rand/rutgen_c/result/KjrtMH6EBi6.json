{"function_name":"rand_pcg::pcg128cm::pcg128cm::Lcg128CmDxsm64::step","tests":3,"tests_lines":[16,16,16],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[112,113,114,115,116,117,118],"codes_lines_covered":[[["{","    // Initialize the Lcg128CmDxsm64 struct","    let mut rng = Lcg128CmDxsm64::new(1, 2);","    ","    // Store the initial state","    let initial_state = rng.state;","    ","    // Call the step method","    rng.step();","    ","    // Calculate the expected state","    let expected_state = initial_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(rng.increment);","    ","    // Assert that the state after stepping matches the expected state","    assert_eq!(rng.state, expected_state);","}"],[112,113,114,115,116,117,118]],[["{","    // Initialize the struct with large values","    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, u128::MAX - 2);","    ","    // Store the initial state","    let initial_state = rng.state;","    ","    // Call the step method","    rng.step();","    ","    // Calculate the expected state","    let expected_state = initial_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(rng.increment);","    ","    // Assert that the state after stepping matches the expected state","    assert_eq!(rng.state, expected_state);","}"],[112,113,114,115,116,117,118]],[["{","    // Initialize the struct with zero increment","    let mut rng = Lcg128CmDxsm64::new(5, 0);","    ","    // Store the initial state","    let initial_state = rng.state;","    ","    // Call the step method","    rng.step();","    ","    // Calculate the expected state","    let expected_state = initial_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(0);","    ","    // Assert that the state after stepping matches the expected state","    assert_eq!(rng.state, expected_state);","}"],[112,113,114,115,116,117,118]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Initialize the Lcg128CmDxsm64 struct","    let mut rng = Lcg128CmDxsm64::new(1, 2);","    ","    // Store the initial state","    let initial_state = rng.state;","    ","    // Call the step method","    rng.step();","    ","    // Calculate the expected state","    let expected_state = initial_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(rng.increment);","    ","    // Assert that the state after stepping matches the expected state","    assert_eq!(rng.state, expected_state);","}"],[]],[["{","    // Initialize the struct with large values","    let mut rng = Lcg128CmDxsm64::new(u128::MAX - 1, u128::MAX - 2);","    ","    // Store the initial state","    let initial_state = rng.state;","    ","    // Call the step method","    rng.step();","    ","    // Calculate the expected state","    let expected_state = initial_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(rng.increment);","    ","    // Assert that the state after stepping matches the expected state","    assert_eq!(rng.state, expected_state);","}"],[]],[["{","    // Initialize the struct with zero increment","    let mut rng = Lcg128CmDxsm64::new(5, 0);","    ","    // Store the initial state","    let initial_state = rng.state;","    ","    // Call the step method","    rng.step();","    ","    // Calculate the expected state","    let expected_state = initial_state.wrapping_mul(MULTIPLIER as u128).wrapping_add(0);","    ","    // Assert that the state after stepping matches the expected state","    assert_eq!(rng.state, expected_state);","}"],[]]]}