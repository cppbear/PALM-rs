{"function_name":"rand_pcg::pcg128cm::pcg128cm::Lcg128CmDxsm64::new","tests":2,"tests_lines":[28,28],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[96,97,98,99,100],"codes_lines_covered":[[["{","    struct Lcg128CmDxsm64 {","        state: u128,","        increment: u128,","    }","    ","    impl Lcg128CmDxsm64 {","        pub fn new(state: u128, stream: u128) -> Self {","            let increment = (stream << 1) | 1;","            Self::from_state_incr(state, increment)","        }","        ","        fn from_state_incr(state: u128, increment: u128) -> Self {","            let mut pcg = Self { state, increment };","            pcg.state = pcg.state.wrapping_add(pcg.increment);","            pcg.step();","            pcg","        }","        ","        fn step(&mut self) {}","    }","","    let state = 0xcafef00dd15ea5e5;","    let stream = 0xa02bdbf7bb3c0a7ac28fa16a64abf96;","","    let pcg = Lcg128CmDxsm64::new(state, stream);","    assert_eq!(pcg.state, state.wrapping_add((stream << 1) | 1));","}"],[]],[["{","    struct Lcg128CmDxsm64 {","        state: u128,","        increment: u128,","    }","    ","    impl Lcg128CmDxsm64 {","        pub fn new(state: u128, stream: u128) -> Self {","            let increment = (stream << 1) | 1;","            Self::from_state_incr(state, increment)","        }","        ","        fn from_state_incr(state: u128, increment: u128) -> Self {","            let mut pcg = Self { state, increment };","            pcg.state = pcg.state.wrapping_add(pcg.increment);","            pcg.step();","            pcg","        }","        ","        fn step(&mut self) {}","    }","","    let state = u128::MAX;","    let stream = u128::MAX;","","    let pcg = Lcg128CmDxsm64::new(state, stream);","    assert_eq!(pcg.state, state.wrapping_add((stream << 1) | 1));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Lcg128CmDxsm64 {","        state: u128,","        increment: u128,","    }","    ","    impl Lcg128CmDxsm64 {","        pub fn new(state: u128, stream: u128) -> Self {","            let increment = (stream << 1) | 1;","            Self::from_state_incr(state, increment)","        }","        ","        fn from_state_incr(state: u128, increment: u128) -> Self {","            let mut pcg = Self { state, increment };","            pcg.state = pcg.state.wrapping_add(pcg.increment);","            pcg.step();","            pcg","        }","        ","        fn step(&mut self) {}","    }","","    let state = 0xcafef00dd15ea5e5;","    let stream = 0xa02bdbf7bb3c0a7ac28fa16a64abf96;","","    let pcg = Lcg128CmDxsm64::new(state, stream);","    assert_eq!(pcg.state, state.wrapping_add((stream << 1) | 1));","}"],[]],[["{","    struct Lcg128CmDxsm64 {","        state: u128,","        increment: u128,","    }","    ","    impl Lcg128CmDxsm64 {","        pub fn new(state: u128, stream: u128) -> Self {","            let increment = (stream << 1) | 1;","            Self::from_state_incr(state, increment)","        }","        ","        fn from_state_incr(state: u128, increment: u128) -> Self {","            let mut pcg = Self { state, increment };","            pcg.state = pcg.state.wrapping_add(pcg.increment);","            pcg.step();","            pcg","        }","        ","        fn step(&mut self) {}","    }","","    let state = u128::MAX;","    let stream = u128::MAX;","","    let pcg = Lcg128CmDxsm64::new(state, stream);","    assert_eq!(pcg.state, state.wrapping_add((stream << 1) | 1));","}"],[]]]}