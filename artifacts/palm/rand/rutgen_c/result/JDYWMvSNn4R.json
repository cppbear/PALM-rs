{"function_name":"rand_core::block::<block::BlockRng64<R> as RngCore>::next_u32","tests":1,"tests_lines":[33],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":16,"lines_covered":11,"lines_coveraged_rate":68.75,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[350,351,352,353,354,355,356,357,358,360,361,362,363,364,365,366],"codes_lines_covered":[[["{","    struct TestCore {","        count: usize,","        results: Vec<u64>,","    }","    ","    impl BlockRngCore for TestCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            for _ in 0..2 {","                results.push(self.count as u64);","                self.count += 1;","            }","        }","    }","","    let core = TestCore { count: 0, results: vec![] };","    let mut rng = BlockRng64 {","        results: vec![0, 0],","        index: 0,","        half_used: false,","        core,","    };","","    assert_eq!(rng.next_u32(), 0); // First call, first half of results[0]: 0","    assert_eq!(rng.next_u32(), 0); // Second call, second half of results[0]: 0","    assert_eq!(rng.next_u32(), 1); // Third call, first half of results[1]: 1","    assert_eq!(rng.next_u32(), 1); // Fourth call, second half of results[1]: 1","    assert_eq!(rng.next_u32(), 2); // Fifth call, results need to be regenerated","}"],[350,351,352,358,360,361,362,363,364,365,366]]],"codes_branches":[{"start_line":352,"start_column":12,"end_line":352,"end_column":48,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    struct TestCore {","        count: usize,","        results: Vec<u64>,","    }","    ","    impl BlockRngCore for TestCore {","        type Item = u64;","        type Results = Vec<u64>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.clear();","            for _ in 0..2 {","                results.push(self.count as u64);","                self.count += 1;","            }","        }","    }","","    let core = TestCore { count: 0, results: vec![] };","    let mut rng = BlockRng64 {","        results: vec![0, 0],","        index: 0,","        half_used: false,","        core,","    };","","    assert_eq!(rng.next_u32(), 0); // First call, first half of results[0]: 0","    assert_eq!(rng.next_u32(), 0); // Second call, second half of results[0]: 0","    assert_eq!(rng.next_u32(), 1); // Third call, first half of results[1]: 1","    assert_eq!(rng.next_u32(), 1); // Fourth call, second half of results[1]: 1","    assert_eq!(rng.next_u32(), 2); // Fifth call, results need to be regenerated","}"],[{"start_line":352,"start_column":12,"end_line":352,"end_column":48,"positive":false,"negative":true}]]]}