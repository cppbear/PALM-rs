{"function_name":"rand::distr::weighted::weighted_index::distr::weighted::weighted_index::WeightedIndex<X>::weight","tests":2,"tests_lines":[38,36],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":13,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[308,309,310,311,314,315,316,317,320,321,322,323,324],"codes_lines_covered":[[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        fn new(weights: &[u32]) -> Option<Self> {","            let cumulative_weights: Vec<u32> = weights.iter().scan(0, |sum, &weight| {","                *sum += weight;","                Some(*sum)","            }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(WeightedIndex { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2];","    let dist = WeightedIndex::new(&weights).unwrap();","    assert_eq!(dist.weight(0), Some(0));","    assert_eq!(dist.weight(1), Some(1));","    assert_eq!(dist.weight(2), Some(2));","}"],[]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        fn new(weights: &[u32]) -> Option<Self> {","            let cumulative_weights: Vec<u32> = weights.iter().scan(0, |sum, &weight| {","                *sum += weight;","                Some(*sum)","            }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(WeightedIndex { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [1, 2, 3];","    let dist = WeightedIndex::new(&weights).unwrap();","    assert_eq!(dist.weight(3), None);","}"],[]]],"codes_branches":[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        fn new(weights: &[u32]) -> Option<Self> {","            let cumulative_weights: Vec<u32> = weights.iter().scan(0, |sum, &weight| {","                *sum += weight;","                Some(*sum)","            }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(WeightedIndex { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [0, 1, 2];","    let dist = WeightedIndex::new(&weights).unwrap();","    assert_eq!(dist.weight(0), Some(0));","    assert_eq!(dist.weight(1), Some(1));","    assert_eq!(dist.weight(2), Some(2));","}"],[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}]],[["{","    struct WeightedIndex {","        cumulative_weights: Vec<u32>,","        total_weight: u32,","    }","","    impl WeightedIndex {","        fn new(weights: &[u32]) -> Option<Self> {","            let cumulative_weights: Vec<u32> = weights.iter().scan(0, |sum, &weight| {","                *sum += weight;","                Some(*sum)","            }).collect();","            let total_weight = cumulative_weights.last().cloned().unwrap_or(0);","            Some(WeightedIndex { cumulative_weights, total_weight })","        }","","        pub fn weight(&self, index: usize) -> Option<u32> {","            use core::cmp::Ordering::*;","","            let mut weight = match index.cmp(&self.cumulative_weights.len()) {","                Less => self.cumulative_weights[index].clone(),","                Equal => self.total_weight.clone(),","                Greater => return None,","            };","","            if index > 0 {","                weight -= &self.cumulative_weights[index - 1];","            }","            Some(weight)","        }","    }","","    let weights = [1, 2, 3];","    let dist = WeightedIndex::new(&weights).unwrap();","    assert_eq!(dist.weight(3), None);","}"],[{"start_line":320,"start_column":12,"end_line":320,"end_column":21,"positive":false,"negative":false}]]]}