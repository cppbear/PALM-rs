{"function_name":"rand::rngs::thread::<rngs::thread::ThreadRng as rand_core::RngCore>::next_u64","tests":2,"tests_lines":[39,41],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[178,179,180,181,182,183],"codes_lines_covered":[[["{","    struct MockRng {","        value: u64,","    }","","    impl MockRng {","        fn new(value: u64) -> Self {","            MockRng { value }","        }","","        fn next_u64(&mut self) -> u64 {","            self.value += 1;","            self.value","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<MockRng>,","    }","","    impl ThreadRng {","        fn new(rng: MockRng) -> Self {","            ThreadRng {","                rng: std::cell::UnsafeCell::new(rng),","            }","        }","","        fn next_u64(&mut self) -> u64 {","            let rng = unsafe { &mut *self.rng.get() };","            rng.next_u64()","        }","    }","","    let mut thread_rng = ThreadRng::new(MockRng::new(0));","","    assert_eq!(thread_rng.next_u64(), 1);","    assert_eq!(thread_rng.next_u64(), 2);","    assert_eq!(thread_rng.next_u64(), 3);","}"],[]],[["{","    struct MockRng {","        value: u64,","    }","","    impl MockRng {","        fn new(value: u64) -> Self {","            MockRng { value }","        }","","        fn next_u64(&mut self) -> u64 {","            self.value += 1;","            self.value","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<MockRng>,","    }","","    impl ThreadRng {","        fn new(rng: MockRng) -> Self {","            ThreadRng {","                rng: std::cell::UnsafeCell::new(rng),","            }","        }","","        fn next_u64(&mut self) -> u64 {","            let rng = unsafe { &mut *self.rng.get() };","            rng.next_u64()","        }","    }","","    let mut thread_rng = ThreadRng::new(MockRng::new(0));","    let _ = thread_rng.next_u64(); // Valid usage","    let _ = thread_rng.next_u64(); // Valid usage","","    // Simulate a panic condition by creating a second mutable reference","    let rng_ref = unsafe { &mut *thread_rng.rng.get() };","    let _ = rng_ref.next_u64(); // Though this code won't actually panic, it's meant to show misuse","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockRng {","        value: u64,","    }","","    impl MockRng {","        fn new(value: u64) -> Self {","            MockRng { value }","        }","","        fn next_u64(&mut self) -> u64 {","            self.value += 1;","            self.value","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<MockRng>,","    }","","    impl ThreadRng {","        fn new(rng: MockRng) -> Self {","            ThreadRng {","                rng: std::cell::UnsafeCell::new(rng),","            }","        }","","        fn next_u64(&mut self) -> u64 {","            let rng = unsafe { &mut *self.rng.get() };","            rng.next_u64()","        }","    }","","    let mut thread_rng = ThreadRng::new(MockRng::new(0));","","    assert_eq!(thread_rng.next_u64(), 1);","    assert_eq!(thread_rng.next_u64(), 2);","    assert_eq!(thread_rng.next_u64(), 3);","}"],[]],[["{","    struct MockRng {","        value: u64,","    }","","    impl MockRng {","        fn new(value: u64) -> Self {","            MockRng { value }","        }","","        fn next_u64(&mut self) -> u64 {","            self.value += 1;","            self.value","        }","    }","","    struct ThreadRng {","        rng: std::cell::UnsafeCell<MockRng>,","    }","","    impl ThreadRng {","        fn new(rng: MockRng) -> Self {","            ThreadRng {","                rng: std::cell::UnsafeCell::new(rng),","            }","        }","","        fn next_u64(&mut self) -> u64 {","            let rng = unsafe { &mut *self.rng.get() };","            rng.next_u64()","        }","    }","","    let mut thread_rng = ThreadRng::new(MockRng::new(0));","    let _ = thread_rng.next_u64(); // Valid usage","    let _ = thread_rng.next_u64(); // Valid usage","","    // Simulate a panic condition by creating a second mutable reference","    let rng_ref = unsafe { &mut *thread_rng.rng.get() };","    let _ = rng_ref.next_u64(); // Though this code won't actually panic, it's meant to show misuse","}"],[]]]}