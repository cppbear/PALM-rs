{"function_name":"rand_core::<UnwrapErr<R> as RngCore>::fill_bytes","tests":2,"tests_lines":[33,25],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[313,314,315],"codes_lines_covered":[[["{","    struct MockRng {","        data: &'static [u8],","        index: usize,","    }","    ","    impl TryRngCore for MockRng {","        type Error = &'static str;","        ","        fn try_next_u32(&mut self) -> Result<u32, Self::Error> {","            Ok(0) // Simplified mock response","        }","        ","        fn try_next_u64(&mut self) -> Result<u64, Self::Error> {","            Ok(0) // Simplified mock response","        }","        ","        fn try_fill_bytes(&mut self, dst: &mut [u8]) -> Result<(), Self::Error> {","            let to_copy = usize::min(dst.len(), self.data.len() - self.index);","            dst[..to_copy].copy_from_slice(&self.data[self.index..self.index + to_copy]);","            self.index += to_copy;","            Ok(())","        }","    }","","    let mut rng = MockRng { data: &[1, 2, 3, 4, 5], index: 0 };","    let mut buffer = [0u8; 3];","    let mut unwrap_err = UnwrapErr(rng);","","    unwrap_err.fill_bytes(&mut buffer);","    ","    assert_eq!(buffer, [1, 2, 3]);","}"],[313,314,315]],[["{","    struct FailingRng;","","    impl TryRngCore for FailingRng {","        type Error = &'static str;","","        fn try_next_u32(&mut self) -> Result<u32, Self::Error> {","            Ok(0) // Simplified mock response","        }","","        fn try_next_u64(&mut self) -> Result<u64, Self::Error> {","            Ok(0) // Simplified mock response","        }","","        fn try_fill_bytes(&mut self, _dst: &mut [u8]) -> Result<(), Self::Error> {","            Err(\"mock error\") // Intentionally returning an error to trigger panic","        }","    }","","    let failing_rng = FailingRng;","    let mut unwrap_err = UnwrapErr(failing_rng);","    let mut buffer = [0u8; 5];","","    unwrap_err.fill_bytes(&mut buffer); // This should panic","}"],[313,314,315]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockRng {","        data: &'static [u8],","        index: usize,","    }","    ","    impl TryRngCore for MockRng {","        type Error = &'static str;","        ","        fn try_next_u32(&mut self) -> Result<u32, Self::Error> {","            Ok(0) // Simplified mock response","        }","        ","        fn try_next_u64(&mut self) -> Result<u64, Self::Error> {","            Ok(0) // Simplified mock response","        }","        ","        fn try_fill_bytes(&mut self, dst: &mut [u8]) -> Result<(), Self::Error> {","            let to_copy = usize::min(dst.len(), self.data.len() - self.index);","            dst[..to_copy].copy_from_slice(&self.data[self.index..self.index + to_copy]);","            self.index += to_copy;","            Ok(())","        }","    }","","    let mut rng = MockRng { data: &[1, 2, 3, 4, 5], index: 0 };","    let mut buffer = [0u8; 3];","    let mut unwrap_err = UnwrapErr(rng);","","    unwrap_err.fill_bytes(&mut buffer);","    ","    assert_eq!(buffer, [1, 2, 3]);","}"],[]],[["{","    struct FailingRng;","","    impl TryRngCore for FailingRng {","        type Error = &'static str;","","        fn try_next_u32(&mut self) -> Result<u32, Self::Error> {","            Ok(0) // Simplified mock response","        }","","        fn try_next_u64(&mut self) -> Result<u64, Self::Error> {","            Ok(0) // Simplified mock response","        }","","        fn try_fill_bytes(&mut self, _dst: &mut [u8]) -> Result<(), Self::Error> {","            Err(\"mock error\") // Intentionally returning an error to trigger panic","        }","    }","","    let failing_rng = FailingRng;","    let mut unwrap_err = UnwrapErr(failing_rng);","    let mut buffer = [0u8; 5];","","    unwrap_err.fill_bytes(&mut buffer); // This should panic","}"],[]]]}