{"function_name":"rand_pcg::pcg128::<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u64","tests":4,"tests_lines":[5,5,7,6],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[146,147,148,149],"codes_lines_covered":[[["{","    let mut rng = Lcg128Xsl64::new(0, 1);","    let result = rng.next_u64();","    assert_eq!(result, 0); // Expecting the output of initial state to be 0","}"],[146,147,148,149]],[["{","    let mut rng = Lcg128Xsl64::new(u128::MAX, 1);","    let result = rng.next_u64();","    assert!(result > 0); // Large state should yield a non-zero output","}"],[146,147,148,149]],[["{","    let mut rng_a = Lcg128Xsl64::new(1234567890, 1);","    let mut rng_b = Lcg128Xsl64::new(1234567890, 2);","    let result_a = rng_a.next_u64();","    let result_b = rng_b.next_u64();","    assert_ne!(result_a, result_b); // Different increments should yield different outputs","}"],[146,147,148,149]],[["{","    let mut rng = Lcg128Xsl64::new(10, 1);","    rng.step(); // Call step explicitly to simulate precondition","    let result = rng.next_u64();","    assert!(result > 0); // Output should be greater than 0 after stepping","}"],[146,147,148,149]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut rng = Lcg128Xsl64::new(0, 1);","    let result = rng.next_u64();","    assert_eq!(result, 0); // Expecting the output of initial state to be 0","}"],[]],[["{","    let mut rng = Lcg128Xsl64::new(u128::MAX, 1);","    let result = rng.next_u64();","    assert!(result > 0); // Large state should yield a non-zero output","}"],[]],[["{","    let mut rng_a = Lcg128Xsl64::new(1234567890, 1);","    let mut rng_b = Lcg128Xsl64::new(1234567890, 2);","    let result_a = rng_a.next_u64();","    let result_b = rng_b.next_u64();","    assert_ne!(result_a, result_b); // Different increments should yield different outputs","}"],[]],[["{","    let mut rng = Lcg128Xsl64::new(10, 1);","    rng.step(); // Call step explicitly to simulate precondition","    let result = rng.next_u64();","    assert!(result > 0); // Output should be greater than 0 after stepping","}"],[]]]}