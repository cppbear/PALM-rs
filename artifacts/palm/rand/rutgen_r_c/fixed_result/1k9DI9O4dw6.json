{"function_name":"rand_pcg::pcg128::pcg128::Mcg128Xsl64::new","tests":5,"tests_lines":[5,5,5,5,5],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":5,"tests_passed":4,"tests_passed_rate":80.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[215,216,217,218],"codes_lines_covered":[[["{","    let state = 0;","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, 1); // 0 | 1 = 1","}"],[215,216,217,218]],[["{","    let state = 0xcafef00dd15ea5e5;","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, 0xcafef00dd15ea5e5 | 1); // Low bit forced to 1","}"],[215,216,217,218]],[["{","    let state = 0xffffffffffffffffffffffffffffffff;","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, 0xffffffffffffffffffffffffffffffff | 1); // Low bit remains 1","}"],[215,216,217,218]],[["{","    let state = u128::MAX; // This simulates -1 for u128","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, u128::MAX | 1); // Low bit remains 1","}"],[215,216,217,218]],[["{","    // There should be no invalid states for u128, so no specific test will panic.","    // Assuming panic would be from some invalid operation, here we won't trigger panic.","    Mcg128Xsl64::new(0); // This is to show it won't panic, so this function does not have a real panic test.","}"],[215,216,217,218]]],"codes_branches":[],"codes_branches_covered":[[["{","    let state = 0;","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, 1); // 0 | 1 = 1","}"],[]],[["{","    let state = 0xcafef00dd15ea5e5;","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, 0xcafef00dd15ea5e5 | 1); // Low bit forced to 1","}"],[]],[["{","    let state = 0xffffffffffffffffffffffffffffffff;","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, 0xffffffffffffffffffffffffffffffff | 1); // Low bit remains 1","}"],[]],[["{","    let state = u128::MAX; // This simulates -1 for u128","    let rng = Mcg128Xsl64::new(state);","    assert_eq!(rng.state, u128::MAX | 1); // Low bit remains 1","}"],[]],[["{","    // There should be no invalid states for u128, so no specific test will panic.","    // Assuming panic would be from some invalid operation, here we won't trigger panic.","    Mcg128Xsl64::new(0); // This is to show it won't panic, so this function does not have a real panic test.","}"],[]]]}