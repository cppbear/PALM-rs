{"function_name":"rand_pcg::pcg128::pcg128::Lcg128Xsl64::advance","tests":9,"tests_lines":[10,10,10,9,9,9,8,9,9],"oracles":9,"oracles_compiled":6,"oracles_compiled_rate":66.66666666666666,"tests_compiled":6,"tests_compiled_rate":66.66666666666666,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":16,"lines_covered":16,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77],"codes_lines_covered":[[["{","    let mut rng = Lcg128Xsl64::new(12345, 67890);","    let initial_state = rng.state;","","    // Positive delta, where mdelta should start as a positive number","    let delta: u128 = 3;","    rng.advance(delta);","    assert!(rng.state != initial_state, \"State should change with positive delta\");","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg128Xsl64::new(12345, 67890);","    let initial_state = rng.state;","","    // Delta is a power of two (should have mdelta & 1 == 0 in some steps)","    let delta: u128 = 4; // mdelta will reduce to 2, then 1, and finally 0","    rng.advance(delta);","    assert!(rng.state != initial_state, \"State should change with power of two delta\");","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg128Xsl64::new(12345, 67890);","    let initial_state = rng.state;","","    // Delta is zero (this should not change the state)","    let delta: u128 = 0; ","    rng.advance(delta);","    assert_eq!(rng.state, initial_state, \"State should remain unchanged with zero delta\");","}"],[60,61,62,63,64,65,67,76,77]],[["{","    let mut rng = Lcg128Xsl64::new(1, 1);","    let initial_state = rng.state;","","    rng.advance(0); // invoke advance with delta = 0","","    assert_eq!(rng.state, initial_state); // state should not change","}"],[60,61,62,63,64,65,67,76,77]],[["{","    let mut rng = Lcg128Xsl64::new(1, 1);","    let initial_state = rng.state;","","    rng.advance(u128::MAX); // invoke advance with the largest possible delta","","    // Check that the state changes, as we are moving forward by a large delta","    assert!(rng.state != initial_state);","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg128Xsl64::new(2, 3);","    let initial_state = rng.state;","","    rng.advance(1); // invoke advance with delta = 1","","    // Check that the state changes from the initial value","    assert!(rng.state != initial_state);","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]]],"codes_branches":[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut rng = Lcg128Xsl64::new(12345, 67890);","    let initial_state = rng.state;","","    // Positive delta, where mdelta should start as a positive number","    let delta: u128 = 3;","    rng.advance(delta);","    assert!(rng.state != initial_state, \"State should change with positive delta\");","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]],[["{","    let mut rng = Lcg128Xsl64::new(12345, 67890);","    let initial_state = rng.state;","","    // Delta is a power of two (should have mdelta & 1 == 0 in some steps)","    let delta: u128 = 4; // mdelta will reduce to 2, then 1, and finally 0","    rng.advance(delta);","    assert!(rng.state != initial_state, \"State should change with power of two delta\");","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":true}]],[["{","    let mut rng = Lcg128Xsl64::new(12345, 67890);","    let initial_state = rng.state;","","    // Delta is zero (this should not change the state)","    let delta: u128 = 0; ","    rng.advance(delta);","    assert_eq!(rng.state, initial_state, \"State should remain unchanged with zero delta\");","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Lcg128Xsl64::new(1, 1);","    let initial_state = rng.state;","","    rng.advance(0); // invoke advance with delta = 0","","    assert_eq!(rng.state, initial_state); // state should not change","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Lcg128Xsl64::new(1, 1);","    let initial_state = rng.state;","","    rng.advance(u128::MAX); // invoke advance with the largest possible delta","","    // Check that the state changes, as we are moving forward by a large delta","    assert!(rng.state != initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]],[["{","    let mut rng = Lcg128Xsl64::new(2, 3);","    let initial_state = rng.state;","","    rng.advance(1); // invoke advance with delta = 1","","    // Check that the state changes from the initial value","    assert!(rng.state != initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]]]}