{"function_name":"rand_pcg::pcg64::pcg64::Lcg64Xsh32::advance","tests":12,"tests_lines":[7,7,7,7,4,8,8,8,9,9,9,11],"oracles":12,"oracles_compiled":12,"oracles_compiled_rate":100.0,"tests_compiled":12,"tests_compiled_rate":100.0,"oracles_run":12,"oracles_passed":11,"oracles_passed_rate":91.66666666666666,"tests_run":12,"tests_passed":11,"tests_passed_rate":91.66666666666666,"lines":16,"lines_covered":16,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77],"codes_lines_covered":[[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(1);","    let new_state = rng.state;","    assert!(new_state != initial_state, \"State should change with positive delta\");","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(1000);","    let new_state = rng.state;","    assert!(new_state != initial_state, \"State should change with large delta\");","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(3);","    let new_state = rng.state;","    assert!(new_state != initial_state, \"State should change with odd delta\");","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(0); // This should not modify the state","    let new_state = rng.state;","    assert_eq!(new_state, initial_state, \"State should remain the same when delta is zero\");","}"],[60,61,62,63,64,65,67,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    rng.advance(u64::MAX); // Assuming this call would wrap around and be effectively negative, it should panic or have some edge behavior.","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1234567890, 1);","    let initial_state = rng.state;","","    rng.advance(10);","    // Verify that the state has changed after advancing","    assert!(rng.state != initial_state);","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1234567890, 1);","    let initial_state = rng.state;","","    rng.advance(8); // 8 is even, which means (mdelta & 1) != 0 is false","    // Verify that the state has changed after advancing","    assert!(rng.state != initial_state);","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1234567890, 1);","    let initial_state = rng.state;","","    rng.advance(0); // mdelta == 0","    // Verify that the state remains the same after advancing with delta 0","    assert_eq!(rng.state, initial_state);","}"],[60,61,62,63,64,65,67,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(42, 7);","    let initial_state = rng.state;","","    // Advance with delta = 0, state should remain the same","    rng.advance(0);","","    assert_eq!(rng.state, initial_state);","}"],[60,61,62,63,64,65,67,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(42, 7);","    let initial_state = rng.state;","","    // Advance with a small positive delta","    rng.advance(1);","","    assert!(rng.state != initial_state);","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(42, 7);","    let initial_state = rng.state;","","    // Advance with a large positive delta","    rng.advance(100);","","    assert!(rng.state != initial_state);","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]],[["{","    let mut rng = Lcg64Xsh32::new(1, 0);","    ","    // Test the smallest possible state transition with advance of 1","    rng.advance(1);","    let state_after_one = rng.state;","","    // Advance with another delta of 1 to test the state again","    rng.advance(1);","    assert!(rng.state != state_after_one);","}"],[60,61,62,63,64,65,67,68,69,70,71,72,73,74,76,77]]],"codes_branches":[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(1);","    let new_state = rng.state;","    assert!(new_state != initial_state, \"State should change with positive delta\");","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(1000);","    let new_state = rng.state;","    assert!(new_state != initial_state, \"State should change with large delta\");","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":true}]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(3);","    let new_state = rng.state;","    assert!(new_state != initial_state, \"State should change with odd delta\");","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    let initial_state = rng.state;","    rng.advance(0); // This should not modify the state","    let new_state = rng.state;","    assert_eq!(new_state, initial_state, \"State should remain the same when delta is zero\");","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Lcg64Xsh32::new(1, 1);","    rng.advance(u64::MAX); // Assuming this call would wrap around and be effectively negative, it should panic or have some edge behavior.","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]],[["{","    let mut rng = Lcg64Xsh32::new(1234567890, 1);","    let initial_state = rng.state;","","    rng.advance(10);","    // Verify that the state has changed after advancing","    assert!(rng.state != initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":true}]],[["{","    let mut rng = Lcg64Xsh32::new(1234567890, 1);","    let initial_state = rng.state;","","    rng.advance(8); // 8 is even, which means (mdelta & 1) != 0 is false","    // Verify that the state has changed after advancing","    assert!(rng.state != initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":true}]],[["{","    let mut rng = Lcg64Xsh32::new(1234567890, 1);","    let initial_state = rng.state;","","    rng.advance(0); // mdelta == 0","    // Verify that the state remains the same after advancing with delta 0","    assert_eq!(rng.state, initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Lcg64Xsh32::new(42, 7);","    let initial_state = rng.state;","","    // Advance with delta = 0, state should remain the same","    rng.advance(0);","","    assert_eq!(rng.state, initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":false,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":false,"negative":false}]],[["{","    let mut rng = Lcg64Xsh32::new(42, 7);","    let initial_state = rng.state;","","    // Advance with a small positive delta","    rng.advance(1);","","    assert!(rng.state != initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]],[["{","    let mut rng = Lcg64Xsh32::new(42, 7);","    let initial_state = rng.state;","","    // Advance with a large positive delta","    rng.advance(100);","","    assert!(rng.state != initial_state);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":true}]],[["{","    let mut rng = Lcg64Xsh32::new(1, 0);","    ","    // Test the smallest possible state transition with advance of 1","    rng.advance(1);","    let state_after_one = rng.state;","","    // Advance with another delta of 1 to test the state again","    rng.advance(1);","    assert!(rng.state != state_after_one);","}"],[{"start_line":67,"start_column":15,"end_line":67,"end_column":25,"positive":true,"negative":true},{"start_line":68,"start_column":16,"end_line":68,"end_column":33,"positive":true,"negative":false}]]]}