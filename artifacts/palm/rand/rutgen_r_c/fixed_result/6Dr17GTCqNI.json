{"function_name":"rand_core::impls::fill_via_chunks","tests":7,"tests_lines":[24,20,23,19,19,19,19],"oracles":7,"oracles_compiled":7,"oracles_compiled_rate":100.0,"tests_compiled":7,"tests_compiled_rate":100.0,"oracles_run":7,"oracles_passed":6,"oracles_passed_rate":85.71428571428571,"tests_run":7,"tests_passed":6,"tests_passed_rate":85.71428571428571,"lines":23,"lines_covered":23,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[78,79,80,81,82,83,84,85,86,87,88,89,90,91,93,94,95,96,97,98,99,100,101],"codes_lines_covered":[[["{","    #[derive(Copy, Clone)]","    struct TestData {","        value: u32,","    }","","    impl Observable for TestData {","        type Bytes = [u8; 4];","","        fn to_le_bytes(self) -> Self::Bytes {","            self.value.to_le_bytes()","        }","    }","","    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];","    let mut dest = [0u8; 10]; // Size enough to fill up to 2 complete chunks of 4 bytes (8 bytes total) plus some extra space.","","    let (n, byte_len) = fill_via_chunks(&src, &mut dest);","","    assert_eq!(n, 3); // 2 complete chunks + 1 partial","    assert_eq!(byte_len, 10); // 8 bytes filled from chunks + 2 bytes from the last element","    assert_eq!(&dest[..8], &[1u8, 0u8, 0u8, 0u8, 2u8, 0u8, 0u8, 0u8]); // Check first 8 bytes after first 2 full chunks","    assert_eq!(&dest[8..10], &[3u8, 0u8]); // Ensure last 2 bytes filled with part of the third element","}"],[78,79,80,81,82,83,84,85,86,87,88,89,90,91,93,94,95,96,97,101]],[["{","    #[derive(Copy, Clone)]","    struct TestData {","        value: u32,","    }","","    impl Observable for TestData {","        type Bytes = [u8; 4];","","        fn to_le_bytes(self) -> Self::Bytes {","            self.value.to_le_bytes()","        }","    }","","    let src = [TestData { value: 1 }, TestData { value: 2 }];","    let mut dest = [0u8; 3]; // Dest is too small to fit even one complete chunk of 4 bytes","","    // This should panic as dest is not large enough","    let _ = fill_via_chunks(&src, &mut dest);","}"],[78,79,80,81,82,83,84,85,86,87,88,89,90,91,93,94,95,96,97,101]],[["{","    #[derive(Copy, Clone)]","    struct TestData {","        value: u32,","    }","","    impl Observable for TestData {","        type Bytes = [u8; 4];","","        fn to_le_bytes(self) -> Self::Bytes {","            self.value.to_le_bytes()","        }","    }","","    let src = [TestData { value: 5 }, TestData { value: 6 }];","    let mut dest = [0u8; 8]; // Size equal to 2 complete chunks of 4 bytes each","","    let (n, byte_len) = fill_via_chunks(&src, &mut dest);","","    assert_eq!(n, 2); // 2 complete chunks filled","    assert_eq!(byte_len, 8); // Fully filled 8 bytes","    assert_eq!(&dest[..], &[5u8, 0u8, 0u8, 0u8, 6u8, 0u8, 0u8, 0u8]); // Ensure both elements are correctly filled","}"],[78,79,80,81,82,83,84,85,86,87,88,89,90,91,99,100,101]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1), TestType(2), TestType(3)];","    let mut dest = [0u8; 12];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 3);","    assert_eq!(byte_len, 12);","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]);","}"],[78,79,80,81,82,83,84,85,86,87,88,89,90,91,99,100,101]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1), TestType(2)];","    let mut dest = [0u8; 10];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 2);","    assert_eq!(byte_len, 8);","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 0, 0]);","}"],[78,79,80,81,82,83,84,85,86,87,88,89,90,91,99,100,101]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1)];","    let mut dest = [0u8; 4];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 1);","    assert_eq!(byte_len, 4);","    assert_eq!(&dest, &[1, 0, 0, 0]);","}"],[78,79,80,81,82,83,84,85,86,87,88,89,90,91,99,100,101]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1), TestType(2), TestType(3)];","    let mut dest = [0u8; 8];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 2);","    assert_eq!(byte_len, 8);","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0]);","}"],[78,79,80,81,82,83,84,85,86,87,88,89,90,91,93,94,95,98,100,101]]],"codes_branches":[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":true,"negative":true},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    #[derive(Copy, Clone)]","    struct TestData {","        value: u32,","    }","","    impl Observable for TestData {","        type Bytes = [u8; 4];","","        fn to_le_bytes(self) -> Self::Bytes {","            self.value.to_le_bytes()","        }","    }","","    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];","    let mut dest = [0u8; 10]; // Size enough to fill up to 2 complete chunks of 4 bytes (8 bytes total) plus some extra space.","","    let (n, byte_len) = fill_via_chunks(&src, &mut dest);","","    assert_eq!(n, 3); // 2 complete chunks + 1 partial","    assert_eq!(byte_len, 10); // 8 bytes filled from chunks + 2 bytes from the last element","    assert_eq!(&dest[..8], &[1u8, 0u8, 0u8, 0u8, 2u8, 0u8, 0u8, 0u8]); // Check first 8 bytes after first 2 full chunks","    assert_eq!(&dest[8..10], &[3u8, 0u8]); // Ensure last 2 bytes filled with part of the third element","}"],[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":true,"negative":false},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":true,"negative":false}]],[["{","    #[derive(Copy, Clone)]","    struct TestData {","        value: u32,","    }","","    impl Observable for TestData {","        type Bytes = [u8; 4];","","        fn to_le_bytes(self) -> Self::Bytes {","            self.value.to_le_bytes()","        }","    }","","    let src = [TestData { value: 1 }, TestData { value: 2 }];","    let mut dest = [0u8; 3]; // Dest is too small to fit even one complete chunk of 4 bytes","","    // This should panic as dest is not large enough","    let _ = fill_via_chunks(&src, &mut dest);","}"],[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":true,"negative":false},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":true,"negative":false}]],[["{","    #[derive(Copy, Clone)]","    struct TestData {","        value: u32,","    }","","    impl Observable for TestData {","        type Bytes = [u8; 4];","","        fn to_le_bytes(self) -> Self::Bytes {","            self.value.to_le_bytes()","        }","    }","","    let src = [TestData { value: 5 }, TestData { value: 6 }];","    let mut dest = [0u8; 8]; // Size equal to 2 complete chunks of 4 bytes each","","    let (n, byte_len) = fill_via_chunks(&src, &mut dest);","","    assert_eq!(n, 2); // 2 complete chunks filled","    assert_eq!(byte_len, 8); // Fully filled 8 bytes","    assert_eq!(&dest[..], &[5u8, 0u8, 0u8, 0u8, 6u8, 0u8, 0u8, 0u8]); // Ensure both elements are correctly filled","}"],[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":false,"negative":true},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":false,"negative":false}]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1), TestType(2), TestType(3)];","    let mut dest = [0u8; 12];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 3);","    assert_eq!(byte_len, 12);","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]);","}"],[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":false,"negative":true},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":false,"negative":false}]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1), TestType(2)];","    let mut dest = [0u8; 10];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 2);","    assert_eq!(byte_len, 8);","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 0, 0]);","}"],[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":false,"negative":true},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":false,"negative":false}]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1)];","    let mut dest = [0u8; 4];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 1);","    assert_eq!(byte_len, 4);","    assert_eq!(&dest, &[1, 0, 0, 0]);","}"],[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":false,"negative":true},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":false,"negative":false}]],[["{","#[derive(Copy, Clone)]","struct TestType(u32);","","impl Observable for TestType {","    type Bytes = [u8; 4];","    ","    fn to_le_bytes(self) -> Self::Bytes {","        self.0.to_le_bytes()","    }","}","    let src = [TestType(1), TestType(2), TestType(3)];","    let mut dest = [0u8; 8];","    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);","    ","    assert_eq!(num_chunks, 2);","    assert_eq!(byte_len, 8);","    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0]);","}"],[{"start_line":91,"start_column":12,"end_line":91,"end_column":21,"positive":true,"negative":false},{"start_line":95,"start_column":12,"end_line":95,"end_column":17,"positive":false,"negative":true}]]]}