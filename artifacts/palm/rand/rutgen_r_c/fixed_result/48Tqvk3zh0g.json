{"function_name":"rand_pcg::pcg128::<pcg128::Lcg128Xsl64 as rand_core::RngCore>::next_u32","tests":1,"tests_lines":[43],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[141,142,143],"codes_lines_covered":[[["{","    struct TestRng {","        state: u128,","        increment: u128,","    }","","    impl RngCore for TestRng {","        #[inline]","        fn next_u32(&mut self) -> u32 {","            self.next_u64() as u32","        }","        ","        #[inline]","        fn next_u64(&mut self) -> u64 {","            self.state = self.state.wrapping_add(self.increment);","            (self.state >> 64) as u64 // Just a simple transformation for testing","        }","        ","        #[inline]","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            for byte in dest.iter_mut() {","                *byte = (self.next_u64() & 0xFF) as u8;","            }","        }","    }","","    let mut rng = TestRng {","        state: 0,","        increment: 1,","    };","","    // Test basic functionality","    assert_eq!(rng.next_u32(), 0);","    rng.state = 1; // setting a new state","    assert_eq!(rng.next_u32(), 1);","    rng.state = 2; // setting a new state","    assert_eq!(rng.next_u32(), 2);","    ","    // Test boundary conditions","    rng.state = u128::MAX;","    let result = rng.next_u32();","    assert_eq!(result, ((u128::MAX.wrapping_add(1)) >> 64) as u32); // Expect a wrap around result","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestRng {","        state: u128,","        increment: u128,","    }","","    impl RngCore for TestRng {","        #[inline]","        fn next_u32(&mut self) -> u32 {","            self.next_u64() as u32","        }","        ","        #[inline]","        fn next_u64(&mut self) -> u64 {","            self.state = self.state.wrapping_add(self.increment);","            (self.state >> 64) as u64 // Just a simple transformation for testing","        }","        ","        #[inline]","        fn fill_bytes(&mut self, dest: &mut [u8]) {","            for byte in dest.iter_mut() {","                *byte = (self.next_u64() & 0xFF) as u8;","            }","        }","    }","","    let mut rng = TestRng {","        state: 0,","        increment: 1,","    };","","    // Test basic functionality","    assert_eq!(rng.next_u32(), 0);","    rng.state = 1; // setting a new state","    assert_eq!(rng.next_u32(), 1);","    rng.state = 2; // setting a new state","    assert_eq!(rng.next_u32(), 2);","    ","    // Test boundary conditions","    rng.state = u128::MAX;","    let result = rng.next_u32();","    assert_eq!(result, ((u128::MAX.wrapping_add(1)) >> 64) as u32); // Expect a wrap around result","}"],[]]]}