{"function_name":"rand_core::block::<block::BlockRng<R> as RngCore>::next_u64","tests":8,"tests_lines":[29,29,32,29,27,27,33,33],"oracles":8,"oracles_compiled":8,"oracles_compiled_rate":100.0,"tests_compiled":8,"tests_compiled_rate":100.0,"oracles_run":8,"oracles_passed":1,"oracles_passed_rate":12.5,"tests_run":8,"tests_passed":1,"tests_passed_rate":12.5,"lines":20,"lines_covered":20,"lines_coveraged_rate":100.0,"branches":4,"branches_covered":4,"branches_coverage_rate":100.0,"codes_lines":[197,198,199,200,201,203,204,205,206,207,208,209,210,211,212,214,215,216,217,219],"codes_lines_covered":[[["{","    struct MockBlockRngCore {","        results: [u32; 4],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 4];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 0;","","    let result = block_rng.next_u64();","    assert_eq!(result, (2u64 << 32) | 1u64); // Expected result for results: [1, 2, 3, 4]","}"],[197,198,199,200,201,203,204,205,206,207,208,209,219]],[["{","    struct MockBlockRngCore {","        results: [u32; 3],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [10, 20, 30],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 1; // Here index < len - 1 is true","","    let result = block_rng.next_u64();","    assert_eq!(result, (30u64 << 32) | 20u64); // Expected result for results: [10, 20, 30]","}"],[197,198,199,200,201,203,204,205,206,207,208,209,219]],[["{","    struct MockBlockRngCore {","        results: [u32; 5],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [5, 10, 15, 20, 25],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 3; // Here index < len - 1 is false, but we'll test the wraparound","","    let result = block_rng.next_u64();","    assert_eq!(result, (25u64 << 32) | 20u64); // Expected result for results: [5, 10, 15, 20, 25]","    ","    // After this execution, index should wrap around","    assert_eq!(block_rng.index, 1);","}"],[197,198,199,200,201,203,204,205,206,207,208,209,219]],[["{","    struct MockBlockRngCore {","        results: [u32; 2],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [100, 200],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 0; // Here index < len - 1 is true","","    let result = block_rng.next_u64();","    assert_eq!(result, (200u64 << 32) | 100u64); // Expected result for results: [100, 200]","}"],[197,198,199,200,201,203,204,205,206,207,208,209,219]],[["{","    struct TestBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl Default for TestBlockRngCore {","        fn default() -> Self {","            TestBlockRngCore { results: vec![1, 2, 3, 4] } // len is 4","        }","    }","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let mut core = TestBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    ","    block_rng.index = 3; // len - 1","    let result = block_rng.next_u64();","    assert_eq!(result, ((2u64 << 32) | 1u64)); // Expecting (2 << 32) | 1","}"],[197,198,203,204,205,206,210]],[["{","    struct TestBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl Default for TestBlockRngCore {","        fn default() -> Self {","            TestBlockRngCore { results: vec![1, 2, 3, 4] } // len is 4","        }","    }","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let mut core = TestBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","","    block_rng.index = 4; // len","    let result = block_rng.next_u64();","    assert_eq!(result, ((4u64 << 32) | 3u64)); // Expecting (3 << 32) | 4","}"],[197,198,203,204,205,206,210]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            MockBlockRngCore {","                results: vec![1, 2, 3, 4], // Example content","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng {","        results: vec![0; 4], // Must match MockBlockRngCore results length","        index: 3, // Set index to len - 1","        core,","    };","","    let result = block_rng.next_u64();","","    assert_eq!(result, (2u64 << 32) | 1u64); // Should return (y << 32) | x","}"],[197,198,203,204,205,206,210,214,215,216,217,219]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            MockBlockRngCore {","                results: vec![1, 2, 3, 4], // Example content","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng {","        results: vec![0; 4], // Must match MockBlockRngCore results length","        index: 4, // Set index to len, which will trigger a generate_and_set","        core,","    };","","    let result = block_rng.next_u64();","","    assert_eq!(result, (2u64 << 32) | 1u64); // Should return (y << 32) | x after generating","}"],[197,198,199,200,201,203,204,205,206,210,211,212,219]]],"codes_branches":[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":true,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    struct MockBlockRngCore {","        results: [u32; 4],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [1, 2, 3, 4],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 4];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 0;","","    let result = block_rng.next_u64();","    assert_eq!(result, (2u64 << 32) | 1u64); // Expected result for results: [1, 2, 3, 4]","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":true,"negative":false},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct MockBlockRngCore {","        results: [u32; 3],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [10, 20, 30],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 3];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 1; // Here index < len - 1 is true","","    let result = block_rng.next_u64();","    assert_eq!(result, (30u64 << 32) | 20u64); // Expected result for results: [10, 20, 30]","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":true,"negative":false},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct MockBlockRngCore {","        results: [u32; 5],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [5, 10, 15, 20, 25],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 5];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 3; // Here index < len - 1 is false, but we'll test the wraparound","","    let result = block_rng.next_u64();","    assert_eq!(result, (25u64 << 32) | 20u64); // Expected result for results: [5, 10, 15, 20, 25]","    ","    // After this execution, index should wrap around","    assert_eq!(block_rng.index, 1);","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":true,"negative":false},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct MockBlockRngCore {","        results: [u32; 2],","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            Self {","                results: [100, 200],","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = [u32; 2];","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    block_rng.index = 0; // Here index < len - 1 is true","","    let result = block_rng.next_u64();","    assert_eq!(result, (200u64 << 32) | 100u64); // Expected result for results: [100, 200]","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":true,"negative":false},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct TestBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl Default for TestBlockRngCore {","        fn default() -> Self {","            TestBlockRngCore { results: vec![1, 2, 3, 4] } // len is 4","        }","    }","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let mut core = TestBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","    ","    block_rng.index = 3; // len - 1","    let result = block_rng.next_u64();","    assert_eq!(result, ((2u64 << 32) | 1u64)); // Expecting (2 << 32) | 1","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct TestBlockRngCore {","        results: Vec<u32>,","    }","    ","    impl Default for TestBlockRngCore {","        fn default() -> Self {","            TestBlockRngCore { results: vec![1, 2, 3, 4] } // len is 4","        }","    }","    ","    impl BlockRngCore for TestBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let mut core = TestBlockRngCore::default();","    let mut block_rng = BlockRng::new(core);","","    block_rng.index = 4; // len","    let result = block_rng.next_u64();","    assert_eq!(result, ((4u64 << 32) | 3u64)); // Expecting (3 << 32) | 4","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":false}]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            MockBlockRngCore {","                results: vec![1, 2, 3, 4], // Example content","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng {","        results: vec![0; 4], // Must match MockBlockRngCore results length","        index: 3, // Set index to len - 1","        core,","    };","","    let result = block_rng.next_u64();","","    assert_eq!(result, (2u64 << 32) | 1u64); // Should return (y << 32) | x","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":false,"negative":true}]],[["{","    struct MockBlockRngCore {","        results: Vec<u32>,","    }","","    impl Default for MockBlockRngCore {","        fn default() -> Self {","            MockBlockRngCore {","                results: vec![1, 2, 3, 4], // Example content","            }","        }","    }","","    impl BlockRngCore for MockBlockRngCore {","        type Item = u32;","        type Results = Vec<u32>;","","        fn generate(&mut self, results: &mut Self::Results) {","            results.copy_from_slice(&self.results);","        }","    }","","    let core = MockBlockRngCore::default();","    let mut block_rng = BlockRng {","        results: vec![0; 4], // Must match MockBlockRngCore results length","        index: 4, // Set index to len, which will trigger a generate_and_set","        core,","    };","","    let result = block_rng.next_u64();","","    assert_eq!(result, (2u64 << 32) | 1u64); // Should return (y << 32) | x after generating","}"],[{"start_line":206,"start_column":12,"end_line":206,"end_column":27,"positive":false,"negative":true},{"start_line":210,"start_column":19,"end_line":210,"end_column":31,"positive":true,"negative":false}]]]}