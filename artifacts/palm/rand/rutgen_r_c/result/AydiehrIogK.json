{"function_name":"rand::rngs::xoshiro256plusplus::<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::RngCore>::next_u32","tests":1,"tests_lines":[48],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[70,71,72,73,74,75],"codes_lines_covered":[[["{","    struct TestRng {","        s: [u64; 4],","    }","","    impl RngCore for TestRng {","        fn next_u32(&mut self) -> u32 {","            let val = self.next_u64();","            (val >> 32) as u32","        }","","        fn next_u64(&mut self) -> u64 {","            let res = self","                .s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","            let t = self.s[1] << 17;","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","            self.s[2] ^= t;","            self.s[3] = self.s[3].rotate_left(45);","            res","        }","","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    let mut rng = TestRng { s: [1, 2, 3, 4] };","","    // Calling next_u32 to check expected behavior","    let output = rng.next_u32();","    assert_eq!(output, 0); // Assuming the initial seed results in next_u64 producing a value lower than 2^32","","    rng.s = [0, 0, 0, 0];","    let output_zero_seed = rng.next_u32();","    assert_eq!(output_zero_seed, 0); // All zeros should also result in 0","","    rng.s = [u64::MAX, u64::MAX, u64::MAX, u64::MAX];","    let output_max_seed = rng.next_u32();","    assert!(output_max_seed > u32::MAX); // Expect non-zero and greater than maximum u32","    ","    rng.s = [0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF_FFFF_FFFF];","    let output_boundary_case = rng.next_u32();","    assert!(output_boundary_case == u32::MAX); // Should hit the maximum boundary case","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestRng {","        s: [u64; 4],","    }","","    impl RngCore for TestRng {","        fn next_u32(&mut self) -> u32 {","            let val = self.next_u64();","            (val >> 32) as u32","        }","","        fn next_u64(&mut self) -> u64 {","            let res = self","                .s[0]","                .wrapping_add(self.s[3])","                .rotate_left(23)","                .wrapping_add(self.s[0]);","            let t = self.s[1] << 17;","            self.s[2] ^= self.s[0];","            self.s[3] ^= self.s[1];","            self.s[1] ^= self.s[2];","            self.s[0] ^= self.s[3];","            self.s[2] ^= t;","            self.s[3] = self.s[3].rotate_left(45);","            res","        }","","        fn fill_bytes(&mut self, _dst: &mut [u8]) {}","    }","","    let mut rng = TestRng { s: [1, 2, 3, 4] };","","    // Calling next_u32 to check expected behavior","    let output = rng.next_u32();","    assert_eq!(output, 0); // Assuming the initial seed results in next_u64 producing a value lower than 2^32","","    rng.s = [0, 0, 0, 0];","    let output_zero_seed = rng.next_u32();","    assert_eq!(output_zero_seed, 0); // All zeros should also result in 0","","    rng.s = [u64::MAX, u64::MAX, u64::MAX, u64::MAX];","    let output_max_seed = rng.next_u32();","    assert!(output_max_seed > u32::MAX); // Expect non-zero and greater than maximum u32","    ","    rng.s = [0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF_FFFF_FFFF];","    let output_boundary_case = rng.next_u32();","    assert!(output_boundary_case == u32::MAX); // Should hit the maximum boundary case","}"],[]]]}