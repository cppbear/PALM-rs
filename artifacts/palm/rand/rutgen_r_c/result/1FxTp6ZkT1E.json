{"function_name":"rand_pcg::pcg64::<pcg64::Lcg64Xsh32 as rand_core::RngCore>::next_u64","tests":4,"tests_lines":[21,21,21,22],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":4,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[156,157,158],"codes_lines_covered":[[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    let mut rng = TestRng::new(1, 1);","    let result = rng.next_u64();","    assert_eq!(result, 0xF57CEBF84BDC739F); // Expected output based on the initial state","}"],[156,157,158]],[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    let mut rng = TestRng::new(u64::MAX, 1);","    let result = rng.next_u64();","    assert_eq!(result, 0xE68F107B6B4C7916); // Expected output based on the large state","}"],[156,157,158]],[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    let mut rng = TestRng::new(0, 0);","    let result = rng.next_u64();","    assert_eq!(result, 0x310A472E4B06DB5B); // Expected output for zero state","}"],[156,157,158]],[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    // Assuming a scenario that would trigger panic, although specifics are not provided.","    // Here, we create an invalid state example.","    let mut rng = TestRng::new(u64::MAX, u64::MAX);","    rng.next_u64(); // This is where we anticipate a panic","}"],[156,157,158]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    let mut rng = TestRng::new(1, 1);","    let result = rng.next_u64();","    assert_eq!(result, 0xF57CEBF84BDC739F); // Expected output based on the initial state","}"],[]],[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    let mut rng = TestRng::new(u64::MAX, 1);","    let result = rng.next_u64();","    assert_eq!(result, 0xE68F107B6B4C7916); // Expected output based on the large state","}"],[]],[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    let mut rng = TestRng::new(0, 0);","    let result = rng.next_u64();","    assert_eq!(result, 0x310A472E4B06DB5B); // Expected output for zero state","}"],[]],[["{","    struct TestRng {","        inner: Lcg64Xsh32,","    }","","    impl TestRng {","        fn new(state: u64, increment: u64) -> Self {","            TestRng {","                inner: Lcg64Xsh32 { state, increment },","            }","        }","","        fn next_u64(&mut self) -> u64 {","            self.inner.next_u64()","        }","    }","","    // Assuming a scenario that would trigger panic, although specifics are not provided.","    // Here, we create an invalid state example.","    let mut rng = TestRng::new(u64::MAX, u64::MAX);","    rng.next_u64(); // This is where we anticipate a panic","}"],[]]]}