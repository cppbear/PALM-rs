{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// rand_chacha/src/chacha.rs\n// crate name is rand_chacha\nuse crate::guts::ChaCha;\nuse core::fmt;\nuse rand_core::block::{BlockRng, BlockRngCore, CryptoBlockRng};\nuse rand_core::{CryptoRng, RngCore, SeedableRng};\n#[cfg(feature = \"serde\")]\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\nconst BUF_BLOCKS: u8 = 4;\nconst BLOCK_WORDS: u8 = 16;\nmacro_rules! chacha_impl {\n    ($ChaChaXCore:ident, $ChaChaXRng:ident, $rounds:expr, $doc:expr, $abst:ident,) => {\n        #[doc =$doc] #[derive(Clone, PartialEq, Eq)] pub struct $ChaChaXCore { state :\n        ChaCha, } impl fmt::Debug for $ChaChaXCore { fn fmt(& self, f : & mut\n        fmt::Formatter) -> fmt::Result { write!(f, \"ChaChaXCore {{}}\") } } impl\n        BlockRngCore for $ChaChaXCore { type Item = u32; type Results = Array64 < u32 >;\n        #[inline] fn generate(& mut self, r : & mut Self::Results) { self.state\n        .refill4($rounds, & mut r.0); } } impl SeedableRng for $ChaChaXCore { type Seed =\n        [u8; 32]; #[inline] fn from_seed(seed : Self::Seed) -> Self { $ChaChaXCore {\n        state : ChaCha::new(& seed, & [0u8; 8]), } } } impl CryptoBlockRng for\n        $ChaChaXCore {} #[doc =\n        \" A cryptographically secure random number generator that uses the ChaCha algorithm.\"]\n        #[doc = \"\"] #[doc =\n        \" ChaCha is a stream cipher designed by Daniel J. Bernstein[^1], that we use as an RNG. It is\"]\n        #[doc =\n        \" an improved variant of the Salsa20 cipher family, which was selected as one of the \\\"stream\"]\n        #[doc = \" ciphers suitable for widespread adoption\\\" by eSTREAM[^2].\"] #[doc =\n        \"\"] #[doc =\n        \" ChaCha uses add-rotate-xor (ARX) operations as its basis. These are safe against timing\"]\n        #[doc =\n        \" attacks, although that is mostly a concern for ciphers and not for RNGs. We provide a SIMD\"]\n        #[doc =\n        \" implementation to support high throughput on a variety of common hardware platforms.\"]\n        #[doc = \"\"] #[doc =\n        \" With the ChaCha algorithm it is possible to choose the number of rounds the core algorithm\"]\n        #[doc =\n        \" should run. The number of rounds is a tradeoff between performance and security, where 8\"]\n        #[doc =\n        \" rounds is the minimum potentially secure configuration, and 20 rounds is widely used as a\"]\n        #[doc = \" conservative choice.\"] #[doc = \"\"] #[doc =\n        \" We use a 64-bit counter and 64-bit stream identifier as in Bernstein's implementation[^1]\"]\n        #[doc =\n        \" except that we use a stream identifier in place of a nonce. A 64-bit counter over 64-byte\"]\n        #[doc =\n        \" (16 word) blocks allows 1 ZiB of output before cycling, and the stream identifier allows\"]\n        #[doc =\n        \" 2<sup>64</sup> unique streams of output per seed. Both counter and stream are initialized\"]\n        #[doc =\n        \" to zero but may be set via the `set_word_pos` and `set_stream` methods.\"] #[doc\n        = \"\"] #[doc = \" The word layout is:\"] #[doc = \"\"] #[doc = \" ```text\"] #[doc =\n        \" constant  constant  constant  constant\"] #[doc =\n        \" seed      seed      seed      seed\"] #[doc =\n        \" seed      seed      seed      seed\"] #[doc =\n        \" counter   counter   stream_id stream_id\"] #[doc = \" ```\"] #[doc = \"\"] #[doc =\n        \" This implementation uses an output buffer of sixteen `u32` words, and uses\"]\n        #[doc = \" [`BlockRng`] to implement the [`RngCore`] methods.\"] #[doc = \"\"] #[doc\n        = \" [^1]: D. J. Bernstein, [*ChaCha, a variant of Salsa20*](\"] #[doc =\n        \"       https://cr.yp.to/chacha.html)\"] #[doc = \"\"] #[doc =\n        \" [^2]: [eSTREAM: the ECRYPT Stream Cipher Project](\"] #[doc =\n        \"       http://www.ecrypt.eu.org/stream/)\"] #[derive(Clone, Debug)] pub struct\n        $ChaChaXRng { rng : BlockRng <$ChaChaXCore >, } impl SeedableRng for $ChaChaXRng\n        { type Seed = [u8; 32]; #[inline] fn from_seed(seed : Self::Seed) -> Self { let\n        core = $ChaChaXCore ::from_seed(seed); Self { rng : BlockRng::new(core), } } }\n        impl RngCore for $ChaChaXRng { #[inline] fn next_u32(& mut self) -> u32 { self\n        .rng.next_u32() } #[inline] fn next_u64(& mut self) -> u64 { self.rng.next_u64()\n        } #[inline] fn fill_bytes(& mut self, bytes : & mut [u8]) { self.rng\n        .fill_bytes(bytes) } } impl $ChaChaXRng { #[doc =\n        \" Get the offset from the start of the stream, in 32-bit words.\"] #[doc = \"\"]\n        #[doc = \" Since the generated blocks are 16 words (2<sup>4</sup>) long and the\"]\n        #[doc =\n        \" counter is 64-bits, the offset is a 68-bit number. Sub-word offsets are\"] #[doc\n        = \" not supported, hence the result can simply be multiplied by 4 to get a\"]\n        #[doc = \" byte-offset.\"] #[inline] pub fn get_word_pos(& self) -> u128 { let\n        buf_start_block = { let buf_end_block = self.rng.core.state.get_block_pos();\n        u64::wrapping_sub(buf_end_block, BUF_BLOCKS.into()) }; let (buf_offset_blocks,\n        block_offset_words) = { let buf_offset_words = self.rng.index() as u64; let\n        blocks_part = buf_offset_words / u64::from(BLOCK_WORDS); let words_part =\n        buf_offset_words % u64::from(BLOCK_WORDS); (blocks_part, words_part) }; let\n        pos_block = u64::wrapping_add(buf_start_block, buf_offset_blocks); let\n        pos_block_words = u128::from(pos_block) * u128::from(BLOCK_WORDS);\n        pos_block_words + u128::from(block_offset_words) } #[doc =\n        \" Set the offset from the start of the stream, in 32-bit words.\"] #[doc = \"\"]\n        #[doc = \" As with `get_word_pos`, we use a 68-bit number. Since the generator\"]\n        #[doc = \" simply cycles at the end of its period (1 ZiB), we ignore the upper\"]\n        #[doc = \" 60 bits.\"] #[inline] pub fn set_word_pos(& mut self, word_offset :\n        u128) { let block = (word_offset / u128::from(BLOCK_WORDS)) as u64; self.rng.core\n        .state.set_block_pos(block); self.rng.generate_and_set((word_offset %\n        u128::from(BLOCK_WORDS)) as usize); } #[doc = \" Set the stream number.\"] #[doc =\n        \"\"] #[doc =\n        \" This is initialized to zero; 2<sup>64</sup> unique streams of output\"] #[doc =\n        \" are available per seed/key.\"] #[doc = \"\"] #[doc =\n        \" Note that in order to reproduce ChaCha output with a specific 64-bit\"] #[doc =\n        \" nonce, one can convert that nonce to a `u64` in little-endian fashion\"] #[doc =\n        \" and pass to this function. In theory a 96-bit nonce can be used by\"] #[doc =\n        \" passing the last 64-bits to this function and using the first 32-bits as\"]\n        #[doc = \" the most significant half of the 64-bit counter (which may be set\"]\n        #[doc = \" indirectly via `set_word_pos`), but this is not directly supported.\"]\n        #[inline] pub fn set_stream(& mut self, stream : u64) { self.rng.core.state\n        .set_nonce(stream); if self.rng.index() != 64 { let wp = self.get_word_pos();\n        self.set_word_pos(wp); } } #[doc = \" Get the stream number.\"] #[inline] pub fn\n        get_stream(& self) -> u64 { self.rng.core.state.get_nonce() } #[doc =\n        \" Get the seed.\"] #[inline] pub fn get_seed(& self) -> [u8; 32] { self.rng.core\n        .state.get_seed() } } impl CryptoRng for $ChaChaXRng {} impl From <$ChaChaXCore >\n        for $ChaChaXRng { fn from(core : $ChaChaXCore) -> Self { $ChaChaXRng { rng :\n        BlockRng::new(core), } } } impl PartialEq <$ChaChaXRng > for $ChaChaXRng { fn\n        eq(& self, rhs : &$ChaChaXRng) -> bool { let a : $abst ::$ChaChaXRng = self\n        .into(); let b : $abst ::$ChaChaXRng = rhs.into(); a == b } } impl Eq for\n        $ChaChaXRng {} #[cfg(feature = \"serde\")] impl Serialize for $ChaChaXRng { fn\n        serialize < S > (& self, s : S) -> Result < S::Ok, S::Error > where S :\n        Serializer, { $abst ::$ChaChaXRng ::from(self).serialize(s) } } #[cfg(feature =\n        \"serde\")] impl <'de > Deserialize <'de > for $ChaChaXRng { fn deserialize < D >\n        (d : D) -> Result < Self, D::Error > where D : Deserializer <'de >, { $abst\n        ::$ChaChaXRng ::deserialize(d).map(| x | Self::from(& x)) } } mod $abst {\n        #[cfg(feature = \"serde\")] use serde:: { Deserialize, Serialize }; #[derive(Debug,\n        PartialEq, Eq)] #[cfg_attr(feature = \"serde\", derive(Serialize, Deserialize))]\n        pub (crate) struct $ChaChaXRng { seed : [u8; 32], stream : u64, word_pos : u128,\n        } impl From <& super::$ChaChaXRng > for $ChaChaXRng { fn from(r : &\n        super::$ChaChaXRng) -> Self { Self { seed : r.get_seed(), stream : r\n        .get_stream(), word_pos : r.get_word_pos(), } } } impl From <&$ChaChaXRng > for\n        super::$ChaChaXRng { fn from(a : &$ChaChaXRng) -> Self { use\n        rand_core::SeedableRng; let mut r = Self::from_seed(a.seed); r.set_stream(a\n        .stream); r.set_word_pos(a.word_pos); r } } }\n    };\n}\nchacha_impl!(ChaCha20Core, ChaCha20Rng, 10, \"ChaCha with 20 rounds\", abstract20,);\nchacha_impl!(ChaCha12Core, ChaCha12Rng, 6, \"ChaCha with 12 rounds\", abstract12,);\nchacha_impl!(ChaCha8Core, ChaCha8Rng, 4, \"ChaCha with 8 rounds\", abstract8,);\n#[repr(transparent)]\npub struct Array64<T>([T; 64]);\nimpl<T> fmt::Debug for Array64<T> {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"Array64 {{}}\")\n    }\n}\n\nThe function to be tested is presented as follows:\nfn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n    write!(f, \"Array64 {{}}\")\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}