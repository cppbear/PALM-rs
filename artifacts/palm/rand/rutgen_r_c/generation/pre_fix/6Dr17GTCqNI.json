{
  "name": "rand_core::impls::fill_via_chunks",
  "name_with_impl": "rand_core::impls::fill_via_chunks",
  "mod_info": {
    "name": "impls",
    "loc": "rand_core/src/lib.rs:45:1:45:15"
  },
  "visible": true,
  "loc": "rand_core/src/impls.rs:78:1:101:2",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// may panic: dest.chunks_exact_mut(size) may panic in certain situations\n",
        "// constraint: let Some(src) = src.next() is true\n",
        "// constraint: n > 0 is true\n",
        "// may panic: src.to_le_bytes().as_ref()[..n] may panic in certain situations\n",
        "// may panic: dest.copy_from_slice(&src.to_le_bytes().as_ref()[..n]) may panic in certain situations\n",
        "// expected return value/type: (num_chunks + 1, byte_len + n)\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    #[derive(Copy, Clone)]",
                  "    struct TestData {",
                  "        value: u32,",
                  "    }",
                  "",
                  "    impl Observable for TestData {",
                  "        type Bytes = [u8; 4];",
                  "",
                  "        fn to_le_bytes(self) -> Self::Bytes {",
                  "            self.value.to_le_bytes()",
                  "        }",
                  "    }",
                  "",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }, TestData { value: 3 }];",
                  "    let mut dest = [0u8; 10]; // Size enough to fill up to 2 complete chunks of 4 bytes (8 bytes total) plus some extra space.",
                  "",
                  "    let (n, byte_len) = fill_via_chunks(&src, &mut dest);",
                  "",
                  "    assert_eq!(n, 3); // 2 complete chunks + 1 partial",
                  "    assert_eq!(byte_len, 10); // 8 bytes filled from chunks + 2 bytes from the last element",
                  "    assert_eq!(&dest[..8], &[1u8, 0u8, 0u8, 0u8, 2u8, 0u8, 0u8, 0u8]); // Check first 8 bytes after first 2 full chunks",
                  "    assert_eq!(&dest[8..10], &[3u8, 0u8]); // Ensure last 2 bytes filled with part of the third element",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    #[derive(Copy, Clone)]",
                  "    struct TestData {",
                  "        value: u32,",
                  "    }",
                  "",
                  "    impl Observable for TestData {",
                  "        type Bytes = [u8; 4];",
                  "",
                  "        fn to_le_bytes(self) -> Self::Bytes {",
                  "            self.value.to_le_bytes()",
                  "        }",
                  "    }",
                  "",
                  "    let src = [TestData { value: 1 }, TestData { value: 2 }];",
                  "    let mut dest = [0u8; 3]; // Dest is too small to fit even one complete chunk of 4 bytes",
                  "",
                  "    // This should panic as dest is not large enough",
                  "    let _ = fill_via_chunks(&src, &mut dest);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    #[derive(Copy, Clone)]",
                  "    struct TestData {",
                  "        value: u32,",
                  "    }",
                  "",
                  "    impl Observable for TestData {",
                  "        type Bytes = [u8; 4];",
                  "",
                  "        fn to_le_bytes(self) -> Self::Bytes {",
                  "            self.value.to_le_bytes()",
                  "        }",
                  "    }",
                  "",
                  "    let src = [TestData { value: 5 }, TestData { value: 6 }];",
                  "    let mut dest = [0u8; 8]; // Size equal to 2 complete chunks of 4 bytes each",
                  "",
                  "    let (n, byte_len) = fill_via_chunks(&src, &mut dest);",
                  "",
                  "    assert_eq!(n, 2); // 2 complete chunks filled",
                  "    assert_eq!(byte_len, 8); // Fully filled 8 bytes",
                  "    assert_eq!(&dest[..], &[5u8, 0u8, 0u8, 0u8, 6u8, 0u8, 0u8, 0u8]); // Ensure both elements are correctly filled",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// may panic: dest.chunks_exact_mut(size) may panic in certain situations\n",
        "// constraint: let Some(src) = src.next() is true\n",
        "// constraint: n > 0 is false, with bound n == 0\n",
        "// expected return value/type: (num_chunks, byte_len)\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[derive(Copy, Clone)]",
            "struct TestType(u32);",
            "",
            "impl Observable for TestType {",
            "    type Bytes = [u8; 4];",
            "    ",
            "    fn to_le_bytes(self) -> Self::Bytes {",
            "        self.0.to_le_bytes()",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let src = [TestType(1), TestType(2), TestType(3)];",
                  "    let mut dest = [0u8; 12];",
                  "    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);",
                  "    ",
                  "    assert_eq!(num_chunks, 3);",
                  "    assert_eq!(byte_len, 12);",
                  "    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let src = [TestType(1), TestType(2)];",
                  "    let mut dest = [0u8; 10];",
                  "    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);",
                  "    ",
                  "    assert_eq!(num_chunks, 2);",
                  "    assert_eq!(byte_len, 8);",
                  "    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0, 0, 0]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let src = [TestType(1)];",
                  "    let mut dest = [0u8; 4];",
                  "    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);",
                  "    ",
                  "    assert_eq!(num_chunks, 1);",
                  "    assert_eq!(byte_len, 4);",
                  "    assert_eq!(&dest, &[1, 0, 0, 0]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let src = [TestType(1), TestType(2), TestType(3)];",
                  "    let mut dest = [0u8; 8];",
                  "    let (num_chunks, byte_len) = fill_via_chunks(&src, &mut dest);",
                  "    ",
                  "    assert_eq!(num_chunks, 2);",
                  "    assert_eq!(byte_len, 8);",
                  "    assert_eq!(&dest, &[1, 0, 0, 0, 2, 0, 0, 0]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}