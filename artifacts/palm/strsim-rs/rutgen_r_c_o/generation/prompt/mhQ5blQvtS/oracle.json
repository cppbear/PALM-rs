{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/lib.rs\n// crate name is strsim\npub type HammingResult = Result<usize, StrSimError>;\nuse std::char;\nuse std::cmp::{max, min};\nuse std::collections::HashMap;\nuse std::convert::TryFrom;\nuse std::error::Error;\nuse std::fmt::{self, Display, Formatter};\nuse std::hash::Hash;\nuse std::mem;\nuse std::str::Chars;\nstruct HybridGrowingHashmapChar<ValueType> {\n    map: GrowingHashmapChar<ValueType>,\n    extended_ascii: [ValueType; 256],\n}\n#[derive(Clone, Copy, PartialEq, Eq)]\nstruct RowId {\n    val: isize,\n}\nimpl<ValueType> HybridGrowingHashmapChar<ValueType>\nwhere\n    ValueType: Default + Clone + Copy + Eq,\n{\n    fn get(&self, key: char) -> ValueType {\n        let value = key as u32;\n        if value <= 255 {\n            let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");\n            self.extended_ascii[usize::from(val_u8)]\n        } else {\n            self.map.get(value)\n        }\n    }\n    fn get_mut(&mut self, key: char) -> &mut ValueType {\n        let value = key as u32;\n        if value <= 255 {\n            let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");\n            &mut self.extended_ascii[usize::from(val_u8)]\n        } else {\n            self.map.get_mut(value)\n        }\n    }\n}\nfn damerau_levenshtein_impl<Iter1, Iter2>(\n    s1: Iter1,\n    len1: usize,\n    s2: Iter2,\n    len2: usize,\n) -> usize\nwhere\n    Iter1: Iterator<Item = char> + Clone,\n    Iter2: Iterator<Item = char> + Clone,\n{\n    let max_val = max(len1, len2) as isize + 1;\n    let mut last_row_id = HybridGrowingHashmapChar::<RowId>::default();\n    let size = len2 + 2;\n    let mut fr = vec![max_val; size];\n    let mut r1 = vec![max_val; size];\n    let mut r: Vec<isize> = (max_val..max_val + 1)\n        .chain(0..(size - 1) as isize)\n        .collect();\n    for (i, ch1) in s1.enumerate().map(|(i, ch1)| (i + 1, ch1)) {\n        mem::swap(&mut r, &mut r1);\n        let mut last_col_id: isize = -1;\n        let mut last_i2l1 = r[1];\n        r[1] = i as isize;\n        let mut t = max_val;\n        for (j, ch2) in s2.clone().enumerate().map(|(j, ch2)| (j + 1, ch2)) {\n            let diag = r1[j] + isize::from(ch1 != ch2);\n            let left = r[j] + 1;\n            let up = r1[j + 1] + 1;\n            let mut temp = min(diag, min(left, up));\n            if ch1 == ch2 {\n                last_col_id = j as isize;\n                fr[j + 1] = r1[j - 1];\n                t = last_i2l1;\n            } else {\n                let k = last_row_id.get(ch2).val;\n                let l = last_col_id;\n                if j as isize - l == 1 {\n                    let transpose = fr[j + 1] + (i as isize - k);\n                    temp = min(temp, transpose);\n                } else if i as isize - k == 1 {\n                    let transpose = t + (j as isize - l);\n                    temp = min(temp, transpose);\n                }\n            }\n            last_i2l1 = r[j + 1];\n            r[j + 1] = temp;\n        }\n        last_row_id.get_mut(ch1).val = i as isize;\n    }\n    r[len2 + 1] as usize\n}\n\nThe function to be tested is presented as follows:\nfn damerau_levenshtein_impl<Iter1, Iter2>(s1: Iter1, len1: usize, s2: Iter2, len2: usize) -> usize\nwhere\n    Iter1: Iterator<Item = char> + Clone,\n    Iter2: Iterator<Item = char> + Clone,\n{\n    // The implementations is based on the paper\n    // `Linear space string correction algorithm using the Damerau-Levenshtein distance`\n    // from Chunchun Zhao and Sartaj Sahni\n    //\n    // It has a runtime complexity of `O(N*M)` and a memory usage of `O(N+M)`.\n    let max_val = max(len1, len2) as isize + 1;\n\n    let mut last_row_id = HybridGrowingHashmapChar::<RowId>::default();\n\n    let size = len2 + 2;\n    let mut fr = vec![max_val; size];\n    let mut r1 = vec![max_val; size];\n    let mut r: Vec<isize> = (max_val..max_val + 1)\n        .chain(0..(size - 1) as isize)\n        .collect();\n\n    for (i, ch1) in s1.enumerate().map(|(i, ch1)| (i + 1, ch1)) {\n        mem::swap(&mut r, &mut r1);\n        let mut last_col_id: isize = -1;\n        let mut last_i2l1 = r[1];\n        r[1] = i as isize;\n        let mut t = max_val;\n\n        for (j, ch2) in s2.clone().enumerate().map(|(j, ch2)| (j + 1, ch2)) {\n            let diag = r1[j] + isize::from(ch1 != ch2);\n            let left = r[j] + 1;\n            let up = r1[j + 1] + 1;\n            let mut temp = min(diag, min(left, up));\n\n            if ch1 == ch2 {\n                last_col_id = j as isize; // last occurence of s1_i\n                fr[j + 1] = r1[j - 1]; // save H_k-1,j-2\n                t = last_i2l1; // save H_i-2,l-1\n            } else {\n                let k = last_row_id.get(ch2).val;\n                let l = last_col_id;\n\n                if j as isize - l == 1 {\n                    let transpose = fr[j + 1] + (i as isize - k);\n                    temp = min(temp, transpose);\n                } else if i as isize - k == 1 {\n                    let transpose = t + (j as isize - l);\n                    temp = min(temp, transpose);\n                }\n            }\n\n            last_i2l1 = r[j + 1];\n            r[j + 1] = temp;\n        }\n        last_row_id.get_mut(ch1).val = i as isize;\n    }\n\n    r[len2 + 1] as usize\n}\n",
  "depend_pt": ""
}