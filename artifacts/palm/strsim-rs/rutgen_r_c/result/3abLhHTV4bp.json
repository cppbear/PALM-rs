{"function_name":"strsim::GrowingHashmapChar<ValueType>::grow","tests":19,"tests_lines":[18,18,10,18,18,18,10,18,15,12,17,10,17,16,12,10,12,14,11],"oracles":19,"oracles_compiled":17,"oracles_compiled_rate":89.47368421052632,"tests_compiled":17,"tests_compiled_rate":89.47368421052632,"oracles_run":17,"oracles_passed":9,"oracles_passed_rate":52.94117647058824,"tests_run":17,"tests_passed":9,"tests_passed_rate":52.94117647058824,"lines":27,"lines_covered":27,"lines_coveraged_rate":100.0,"branches":6,"branches_covered":6,"branches_coverage_rate":100.0,"codes_lines":[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,560,563,564],"codes_lines_covered":[[["{","    let mut hashmap = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 42 },","            GrowingHashmapMapElemChar { key: 2, value: 43 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","    ","    hashmap.grow(4);","    ","    assert_eq!(hashmap.mask, 3); // 4 - 1","    assert_eq!(hashmap.used, 2);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,563,564]],[["{","    let mut hashmap = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 42 },","            GrowingHashmapMapElemChar { key: 2, value: 43 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","    ","    hashmap.grow(6);","    ","    assert_eq!(hashmap.mask, 7); // Grows to the next power of 2 (8 - 1)","    assert_eq!(hashmap.used, 2);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: None,","    };","    ","    hashmap.grow(4);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557]],[["{","    let mut hashmap = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 42 },","            GrowingHashmapMapElemChar { key: 2, value: 43 },","            GrowingHashmapMapElemChar::default(), // value is default","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(4);","    ","    assert_eq!(hashmap.mask, 3);","    assert_eq!(hashmap.used, 2);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(3);","","    assert_eq!(hashmap.mask, 7); // new size should be 8","    assert_eq!(hashmap.used, 2);  // used should remain unchanged","}"],[534,535,536,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: None,","    };","","    hashmap.grow(1);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 3,","        fill: 3,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar { key: 3, value: 30 },","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(4);","","    assert_eq!(hashmap.mask, 7); // new mask after growing","    assert_eq!(hashmap.used, 3);  // used count should remain the same","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 1,","        fill: 1,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 4, value: 40 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(2);","}"],[534,535,536,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 1,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 2]),","    };","    ","    // Ensure that min_used is larger than current size ","    hashmap.grow(3); // new_size will be greater than current min_used (1)","    assert_eq!(hashmap.mask, 3); // Ensure the mask is updated correctly","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,560,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(2); // This should not trigger a reallocation","    assert_eq!(hashmap.mask, 3); // Ensure the mask is unchanged","    assert_eq!(hashmap.used, 2); // Ensure used count is unchanged","}"],[534,535,536,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 1,","        map: None,","    };","","    hashmap.grow(2); // This should panic","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 3,","        fill: 3,","        mask: 1,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar { key: 3, value: 30 },","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(5); // We want to ensure elements are moved and there is space","    assert_eq!(hashmap.mask, 7); // Ensure the mask is updated correctly","    assert_eq!(hashmap.used, 3); // Ensure used count is correct","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,559,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar::<i32>::default(),","            GrowingHashmapMapElemChar::<i32>::default(),","            GrowingHashmapMapElemChar::<i32>::default(),","            GrowingHashmapMapElemChar::<i32>::default(),","        ]),","    };","","    hashmap.grow(1); // Should reallocate and grow as used is zero","    assert_eq!(hashmap.mask, 1); // Ensure mask is updated correctly","}"],[534,535,536,540,541,542,543,544,545,546,547,548,550,551,560,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 1]),","    };","","    hashmap.grow(1); // Should be able to grow, shouldn't panic","    assert_eq!(hashmap.mask, 0); // Ensure the mask is still valid","    assert_eq!(hashmap.used, 0); // Ensure count is correct","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,560,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 1]),","    };","    hashmap.grow(2);","    assert_eq!(hashmap.mask, 1);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,560,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 1,","        fill: 1,","        mask: 0,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar::default(),","        ]),","    };","    hashmap.grow(2);","    assert_eq!(hashmap.map.as_ref().unwrap()[0].key, 1);","    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 10);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,552,553,554,555,556,557,558,563,564]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 1]),","    };","    hashmap.grow(1);","    assert_eq!(hashmap.fill, 0);","    assert_eq!(hashmap.used, 0);","}"],[534,535,536,537,538,540,541,542,543,544,545,546,547,548,550,551,560,563,564]]],"codes_branches":[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":true},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut hashmap = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 42 },","            GrowingHashmapMapElemChar { key: 2, value: 43 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","    ","    hashmap.grow(4);","    ","    assert_eq!(hashmap.mask, 3); // 4 - 1","    assert_eq!(hashmap.used, 2);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}]],[["{","    let mut hashmap = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 42 },","            GrowingHashmapMapElemChar { key: 2, value: 43 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","    ","    hashmap.grow(6);","    ","    assert_eq!(hashmap.mask, 7); // Grows to the next power of 2 (8 - 1)","    assert_eq!(hashmap.used, 2);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: None,","    };","    ","    hashmap.grow(4);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut hashmap = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 42 },","            GrowingHashmapMapElemChar { key: 2, value: 43 },","            GrowingHashmapMapElemChar::default(), // value is default","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(4);","    ","    assert_eq!(hashmap.mask, 3);","    assert_eq!(hashmap.used, 2);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(3);","","    assert_eq!(hashmap.mask, 7); // new size should be 8","    assert_eq!(hashmap.used, 2);  // used should remain unchanged","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":false,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: None,","    };","","    hashmap.grow(1);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 3,","        fill: 3,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar { key: 3, value: 30 },","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(4);","","    assert_eq!(hashmap.mask, 7); // new mask after growing","    assert_eq!(hashmap.used, 3);  // used count should remain the same","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 1,","        fill: 1,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 4, value: 40 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(2);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":false,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 1,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 2]),","    };","    ","    // Ensure that min_used is larger than current size ","    hashmap.grow(3); // new_size will be greater than current min_used (1)","    assert_eq!(hashmap.mask, 3); // Ensure the mask is updated correctly","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":false,"negative":true},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 2,","        fill: 2,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar::default(),","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(2); // This should not trigger a reallocation","    assert_eq!(hashmap.mask, 3); // Ensure the mask is unchanged","    assert_eq!(hashmap.used, 2); // Ensure used count is unchanged","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":false,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 1,","        map: None,","    };","","    hashmap.grow(2); // This should panic","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 3,","        fill: 3,","        mask: 1,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar { key: 2, value: 20 },","            GrowingHashmapMapElemChar { key: 3, value: 30 },","            GrowingHashmapMapElemChar::default(),","        ]),","    };","","    hashmap.grow(5); // We want to ensure elements are moved and there is space","    assert_eq!(hashmap.mask, 7); // Ensure the mask is updated correctly","    assert_eq!(hashmap.used, 3); // Ensure used count is correct","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":true}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 3,","        map: Some(vec![","            GrowingHashmapMapElemChar::<i32>::default(),","            GrowingHashmapMapElemChar::<i32>::default(),","            GrowingHashmapMapElemChar::<i32>::default(),","            GrowingHashmapMapElemChar::<i32>::default(),","        ]),","    };","","    hashmap.grow(1); // Should reallocate and grow as used is zero","    assert_eq!(hashmap.mask, 1); // Ensure mask is updated correctly","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":false,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":false,"negative":true},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 1]),","    };","","    hashmap.grow(1); // Should be able to grow, shouldn't panic","    assert_eq!(hashmap.mask, 0); // Ensure the mask is still valid","    assert_eq!(hashmap.used, 0); // Ensure count is correct","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":false,"negative":true},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 1]),","    };","    hashmap.grow(2);","    assert_eq!(hashmap.mask, 1);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":false,"negative":true},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 1,","        fill: 1,","        mask: 0,","        map: Some(vec![","            GrowingHashmapMapElemChar { key: 1, value: 10 },","            GrowingHashmapMapElemChar::default(),","        ]),","    };","    hashmap.grow(2);","    assert_eq!(hashmap.map.as_ref().unwrap()[0].key, 1);","    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 10);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":true,"negative":false},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":true,"negative":false}]],[["{","    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {","        used: 0,","        fill: 0,","        mask: 0,","        map: Some(vec![GrowingHashmapMapElemChar::<i32>::default(); 1]),","    };","    hashmap.grow(1);","    assert_eq!(hashmap.fill, 0);","    assert_eq!(hashmap.used, 0);","}"],[{"start_line":536,"start_column":15,"end_line":536,"end_column":35,"positive":true,"negative":true},{"start_line":551,"start_column":16,"end_line":551,"end_column":48,"positive":false,"negative":true},{"start_line":557,"start_column":20,"end_line":557,"end_column":34,"positive":false,"negative":false}]]]}