{"function_name":"strsim::HybridGrowingHashmapChar<ValueType>::get_mut","tests":6,"tests_lines":[23,24,36,20,78,65],"oracles":6,"oracles_compiled":5,"oracles_compiled_rate":83.33333333333334,"tests_compiled":5,"tests_compiled_rate":83.33333333333334,"oracles_run":5,"oracles_passed":4,"oracles_passed_rate":80.0,"tests_run":5,"tests_passed":4,"tests_passed_rate":80.0,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[586,587,588,589,590,592,594],"codes_lines_covered":[[["{","   #[derive(Copy, Clone)]  ","  #[derive(Eq, PartialEq)]  ","  struct TestValueType(i32);  ","   impl Default for TestValueType {  ","       fn default() -> Self {  ","           TestValueType(0)  ","       }  ","   }  ","   ","   let mut hashmap = HybridGrowingHashmapChar {  ","       map: GrowingHashmapChar {  ","           used: 0,  ","           fill: 0,  ","           mask: 0,  ","           map: None,  ","       },  ","       extended_ascii: [TestValueType::default(); 256],  ","   };  "," ","   let result = hashmap.get_mut('A'); // 'A' has a value of 65, <= 255  ","   result.0 = 1; // Test modification  ","}"],[586,587,588,589,590,594]],[["{","   #[derive(Copy, Clone)]","  #[derive(Eq, PartialEq)]","  struct TestValueType(i32);","    impl Default for TestValueType {","        fn default() -> Self {","            TestValueType(0)","        }","    }","    ","    let mut hashmap = HybridGrowingHashmapChar {","        map: GrowingHashmapChar {","            used: 0,","            fill: 0,","            mask: 0,","            map: None,","        },","        extended_ascii: [TestValueType::default(); 256],","    };","","    let result = hashmap.get_mut('\\u{FF}'); // '\\u{FF}' has a value of 255, <= 255","    result.0 = 1; // Test modification","    assert_eq!(hashmap.extended_ascii[255].0, 1);","}"],[586,587,588,589,590,594]],[["{","  #[derive(Copy, Clone)]  "," #[derive(Eq, PartialEq)]  "," struct TestValueType(i32);  ","  impl Default for TestValueType {  ","      fn default() -> Self {  ","          TestValueType(0)  ","      }  ","  }  ","  ","  #[derive(Clone)]  ","  struct MapElem {  ","      key: u32,  ","      value: TestValueType,  ","  }  ","  impl Default for MapElem {  ","      fn default() -> Self {  ","          MapElem {  ","              key: 0,  ","              value: TestValueType::default(),  ","          }  ","      }  ","  }  ","  "," let mut hashmap = HybridGrowingHashmapChar {  ","     map: GrowingHashmapChar {  ","         used: 0,  ","         fill: 0,  ","         mask: 0,  ","         map: Some(vec![GrowingHashmapMapElemChar::default(); 10]), // Preallocated map  ","      },  ","      extended_ascii: [TestValueType::default(); 256],  ","  };  "," ","   let result = hashmap.get_mut('\\u{100}'); // '\\u{100}' has a value of 256, > 255  ","}"],[586,587,588,592,594]],[["{","   #[derive(Copy, Clone)]  ","   struct TestValueType(i32);  ","   impl Default for TestValueType {  ","       fn default() -> Self {  ","           TestValueType(0)  ","       }  ","   }  ","   ","   let mut hashmap = HybridGrowingHashmapChar {  ","       map: GrowingHashmapChar {  ","           used: 0,  ","           fill: 0,  ","           mask: 0,  ","           map: None,  ","       },  ","       extended_ascii: [TestValueType::default(); 256],  ","   };  "," ","}"],[]],[["{","   #[derive(Copy, Clone)]","   struct DummyValue {","       value: usize,","    }","    ","   #[derive(Clone)]","   struct DummyMapElement {","       key: u32,","       value: DummyValue,","   }","","    struct GrowingHashmapChar {","        used: i32,","        fill: i32,","        mask: i32,","        map: Option<Vec<DummyMapElement>>,","    }","","    impl GrowingHashmapChar {","        fn new() -> Self {","            GrowingHashmapChar {","                used: 0,","                fill: 0,","                mask: 255,","                map: Some(vec![","                    DummyMapElement { key: 0, value: DummyValue { value: 0 } }; 256","                ]),","            }","        }","","       fn get_mut(&mut self, key: u32) -> &mut DummyValue {  ","           &mut self.map.as_mut().unwrap().get_mut(key as usize).unwrap().value  ","       }  ","    }","","    struct HybridGrowingHashmapChar {","        map: GrowingHashmapChar,","        extended_ascii: [DummyValue; 256],","    }","","    impl HybridGrowingHashmapChar {","        fn new() -> Self {","            HybridGrowingHashmapChar {","                map: GrowingHashmapChar::new(),","                extended_ascii: [DummyValue { value: 0 }; 256],","            }","        }","","        fn get_mut(&mut self, key: char) -> &mut DummyValue {","            let value = key as u32;","            if value <= 255 {","                let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");","                &mut self.extended_ascii[usize::from(val_u8)]","            } else {","                self.map.get_mut(value)","            }","        }","    }","","    let mut hashmap = HybridGrowingHashmapChar::new();","","    // Testing for a character that has not been initialized in the map","    let _value = hashmap.get_mut('\\u{1000}'); // This should panic as the map is not initialized yet for this value","}"],[]]],"codes_branches":[{"start_line":588,"start_column":12,"end_line":588,"end_column":24,"positive":true,"negative":true}],"codes_branches_covered":[[["{","   #[derive(Copy, Clone)]  ","  #[derive(Eq, PartialEq)]  ","  struct TestValueType(i32);  ","   impl Default for TestValueType {  ","       fn default() -> Self {  ","           TestValueType(0)  ","       }  ","   }  ","   ","   let mut hashmap = HybridGrowingHashmapChar {  ","       map: GrowingHashmapChar {  ","           used: 0,  ","           fill: 0,  ","           mask: 0,  ","           map: None,  ","       },  ","       extended_ascii: [TestValueType::default(); 256],  ","   };  "," ","   let result = hashmap.get_mut('A'); // 'A' has a value of 65, <= 255  ","   result.0 = 1; // Test modification  ","}"],[{"start_line":588,"start_column":12,"end_line":588,"end_column":24,"positive":true,"negative":false}]],[["{","   #[derive(Copy, Clone)]","  #[derive(Eq, PartialEq)]","  struct TestValueType(i32);","    impl Default for TestValueType {","        fn default() -> Self {","            TestValueType(0)","        }","    }","    ","    let mut hashmap = HybridGrowingHashmapChar {","        map: GrowingHashmapChar {","            used: 0,","            fill: 0,","            mask: 0,","            map: None,","        },","        extended_ascii: [TestValueType::default(); 256],","    };","","    let result = hashmap.get_mut('\\u{FF}'); // '\\u{FF}' has a value of 255, <= 255","    result.0 = 1; // Test modification","    assert_eq!(hashmap.extended_ascii[255].0, 1);","}"],[{"start_line":588,"start_column":12,"end_line":588,"end_column":24,"positive":true,"negative":false}]],[["{","  #[derive(Copy, Clone)]  "," #[derive(Eq, PartialEq)]  "," struct TestValueType(i32);  ","  impl Default for TestValueType {  ","      fn default() -> Self {  ","          TestValueType(0)  ","      }  ","  }  ","  ","  #[derive(Clone)]  ","  struct MapElem {  ","      key: u32,  ","      value: TestValueType,  ","  }  ","  impl Default for MapElem {  ","      fn default() -> Self {  ","          MapElem {  ","              key: 0,  ","              value: TestValueType::default(),  ","          }  ","      }  ","  }  ","  "," let mut hashmap = HybridGrowingHashmapChar {  ","     map: GrowingHashmapChar {  ","         used: 0,  ","         fill: 0,  ","         mask: 0,  ","         map: Some(vec![GrowingHashmapMapElemChar::default(); 10]), // Preallocated map  ","      },  ","      extended_ascii: [TestValueType::default(); 256],  ","  };  "," ","   let result = hashmap.get_mut('\\u{100}'); // '\\u{100}' has a value of 256, > 255  ","}"],[{"start_line":588,"start_column":12,"end_line":588,"end_column":24,"positive":false,"negative":true}]],[["{","   #[derive(Copy, Clone)]  ","   struct TestValueType(i32);  ","   impl Default for TestValueType {  ","       fn default() -> Self {  ","           TestValueType(0)  ","       }  ","   }  ","   ","   let mut hashmap = HybridGrowingHashmapChar {  ","       map: GrowingHashmapChar {  ","           used: 0,  ","           fill: 0,  ","           mask: 0,  ","           map: None,  ","       },  ","       extended_ascii: [TestValueType::default(); 256],  ","   };  "," ","}"],[{"start_line":588,"start_column":12,"end_line":588,"end_column":24,"positive":false,"negative":false}]],[["{","   #[derive(Copy, Clone)]","   struct DummyValue {","       value: usize,","    }","    ","   #[derive(Clone)]","   struct DummyMapElement {","       key: u32,","       value: DummyValue,","   }","","    struct GrowingHashmapChar {","        used: i32,","        fill: i32,","        mask: i32,","        map: Option<Vec<DummyMapElement>>,","    }","","    impl GrowingHashmapChar {","        fn new() -> Self {","            GrowingHashmapChar {","                used: 0,","                fill: 0,","                mask: 255,","                map: Some(vec![","                    DummyMapElement { key: 0, value: DummyValue { value: 0 } }; 256","                ]),","            }","        }","","       fn get_mut(&mut self, key: u32) -> &mut DummyValue {  ","           &mut self.map.as_mut().unwrap().get_mut(key as usize).unwrap().value  ","       }  ","    }","","    struct HybridGrowingHashmapChar {","        map: GrowingHashmapChar,","        extended_ascii: [DummyValue; 256],","    }","","    impl HybridGrowingHashmapChar {","        fn new() -> Self {","            HybridGrowingHashmapChar {","                map: GrowingHashmapChar::new(),","                extended_ascii: [DummyValue { value: 0 }; 256],","            }","        }","","        fn get_mut(&mut self, key: char) -> &mut DummyValue {","            let value = key as u32;","            if value <= 255 {","                let val_u8 = u8::try_from(value).expect(\"we check the bounds above\");","                &mut self.extended_ascii[usize::from(val_u8)]","            } else {","                self.map.get_mut(value)","            }","        }","    }","","    let mut hashmap = HybridGrowingHashmapChar::new();","","    // Testing for a character that has not been initialized in the map","    let _value = hashmap.get_mut('\\u{1000}'); // This should panic as the map is not initialized yet for this value","}"],[{"start_line":588,"start_column":12,"end_line":588,"end_column":24,"positive":false,"negative":false}]]]}