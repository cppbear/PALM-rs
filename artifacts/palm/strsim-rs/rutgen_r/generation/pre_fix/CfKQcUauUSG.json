{
  "name": "strsim::generic_damerau_levenshtein",
  "name_with_impl": "strsim::generic_damerau_levenshtein",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1307:2"
  },
  "visible": true,
  "loc": "src/lib.rs:353:1:414:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: a_len == 0 is false\n",
        "// expected return value/type: b_len\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein(&[1, 2, 3], &[]);",
                  "    assert_eq!(result, 3); // b_len is 0, so expected result is 3 (length of a)",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein(&[1, 2], &[2, 3, 1]);",
                  "    assert_eq!(result, 2); // expected output based on the example provided",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein(&[1, 1, 1], &[1, 1, 1]);",
                  "    assert_eq!(result, 0); // both are equal, distance is 0",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein(&[1, 2, 3], &[4, 5, 6]);",
                  "    assert_eq!(result, 6); // all elements differ, so expected is the sum of lengths",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein(&[1], &[2]);",
                  "    assert_eq!(result, 2); // both elements differ",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein(&[1, 2], &[1, 2, 3, 4]);",
                  "    assert_eq!(result, 2); // expected result: insertions to match length",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    #[should_panic] // this would simulate a zero-length a with non-zero b, expecting a panic",
                  "    fn test_empty_a_non_empty_b() {",
                  "        let _ = generic_damerau_levenshtein(&[], &[1]);",
                  "    }",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: a_len == 0 is true\n",
        "// constraint: b_len == 0 is false\n",
        "// expected return value/type: a_len\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let a: Vec<i32> = vec![];",
                  "    let b: Vec<i32> = vec![1, 2, 3];",
                  "    let result = generic_damerau_levenshtein(&a, &b);",
                  "    assert_eq!(result, a.len());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let a: Vec<char> = vec![];",
                  "    let b: Vec<char> = vec!['x', 'y', 'z'];",
                  "    let result = generic_damerau_levenshtein(&a, &b);",
                  "    assert_eq!(result, a.len());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let a: Vec<&str> = vec![];",
                  "    let b: Vec<&str> = vec![\"hello\", \"world\"];",
                  "    let result = generic_damerau_levenshtein(&a, &b);",
                  "    assert_eq!(result, a.len());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: a_len == 0 is true\n",
        "// constraint: b_len == 0 is true\n",
        "// may panic: distances[0] may panic in certain situations\n",
        "// constraint: i in 0..(a_len + 1) is true\n",
        "// may panic: distances[flat_index(i + 1, 0, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(i + 1, 1, width)] may panic in certain situations\n",
        "// constraint: i in 0..(a_len + 1) is false\n",
        "// constraint: j in 0..(b_len + 1) is true\n",
        "// may panic: distances[flat_index(0, j + 1, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(1, j + 1, width)] may panic in certain situations\n",
        "// constraint: j in 0..(b_len + 1) is false\n",
        "// constraint: i in 1..(a_len + 1) is true\n",
        "// constraint: j in 1..(b_len + 1) is true\n",
        "// constraint: j - 1 is true\n",
        "// constraint: elems.get(&b_elems[j - 1]) matches Some(&value) is true\n",
        "// may panic: distances[flat_index(i, j + 1, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(i + 1, j, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(k, db, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(i, j, width)] may panic in certain situations\n",
        "// constraint: a_elems[i - 1] == b_elems[j - 1] is false\n",
        "// may panic: distances[flat_index(i + 1, j + 1, width)] may panic in certain situations\n",
        "// constraint: j in 1..(b_len + 1) is false\n",
        "// constraint: i in 1..(a_len + 1) is false\n",
        "// may panic: distances[flat_index(a_len + 1, b_len + 1, width)] may panic in certain situations\n",
        "// expected return value/type: distances[flat_index(a_len + 1, b_len + 1, width)]\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use std::collections::HashMap;",
            "use std::hash::Hash;",
            "use std::cmp::min;"
          ],
          "has_test_mod": false,
          "common": [
            "// Add a flat_index helper function to facilitate distance calculations.",
            "fn flat_index(i: usize, j: usize, width: usize) -> usize {",
            "    i * width + j",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein::<i32>(&[], &[]), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[], &[1, 2, 3]), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[]), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1], &[2]), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2], &[2, 1]), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[2, 1, 3]), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[4, 5, 6]), 6);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[1, 2, 3]), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 23,
      "prompt_conds": [
        "// constraint: a_len == 0 is true\n",
        "// constraint: b_len == 0 is true\n",
        "// may panic: distances[0] may panic in certain situations\n",
        "// constraint: i in 0..(a_len + 1) is false\n",
        "// constraint: j in 0..(b_len + 1) is false\n",
        "// constraint: i in 1..(a_len + 1) is true\n",
        "// constraint: j in 1..(b_len + 1) is true\n",
        "// constraint: j - 1 is false\n",
        "// may panic: distances[flat_index(i, j + 1, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(i + 1, j, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(k, db, width)] may panic in certain situations\n",
        "// may panic: distances[flat_index(i, j, width)] may panic in certain situations\n",
        "// constraint: a_elems[i - 1] == b_elems[j - 1] is true\n",
        "// may panic: distances[flat_index(i + 1, j + 1, width)] may panic in certain situations\n",
        "// constraint: j in 1..(b_len + 1) is false\n",
        "// constraint: i in 1..(a_len + 1) is false\n",
        "// may panic: distances[flat_index(a_len + 1, b_len + 1, width)] may panic in certain situations\n",
        "// expected return value/type: distances[flat_index(a_len + 1, b_len + 1, width)]\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use std::cmp::min;",
            "use std::collections::HashMap;",
            "use std::hash::Hash;"
          ],
          "has_test_mod": false,
          "common": [
            "fn flat_index(i: usize, j: usize, width: usize) -> usize {",
            "    i * width + j",
            "}",
            "",
            "pub fn generic_damerau_levenshtein<Elem>(a_elems: &[Elem], b_elems: &[Elem]) -> usize",
            "where",
            "    Elem: Eq + Hash + Clone,",
            "{",
            "    let a_len = a_elems.len();",
            "    let b_len = b_elems.len();",
            "",
            "    if a_len == 0 {",
            "        return b_len;",
            "    }",
            "    if b_len == 0 {",
            "        return a_len;",
            "    }",
            "",
            "    let width = a_len + 2;",
            "    let mut distances = vec![0; (a_len + 2) * (b_len + 2)];",
            "    let max_distance = a_len + b_len;",
            "    distances[0] = max_distance;",
            "",
            "    for i in 0..(a_len + 1) {",
            "        distances[flat_index(i + 1, 0, width)] = max_distance;",
            "        distances[flat_index(i + 1, 1, width)] = i;",
            "    }",
            "",
            "    for j in 0..(b_len + 1) {",
            "        distances[flat_index(0, j + 1, width)] = max_distance;",
            "        distances[flat_index(1, j + 1, width)] = j;",
            "    }",
            "",
            "    let mut elems: HashMap<Elem, usize> = HashMap::with_capacity(64);",
            "",
            "    for i in 1..(a_len + 1) {",
            "        let mut db = 0;",
            "",
            "        for j in 1..(b_len + 1) {",
            "            let k = match elems.get(&b_elems[j - 1]) {",
            "                Some(&value) => value,",
            "                None => 0,",
            "            };",
            "",
            "            let insertion_cost = distances[flat_index(i, j + 1, width)] + 1;",
            "            let deletion_cost = distances[flat_index(i + 1, j, width)] + 1;",
            "            let transposition_cost =",
            "                distances[flat_index(k, db, width)] + (i - k - 1) + 1 + (j - db - 1);",
            "",
            "            let mut substitution_cost = distances[flat_index(i, j, width)] + 1;",
            "            if a_elems[i - 1] == b_elems[j - 1] {",
            "                db = j;",
            "                substitution_cost -= 1;",
            "            }",
            "",
            "            distances[flat_index(i + 1, j + 1, width)] = min(",
            "                substitution_cost,",
            "                min(insertion_cost, min(deletion_cost, transposition_cost)),",
            "            );",
            "        }",
            "",
            "        elems.insert(a_elems[i - 1].clone(), i);",
            "    }",
            "",
            "    distances[flat_index(a_len + 1, b_len + 1, width)]",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein::<i32>(&[], &[]), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein::<i32>(&[], &[1, 2, 3]), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein::<i32>(&[1, 2, 3], &[]), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[1, 2, 3]), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[4, 5, 6]), 6);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    assert_eq!(generic_damerau_levenshtein(&[1, 2, 3], &[2, 3, 4]), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 26,
      "prompt_conds": [
        "// constraint: a_len == 0 is true\n",
        "// constraint: b_len == 0 is true\n",
        "// may panic: distances[0] may panic in certain situations\n",
        "// constraint: i in 0..(a_len + 1) is false\n",
        "// constraint: j in 0..(b_len + 1) is false\n",
        "// constraint: i in 1..(a_len + 1) is false\n",
        "// may panic: distances[flat_index(a_len + 1, b_len + 1, width)] may panic in certain situations\n",
        "// expected return value/type: distances[flat_index(a_len + 1, b_len + 1, width)]\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein::<i32>(&[], &[]);",
                  "    assert_eq!(result, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein::<i32>(&[], &[1, 2, 3]);",
                  "    assert_eq!(result, 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein::<i32>(&[1, 2, 3], &[]);",
                  "    assert_eq!(result, 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein::<i32>(&[1, 2, 3], &[1, 2, 3]);",
                  "    assert_eq!(result, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein::<i32>(&[1, 2, 3], &[4, 5, 6]);",
                  "    assert_eq!(result, 6);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let result = generic_damerau_levenshtein::<i32>(&[1, 2, 3], &[2, 3, 4]);",
                  "    assert_eq!(result, 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}