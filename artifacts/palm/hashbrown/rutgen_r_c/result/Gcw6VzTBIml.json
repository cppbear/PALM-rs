{"function_name":"hashbrown::raw::bitmask::raw::bitmask::BitMask::nonzero_trailing_zeros","tests":3,"tests_lines":[34,29,29],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[74,75,77,78,80,82],"codes_lines_covered":[[["{","    struct NonZeroBitMaskWordWrapper(usize);","    ","    impl NonZeroBitMaskWordWrapper {","        fn new_unchecked(value: usize) -> Self {","            assert!(value != 0);","            NonZeroBitMaskWordWrapper(value)","        }","        ","        fn get(self) -> usize {","            self.0","        }","","        fn trailing_zeros(self) -> usize {","            self.get().trailing_zeros() as usize","        }","","        fn leading_zeros(self) -> usize {","            self.get().leading_zeros() as usize","        }","    }","","    const BITMASK_STRIDE: usize = 4; // Simulate the BITMASK_STRIDE constant value","","    let nonzero_mask = NonZeroBitMaskWordWrapper::new_unchecked(0b0000_1000);","    let result = if cfg!(target_arch = \"arm\") && BITMASK_STRIDE % 8 == 0 {","        let swapped = unsafe { NonZeroBitMaskWordWrapper::new_unchecked(nonzero_mask.get().swap_bytes()) };","        swapped.leading_zeros() / BITMASK_STRIDE","    } else {","        nonzero_mask.trailing_zeros() / BITMASK_STRIDE","    };","    ","    assert_eq!(result, 1); // Adjust according to the actual expected outcome","}"],[]],[["{","    struct NonZeroBitMaskWordWrapper(usize);","    ","    impl NonZeroBitMaskWordWrapper {","        fn new_unchecked(value: usize) -> Self {","            assert!(value != 0);","            NonZeroBitMaskWordWrapper(value)","        }","        ","        fn get(self) -> usize {","            self.0","        }","","        fn trailing_zeros(self) -> usize {","            self.get().trailing_zeros() as usize","        }","","        fn leading_zeros(self) -> usize {","            self.get().leading_zeros() as usize","        }","    }","","    const BITMASK_STRIDE: usize = 4; // Simulate the BITMASK_STRIDE constant value","","    let nonzero_mask = NonZeroBitMaskWordWrapper::new_unchecked(0b0010); // 2 has 1 trailing zero","    let result = nonzero_mask.trailing_zeros() / BITMASK_STRIDE;","    ","    assert_eq!(result, 0); // Expected result for non-zero value trailing zeros divided by BITMASK_STRIDE","}"],[]],[["{","    struct NonZeroBitMaskWordWrapper(usize);","    ","    impl NonZeroBitMaskWordWrapper {","        fn new_unchecked(value: usize) -> Self {","            assert!(value != 0);","            NonZeroBitMaskWordWrapper(value)","        }","        ","        fn get(self) -> usize {","            self.0","        }","","        fn trailing_zeros(self) -> usize {","            self.get().trailing_zeros() as usize","        }","","        fn leading_zeros(self) -> usize {","            self.get().leading_zeros() as usize","        }","    }","","    const BITMASK_STRIDE: usize = 4; // Simulate the BITMASK_STRIDE constant value","","    let nonzero_mask = NonZeroBitMaskWordWrapper::new_unchecked(1); // 1 has 0 trailing zeros","    let result = nonzero_mask.trailing_zeros() / BITMASK_STRIDE;","","    assert_eq!(result, 0); // Division by BITMASK_STRIDE should still yield 0","}"],[]]],"codes_branches":[{"start_line":75,"start_column":41,"end_line":75,"end_column":64,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct NonZeroBitMaskWordWrapper(usize);","    ","    impl NonZeroBitMaskWordWrapper {","        fn new_unchecked(value: usize) -> Self {","            assert!(value != 0);","            NonZeroBitMaskWordWrapper(value)","        }","        ","        fn get(self) -> usize {","            self.0","        }","","        fn trailing_zeros(self) -> usize {","            self.get().trailing_zeros() as usize","        }","","        fn leading_zeros(self) -> usize {","            self.get().leading_zeros() as usize","        }","    }","","    const BITMASK_STRIDE: usize = 4; // Simulate the BITMASK_STRIDE constant value","","    let nonzero_mask = NonZeroBitMaskWordWrapper::new_unchecked(0b0000_1000);","    let result = if cfg!(target_arch = \"arm\") && BITMASK_STRIDE % 8 == 0 {","        let swapped = unsafe { NonZeroBitMaskWordWrapper::new_unchecked(nonzero_mask.get().swap_bytes()) };","        swapped.leading_zeros() / BITMASK_STRIDE","    } else {","        nonzero_mask.trailing_zeros() / BITMASK_STRIDE","    };","    ","    assert_eq!(result, 1); // Adjust according to the actual expected outcome","}"],[{"start_line":75,"start_column":41,"end_line":75,"end_column":64,"positive":false,"negative":false}]],[["{","    struct NonZeroBitMaskWordWrapper(usize);","    ","    impl NonZeroBitMaskWordWrapper {","        fn new_unchecked(value: usize) -> Self {","            assert!(value != 0);","            NonZeroBitMaskWordWrapper(value)","        }","        ","        fn get(self) -> usize {","            self.0","        }","","        fn trailing_zeros(self) -> usize {","            self.get().trailing_zeros() as usize","        }","","        fn leading_zeros(self) -> usize {","            self.get().leading_zeros() as usize","        }","    }","","    const BITMASK_STRIDE: usize = 4; // Simulate the BITMASK_STRIDE constant value","","    let nonzero_mask = NonZeroBitMaskWordWrapper::new_unchecked(0b0010); // 2 has 1 trailing zero","    let result = nonzero_mask.trailing_zeros() / BITMASK_STRIDE;","    ","    assert_eq!(result, 0); // Expected result for non-zero value trailing zeros divided by BITMASK_STRIDE","}"],[{"start_line":75,"start_column":41,"end_line":75,"end_column":64,"positive":false,"negative":false}]],[["{","    struct NonZeroBitMaskWordWrapper(usize);","    ","    impl NonZeroBitMaskWordWrapper {","        fn new_unchecked(value: usize) -> Self {","            assert!(value != 0);","            NonZeroBitMaskWordWrapper(value)","        }","        ","        fn get(self) -> usize {","            self.0","        }","","        fn trailing_zeros(self) -> usize {","            self.get().trailing_zeros() as usize","        }","","        fn leading_zeros(self) -> usize {","            self.get().leading_zeros() as usize","        }","    }","","    const BITMASK_STRIDE: usize = 4; // Simulate the BITMASK_STRIDE constant value","","    let nonzero_mask = NonZeroBitMaskWordWrapper::new_unchecked(1); // 1 has 0 trailing zeros","    let result = nonzero_mask.trailing_zeros() / BITMASK_STRIDE;","","    assert_eq!(result, 0); // Division by BITMASK_STRIDE should still yield 0","}"],[{"start_line":75,"start_column":41,"end_line":75,"end_column":64,"positive":false,"negative":false}]]]}