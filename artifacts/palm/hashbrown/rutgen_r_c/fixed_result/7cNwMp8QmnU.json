{"function_name":"hashbrown::map::map::HashMap<K, V, S>::with_capacity_and_hasher","tests":3,"tests_lines":[13,13,14],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[498,499,500,501,502,503],"codes_lines_covered":[[["{","    struct DummyHasher;","    impl BuildHasher for DummyHasher {","        type Hasher = std::collections::hash_map::DefaultHasher;","        fn build_hasher(&self) -> Self::Hasher {","            std::collections::hash_map::DefaultHasher::new()","        }","    }","","    let hasher = DummyHasher;","    let map: HashMap<i32, i32, DummyHasher> = HashMap::with_capacity_and_hasher(0, hasher);","    assert_eq!(map.table.len(), 0); // assuming RawTable has a method to get current length","}"],[498,499,500,501,502,503]],[["{","    struct DummyHasher;","    impl BuildHasher for DummyHasher {","        type Hasher = std::collections::hash_map::DefaultHasher;","        fn build_hasher(&self) -> Self::Hasher {","            std::collections::hash_map::DefaultHasher::new()","        }","    }","","    let hasher = DummyHasher;","    let map: HashMap<i32, i32, DummyHasher> = HashMap::with_capacity_and_hasher(10, hasher);","    assert_eq!(map.table.len(), 0); // assuming RawTable has a method to get current length","}"],[498,499,500,501,502,503]],[["{","    struct DummyHasher;","    impl BuildHasher for DummyHasher {","        type Hasher = std::collections::hash_map::DefaultHasher;","        fn build_hasher(&self) -> Self::Hasher {","            std::collections::hash_map::DefaultHasher::new()","        }","    }","","    let hasher = DummyHasher;","    let capacity = usize::MAX; // testing upper boundary","    let map: HashMap<i32, i32, DummyHasher> = HashMap::with_capacity_and_hasher(capacity, hasher);","    assert_eq!(map.table.len(), 0); // assuming RawTable has a method to get current length","}"],[498,499,500,501,502,503]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct DummyHasher;","    impl BuildHasher for DummyHasher {","        type Hasher = std::collections::hash_map::DefaultHasher;","        fn build_hasher(&self) -> Self::Hasher {","            std::collections::hash_map::DefaultHasher::new()","        }","    }","","    let hasher = DummyHasher;","    let map: HashMap<i32, i32, DummyHasher> = HashMap::with_capacity_and_hasher(0, hasher);","    assert_eq!(map.table.len(), 0); // assuming RawTable has a method to get current length","}"],[]],[["{","    struct DummyHasher;","    impl BuildHasher for DummyHasher {","        type Hasher = std::collections::hash_map::DefaultHasher;","        fn build_hasher(&self) -> Self::Hasher {","            std::collections::hash_map::DefaultHasher::new()","        }","    }","","    let hasher = DummyHasher;","    let map: HashMap<i32, i32, DummyHasher> = HashMap::with_capacity_and_hasher(10, hasher);","    assert_eq!(map.table.len(), 0); // assuming RawTable has a method to get current length","}"],[]],[["{","    struct DummyHasher;","    impl BuildHasher for DummyHasher {","        type Hasher = std::collections::hash_map::DefaultHasher;","        fn build_hasher(&self) -> Self::Hasher {","            std::collections::hash_map::DefaultHasher::new()","        }","    }","","    let hasher = DummyHasher;","    let capacity = usize::MAX; // testing upper boundary","    let map: HashMap<i32, i32, DummyHasher> = HashMap::with_capacity_and_hasher(capacity, hasher);","    assert_eq!(map.table.len(), 0); // assuming RawTable has a method to get current length","}"],[]]]}