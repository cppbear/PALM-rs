{"function_name":"hashbrown::raw::bitmask::raw::bitmask::BitMask::trailing_zeros","tests":2,"tests_lines":[23,8],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":10,"lines_covered":9,"lines_coveraged_rate":90.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[59,60,61,62,63,64,65,66,68,70],"codes_lines_covered":[[["{","    const BITMASK_STRIDE: usize = 8; // Assuming a stride of 8 for this test.","    ","    // Scenario 1: All bits are set","    let bitmask_all_set = BitMask(0b11111111); // This should have 0 trailing zeros","    assert_eq!(bitmask_all_set.trailing_zeros(), 0);","    ","    // Scenario 2: One bit set at position 0","    let bitmask_one_set = BitMask(0b00000001); // This should have 3 trailing zeros (1 zero for each bit in stride)","    assert_eq!(bitmask_one_set.trailing_zeros(), 3);","    ","    // Scenario 3: One bit set at position 1","    let bitmask_position_1 = BitMask(0b00000010); // This should have 2 trailing zeros","    assert_eq!(bitmask_position_1.trailing_zeros(), 2);","    ","    // Scenario 4: One bit set at position 2","    let bitmask_position_2 = BitMask(0b00000100); // This should have 1 trailing zero","    assert_eq!(bitmask_position_2.trailing_zeros(), 1);","    ","    // Scenario 5: No bits set (0)","    let bitmask_none_set = BitMask(0b00000000); // This should have 8 trailing zeros","    assert_eq!(bitmask_none_set.trailing_zeros(), 8);","}"],[59,60,61,62,63,64,65,68,70]],[["{","    const BITMASK_STRIDE: usize = 8; // Assuming a stride of 8 for this test.","    ","    // Scenario 6: For non-ARM architectures, similar cases can be done.","    // Testing this requires non-ARM architecture; hence, assume this behavior in a hypothetical context.","    let bitmask_for_non_arm = BitMask(0b00000010); // This should still have 2 trailing zeros","    assert_eq!(bitmask_for_non_arm.trailing_zeros(), 2);","}"],[59,60,61,62,63,64,65,68,70]]],"codes_branches":[{"start_line":65,"start_column":41,"end_line":65,"end_column":64,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    const BITMASK_STRIDE: usize = 8; // Assuming a stride of 8 for this test.","    ","    // Scenario 1: All bits are set","    let bitmask_all_set = BitMask(0b11111111); // This should have 0 trailing zeros","    assert_eq!(bitmask_all_set.trailing_zeros(), 0);","    ","    // Scenario 2: One bit set at position 0","    let bitmask_one_set = BitMask(0b00000001); // This should have 3 trailing zeros (1 zero for each bit in stride)","    assert_eq!(bitmask_one_set.trailing_zeros(), 3);","    ","    // Scenario 3: One bit set at position 1","    let bitmask_position_1 = BitMask(0b00000010); // This should have 2 trailing zeros","    assert_eq!(bitmask_position_1.trailing_zeros(), 2);","    ","    // Scenario 4: One bit set at position 2","    let bitmask_position_2 = BitMask(0b00000100); // This should have 1 trailing zero","    assert_eq!(bitmask_position_2.trailing_zeros(), 1);","    ","    // Scenario 5: No bits set (0)","    let bitmask_none_set = BitMask(0b00000000); // This should have 8 trailing zeros","    assert_eq!(bitmask_none_set.trailing_zeros(), 8);","}"],[{"start_line":65,"start_column":41,"end_line":65,"end_column":64,"positive":false,"negative":false}]],[["{","    const BITMASK_STRIDE: usize = 8; // Assuming a stride of 8 for this test.","    ","    // Scenario 6: For non-ARM architectures, similar cases can be done.","    // Testing this requires non-ARM architecture; hence, assume this behavior in a hypothetical context.","    let bitmask_for_non_arm = BitMask(0b00000010); // This should still have 2 trailing zeros","    assert_eq!(bitmask_for_non_arm.trailing_zeros(), 2);","}"],[{"start_line":65,"start_column":41,"end_line":65,"end_column":64,"positive":false,"negative":false}]]]}