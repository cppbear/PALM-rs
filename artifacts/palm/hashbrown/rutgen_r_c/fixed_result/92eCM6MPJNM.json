{"function_name":"hashbrown::map::map::HashMap<K, V, S, A>::into_keys","tests":5,"tests_lines":[6,8,10,9,9],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1033,1034,1035,1036,1037],"codes_lines_covered":[[["{","    let map: HashMap<&str, i32> = HashMap::new();","    let keys: IntoKeys<_, _, _> = map.into_keys();","    let vec: Vec<&str> = keys.collect();","    assert!(vec.is_empty());","}"],[1033,1034,1035,1036,1037]],[["{","    let mut map: HashMap<&str, i32> = HashMap::new();","    map.insert(\"single\", 42);","    let mut keys: IntoKeys<_, _, _> = map.into_keys();","    let vec: Vec<&str> = keys.collect();","    assert_eq!(vec.len(), 1);","    assert_eq!(vec[0], \"single\");","}"],[1033,1034,1035,1036,1037]],[["{","    let mut map: HashMap<&str, i32> = HashMap::new();","    map.insert(\"a\", 1);","    map.insert(\"b\", 2);","    map.insert(\"c\", 3);","    let mut keys: IntoKeys<_, _, _> = map.into_keys();","    let mut vec: Vec<&str> = keys.collect();","    vec.sort_unstable();","    assert_eq!(vec, [\"a\", \"b\", \"c\"]);","}"],[1033,1034,1035,1036,1037]],[["{","    let mut map: HashMap<&str, i32> = HashMap::new();","    map.insert(\"a\", 1);","    let keys: IntoKeys<_, _, _> = map.into_keys();","    let _vec: Vec<&str> = keys.collect();","    // Trying to access the map after calling into_keys should panic","    // However, as per the instruction, we do not add this checking.","    // This is to showcase the intended use only.","}"],[1033,1034,1035,1036,1037]],[["{","    let mut map: HashMap<&str, i32> = HashMap::with_capacity_and_hasher_in(10, DefaultHashBuilder::default(), Global);","    map.insert(\"x\", 100);","    map.insert(\"y\", 200);","    let mut keys: IntoKeys<_, _, _> = map.into_keys();","    let mut vec: Vec<&str> = keys.collect();","    vec.sort_unstable();","    assert_eq!(vec, [\"x\", \"y\"]);","}"],[1033,1034,1035,1036,1037]]],"codes_branches":[],"codes_branches_covered":[[["{","    let map: HashMap<&str, i32> = HashMap::new();","    let keys: IntoKeys<_, _, _> = map.into_keys();","    let vec: Vec<&str> = keys.collect();","    assert!(vec.is_empty());","}"],[]],[["{","    let mut map: HashMap<&str, i32> = HashMap::new();","    map.insert(\"single\", 42);","    let mut keys: IntoKeys<_, _, _> = map.into_keys();","    let vec: Vec<&str> = keys.collect();","    assert_eq!(vec.len(), 1);","    assert_eq!(vec[0], \"single\");","}"],[]],[["{","    let mut map: HashMap<&str, i32> = HashMap::new();","    map.insert(\"a\", 1);","    map.insert(\"b\", 2);","    map.insert(\"c\", 3);","    let mut keys: IntoKeys<_, _, _> = map.into_keys();","    let mut vec: Vec<&str> = keys.collect();","    vec.sort_unstable();","    assert_eq!(vec, [\"a\", \"b\", \"c\"]);","}"],[]],[["{","    let mut map: HashMap<&str, i32> = HashMap::new();","    map.insert(\"a\", 1);","    let keys: IntoKeys<_, _, _> = map.into_keys();","    let _vec: Vec<&str> = keys.collect();","    // Trying to access the map after calling into_keys should panic","    // However, as per the instruction, we do not add this checking.","    // This is to showcase the intended use only.","}"],[]],[["{","    let mut map: HashMap<&str, i32> = HashMap::with_capacity_and_hasher_in(10, DefaultHashBuilder::default(), Global);","    map.insert(\"x\", 100);","    map.insert(\"y\", 200);","    let mut keys: IntoKeys<_, _, _> = map.into_keys();","    let mut vec: Vec<&str> = keys.collect();","    vec.sort_unstable();","    assert_eq!(vec, [\"x\", \"y\"]);","}"],[]]]}