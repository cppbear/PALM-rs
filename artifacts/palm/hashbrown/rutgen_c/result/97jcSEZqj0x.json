{"function_name":"hashbrown::raw_entry::raw_entry::RawOccupiedEntryMut<'a, K, V, S, A>::into_key_value","tests":2,"tests_lines":[32,15],"oracles":2,"oracles_compiled":1,"oracles_compiled_rate":50.0,"tests_compiled":1,"tests_compiled_rate":50.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1146,1147,1148,1149,1150,1151],"codes_lines_covered":[[["{","    use crate::hash_map::{HashMap, RawEntryMut};","    use std::rc::Rc;","","    let key_one = Rc::new(\"a\");","    let key_two = Rc::new(\"a\");","","    let mut map: HashMap<Rc<&str>, u32> = HashMap::new();","    map.insert(key_one.clone(), 10);","","    assert_eq!(map[&key_one], 10);","    assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);","","    let tuple;","    let inside_key: &mut Rc<&str>;","    let inside_value: &mut u32;","","    match map.raw_entry_mut().from_key(&key_one) {","        RawEntryMut::Vacant(_) => panic!(),","        RawEntryMut::Occupied(o) => {","            tuple = o.into_key_value();","            inside_key = tuple.0;","            inside_value = tuple.1;","        }","    }","    ","    *inside_key = key_two.clone();","    *inside_value = 100;","","    assert_eq!(map[&key_two], 100);","    assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);","}"],[1146,1147,1148,1149,1150,1151]]],"codes_branches":[],"codes_branches_covered":[[["{","    use crate::hash_map::{HashMap, RawEntryMut};","    use std::rc::Rc;","","    let key_one = Rc::new(\"a\");","    let key_two = Rc::new(\"a\");","","    let mut map: HashMap<Rc<&str>, u32> = HashMap::new();","    map.insert(key_one.clone(), 10);","","    assert_eq!(map[&key_one], 10);","    assert!(Rc::strong_count(&key_one) == 2 && Rc::strong_count(&key_two) == 1);","","    let tuple;","    let inside_key: &mut Rc<&str>;","    let inside_value: &mut u32;","","    match map.raw_entry_mut().from_key(&key_one) {","        RawEntryMut::Vacant(_) => panic!(),","        RawEntryMut::Occupied(o) => {","            tuple = o.into_key_value();","            inside_key = tuple.0;","            inside_value = tuple.1;","        }","    }","    ","    *inside_key = key_two.clone();","    *inside_value = 100;","","    assert_eq!(map[&key_two], 100);","    assert!(Rc::strong_count(&key_one) == 1 && Rc::strong_count(&key_two) == 2);","}"],[]]]}