{
  "name": "hashbrown::set::set::HashSet<T, S, A>::insert_unique_unchecked",
  "name_with_impl": "hashbrown::set::{impl#6}::insert_unique_unchecked",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:71:1:71:9"
  },
  "visible": true,
  "loc": "src/set.rs:1118:5:1120:6",
  "doc": "/// Insert a value the set without checking if the value already exists in the set.\n///\n/// This operation is faster than regular insert, because it does not perform\n/// lookup before insertion.\n///\n/// This operation is useful during initial population of the set.\n/// For example, when constructing a set from another set, we know\n/// that values are unique.\n///\n/// # Safety\n///\n/// This operation is safe if a value does not exist in the set.\n///\n/// However, if a value exists in the set already, the behavior is unspecified:\n/// this operation may panic, loop forever, or any following operation with the set\n/// may panic, loop forever or return arbitrary result.\n///\n/// That said, this operation (and following operations) are guaranteed to\n/// not violate memory safety.\n///\n/// However this operation is still unsafe because the resulting `HashSet`\n/// may be passed to unsafe code which does expect the set to behave\n/// correctly, and would cause unsoundness as a result.\n",
  "code": [
    "pub unsafe fn insert_unique_unchecked(&mut self, value: T) -> &T {",
    "    self.map.insert_unique_unchecked(value, ()).0",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.map.insert_unique_unchecked(value, ())",
          "norm": null,
          "value": "",
          "line": 1119,
          "bound": null,
          "may_panic": true
        }
      ],
      "ret": "self.map.insert_unique_unchecked(value, ()).0",
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}