{
  "name": "hashbrown::raw::raw::RawTableInner::rehash_in_place",
  "name_with_impl": "hashbrown::raw::{impl#13}::rehash_in_place",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:2925:5:3006:6",
  "doc": "/// Rehashes the contents of the table in place (i.e. without changing the\n/// allocation).\n///\n/// If `hasher` panics then some the table's contents may be lost.\n///\n/// This uses dynamic dispatch to reduce the amount of\n/// code generated, but it is eliminated by LLVM optimizations when inlined.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is [`undefined behavior`]:\n///\n/// * The `size_of` must be equal to the size of the elements stored in the table;\n///\n/// * The `drop` function (`fn(*mut u8)`) must be the actual drop function of\n///   the elements stored in the table.\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes.\n///\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "code": [
    "unsafe fn rehash_in_place(",
    "    &mut self,",
    "    hasher: &dyn Fn(&mut Self, usize) -> u64,",
    "    size_of: usize,",
    "    drop: Option<unsafe fn(*mut u8)>,",
    ") {",
    "    // If the hash function panics then properly clean up any elements",
    "    // that we haven't rehashed yet. We unfortunately can't preserve the",
    "    // element since we lost their hash and have no way of recovering it",
    "    // without risking another panic.",
    "    self.prepare_rehash_in_place();",
    "",
    "    let mut guard = guard(self, move |self_| {",
    "        if let Some(drop) = drop {",
    "            for i in 0..self_.buckets() {",
    "                if *self_.ctrl(i) == Tag::DELETED {",
    "                    self_.set_ctrl(i, Tag::EMPTY);",
    "                    drop(self_.bucket_ptr(i, size_of));",
    "                    self_.items -= 1;",
    "                }",
    "            }",
    "        }",
    "        self_.growth_left = bucket_mask_to_capacity(self_.bucket_mask) - self_.items;",
    "    });",
    "",
    "    // At this point, DELETED elements are elements that we haven't",
    "    // rehashed yet. Find them and re-insert them at their ideal",
    "    // position.",
    "    'outer: for i in 0..guard.buckets() {",
    "        if *guard.ctrl(i) != Tag::DELETED {",
    "            continue;",
    "        }",
    "",
    "        let i_p = guard.bucket_ptr(i, size_of);",
    "",
    "        'inner: loop {",
    "            // Hash the current item",
    "            let hash = hasher(*guard, i);",
    "",
    "            // Search for a suitable place to put it",
    "            //",
    "            // SAFETY: Caller of this function ensures that the control bytes",
    "            // are properly initialized.",
    "            let new_i = guard.find_insert_slot(hash).index;",
    "",
    "            // Probing works by scanning through all of the control",
    "            // bytes in groups, which may not be aligned to the group",
    "            // size. If both the new and old position fall within the",
    "            // same unaligned group, then there is no benefit in moving",
    "            // it and we can just continue to the next item.",
    "            if likely(guard.is_in_same_group(i, new_i, hash)) {",
    "                guard.set_ctrl_hash(i, hash);",
    "                continue 'outer;",
    "            }",
    "",
    "            let new_i_p = guard.bucket_ptr(new_i, size_of);",
    "",
    "            // We are moving the current item to a new position. Write",
    "            // our H2 to the control byte of the new position.",
    "            let prev_ctrl = guard.replace_ctrl_hash(new_i, hash);",
    "            if prev_ctrl == Tag::EMPTY {",
    "                guard.set_ctrl(i, Tag::EMPTY);",
    "                // If the target slot is empty, simply move the current",
    "                // element into the new slot and clear the old control",
    "                // byte.",
    "                ptr::copy_nonoverlapping(i_p, new_i_p, size_of);",
    "                continue 'outer;",
    "            } else {",
    "                // If the target slot is occupied, swap the two elements",
    "                // and then continue processing the element that we just",
    "                // swapped into the old slot.",
    "                debug_assert_eq!(prev_ctrl, Tag::DELETED);",
    "                ptr::swap_nonoverlapping(i_p, new_i_p, size_of);",
    "                continue 'inner;",
    "            }",
    "        }",
    "    }",
    "",
    "    guard.growth_left = bucket_mask_to_capacity(guard.bucket_mask) - guard.items;",
    "",
    "    mem::forget(guard);",
    "}"
  ],
  "size": {
    "chain": 6,
    "contra": 4,
    "min_set": 5
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "true",
          "line": 2953,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*guard.ctrl(i) != Tag::DELETED",
          "norm": null,
          "value": "true",
          "line": 2954,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "false",
          "line": 2953,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        16,
        51,
        6,
        7,
        8,
        10,
        12,
        52,
        53,
        54,
        55,
        56,
        57,
        58
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "true",
          "line": 2953,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*guard.ctrl(i) != Tag::DELETED",
          "norm": null,
          "value": "false",
          "line": 2954,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "likely(guard.is_in_same_group(i, new_i, hash))",
          "norm": null,
          "value": "true",
          "line": 2975,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "false",
          "line": 2953,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        50,
        51,
        6,
        7,
        8,
        10,
        12,
        52,
        53,
        54,
        55,
        56,
        57,
        58
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "true",
          "line": 2953,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*guard.ctrl(i) != Tag::DELETED",
          "norm": null,
          "value": "false",
          "line": 2954,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "likely(guard.is_in_same_group(i, new_i, hash))",
          "norm": null,
          "value": "false",
          "line": 2975,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "prev_ctrl == Tag::EMPTY",
          "norm": "Tag::EMPTY == prev_ctrl",
          "value": "true",
          "line": 2985,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "false",
          "line": 2953,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        50,
        51,
        6,
        7,
        8,
        10,
        12,
        52,
        53,
        54,
        55,
        56,
        57,
        58
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "true",
          "line": 2953,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*guard.ctrl(i) != Tag::DELETED",
          "norm": null,
          "value": "false",
          "line": 2954,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "likely(guard.is_in_same_group(i, new_i, hash))",
          "norm": null,
          "value": "false",
          "line": 2975,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "prev_ctrl == Tag::EMPTY",
          "norm": "Tag::EMPTY == prev_ctrl",
          "value": "false",
          "line": 2985,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "true",
          "line": 40,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "likely(guard.is_in_same_group(i, new_i, hash))",
          "norm": null,
          "value": "true",
          "line": 2975,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "false",
          "line": 2953,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        32,
        33,
        34,
        35,
        36,
        37,
        42,
        43,
        44,
        45,
        48,
        49,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        50,
        51,
        6,
        7,
        8,
        10,
        12,
        52,
        53,
        54,
        55,
        56,
        57,
        58
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "true",
          "line": 2953,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*guard.ctrl(i) != Tag::DELETED",
          "norm": null,
          "value": "false",
          "line": 2954,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "likely(guard.is_in_same_group(i, new_i, hash))",
          "norm": null,
          "value": "false",
          "line": 2975,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "prev_ctrl == Tag::EMPTY",
          "norm": "Tag::EMPTY == prev_ctrl",
          "value": "false",
          "line": 2985,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "(*left_val == *right_val)",
          "norm": null,
          "value": "false",
          "line": 40,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        11,
        13,
        14,
        15,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        32,
        33,
        34,
        35,
        36,
        37,
        42,
        43,
        44,
        46,
        60,
        61
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "i in 0..guard.buckets()",
          "norm": null,
          "value": "false",
          "line": 2953,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        10,
        12,
        52,
        53,
        54,
        55,
        56,
        57,
        58
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}