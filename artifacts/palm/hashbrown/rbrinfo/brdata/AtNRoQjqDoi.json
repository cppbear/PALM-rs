{
  "name": "hashbrown::raw::raw::RawTable<T, A>::resize",
  "name_with_impl": "hashbrown::raw::{impl#9}::resize",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:1093:5:1112:6",
  "doc": "/// Allocates a new table of a different size and moves the contents of the\n/// current table into it.\n///\n/// # Safety\n///\n/// The [`RawTableInner`] must have properly initialized control bytes,\n/// otherwise calling this function results in [`undefined behavior`]\n///\n/// The caller of this function must ensure that `capacity >= self.table.items`\n/// otherwise:\n///\n/// * If `self.table.items != 0`, calling of this function with `capacity`\n///   equal to 0 (`capacity == 0`) results in [`undefined behavior`].\n///\n/// * If `capacity_to_buckets(capacity) < Group::WIDTH` and\n///   `self.table.items > capacity_to_buckets(capacity)`\n///   calling this function results in [`undefined behavior`].\n///\n/// * If `capacity_to_buckets(capacity) >= Group::WIDTH` and\n///   `self.table.items > capacity_to_buckets(capacity)`\n///   calling this function are never return (will go into an\n///   infinite loop).\n///\n/// See [`RawTableInner::find_insert_slot`] for more information.\n///\n/// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "code": [
    "unsafe fn resize(",
    "    &mut self,",
    "    capacity: usize,",
    "    hasher: impl Fn(&T) -> u64,",
    "    fallibility: Fallibility,",
    ") -> Result<(), TryReserveError> {",
    "    // SAFETY:",
    "    // 1. The caller of this function guarantees that `capacity >= self.table.items`.",
    "    // 2. We know for sure that `alloc` and `layout` matches the [`Allocator`] and",
    "    //    [`TableLayout`] that were used to allocate this table.",
    "    // 3. The caller ensures that the control bytes of the `RawTableInner`",
    "    //    are already initialized.",
    "    self.table.resize_inner(",
    "        &self.alloc,",
    "        capacity,",
    "        &|table, index| hasher(table.bucket::<T>(index).as_ref()),",
    "        fallibility,",
    "        Self::TABLE_LAYOUT,",
    "    )",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}