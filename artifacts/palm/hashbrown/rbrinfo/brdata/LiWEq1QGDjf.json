{
  "name": "hashbrown::raw::raw::FullBucketsIndices::next_impl",
  "name_with_impl": "hashbrown::raw::{impl#32}::next_impl",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:3836:5:3873:6",
  "doc": "/// Advances the iterator and returns the next value.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is\n/// [`Undefined Behavior`]:\n///\n/// * The [`RawTableInner`] / [`RawTable`] must be alive and not moved,\n///   i.e. table outlives the `FullBucketsIndices`;\n///\n/// * It never tries to iterate after getting all elements.\n///\n/// [`Undefined Behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "code": [
    "unsafe fn next_impl(&mut self) -> Option<usize> {",
    "    loop {",
    "        if let Some(index) = self.current_group.next() {",
    "            // The returned `self.group_first_index + index` will always",
    "            // be in the range `0..self.buckets()`. See explanation below.",
    "            return Some(self.group_first_index + index);",
    "        }",
    "",
    "        // SAFETY: The caller of this function ensures that:",
    "        //",
    "        // 1. It never tries to iterate after getting all the elements;",
    "        // 2. The table is alive and did not moved;",
    "        // 3. The first `self.ctrl` pointed to the start of the array of control bytes.",
    "        //",
    "        // Taking the above into account, we always stay within the bounds, because:",
    "        //",
    "        // 1. For tables smaller than the group width (self.buckets() <= Group::WIDTH),",
    "        //    we will never end up in the given branch, since we should have already",
    "        //    yielded all the elements of the table.",
    "        //",
    "        // 2. For tables larger than the group width. The number of buckets is a",
    "        //    power of two (2 ^ n), Group::WIDTH is also power of two (2 ^ k). Since",
    "        //    `(2 ^ n) > (2 ^ k)`, than `(2 ^ n) % (2 ^ k) = 0`. As we start from the",
    "        //    the start of the array of control bytes, and never try to iterate after",
    "        //    getting all the elements, the last `self.ctrl` will be equal to",
    "        //    the `self.buckets() - Group::WIDTH`, so `self.current_group.next()`",
    "        //    will always contains indices within the range `0..Group::WIDTH`,",
    "        //    and subsequent `self.group_first_index + index` will always return a",
    "        //    number less than `self.buckets()`.",
    "        self.ctrl = NonNull::new_unchecked(self.ctrl.as_ptr().add(Group::WIDTH));",
    "",
    "        // SAFETY: See explanation above.",
    "        self.current_group = Group::load_aligned(self.ctrl.as_ptr().cast())",
    "            .match_full()",
    "            .into_iter();",
    "        self.group_first_index += Group::WIDTH;",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 1,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.current_group.next() matches Some(index)",
          "norm": null,
          "value": "false",
          "line": 3838,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.current_group.next() matches Some(index)",
          "norm": null,
          "value": "true",
          "line": 3838,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(self.group_first_index + index)",
      "path": [
        0,
        1,
        2,
        3,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.current_group.next() matches Some(index)",
          "norm": null,
          "value": "true",
          "line": 3838,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(self.group_first_index + index)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}