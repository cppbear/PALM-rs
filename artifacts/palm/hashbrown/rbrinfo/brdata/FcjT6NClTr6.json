{
  "name": "hashbrown::set::set::HashSet<T, S, A>::entry",
  "name_with_impl": "hashbrown::set::{impl#6}::entry",
  "mod_info": {
    "name": "set",
    "loc": "src/lib.rs:71:1:71:9"
  },
  "visible": true,
  "loc": "src/set.rs:998:5:1003:6",
  "doc": "/// Gets the given value's corresponding entry in the set for in-place manipulation.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashSet;\n/// use hashbrown::hash_set::Entry::*;\n///\n/// let mut singles = HashSet::new();\n/// let mut dupes = HashSet::new();\n///\n/// for ch in \"a short treatise on fungi\".chars() {\n///     if let Vacant(dupe_entry) = dupes.entry(ch) {\n///         // We haven't already seen a duplicate, so\n///         // check if we've at least seen it once.\n///         match singles.entry(ch) {\n///             Vacant(single_entry) => {\n///                 // We found a new character for the first time.\n///                 single_entry.insert();\n///             }\n///             Occupied(single_entry) => {\n///                 // We've already seen this once, \"move\" it to dupes.\n///                 single_entry.remove();\n///                 dupe_entry.insert();\n///             }\n///         }\n///     }\n/// }\n///\n/// assert!(!singles.contains(&'t') && dupes.contains(&'t'));\n/// assert!(singles.contains(&'u') && !dupes.contains(&'u'));\n/// assert!(!singles.contains(&'v') && !dupes.contains(&'v'));\n/// ```\n",
  "code": [
    "pub fn entry(&mut self, value: T) -> Entry<'_, T, S, A> {",
    "    match self.map.entry(value) {",
    "        map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { inner: entry }),",
    "        map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry { inner: entry }),",
    "    }",
    "}"
  ],
  "size": {
    "chain": 2,
    "contra": 0,
    "min_set": 2
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.map.entry(value) matches map::Entry::Vacant(entry)",
          "norm": null,
          "value": "true",
          "line": 999,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Entry::Vacant(VacantEntry { inner: entry })",
      "path": [
        0,
        1,
        4,
        6,
        7,
        8,
        9,
        10,
        11
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.map.entry(value) matches map::Entry::Occupied(entry)",
          "norm": null,
          "value": "true",
          "line": 999,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.map.entry(value) matches map::Entry::Occupied(entry)",
          "norm": null,
          "value": "true",
          "line": 999,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Entry::Occupied(OccupiedEntry { inner: entry })",
      "path": [
        0,
        1,
        3,
        5,
        9,
        10,
        11
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}