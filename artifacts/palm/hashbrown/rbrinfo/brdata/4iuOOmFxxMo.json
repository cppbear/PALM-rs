{
  "name": "hashbrown::raw::raw::RawTableInner::resize_inner",
  "name_with_impl": "hashbrown::raw::{impl#13}::resize_inner",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:2828:5:2898:6",
  "doc": "/// Allocates a new table of a different size and moves the contents of the\n/// current table into it.\n///\n/// This uses dynamic dispatch to reduce the amount of\n/// code generated, but it is eliminated by LLVM optimizations when inlined.\n///\n/// # Safety\n///\n/// If any of the following conditions are violated, the result is\n/// [`undefined behavior`]:\n///\n/// * The `alloc` must be the same [`Allocator`] as the `Allocator` used\n///   to allocate this table;\n///\n/// * The `layout` must be the same [`TableLayout`] as the `TableLayout`\n///   used to allocate this table;\n///\n/// * The [`RawTableInner`] must have properly initialized control bytes.\n///\n/// The caller of this function must ensure that `capacity >= self.items`\n/// otherwise:\n///\n/// * If `self.items != 0`, calling of this function with `capacity == 0`\n///   results in [`undefined behavior`].\n///\n/// * If `capacity_to_buckets(capacity) < Group::WIDTH` and\n///   `self.items > capacity_to_buckets(capacity)` calling this function\n///   results in [`undefined behavior`].\n///\n/// * If `capacity_to_buckets(capacity) >= Group::WIDTH` and\n///   `self.items > capacity_to_buckets(capacity)` calling this function\n///   are never return (will go into an infinite loop).\n///\n/// Note: It is recommended (but not required) that the new table's `capacity`\n/// be greater than or equal to `self.items`. In case if `capacity <= self.items`\n/// this function can never return. See [`RawTableInner::find_insert_slot`] for\n/// more information.\n///\n/// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "code": [
    "unsafe fn resize_inner<A>(",
    "    &mut self,",
    "    alloc: &A,",
    "    capacity: usize,",
    "    hasher: &dyn Fn(&mut Self, usize) -> u64,",
    "    fallibility: Fallibility,",
    "    layout: TableLayout,",
    ") -> Result<(), TryReserveError>",
    "where",
    "    A: Allocator,",
    "{",
    "    // SAFETY: We know for sure that `alloc` and `layout` matches the [`Allocator`] and [`TableLayout`]",
    "    // that were used to allocate this table.",
    "    let mut new_table = self.prepare_resize(alloc, layout, capacity, fallibility)?;",
    "",
    "    // SAFETY: We know for sure that RawTableInner will outlive the",
    "    // returned `FullBucketsIndices` iterator, and the caller of this",
    "    // function ensures that the control bytes are properly initialized.",
    "    for full_byte_index in self.full_buckets_indices() {",
    "        // This may panic.",
    "        let hash = hasher(self, full_byte_index);",
    "",
    "        // SAFETY:",
    "        // We can use a simpler version of insert() here since:",
    "        // 1. There are no DELETED entries.",
    "        // 2. We know there is enough space in the table.",
    "        // 3. All elements are unique.",
    "        // 4. The caller of this function guarantees that `capacity > 0`",
    "        //    so `new_table` must already have some allocated memory.",
    "        // 5. We set `growth_left` and `items` fields of the new table",
    "        //    after the loop.",
    "        // 6. We insert into the table, at the returned index, the data",
    "        //    matching the given hash immediately after calling this function.",
    "        let (new_index, _) = new_table.prepare_insert_slot(hash);",
    "",
    "        // SAFETY:",
    "        //",
    "        // * `src` is valid for reads of `layout.size` bytes, since the",
    "        //   table is alive and the `full_byte_index` is guaranteed to be",
    "        //   within bounds (see `FullBucketsIndices::next_impl`);",
    "        //",
    "        // * `dst` is valid for writes of `layout.size` bytes, since the",
    "        //   caller ensures that `table_layout` matches the [`TableLayout`]",
    "        //   that was used to allocate old table and we have the `new_index`",
    "        //   returned by `prepare_insert_slot`.",
    "        //",
    "        // * Both `src` and `dst` are properly aligned.",
    "        //",
    "        // * Both `src` and `dst` point to different region of memory.",
    "        ptr::copy_nonoverlapping(",
    "            self.bucket_ptr(full_byte_index, layout.size),",
    "            new_table.bucket_ptr(new_index, layout.size),",
    "            layout.size,",
    "        );",
    "    }",
    "",
    "    // The hash function didn't panic, so we can safely set the",
    "    // `growth_left` and `items` fields of the new table.",
    "    new_table.growth_left -= self.items;",
    "    new_table.items = self.items;",
    "",
    "    // We successfully copied all elements without panicking. Now replace",
    "    // self with the new table. The old table will have its memory freed but",
    "    // the items will not be dropped (since they have been moved into the",
    "    // new table).",
    "    // SAFETY: The caller ensures that `table_layout` matches the [`TableLayout`]",
    "    // that was used to allocate this table.",
    "    mem::swap(self, &mut new_table);",
    "",
    "    Ok(())",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 1,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.prepare_resize(alloc, layout, capacity, fallibility)?",
          "norm": null,
          "value": "Err/None",
          "line": 2841,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        6,
        7,
        32,
        33
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.prepare_resize(alloc, layout, capacity, fallibility)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2841,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "full_byte_index in self.full_buckets_indices()",
          "norm": null,
          "value": "true",
          "line": 2846,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "full_byte_index in self.full_buckets_indices()",
          "norm": null,
          "value": "false",
          "line": 2846,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Ok(())",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        17,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        12,
        13,
        14,
        16,
        18,
        26,
        27,
        28,
        29,
        30,
        31,
        33
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "self.prepare_resize(alloc, layout, capacity, fallibility)?",
          "norm": null,
          "value": "Ok/Some",
          "line": 2841,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "full_byte_index in self.full_buckets_indices()",
          "norm": null,
          "value": "false",
          "line": 2846,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Ok(())",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        16,
        18,
        26,
        27,
        28,
        29,
        30,
        31,
        33
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}