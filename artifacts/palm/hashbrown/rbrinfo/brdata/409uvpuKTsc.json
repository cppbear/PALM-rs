{
  "name": "hashbrown::raw::raw::RawTableInner::set_ctrl",
  "name_with_impl": "hashbrown::raw::{impl#13}::set_ctrl",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:2517:5:2547:6",
  "doc": "/// Sets a control byte, and possibly also the replicated control byte at\n/// the end of the array.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// You must observe the following safety rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n///\n/// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "code": [
    "unsafe fn set_ctrl(&mut self, index: usize, ctrl: Tag) {",
    "    // Replicate the first Group::WIDTH control bytes at the end of",
    "    // the array without using a branch. If the tables smaller than",
    "    // the group width (self.buckets() < Group::WIDTH),",
    "    // `index2 = Group::WIDTH + index`, otherwise `index2` is:",
    "    //",
    "    // - If index >= Group::WIDTH then index == index2.",
    "    // - Otherwise index2 == self.bucket_mask + 1 + index.",
    "    //",
    "    // The very last replicated control byte is never actually read because",
    "    // we mask the initial index for unaligned loads, but we write it",
    "    // anyways because it makes the set_ctrl implementation simpler.",
    "    //",
    "    // If there are fewer buckets than Group::WIDTH then this code will",
    "    // replicate the buckets at the end of the trailing group. For example",
    "    // with 2 buckets and a group size of 4, the control bytes will look",
    "    // like this:",
    "    //",
    "    //     Real    |             Replicated",
    "    // ---------------------------------------------",
    "    // | [A] | [B] | [Tag::EMPTY] | [EMPTY] | [A] | [B] |",
    "    // ---------------------------------------------",
    "",
    "    // This is the same as `(index.wrapping_sub(Group::WIDTH)) % self.buckets() + Group::WIDTH`",
    "    // because the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.",
    "    let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;",
    "",
    "    // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::set_ctrl`]",
    "    *self.ctrl(index) = ctrl;",
    "    *self.ctrl(index2) = ctrl;",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}