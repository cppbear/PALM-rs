{
  "name": "hashbrown::raw::raw::RawTableInner::prepare_insert_slot",
  "name_with_impl": "hashbrown::raw::{impl#13}::prepare_insert_slot",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:1860:5:1872:6",
  "doc": "/// Searches for an empty or deleted bucket which is suitable for inserting a new\n/// element and sets the hash for that slot. Returns an index of that slot and the\n/// old control byte stored in the found index.\n///\n/// This function does not check if the given element exists in the table. Also,\n/// this function does not check if there is enough space in the table to insert\n/// a new element. The caller of the function must make sure that the table has at\n/// least 1 empty or deleted `bucket`, otherwise this function will never return\n/// (will go into an infinite loop) for tables larger than the group width, or\n/// return an index outside of the table indices range if the table is less than\n/// the group width.\n///\n/// If there is at least 1 empty or deleted `bucket` in the table, the function is\n/// guaranteed to return an `index` in the range `0..self.buckets()`, but in any case,\n/// if this function returns an `index` it will be in the range `0..=self.buckets()`.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// The safety rules are directly derived from the safety rules for the\n/// [`RawTableInner::set_ctrl_hash`] and [`RawTableInner::find_insert_slot`] methods.\n/// Thus, in order to uphold the safety contracts for that methods, as well as for\n/// the correct logic of the work of this crate, you must observe the following rules\n/// when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated and has properly initialized\n///   control bytes otherwise calling this function results in [`undefined behavior`].\n///\n/// * The caller of this function must ensure that the \"data\" parts of the table\n///   will have an entry in the returned index (matching the given hash) right\n///   after calling this function.\n///\n/// Attempt to write data at the `index` returned by this function when the table is\n/// less than the group width and if there was not at least one empty or deleted bucket in\n/// the table will cause immediate [`undefined behavior`]. This is because in this case the\n/// function will return `self.bucket_mask + 1` as an index due to the trailing [`Tag::EMPTY`]\n/// control bytes outside the table range.\n///\n/// The caller must independently increase the `items` field of the table, and also,\n/// if the old control byte was [`Tag::EMPTY`], then decrease the table's `growth_left`\n/// field, and do not change it if the old control byte was [`Tag::DELETED`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n/// [`RawTableInner::ctrl`]: RawTableInner::ctrl\n/// [`RawTableInner::set_ctrl_hash`]: RawTableInner::set_ctrl_hash\n/// [`RawTableInner::find_insert_slot`]: RawTableInner::find_insert_slot\n",
  "code": [
    "unsafe fn prepare_insert_slot(&mut self, hash: u64) -> (usize, Tag) {",
    "    // SAFETY: Caller of this function ensures that the control bytes are properly initialized.",
    "    let index: usize = self.find_insert_slot(hash).index;",
    "    // SAFETY:",
    "    // 1. The `find_insert_slot` function either returns an `index` less than or",
    "    //    equal to `self.buckets() = self.bucket_mask + 1` of the table, or never",
    "    //    returns if it cannot find an empty or deleted slot.",
    "    // 2. The caller of this function guarantees that the table has already been",
    "    //    allocated",
    "    let old_ctrl = *self.ctrl(index);",
    "    self.set_ctrl_hash(index, hash);",
    "    (index, old_ctrl)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "(index, old_ctrl)",
      "path": [
        0,
        1,
        2,
        3
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}