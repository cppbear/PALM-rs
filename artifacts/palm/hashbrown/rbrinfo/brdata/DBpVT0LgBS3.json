{
  "name": "hashbrown::table::table::HashTable<T, A>::extract_if",
  "name_with_impl": "hashbrown::table::{impl#1}::extract_if",
  "mod_info": {
    "name": "table",
    "loc": "src/lib.rs:72:1:72:11"
  },
  "visible": true,
  "loc": "src/table.rs:950:5:961:6",
  "doc": "/// Drains elements which are true under the given predicate,\n/// and returns an iterator over the removed items.\n///\n/// In other words, move all elements `e` such that `f(&e)` returns `true` out\n/// into another iterator.\n///\n/// If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n/// or the iteration short-circuits, then the remaining elements will be retained.\n/// Use [`retain()`] with a negated predicate if you do not need the returned iterator.\n///\n/// [`retain()`]: HashTable::retain\n///\n/// # Examples\n///\n/// ```\n/// # #[cfg(feature = \"nightly\")]\n/// # fn test() {\n/// use hashbrown::{HashTable, DefaultHashBuilder};\n/// use std::hash::BuildHasher;\n///\n/// let mut table = HashTable::new();\n/// let hasher = DefaultHashBuilder::default();\n/// let hasher = |val: &_| hasher.hash_one(val);\n/// for x in 0..8 {\n///     table.insert_unique(hasher(&x), x, hasher);\n/// }\n/// let drained: Vec<i32> = table.extract_if(|&mut v| v % 2 == 0).collect();\n///\n/// let mut evens = drained.into_iter().collect::<Vec<_>>();\n/// let mut odds = table.into_iter().collect::<Vec<_>>();\n/// evens.sort();\n/// odds.sort();\n///\n/// assert_eq!(evens, vec![0, 2, 4, 6]);\n/// assert_eq!(odds, vec![1, 3, 5, 7]);\n/// # }\n/// # fn main() {\n/// #     #[cfg(feature = \"nightly\")]\n/// #     test()\n/// # }\n/// ```\n",
  "code": [
    "pub fn extract_if<F>(&mut self, f: F) -> ExtractIf<'_, T, F, A>",
    "where",
    "    F: FnMut(&mut T) -> bool,",
    "{",
    "    ExtractIf {",
    "        f,",
    "        inner: RawExtractIf {",
    "            iter: unsafe { self.raw.iter() },",
    "            table: &mut self.raw,",
    "        },",
    "    }",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "ExtractIf {\n            f,\n            inner: RawExtractIf {\n                iter: unsafe { self.raw.iter() },\n                table: &mut self.raw,\n            },\n        }",
      "path": [
        0,
        1,
        2,
        3
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}