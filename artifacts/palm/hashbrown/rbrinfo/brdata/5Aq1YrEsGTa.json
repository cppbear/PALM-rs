{
  "name": "hashbrown::map::map::HashMap<K, V, S, A>::retain",
  "name_with_impl": "hashbrown::map::{impl#4}::retain",
  "mod_info": {
    "name": "map",
    "loc": "src/lib.rs:65:1:65:9"
  },
  "visible": true,
  "loc": "src/map.rs:915:5:928:6",
  "doc": "/// Retains only the elements specified by the predicate. Keeps the\n/// allocated memory for reuse.\n///\n/// In other words, remove all pairs `(k, v)` such that `f(&k, &mut v)` returns `false`.\n/// The elements are visited in unsorted (and unspecified) order.\n///\n/// # Examples\n///\n/// ```\n/// use hashbrown::HashMap;\n///\n/// let mut map: HashMap<i32, i32> = (0..8).map(|x|(x, x*10)).collect();\n/// assert_eq!(map.len(), 8);\n///\n/// map.retain(|&k, _| k % 2 == 0);\n///\n/// // We can see, that the number of elements inside map is changed.\n/// assert_eq!(map.len(), 4);\n///\n/// let mut vec: Vec<(i32, i32)> = map.iter().map(|(&k, &v)| (k, v)).collect();\n/// vec.sort_unstable();\n/// assert_eq!(vec, [(0, 0), (2, 20), (4, 40), (6, 60)]);\n/// ```\n",
  "code": [
    "pub fn retain<F>(&mut self, mut f: F)",
    "where",
    "    F: FnMut(&K, &mut V) -> bool,",
    "{",
    "    // Here we only use `iter` as a temporary, preventing use-after-free",
    "    unsafe {",
    "        for item in self.table.iter() {",
    "            let &mut (ref key, ref mut value) = item.as_mut();",
    "            if !f(key, value) {",
    "                self.table.erase(item);",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 2,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "item in self.table.iter()",
          "norm": null,
          "value": "true",
          "line": 921,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "f(key, value)",
          "norm": null,
          "value": "true",
          "line": 923,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "item in self.table.iter()",
          "norm": null,
          "value": "false",
          "line": 921,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        11,
        12,
        15,
        3,
        4,
        5,
        7,
        9,
        16
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "item in self.table.iter()",
          "norm": null,
          "value": "true",
          "line": 921,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "f(key, value)",
          "norm": null,
          "value": "false",
          "line": 923,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "item in self.table.iter()",
          "norm": null,
          "value": "false",
          "line": 921,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        8,
        10,
        11,
        13,
        14,
        15,
        3,
        4,
        5,
        7,
        9,
        16
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "item in self.table.iter()",
          "norm": null,
          "value": "false",
          "line": 921,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        16
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}