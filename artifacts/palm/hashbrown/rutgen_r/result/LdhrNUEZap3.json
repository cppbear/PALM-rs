{"function_name":"hashbrown::raw::raw::RawIterRange<T>::fold_impl","tests":11,"tests_lines":[26,29,31,35,57,34,76,49,45,54,50],"oracles":11,"oracles_compiled":1,"oracles_compiled_rate":9.090909090909092,"tests_compiled":1,"tests_compiled_rate":9.090909090909092,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":47,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[3609,3610,3611,3612,3614,3617,3618,3619,3620,3623,3624,3625,3626,3627,3628,3629,3630,3631,3632,3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,3649,3650,3651,3652,3653,3654,3655,3656,3657,3658,3659,3661],"codes_lines_covered":[[["{","    struct Dummy {","        current_group: Group,","        data: Vec<usize>,","        index: usize,","    }","","    struct Group {","        elements: usize,","    }","","    impl Group {","        fn next(&mut self) -> Option<usize> {","            if self.elements > 0 {","                self.elements -= 1;","                Some(self.elements)","            } else {","                None","            }","        }","","        fn load_aligned(ptr: *const usize) -> Self {","            Group { elements: unsafe { *ptr } }","        }","    }","","    impl Dummy {","        unsafe fn fold_impl<F, B>(mut self, mut n: usize, mut acc: B, mut f: F) -> B","        where","            F: FnMut(B, usize) -> B,","        {","            loop {","                while let Some(index) = self.current_group.next() {","                    debug_assert!(n != 0);","                    let bucket = self.data[index];","                    acc = f(acc, bucket);","                    n -= 1;","                }","","                if n == 0 {","                    return acc;","                }","","                self.current_group = Group::load_aligned(&self.index);","                self.data = vec![1, 2, 3, 4]; // Non-empty data for testing","                self.index += 1;","            }","        }","    }","","    unsafe {","        let group = Group { elements: 4 };","        let dummy = Dummy { current_group: group, data: vec![1, 2, 3, 4], index: 0 };","        let result: usize = dummy.fold_impl(4, 0, |acc, x| acc + x);","        assert_eq!(result, 10); // 1 + 2 + 3 + 4 = 10","    }","}"],[]]],"codes_branches":[{"start_line":3614,"start_column":23,"end_line":3614,"end_column":34,"positive":false,"negative":false},{"start_line":3623,"start_column":16,"end_line":3623,"end_column":22,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct Dummy {","        current_group: Group,","        data: Vec<usize>,","        index: usize,","    }","","    struct Group {","        elements: usize,","    }","","    impl Group {","        fn next(&mut self) -> Option<usize> {","            if self.elements > 0 {","                self.elements -= 1;","                Some(self.elements)","            } else {","                None","            }","        }","","        fn load_aligned(ptr: *const usize) -> Self {","            Group { elements: unsafe { *ptr } }","        }","    }","","    impl Dummy {","        unsafe fn fold_impl<F, B>(mut self, mut n: usize, mut acc: B, mut f: F) -> B","        where","            F: FnMut(B, usize) -> B,","        {","            loop {","                while let Some(index) = self.current_group.next() {","                    debug_assert!(n != 0);","                    let bucket = self.data[index];","                    acc = f(acc, bucket);","                    n -= 1;","                }","","                if n == 0 {","                    return acc;","                }","","                self.current_group = Group::load_aligned(&self.index);","                self.data = vec![1, 2, 3, 4]; // Non-empty data for testing","                self.index += 1;","            }","        }","    }","","    unsafe {","        let group = Group { elements: 4 };","        let dummy = Dummy { current_group: group, data: vec![1, 2, 3, 4], index: 0 };","        let result: usize = dummy.fold_impl(4, 0, |acc, x| acc + x);","        assert_eq!(result, 10); // 1 + 2 + 3 + 4 = 10","    }","}"],[{"start_line":3614,"start_column":23,"end_line":3614,"end_column":34,"positive":false,"negative":false},{"start_line":3623,"start_column":16,"end_line":3623,"end_column":22,"positive":false,"negative":false}]]]}