{"function_name":"hashbrown::raw::raw::RawTable<T, A>::insert","tests":4,"tests_lines":[64,63,11,12],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":2,"tests_compiled_rate":50.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":24,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1140,1141,1142],"codes_lines_covered":[[["{","    struct TestTable {","        growth_left: usize,","        ctrl: Vec<u8>,","    }","","    impl TestTable {","        fn new() -> Self {","            Self {","                growth_left: 1,","                ctrl: vec![0; 10], // assuming control bytes initialized","            }","        }","","        fn find_insert_slot(&self, _hash: u64) -> InsertSlot {","            InsertSlot { index: 0 } // returning a valid index","        }","","        fn buckets(&self) -> usize {","            self.ctrl.len()","        }","    }","","    struct Bucket<T> {","        _value: T,","    }","","    struct InsertSlot {","        index: usize,","    }","","    struct RawTable {","        table: TestTable,","    }","","    impl RawTable {","        fn insert(&mut self, hash: u64, value: i32) -> Bucket<i32> {","            unsafe {","                let mut slot = self.table.find_insert_slot(hash);","                let old_ctrl = self.table.ctrl[slot.index];","","                if self.table.growth_left == 0 && old_ctrl == 0 { // simulating empty control","                    panic!(\"Should not enter this branch as growth_left is not 0\");","                }","","                self.insert_in_slot(hash, slot, value)","            }","        }","","        unsafe fn insert_in_slot(&mut self, _hash: u64, _slot: InsertSlot, value: i32) -> Bucket<i32> {","            Bucket { _value: value } // returning the bucket with the value","        }","    }","","    let mut raw_table = RawTable {","        table: TestTable::new(),","    };","","    let hash = 12345u64;","    let value = 42;","    let result = raw_table.insert(hash, value);","","    assert_eq!(result._value, 42);","}"],[]],[["{","    struct TestTable {","        growth_left: usize,","        ctrl: Vec<u8>,","    }","","    impl TestTable {","        fn new(growth: usize) -> Self {","            Self {","                growth_left: growth,","                ctrl: vec![0; 10],","            }","        }","","        fn find_insert_slot(&self, _hash: u64) -> InsertSlot {","            InsertSlot { index: 0 }","        }","","        fn buckets(&self) -> usize {","            self.ctrl.len()","        }","    }","","    struct Bucket<T> {","        _value: T,","    }","","    struct InsertSlot {","        index: usize,","    }","","    struct RawTable {","        table: TestTable,","    }","","    impl RawTable {","        fn insert(&mut self, hash: u64, value: i32) -> Bucket<i32> {","            unsafe {","                let mut slot = self.table.find_insert_slot(hash);","                let old_ctrl = self.table.ctrl[slot.index];","","                if self.table.growth_left == 0 && old_ctrl == 0 {","                    // This will trigger the panic for test purposes","                    panic!(\"Should not enter this branch as growth_left is not 0\");","                }","","                self.insert_in_slot(hash, slot, value)","            }","        }","","        unsafe fn insert_in_slot(&mut self, _hash: u64, _slot: InsertSlot, value: i32) -> Bucket<i32> {","            Bucket { _value: value }","        }","    }","","    let mut raw_table = RawTable {","        table: TestTable::new(0), // Setting growth_left to 0 to induce panic","    };","","    let hash = 12345u64;","    let value = 42;","    let _result = raw_table.insert(hash, value); // Expecting this to panic","}"],[]]],"codes_branches":[{"start_line":1133,"start_column":16,"end_line":1133,"end_column":84,"positive":false,"negative":false},{"start_line":1133,"start_column":25,"end_line":1133,"end_column":52,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestTable {","        growth_left: usize,","        ctrl: Vec<u8>,","    }","","    impl TestTable {","        fn new() -> Self {","            Self {","                growth_left: 1,","                ctrl: vec![0; 10], // assuming control bytes initialized","            }","        }","","        fn find_insert_slot(&self, _hash: u64) -> InsertSlot {","            InsertSlot { index: 0 } // returning a valid index","        }","","        fn buckets(&self) -> usize {","            self.ctrl.len()","        }","    }","","    struct Bucket<T> {","        _value: T,","    }","","    struct InsertSlot {","        index: usize,","    }","","    struct RawTable {","        table: TestTable,","    }","","    impl RawTable {","        fn insert(&mut self, hash: u64, value: i32) -> Bucket<i32> {","            unsafe {","                let mut slot = self.table.find_insert_slot(hash);","                let old_ctrl = self.table.ctrl[slot.index];","","                if self.table.growth_left == 0 && old_ctrl == 0 { // simulating empty control","                    panic!(\"Should not enter this branch as growth_left is not 0\");","                }","","                self.insert_in_slot(hash, slot, value)","            }","        }","","        unsafe fn insert_in_slot(&mut self, _hash: u64, _slot: InsertSlot, value: i32) -> Bucket<i32> {","            Bucket { _value: value } // returning the bucket with the value","        }","    }","","    let mut raw_table = RawTable {","        table: TestTable::new(),","    };","","    let hash = 12345u64;","    let value = 42;","    let result = raw_table.insert(hash, value);","","    assert_eq!(result._value, 42);","}"],[{"start_line":1133,"start_column":16,"end_line":1133,"end_column":84,"positive":false,"negative":false},{"start_line":1133,"start_column":25,"end_line":1133,"end_column":52,"positive":false,"negative":false}]],[["{","    struct TestTable {","        growth_left: usize,","        ctrl: Vec<u8>,","    }","","    impl TestTable {","        fn new(growth: usize) -> Self {","            Self {","                growth_left: growth,","                ctrl: vec![0; 10],","            }","        }","","        fn find_insert_slot(&self, _hash: u64) -> InsertSlot {","            InsertSlot { index: 0 }","        }","","        fn buckets(&self) -> usize {","            self.ctrl.len()","        }","    }","","    struct Bucket<T> {","        _value: T,","    }","","    struct InsertSlot {","        index: usize,","    }","","    struct RawTable {","        table: TestTable,","    }","","    impl RawTable {","        fn insert(&mut self, hash: u64, value: i32) -> Bucket<i32> {","            unsafe {","                let mut slot = self.table.find_insert_slot(hash);","                let old_ctrl = self.table.ctrl[slot.index];","","                if self.table.growth_left == 0 && old_ctrl == 0 {","                    // This will trigger the panic for test purposes","                    panic!(\"Should not enter this branch as growth_left is not 0\");","                }","","                self.insert_in_slot(hash, slot, value)","            }","        }","","        unsafe fn insert_in_slot(&mut self, _hash: u64, _slot: InsertSlot, value: i32) -> Bucket<i32> {","            Bucket { _value: value }","        }","    }","","    let mut raw_table = RawTable {","        table: TestTable::new(0), // Setting growth_left to 0 to induce panic","    };","","    let hash = 12345u64;","    let value = 42;","    let _result = raw_table.insert(hash, value); // Expecting this to panic","}"],[{"start_line":1133,"start_column":16,"end_line":1133,"end_column":84,"positive":false,"negative":false},{"start_line":1133,"start_column":25,"end_line":1133,"end_column":52,"positive":false,"negative":false}]]]}