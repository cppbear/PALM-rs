{"function_name":"hashbrown::raw::raw::RawTableInner::probe_seq","tests":2,"tests_lines":[37,31],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[2399,2400,2401,2402,2403,2404,2405,2406],"codes_lines_covered":[[["{","    struct Table {","        bucket_mask: usize,","    }","","    impl Table {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % 16) as usize // Simulating a hash function, assuming 16 buckets","    }","","    let table = Table { bucket_mask: 15 }; // 16 buckets, bucket_mask = 15","","    // Test with various hashes","    for hash in &[0u64, 1u64, 14u64, 15u64, 16u64, 17u64] {","        let probe_seq = table.probe_seq(*hash);","        let expected_pos = h1(*hash) & table.bucket_mask;","        assert_eq!(probe_seq.pos, expected_pos);","        assert_eq!(probe_seq.stride, 0);","    }","}"],[]],[["{","    struct Table {","        bucket_mask: usize,","    }","","    impl Table {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % 16) as usize","    }","","    let table = Table { bucket_mask: 0 }; // Invalid case, should cause panic","","    let _ = table.probe_seq(1u64); // This should trigger a panic in a real scenario as it would lead to division/modulus by zero.","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Table {","        bucket_mask: usize,","    }","","    impl Table {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % 16) as usize // Simulating a hash function, assuming 16 buckets","    }","","    let table = Table { bucket_mask: 15 }; // 16 buckets, bucket_mask = 15","","    // Test with various hashes","    for hash in &[0u64, 1u64, 14u64, 15u64, 16u64, 17u64] {","        let probe_seq = table.probe_seq(*hash);","        let expected_pos = h1(*hash) & table.bucket_mask;","        assert_eq!(probe_seq.pos, expected_pos);","        assert_eq!(probe_seq.stride, 0);","    }","}"],[]],[["{","    struct Table {","        bucket_mask: usize,","    }","","    impl Table {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % 16) as usize","    }","","    let table = Table { bucket_mask: 0 }; // Invalid case, should cause panic","","    let _ = table.probe_seq(1u64); // This should trigger a panic in a real scenario as it would lead to division/modulus by zero.","}"],[]]]}