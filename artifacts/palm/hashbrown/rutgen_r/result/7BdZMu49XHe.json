{"function_name":"hashbrown::raw::bitmask::raw::bitmask::BitMask::lowest_set_bit","tests":3,"tests_lines":[36,50,33],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[49,50,51,53,55],"codes_lines_covered":[[["{","    struct BitMask(u64);","","    impl BitMask {","        pub(crate) fn lowest_set_bit(self) -> Option<usize> {","            if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {","                Some(Self::nonzero_trailing_zeros(nonzero))","            } else {","                None","            }","        }","    }","","    struct NonZeroBitMaskWord(u64);","","    impl NonZeroBitMaskWord {","        pub fn new(value: u64) -> Option<Self> {","            if value != 0 {","                Some(NonZeroBitMaskWord(value))","            } else {","                None","            }","        }","    }","","    impl BitMask {","        pub fn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize {","            let value = nonzero.0;","            value.trailing_zeros() as usize","        }","    }","","    // Test case where the BitMask has no bits set (value of 0)","    let bitmask_zero = BitMask(0);","    assert_eq!(bitmask_zero.lowest_set_bit(), None);","}"],[]],[["{","    struct BitMask(u64);","    ","    impl BitMask {","        pub(crate) fn lowest_set_bit(self) -> Option<usize> {","            if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {","                Some(Self::nonzero_trailing_zeros(nonzero))","            } else {","                None","            }","        }","","        fn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize {","            // implementation to calculate trailing zeros; assume it returns a usize","            nonzero.0.trailing_zeros() as usize","        }","    }","","    struct NonZeroBitMaskWord(u64);","","    impl NonZeroBitMaskWord {","        pub fn new(value: u64) -> Option<Self> {","            if value != 0 {","                Some(Self(value))","            } else {","                None","            }","        }","    }","","    // Test case 1: Lowest set bit at position 0 (value = 1)","    let bitmask_1 = BitMask(1);","    assert_eq!(bitmask_1.lowest_set_bit(), Some(0));","","    // Test case 2: Lowest set bit at position 1 (value = 2)","    let bitmask_2 = BitMask(2);","    assert_eq!(bitmask_2.lowest_set_bit(), Some(1));","","    // Test case 3: Lowest set bit at position 3 (value = 8)","    let bitmask_3 = BitMask(8);","    assert_eq!(bitmask_3.lowest_set_bit(), Some(3));","","    // Test case 4: Lowest set bit at position 5 (value = 32)","    let bitmask_4 = BitMask(32);","    assert_eq!(bitmask_4.lowest_set_bit(), Some(5));","","    // Test case 5: Lowest set bit at position 63 (value = 0x8000000000000000)","    let bitmask_5 = BitMask(0x8000000000000000);","    assert_eq!(bitmask_5.lowest_set_bit(), Some(63));","}"],[]],[["{","    struct BitMask(u64);","    ","    impl BitMask {","        pub(crate) fn lowest_set_bit(self) -> Option<usize> {","            if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {","                Some(Self::nonzero_trailing_zeros(nonzero))","            } else {","                None","            }","        }","","        fn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize {","            nonzero.0.trailing_zeros() as usize","        }","    }","","    struct NonZeroBitMaskWord(u64);","","    impl NonZeroBitMaskWord {","        pub fn new(value: u64) -> Option<Self> {","            if value != 0 {","                Some(Self(value))","            } else {","                None","            }","        }","    }","","    // Test case: Bitmask is zero","    let bitmask = BitMask(0);","    assert_eq!(bitmask.lowest_set_bit(), None);","}"],[]]],"codes_branches":[{"start_line":50,"start_column":16,"end_line":50,"end_column":29,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct BitMask(u64);","","    impl BitMask {","        pub(crate) fn lowest_set_bit(self) -> Option<usize> {","            if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {","                Some(Self::nonzero_trailing_zeros(nonzero))","            } else {","                None","            }","        }","    }","","    struct NonZeroBitMaskWord(u64);","","    impl NonZeroBitMaskWord {","        pub fn new(value: u64) -> Option<Self> {","            if value != 0 {","                Some(NonZeroBitMaskWord(value))","            } else {","                None","            }","        }","    }","","    impl BitMask {","        pub fn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize {","            let value = nonzero.0;","            value.trailing_zeros() as usize","        }","    }","","    // Test case where the BitMask has no bits set (value of 0)","    let bitmask_zero = BitMask(0);","    assert_eq!(bitmask_zero.lowest_set_bit(), None);","}"],[{"start_line":50,"start_column":16,"end_line":50,"end_column":29,"positive":false,"negative":false}]],[["{","    struct BitMask(u64);","    ","    impl BitMask {","        pub(crate) fn lowest_set_bit(self) -> Option<usize> {","            if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {","                Some(Self::nonzero_trailing_zeros(nonzero))","            } else {","                None","            }","        }","","        fn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize {","            // implementation to calculate trailing zeros; assume it returns a usize","            nonzero.0.trailing_zeros() as usize","        }","    }","","    struct NonZeroBitMaskWord(u64);","","    impl NonZeroBitMaskWord {","        pub fn new(value: u64) -> Option<Self> {","            if value != 0 {","                Some(Self(value))","            } else {","                None","            }","        }","    }","","    // Test case 1: Lowest set bit at position 0 (value = 1)","    let bitmask_1 = BitMask(1);","    assert_eq!(bitmask_1.lowest_set_bit(), Some(0));","","    // Test case 2: Lowest set bit at position 1 (value = 2)","    let bitmask_2 = BitMask(2);","    assert_eq!(bitmask_2.lowest_set_bit(), Some(1));","","    // Test case 3: Lowest set bit at position 3 (value = 8)","    let bitmask_3 = BitMask(8);","    assert_eq!(bitmask_3.lowest_set_bit(), Some(3));","","    // Test case 4: Lowest set bit at position 5 (value = 32)","    let bitmask_4 = BitMask(32);","    assert_eq!(bitmask_4.lowest_set_bit(), Some(5));","","    // Test case 5: Lowest set bit at position 63 (value = 0x8000000000000000)","    let bitmask_5 = BitMask(0x8000000000000000);","    assert_eq!(bitmask_5.lowest_set_bit(), Some(63));","}"],[{"start_line":50,"start_column":16,"end_line":50,"end_column":29,"positive":false,"negative":false}]],[["{","    struct BitMask(u64);","    ","    impl BitMask {","        pub(crate) fn lowest_set_bit(self) -> Option<usize> {","            if let Some(nonzero) = NonZeroBitMaskWord::new(self.0) {","                Some(Self::nonzero_trailing_zeros(nonzero))","            } else {","                None","            }","        }","","        fn nonzero_trailing_zeros(nonzero: NonZeroBitMaskWord) -> usize {","            nonzero.0.trailing_zeros() as usize","        }","    }","","    struct NonZeroBitMaskWord(u64);","","    impl NonZeroBitMaskWord {","        pub fn new(value: u64) -> Option<Self> {","            if value != 0 {","                Some(Self(value))","            } else {","                None","            }","        }","    }","","    // Test case: Bitmask is zero","    let bitmask = BitMask(0);","    assert_eq!(bitmask.lowest_set_bit(), None);","}"],[{"start_line":50,"start_column":16,"end_line":50,"end_column":29,"positive":false,"negative":false}]]]}