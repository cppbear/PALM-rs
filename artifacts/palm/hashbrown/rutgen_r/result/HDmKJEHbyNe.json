{"function_name":"hashbrown::raw::raw::RawTableInner::rehash_in_place","tests":11,"tests_lines":[61,52,47,44,14,14,11,21,18,63,62],"oracles":11,"oracles_compiled":5,"oracles_compiled_rate":45.45454545454545,"tests_compiled":5,"tests_compiled_rate":45.45454545454545,"oracles_run":5,"oracles_passed":3,"oracles_passed_rate":60.0,"tests_run":5,"tests_passed":3,"tests_passed_rate":60.0,"lines":66,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":10,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[2925,2926,2927,2928,2929,2930,2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,2944,2946,2947,2948,2953,2954,2955,2956,2957,2958,2962,2963,2964,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2996,2997,2998,3003,3004,3005,3006],"codes_lines_covered":[[["{","        unsafe {","            let mut table = RawTableInner::new(10);","            for i in 0..10 {","                table.set_ctrl(i, Tag::DELETED);","            }","","            let hasher = |_: &mut RawTableInner, _: usize| 5; // Choose a fixed hash to create a conflict","","            rehash_in_place(&mut table, &hasher, std::mem::size_of::<u8>(), None);","            ","            assert!(table.ctrl.iter().all(|&c| c == Tag::EMPTY));","        }","    }"],[]],[["{","        unsafe {","            let mut table = RawTableInner::new(10);","            for i in 0..10 {","                table.set_ctrl(i, Tag::DELETED);","            }","","            let hasher = |_: &mut RawTableInner, _: usize| 20; // A hash that guarantees overflow","","            rehash_in_place(&mut table, &hasher, std::mem::size_of::<u8>(), None);","            ","            assert!(table.ctrl.iter().all(|c| *c == Tag::EMPTY));","        }","    }"],[]],[["{","        unsafe {","            let mut table = RawTableInner::new(10);","            ","            let hasher = |_: &mut RawTableInner, _: usize| panic!(\"Hashed to panic!\");","","            table.set_ctrl(0, Tag::DELETED); // Induce a deletion again","","            rehash_in_place(&mut table, &hasher, std::mem::size_of::<u8>(), None);","        }","    }"],[]],[["{","        let size_of = std::mem::size_of::<u8>();","        let mut table = RawTableInner {","            items: 5,","            bucket_mask: 0b00001111,","            growth_left: 5,","            ctrl: vec![Tag::DELETED, Tag::DELETED, Tag::EMPTY, Tag::DELETED],","            buckets: vec![0u8; 4],","        };","","        let hasher = |_: &mut RawTableInner, _: usize| {","            42 // Mocked hash value","        };","","        unsafe {","            rehash_in_place(&mut table, &hasher, size_of, None);","        }","","        // Ensure items have been rehashed correctly","        assert_eq!(table.items, 5);","    }"],[]],[["{","        let size_of = std::mem::size_of::<u8>();","        let mut table = RawTableInner {","            items: 5,","            bucket_mask: 0b00001111,","            growth_left: 5,","            ctrl: vec![Tag::DELETED, Tag::DELETED, Tag::DELETED, Tag::DELETED],","            buckets: vec![0u8; 4],","        };","","        let hasher = |_: &mut RawTableInner, _: usize| {","            panic!(\"Forcing a panic in hasher\");","        };","","        unsafe {","            rehash_in_place(&mut table, &hasher, size_of, None);","        }","    }"],[]]],"codes_branches":[{"start_line":2954,"start_column":16,"end_line":2954,"end_column":46,"positive":false,"negative":false},{"start_line":2975,"start_column":20,"end_line":2975,"end_column":66,"positive":false,"negative":false},{"start_line":2985,"start_column":20,"end_line":2985,"end_column":43,"positive":false,"negative":false},{"start_line":2938,"start_column":20,"end_line":2938,"end_column":30,"positive":false,"negative":false},{"start_line":2940,"start_column":24,"end_line":2940,"end_column":54,"positive":false,"negative":false}],"codes_branches_covered":[[["{","        unsafe {","            let mut table = RawTableInner::new(10);","            for i in 0..10 {","                table.set_ctrl(i, Tag::DELETED);","            }","","            let hasher = |_: &mut RawTableInner, _: usize| 5; // Choose a fixed hash to create a conflict","","            rehash_in_place(&mut table, &hasher, std::mem::size_of::<u8>(), None);","            ","            assert!(table.ctrl.iter().all(|&c| c == Tag::EMPTY));","        }","    }"],[{"start_line":2954,"start_column":16,"end_line":2954,"end_column":46,"positive":false,"negative":false},{"start_line":2975,"start_column":20,"end_line":2975,"end_column":66,"positive":false,"negative":false},{"start_line":2985,"start_column":20,"end_line":2985,"end_column":43,"positive":false,"negative":false},{"start_line":2938,"start_column":20,"end_line":2938,"end_column":30,"positive":false,"negative":false},{"start_line":2940,"start_column":24,"end_line":2940,"end_column":54,"positive":false,"negative":false}]],[["{","        unsafe {","            let mut table = RawTableInner::new(10);","            for i in 0..10 {","                table.set_ctrl(i, Tag::DELETED);","            }","","            let hasher = |_: &mut RawTableInner, _: usize| 20; // A hash that guarantees overflow","","            rehash_in_place(&mut table, &hasher, std::mem::size_of::<u8>(), None);","            ","            assert!(table.ctrl.iter().all(|c| *c == Tag::EMPTY));","        }","    }"],[{"start_line":2954,"start_column":16,"end_line":2954,"end_column":46,"positive":false,"negative":false},{"start_line":2975,"start_column":20,"end_line":2975,"end_column":66,"positive":false,"negative":false},{"start_line":2985,"start_column":20,"end_line":2985,"end_column":43,"positive":false,"negative":false},{"start_line":2938,"start_column":20,"end_line":2938,"end_column":30,"positive":false,"negative":false},{"start_line":2940,"start_column":24,"end_line":2940,"end_column":54,"positive":false,"negative":false}]],[["{","        unsafe {","            let mut table = RawTableInner::new(10);","            ","            let hasher = |_: &mut RawTableInner, _: usize| panic!(\"Hashed to panic!\");","","            table.set_ctrl(0, Tag::DELETED); // Induce a deletion again","","            rehash_in_place(&mut table, &hasher, std::mem::size_of::<u8>(), None);","        }","    }"],[{"start_line":2954,"start_column":16,"end_line":2954,"end_column":46,"positive":false,"negative":false},{"start_line":2975,"start_column":20,"end_line":2975,"end_column":66,"positive":false,"negative":false},{"start_line":2985,"start_column":20,"end_line":2985,"end_column":43,"positive":false,"negative":false},{"start_line":2938,"start_column":20,"end_line":2938,"end_column":30,"positive":false,"negative":false},{"start_line":2940,"start_column":24,"end_line":2940,"end_column":54,"positive":false,"negative":false}]],[["{","        let size_of = std::mem::size_of::<u8>();","        let mut table = RawTableInner {","            items: 5,","            bucket_mask: 0b00001111,","            growth_left: 5,","            ctrl: vec![Tag::DELETED, Tag::DELETED, Tag::EMPTY, Tag::DELETED],","            buckets: vec![0u8; 4],","        };","","        let hasher = |_: &mut RawTableInner, _: usize| {","            42 // Mocked hash value","        };","","        unsafe {","            rehash_in_place(&mut table, &hasher, size_of, None);","        }","","        // Ensure items have been rehashed correctly","        assert_eq!(table.items, 5);","    }"],[{"start_line":2954,"start_column":16,"end_line":2954,"end_column":46,"positive":false,"negative":false},{"start_line":2975,"start_column":20,"end_line":2975,"end_column":66,"positive":false,"negative":false},{"start_line":2985,"start_column":20,"end_line":2985,"end_column":43,"positive":false,"negative":false},{"start_line":2938,"start_column":20,"end_line":2938,"end_column":30,"positive":false,"negative":false},{"start_line":2940,"start_column":24,"end_line":2940,"end_column":54,"positive":false,"negative":false}]],[["{","        let size_of = std::mem::size_of::<u8>();","        let mut table = RawTableInner {","            items: 5,","            bucket_mask: 0b00001111,","            growth_left: 5,","            ctrl: vec![Tag::DELETED, Tag::DELETED, Tag::DELETED, Tag::DELETED],","            buckets: vec![0u8; 4],","        };","","        let hasher = |_: &mut RawTableInner, _: usize| {","            panic!(\"Forcing a panic in hasher\");","        };","","        unsafe {","            rehash_in_place(&mut table, &hasher, size_of, None);","        }","    }"],[{"start_line":2954,"start_column":16,"end_line":2954,"end_column":46,"positive":false,"negative":false},{"start_line":2975,"start_column":20,"end_line":2975,"end_column":66,"positive":false,"negative":false},{"start_line":2985,"start_column":20,"end_line":2985,"end_column":43,"positive":false,"negative":false},{"start_line":2938,"start_column":20,"end_line":2938,"end_column":30,"positive":false,"negative":false},{"start_line":2940,"start_column":24,"end_line":2940,"end_column":54,"positive":false,"negative":false}]]]}