{"function_name":"hashbrown::raw::raw::RawTable<T, A>::new_uninitialized","tests":44,"tests_lines":[12,13,13,13,13,13,13,13,13,13,14,14,14,13,11,15,15,15,10,16,17,17,8,8,9,9,10,10,11,12,12,10,14,14,14,12,12,13,13,12,13,13,13,13],"oracles":16,"oracles_compiled":4,"oracles_compiled_rate":25.0,"tests_compiled":15,"tests_compiled_rate":34.090909090909086,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":15,"tests_passed":8,"tests_passed_rate":53.333333333333336,"lines":15,"lines_covered":15,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734],"codes_lines_covered":[[["{","    let alloc = Global;","    let buckets = 1073741825; // Exceeds maximum limit","    let fallibility = Fallibility::Fallible;","    unsafe {","        RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility);","    }","    let alloc = Global;","    let buckets = 1073741825;","    let fallibility = Fallibility::Fallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility) };","    assert!(result.is_err());","}"],[717,718,719,720,721,722]],[["{","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.unwrap().table.bucket_mask == buckets - 1);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 3);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(!buckets.is_power_of_two());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 1024);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets.is_power_of_two());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let table = result.unwrap();","    assert!(table.capacity() >= buckets);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    assert!(std::panic::catch_unwind(|| { unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) }}).is_err());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().buckets(), buckets);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().capacity(), bucket_mask_to_capacity(buckets - 1));","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]]],"codes_branches":[],"codes_branches_covered":[[["{","    let alloc = Global;","    let buckets = 1073741825; // Exceeds maximum limit","    let fallibility = Fallibility::Fallible;","    unsafe {","        RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility);","    }","    let alloc = Global;","    let buckets = 1073741825;","    let fallibility = Fallibility::Fallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility) };","    assert!(result.is_err());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.unwrap().table.bucket_mask == buckets - 1);","}"],[]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 3);","}"],[]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(!buckets.is_power_of_two());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 1024);","}"],[]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets.is_power_of_two());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let table = result.unwrap();","    assert!(table.capacity() >= buckets);","}"],[]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    assert!(std::panic::catch_unwind(|| { unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) }}).is_err());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().buckets(), buckets);","}"],[]],[["{","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().capacity(), bucket_mask_to_capacity(buckets - 1));","}"],[]]]}