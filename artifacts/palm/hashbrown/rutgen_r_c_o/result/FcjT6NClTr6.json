{"function_name":"hashbrown::set::set::HashSet<T, S, A>::entry","tests":15,"tests_lines":[7,7,7,7,8,7,18,18,15,15,27,27,27,27,27],"oracles":9,"oracles_compiled":8,"oracles_compiled_rate":88.88888888888889,"tests_compiled":10,"tests_compiled_rate":66.66666666666666,"oracles_run":8,"oracles_passed":8,"oracles_passed_rate":100.0,"tests_run":10,"tests_passed":10,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[998,999,1000,1001,1003],"codes_lines_covered":[[["{","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(1);","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(1);","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[998,999,1001,1003]],[["{","    let mut set: HashSet<char> = HashSet::new();","    let entry = set.entry('a');","    let mut set: HashSet<char> = HashSet::new();","    let entry = set.entry('a');","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[998,999,1001,1003]],[["{","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(2);","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(2);","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[998,999,1001,1003]],[["{","    let mut set: HashSet<char> = HashSet::new();","    let entry_a = set.entry('a');","    let entry_b = set.entry('b');","    let entry_a = set.entry('a');","    assert!(matches!(entry_a, Entry::Vacant(_)));","}"],[998,999,1001,1003]],[["{","    let mut set: HashSet<char> = HashSet::new();","    let entry_a = set.entry('a');","    let entry_b = set.entry('b');","    let entry_a = set.entry('a');","    let entry_b = set.entry('b');","    assert!(matches!(entry_b, Entry::Vacant(_)));","}"],[998,999,1001,1003]],[["{","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(10);","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(10);","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[998,999,1001,1003]],[["{","    let mut set: HashSet<char> = HashSet::new();","    set.insert('a');","    set.insert('b');","","    let entry_a = set.entry('a');","    match entry_a {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 'a'\"),","    }","    let mut set: HashSet<char> = HashSet::new();","    set.insert('a');","    set.insert('b');","    let entry_a = set.entry('a');","    assert!(matches!(entry_a, Entry::Occupied(_)));","}"],[998,999,1000,1003]],[["{","    let mut set: HashSet<i32> = HashSet::new();","    set.insert(1);","    set.insert(2);","","    let entry_1 = set.entry(1);","    match entry_1 {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 1\"),","    }","    let mut set: HashSet<i32> = HashSet::new();","    set.insert(1);","    set.insert(2);","    let entry_1 = set.entry(1);","    assert!(matches!(entry_1, Entry::Occupied(_)));","}"],[998,999,1000,1003]],[["{","    let mut set: HashSet<String> = HashSet::new();","    set.insert(\"foo\".to_string());","    set.insert(\"bar\".to_string());","","    let entry_foo = set.entry(\"foo\".to_string());","    match entry_foo {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 'foo'\"),","    }","    let entry_foo = set.entry(\"foo\".to_string());","    assert!(matches!(entry_foo, Entry::Occupied(_)));","}"],[998,999,1000,1003]],[["{","    let mut set: HashSet<String> = HashSet::new();","    set.insert(\"foo\".to_string());","    set.insert(\"bar\".to_string());","","    let entry_foo = set.entry(\"foo\".to_string());","    match entry_foo {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 'foo'\"),","    }","    let entry_foo = set.entry(\"foo\".to_string());","    assert!(set.contains(&\"foo\".to_string()));","}"],[998,999,1000,1003]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(1);","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(1);","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[]],[["{","    let mut set: HashSet<char> = HashSet::new();","    let entry = set.entry('a');","    let mut set: HashSet<char> = HashSet::new();","    let entry = set.entry('a');","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[]],[["{","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(2);","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(2);","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[]],[["{","    let mut set: HashSet<char> = HashSet::new();","    let entry_a = set.entry('a');","    let entry_b = set.entry('b');","    let entry_a = set.entry('a');","    assert!(matches!(entry_a, Entry::Vacant(_)));","}"],[]],[["{","    let mut set: HashSet<char> = HashSet::new();","    let entry_a = set.entry('a');","    let entry_b = set.entry('b');","    let entry_a = set.entry('a');","    let entry_b = set.entry('b');","    assert!(matches!(entry_b, Entry::Vacant(_)));","}"],[]],[["{","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(10);","    let mut set: HashSet<i32> = HashSet::new();","    let entry = set.entry(10);","    assert!(matches!(entry, Entry::Vacant(_)));","}"],[]],[["{","    let mut set: HashSet<char> = HashSet::new();","    set.insert('a');","    set.insert('b');","","    let entry_a = set.entry('a');","    match entry_a {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 'a'\"),","    }","    let mut set: HashSet<char> = HashSet::new();","    set.insert('a');","    set.insert('b');","    let entry_a = set.entry('a');","    assert!(matches!(entry_a, Entry::Occupied(_)));","}"],[]],[["{","    let mut set: HashSet<i32> = HashSet::new();","    set.insert(1);","    set.insert(2);","","    let entry_1 = set.entry(1);","    match entry_1 {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 1\"),","    }","    let mut set: HashSet<i32> = HashSet::new();","    set.insert(1);","    set.insert(2);","    let entry_1 = set.entry(1);","    assert!(matches!(entry_1, Entry::Occupied(_)));","}"],[]],[["{","    let mut set: HashSet<String> = HashSet::new();","    set.insert(\"foo\".to_string());","    set.insert(\"bar\".to_string());","","    let entry_foo = set.entry(\"foo\".to_string());","    match entry_foo {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 'foo'\"),","    }","    let entry_foo = set.entry(\"foo\".to_string());","    assert!(matches!(entry_foo, Entry::Occupied(_)));","}"],[]],[["{","    let mut set: HashSet<String> = HashSet::new();","    set.insert(\"foo\".to_string());","    set.insert(\"bar\".to_string());","","    let entry_foo = set.entry(\"foo\".to_string());","    match entry_foo {","        Entry::Occupied(_) => {","            // Do nothing, just ensuring this branch is taken","        }","        _ => panic!(\"Expected Occupied entry for 'foo'\"),","    }","    let entry_foo = set.entry(\"foo\".to_string());","    assert!(set.contains(&\"foo\".to_string()));","}"],[]]]}