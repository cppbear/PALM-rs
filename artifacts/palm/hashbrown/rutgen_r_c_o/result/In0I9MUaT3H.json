{"function_name":"hashbrown::raw::raw::RawTable<T, A>::bucket_index","tests":5,"tests_lines":[14,13,13,13,15],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":2,"oracles_passed_rate":40.0,"tests_run":5,"tests_passed":2,"tests_passed_rate":40.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[802,803,804],"codes_lines_covered":[[["{","    let alloc = Global; // Using the global allocator","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 3; // Valid bucket index","    // Assume we initialize the table to contain a valid number of buckets","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 3;","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert_eq!(index, bucket_index);","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 0; // Minimum valid bucket index","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 0;","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert_eq!(index, bucket_index);","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32) - 1; // Maximum valid bucket index","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32) - 1;","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert_eq!(index, bucket_index);","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32); // Invalid bucket index, should panic","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32);","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert!(std::panic::catch_unwind(|| unsafe { table.bucket_index(&bucket) }).is_err());","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 2; // Choose an index we expect to be valid initially","    let bucket = unsafe { table.bucket(bucket_index) };","    ","    let bucket_null = Bucket { ptr: NonNull::dangling() }; // Create an invalid Bucket","    let index = unsafe { table.bucket_index(&bucket_null) }; // Expect it to panic","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 2;","    let bucket = unsafe { table.bucket(bucket_index) };","    let bucket_null = Bucket { ptr: NonNull::dangling() };","    assert!(std::panic::catch_unwind(|| { unsafe { table.bucket_index(&bucket_null) } }).is_err());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let alloc = Global; // Using the global allocator","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 3; // Valid bucket index","    // Assume we initialize the table to contain a valid number of buckets","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 3;","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert_eq!(index, bucket_index);","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 0; // Minimum valid bucket index","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 0;","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert_eq!(index, bucket_index);","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32) - 1; // Maximum valid bucket index","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32) - 1;","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert_eq!(index, bucket_index);","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32); // Invalid bucket index, should panic","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = (1 << 32);","    let bucket = unsafe { table.bucket(bucket_index) };","    let index = unsafe { table.bucket_index(&bucket) };","    assert!(std::panic::catch_unwind(|| unsafe { table.bucket_index(&bucket) }).is_err());","}"],[]],[["{","    let alloc = Global; ","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 2; // Choose an index we expect to be valid initially","    let bucket = unsafe { table.bucket(bucket_index) };","    ","    let bucket_null = Bucket { ptr: NonNull::dangling() }; // Create an invalid Bucket","    let index = unsafe { table.bucket_index(&bucket_null) }; // Expect it to panic","    let alloc = Global;","    let table = RawTable::<u32, Global>::new_in(alloc);","    let bucket_index = 2;","    let bucket = unsafe { table.bucket(bucket_index) };","    let bucket_null = Bucket { ptr: NonNull::dangling() };","    assert!(std::panic::catch_unwind(|| { unsafe { table.bucket_index(&bucket_null) } }).is_err());","}"],[]]]}