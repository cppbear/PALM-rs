[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = Global;",
          "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
          "    unsafe {",
          "        let bucket = table.insert(0, 42, |x| *x as u64);",
          "        let (value, insert_slot) = table.remove(bucket);",
          "        let expected_index = table.bucket_index(&bucket);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, 42, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    assert_eq!(value, 42);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, 42, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    let expected_index = table.bucket_index(&bucket);",
            "    assert_eq!(insert_slot.index, expected_index);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    unsafe {",
            "        let bucket = table.insert(0, 42, |x| *x as u64);",
            "        let (value, insert_slot) = table.remove(bucket);",
            "        let expected_index = table.bucket_index(&bucket);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, 42, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    assert_eq!(value, 42);",
            "}"
          ],
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    unsafe {",
            "        let bucket = table.insert(0, 42, |x| *x as u64);",
            "        let (value, insert_slot) = table.remove(bucket);",
            "        let expected_index = table.bucket_index(&bucket);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, 42, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    let expected_index = table.bucket_index(&bucket);",
            "    assert_eq!(insert_slot.index, expected_index);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = Global;",
          "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
          "    unsafe {",
          "        let bucket1 = table.insert(0, 10, |x| *x as u64);",
          "        let bucket2 = table.insert(1, 20, |x| *x as u64);",
          "        let (value, insert_slot) = table.remove(bucket1);",
          "        let expected_index = table.bucket_index(&bucket1);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket1);",
            "    assert_eq!(value, 10);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket1);",
            "    let expected_index = table.bucket_index(&bucket1);",
            "    assert_eq!(insert_slot.index, expected_index);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    unsafe {",
            "        let bucket1 = table.insert(0, 10, |x| *x as u64);",
            "        let bucket2 = table.insert(1, 20, |x| *x as u64);",
            "        let (value, insert_slot) = table.remove(bucket1);",
            "        let expected_index = table.bucket_index(&bucket1);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket1);",
            "    assert_eq!(value, 10);",
            "}"
          ],
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    unsafe {",
            "        let bucket1 = table.insert(0, 10, |x| *x as u64);",
            "        let bucket2 = table.insert(1, 20, |x| *x as u64);",
            "        let (value, insert_slot) = table.remove(bucket1);",
            "        let expected_index = table.bucket_index(&bucket1);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket1);",
            "    let expected_index = table.bucket_index(&bucket1);",
            "    assert_eq!(insert_slot.index, expected_index);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = Global;",
          "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
          "    unsafe {",
          "        let bucket1 = table.insert(0, 1, |x| *x as u64);",
          "        let bucket2 = table.insert(1, 2, |x| *x as u64);",
          "        let bucket3 = table.insert(2, 3, |x| *x as u64);",
          "        let bucket4 = table.insert(3, 4, |x| *x as u64);",
          "        let (value, insert_slot) = table.remove(bucket4);",
          "        let expected_index = table.bucket_index(&bucket4);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
            "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
            "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
            "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket4);",
            "    assert_eq!(value, 4);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
            "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
            "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
            "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket4);",
            "    let expected_index = table.bucket_index(&bucket4);",
            "    assert_eq!(insert_slot.index, expected_index);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
            "    unsafe {",
            "        let bucket1 = table.insert(0, 1, |x| *x as u64);",
            "        let bucket2 = table.insert(1, 2, |x| *x as u64);",
            "        let bucket3 = table.insert(2, 3, |x| *x as u64);",
            "        let bucket4 = table.insert(3, 4, |x| *x as u64);",
            "        let (value, insert_slot) = table.remove(bucket4);",
            "        let expected_index = table.bucket_index(&bucket4);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
            "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
            "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
            "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket4);",
            "    assert_eq!(value, 4);",
            "}"
          ],
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
            "    unsafe {",
            "        let bucket1 = table.insert(0, 1, |x| *x as u64);",
            "        let bucket2 = table.insert(1, 2, |x| *x as u64);",
            "        let bucket3 = table.insert(2, 3, |x| *x as u64);",
            "        let bucket4 = table.insert(3, 4, |x| *x as u64);",
            "        let (value, insert_slot) = table.remove(bucket4);",
            "        let expected_index = table.bucket_index(&bucket4);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
            "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
            "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
            "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
            "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
            "    let (value, insert_slot) = table.remove(bucket4);",
            "    let expected_index = table.bucket_index(&bucket4);",
            "    assert_eq!(insert_slot.index, expected_index);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let alloc = Global;",
          "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
          "    unsafe {",
          "        let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
          "        let _ = table.remove(invalid_bucket);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
            "    assert!(std::panic::catch_unwind(|| table.remove(invalid_bucket)).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    unsafe {",
            "        let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
            "        let _ = table.remove(invalid_bucket);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
            "    let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
            "    assert!(std::panic::catch_unwind(|| table.remove(invalid_bucket)).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct ZeroSized;",
          "",
          "    let alloc = Global;",
          "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
          "    unsafe {",
          "        let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
          "        let (value, insert_slot) = table.remove(bucket);",
          "        let expected_index = table.bucket_index(&bucket);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    assert_eq!(value, ZeroSized);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    let expected_index = table.bucket_index(&bucket);",
            "    assert_eq!(insert_slot.index, expected_index);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct ZeroSized;",
            "",
            "    let alloc = Global;",
            "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
            "    unsafe {",
            "        let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
            "        let (value, insert_slot) = table.remove(bucket);",
            "        let expected_index = table.bucket_index(&bucket);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    assert_eq!(value, ZeroSized);",
            "}"
          ],
          [
            "{",
            "    struct ZeroSized;",
            "",
            "    let alloc = Global;",
            "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
            "    unsafe {",
            "        let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
            "        let (value, insert_slot) = table.remove(bucket);",
            "        let expected_index = table.bucket_index(&bucket);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
            "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
            "    let (value, insert_slot) = table.remove(bucket);",
            "    let expected_index = table.bucket_index(&bucket);",
            "    assert_eq!(insert_slot.index, expected_index);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = Global;",
          "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
          "    unsafe {",
          "        for i in 0..16 {",
          "            table.insert(i, i * 10, |x| *x);",
          "        }",
          "        let bucket_to_remove = table.bucket(0);",
          "        let (value, insert_slot) = table.remove(bucket_to_remove);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(value, 0);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(insert_slot.index, 0);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert!(unsafe { table.is_bucket_full(insert_slot.index) } == false);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(table.len(), 15);"
          ],
          [
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(table.capacity(), 16);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "        for i in 0..16 {",
            "            table.insert(i, i * 10, |x| *x);",
            "        }",
            "        let bucket_to_remove = table.bucket(0);",
            "        let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(value, 0);",
            "}"
          ],
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "        for i in 0..16 {",
            "            table.insert(i, i * 10, |x| *x);",
            "        }",
            "        let bucket_to_remove = table.bucket(0);",
            "        let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(insert_slot.index, 0);",
            "}"
          ],
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "        for i in 0..16 {",
            "            table.insert(i, i * 10, |x| *x);",
            "        }",
            "        let bucket_to_remove = table.bucket(0);",
            "        let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert!(unsafe { table.is_bucket_full(insert_slot.index) } == false);",
            "}"
          ],
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "        for i in 0..16 {",
            "            table.insert(i, i * 10, |x| *x);",
            "        }",
            "        let bucket_to_remove = table.bucket(0);",
            "        let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(table.len(), 15);",
            "}"
          ],
          [
            "{",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "        for i in 0..16 {",
            "            table.insert(i, i * 10, |x| *x);",
            "        }",
            "        let bucket_to_remove = table.bucket(0);",
            "        let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    let alloc = Global;",
            "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
            "    unsafe {",
            "    for i in 0..16 {",
            "    table.insert(i, i * 10, |x| *x);",
            "    }",
            "    let bucket_to_remove = table.bucket(0);",
            "    let (value, insert_slot) = table.remove(bucket_to_remove);",
            "    }",
            "    assert_eq!(table.capacity(), 16);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]