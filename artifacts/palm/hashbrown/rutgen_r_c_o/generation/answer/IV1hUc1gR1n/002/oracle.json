[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = &Global;",
          "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
          "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
          "    let additional = 1;",
          "    ",
          "    unsafe {",
          "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    assert_eq!(table.items, 0);"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    assert_eq!(table.bucket_mask, usize::MAX - 1);"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    assert!(table.growth_left > 0);"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    unsafe {",
            "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    unsafe {",
            "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    assert_eq!(table.items, 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    ",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    assert_eq!(table.items, 0);",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    ",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    assert_eq!(table.bucket_mask, usize::MAX - 1);",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    ",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    assert!(table.growth_left > 0);",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    ",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    unsafe {",
            "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    ",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, usize::MAX);",
            "    let additional = 1;",
            "    unsafe {",
            "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    assert_eq!(table.items, 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = &Global;",
          "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
          "    let capacity = 16;",
          "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
          "    table.items = capacity - 1;",
          "    let additional = 2;",
          "",
          "    unsafe {",
          "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 16;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = capacity - 1;",
            "    let additional = 2;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert!(result.is_err());"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 16;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = capacity - 1;",
            "    let additional = 2;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 16;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = capacity - 1;",
            "    let additional = 2;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 16;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = capacity - 1;",
            "    let additional = 2;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 16;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = capacity - 1;",
            "    let additional = 2;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 16;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = capacity - 1;",
            "    let additional = 2;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = &Global;",
          "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
          "    let capacity = 32;",
          "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
          "    table.items = 12; // less than half of capacity",
          "    let additional = 2;",
          "",
          "    unsafe {",
          "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(table.items == 12);"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(table.bucket_mask == 31);"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(table.growth_left == bucket_mask_to_capacity(table.bucket_mask));"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(unsafe { table.num_ctrl_bytes() } >= 0);"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(unsafe { table.is_empty_singleton() } == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12; // less than half of capacity",
            "    let additional = 2;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(table.items == 12);",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12; // less than half of capacity",
            "    let additional = 2;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(table.bucket_mask == 31);",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12; // less than half of capacity",
            "    let additional = 2;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(table.growth_left == bucket_mask_to_capacity(table.bucket_mask));",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12; // less than half of capacity",
            "    let additional = 2;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(unsafe { table.num_ctrl_bytes() } >= 0);",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12; // less than half of capacity",
            "    let additional = 2;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 12;",
            "    let additional = 2;",
            "    assert!(unsafe { table.is_empty_singleton() } == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = &Global;",
          "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
          "    let capacity = 32;",
          "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
          "    table.items = 16; // exactly half of capacity",
          "    let additional = 3;",
          "",
          "    unsafe {",
          "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 16;",
            "    let additional = 3;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert_eq!(result.is_err(), true);"
          ],
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 16;",
            "    let additional = 3;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 16; // exactly half of capacity",
            "    let additional = 3;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 16;",
            "    let additional = 3;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert_eq!(result.is_err(), true);",
            "}"
          ],
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 16; // exactly half of capacity",
            "    let additional = 3;",
            "",
            "    unsafe {",
            "        table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None);",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = 32;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = 16;",
            "    let additional = 3;",
            "    let result = unsafe { table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Fallible, layout, None) };",
            "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let alloc = &Global;",
          "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
          "    let capacity = usize::MAX; // extreme case",
          "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
          "    table.items = usize::MAX - 1; // almost max size",
          "    let additional = 1; // to test overflow",
          "",
          "    unsafe {",
          "        let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
          "        assert!(result.is_err());",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = usize::MAX;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = usize::MAX - 1;",
            "    let additional = 1;",
            "    unsafe {",
            "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    assert!(result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = usize::MAX; // extreme case",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = usize::MAX - 1; // almost max size",
            "    let additional = 1; // to test overflow",
            "",
            "    unsafe {",
            "        let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "        assert!(result.is_err());",
            "    }",
            "    let alloc = &Global;",
            "    let layout = TableLayout { size: 8, ctrl_align: 8 };",
            "    let capacity = usize::MAX;",
            "    let mut table = RawTableInner::with_capacity(alloc, layout, capacity);",
            "    table.items = usize::MAX - 1;",
            "    let additional = 1;",
            "    unsafe {",
            "    let result = table.reserve_rehash_inner(alloc, additional, &|_, _| 0, Fallibility::Infallible, layout, None);",
            "    assert!(result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]