[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_width = Group::WIDTH;",
          "",
          "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0, 1",
          "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
          "    let next_ctrl = 0x1000 as *const u8; // initial next control",
          "    let end = (next_ctrl as usize + group_width) as *const u8; // end within range",
          "    ",
          "    let mut raw_iter_range = RawIterRange {",
          "        current_group,",
          "        data: data_bucket,",
          "        next_ctrl,",
          "        end,",
          "    };",
          "",
          "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
          "}"
        ],
        "oracles": [
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = 0x1000 as *const u8;",
            "    let end = (next_ctrl as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    assert!(result.is_some());"
          ],
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = 0x1000 as *const u8;",
            "    let end = (next_ctrl as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    assert_eq!(result.unwrap().as_ptr(), data_bucket.next_n(0).as_ptr());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0, 1",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = 0x1000 as *const u8; // initial next control",
            "    let end = (next_ctrl as usize + group_width) as *const u8; // end within range",
            "    ",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = 0x1000 as *const u8;",
            "    let end = (next_ctrl as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0, 1",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = 0x1000 as *const u8; // initial next control",
            "    let end = (next_ctrl as usize + group_width) as *const u8; // end within range",
            "    ",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = 0x1000 as *const u8;",
            "    let end = (next_ctrl as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    assert_eq!(result.unwrap().as_ptr(), data_bucket.next_n(0).as_ptr());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_width = Group::WIDTH;",
          "",
          "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0010)); // conditions to yield index 0",
          "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
          "    let next_ctrl = (0x1000 + group_width) as *const u8; // next control aligned with group size",
          "    let end = (0x1000 + group_width * 2) as *const u8; // valid end reference within range",
          "",
          "    let mut raw_iter_range = RawIterRange {",
          "        current_group,",
          "        data: data_bucket,",
          "        next_ctrl,",
          "        end,",
          "    };",
          "",
          "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
          "}"
        ],
        "oracles": [
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0010));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x1000 + group_width) as *const u8;",
            "    let end = (0x1000 + group_width * 2) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_some());"
          ],
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0010));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x1000 + group_width) as *const u8;",
            "    let end = (0x1000 + group_width * 2) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert_eq!(result.unwrap().ptr.as_ptr(), (0x1000 + 0).sub(0) as *mut u8);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0010)); // conditions to yield index 0",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = (0x1000 + group_width) as *const u8; // next control aligned with group size",
            "    let end = (0x1000 + group_width * 2) as *const u8; // valid end reference within range",
            "",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0010));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x1000 + group_width) as *const u8;",
            "    let end = (0x1000 + group_width * 2) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0010)); // conditions to yield index 0",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = (0x1000 + group_width) as *const u8; // next control aligned with group size",
            "    let end = (0x1000 + group_width * 2) as *const u8; // valid end reference within range",
            "",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0010));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x1000 + group_width) as *const u8;",
            "    let end = (0x1000 + group_width * 2) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert_eq!(result.unwrap().ptr.as_ptr(), (0x1000 + 0).sub(0) as *mut u8);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_width = Group::WIDTH;",
          "",
          "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000)); // no indices available",
          "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
          "    let next_ctrl = 0x1000 as *const u8;",
          "    let end = (next_ctrl as usize + group_width) as *const u8; // end aligned within bounds",
          "",
          "    let mut raw_iter_range = RawIterRange {",
          "        current_group,",
          "        data: data_bucket,",
          "        next_ctrl,",
          "        end,",
          "    };",
          "",
          "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
          "}"
        ],
        "oracles": [
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = 0x1000 as *const u8;",
            "    let end = (next_ctrl as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    assert!(result.is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000)); // no indices available",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = 0x1000 as *const u8;",
            "    let end = (next_ctrl as usize + group_width) as *const u8; // end aligned within bounds",
            "",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = 0x1000 as *const u8;",
            "    let end = (next_ctrl as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<false>();",
            "    assert!(result.is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let group_width = Group::WIDTH;",
          "",
          "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0 and 1",
          "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
          "    let next_ctrl = (0x2000) as *const u8; // next control exceeds end",
          "    let end = (0x1000 as usize + group_width) as *const u8; // control end within group size",
          "",
          "    let mut raw_iter_range = RawIterRange {",
          "        current_group,",
          "        data: data_bucket,",
          "        next_ctrl,",
          "        end,",
          "    };",
          "",
          "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
          "}"
        ],
        "oracles": [
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_some());"
          ],
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert_eq!(result.unwrap().as_ptr(), (0x1000 as usize).wrapping_sub(0).as_mut());"
          ],
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000));",
            "    raw_iter_range.current_group = current_group;",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_none());"
          ],
          [
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000));",
            "    raw_iter_range.current_group = current_group;",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    raw_iter_range.next_ctrl = (0x1000 as *const u8);",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0 and 1",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = (0x2000) as *const u8; // next control exceeds end",
            "    let end = (0x1000 as usize + group_width) as *const u8; // control end within group size",
            "",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0 and 1",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = (0x2000) as *const u8; // next control exceeds end",
            "    let end = (0x1000 as usize + group_width) as *const u8; // control end within group size",
            "",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert_eq!(result.unwrap().as_ptr(), (0x1000 as usize).wrapping_sub(0).as_mut());",
            "}"
          ],
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0 and 1",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = (0x2000) as *const u8; // next control exceeds end",
            "    let end = (0x1000 as usize + group_width) as *const u8; // control end within group size",
            "",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000));",
            "    raw_iter_range.current_group = current_group;",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_none());",
            "}"
          ],
          [
            "{",
            "    let group_width = Group::WIDTH;",
            "",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011)); // conditions to yield indices 0 and 1",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) }; // mock pointer",
            "    let next_ctrl = (0x2000) as *const u8; // next control exceeds end",
            "    let end = (0x1000 as usize + group_width) as *const u8; // control end within group size",
            "",
            "    let mut raw_iter_range = RawIterRange {",
            "        current_group,",
            "        data: data_bucket,",
            "        next_ctrl,",
            "        end,",
            "    };",
            "",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let group_width = Group::WIDTH;",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0011));",
            "    let data_bucket = Bucket { ptr: NonNull::new_unchecked(0x1000 as *mut u8) };",
            "    let next_ctrl = (0x2000) as *const u8;",
            "    let end = (0x1000 as usize + group_width) as *const u8;",
            "    let mut raw_iter_range = RawIterRange {",
            "    current_group,",
            "    data: data_bucket,",
            "    next_ctrl,",
            "    end,",
            "    };",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    let current_group = BitMaskIter(BitMask(0b0000_0000_0000_0000_0000_0000_0000_0000));",
            "    raw_iter_range.current_group = current_group;",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    raw_iter_range.next_ctrl = (0x1000 as *const u8);",
            "    let result: Option<Bucket<u8>> = raw_iter_range.next_impl::<true>();",
            "    assert!(result.is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]