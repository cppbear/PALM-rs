{
  "name": "hashbrown::raw::raw::RawTable<T, A>::remove",
  "name_with_impl": "hashbrown::raw::{impl#9}::remove",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": true,
  "loc": "src/raw/mod.rs:882:5:890:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: (\n            item.read(),\n            InsertSlot {\n                index: self.bucket_index(&item),\n            },\n        )\n"
      ],
      "input_infer": "(0, 1, 2, 3, ..., 2^n-1) for bucket index with n >= 0, where T is any valid type and item is always non-null NonNull<T> in range of allocated memory.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alloc = Global;",
                "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                "    unsafe {",
                "        let bucket = table.insert(0, 42, |x| *x as u64);",
                "        let (value, insert_slot) = table.remove(bucket);",
                "        let expected_index = table.bucket_index(&bucket);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, 42, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    assert_eq!(value, 42);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, 42, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    let expected_index = table.bucket_index(&bucket);",
                  "    assert_eq!(insert_slot.index, expected_index);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    unsafe {",
                  "        let bucket = table.insert(0, 42, |x| *x as u64);",
                  "        let (value, insert_slot) = table.remove(bucket);",
                  "        let expected_index = table.bucket_index(&bucket);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, 42, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    assert_eq!(value, 42);",
                  "}"
                ],
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    unsafe {",
                  "        let bucket = table.insert(0, 42, |x| *x as u64);",
                  "        let (value, insert_slot) = table.remove(bucket);",
                  "        let expected_index = table.bucket_index(&bucket);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, 42, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    let expected_index = table.bucket_index(&bucket);",
                  "    assert_eq!(insert_slot.index, expected_index);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling crossbeam-utils v0.8.21\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling rayon-core v1.12.1\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4493:14\n     |\n4493 |         let (value, insert_slot) = table.remove(bucket);\n     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4493:21\n     |\n4493 |         let (value, insert_slot) = table.remove(bucket);\n     |                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nwarning: unused variable: `expected_index`\n    --> src/raw/mod.rs:4494:13\n     |\n4494 |         let expected_index = table.bucket_index(&bucket);\n     |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_index`\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4499:17\n     |\n4499 |     let (value, insert_slot) = table.remove(bucket);\n     |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::remove` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4499:32\n     |\n4499 |     let (value, insert_slot) = table.remove(bucket);\n     |                                ^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0382]: borrow of moved value: `bucket`\n    --> src/raw/mod.rs:4494:49\n     |\n4492 |         let bucket = table.insert(0, 42, |x| *x as u64);\n     |             ------ move occurs because `bucket` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4493 |         let (value, insert_slot) = table.remove(bucket);\n     |                                                 ------ value moved here\n4494 |         let expected_index = table.bucket_index(&bucket);\n     |                                                 ^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4493 |         let (value, insert_slot) = table.remove(bucket.clone());\n     |                                                       ++++++++\n\nSome errors have detailed explanations: E0133, E0382.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 16 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 16 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling crossbeam-utils v0.8.21\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling rayon-core v1.12.1\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4493:14\n     |\n4493 |         let (value, insert_slot) = table.remove(bucket);\n     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4493:21\n     |\n4493 |         let (value, insert_slot) = table.remove(bucket);\n     |                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nwarning: unused variable: `expected_index`\n    --> src/raw/mod.rs:4494:13\n     |\n4494 |         let expected_index = table.bucket_index(&bucket);\n     |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_index`\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4499:10\n     |\n4499 |     let (value, insert_slot) = table.remove(bucket);\n     |          ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::remove` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4499:32\n     |\n4499 |     let (value, insert_slot) = table.remove(bucket);\n     |                                ^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::bucket_index` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4500:26\n     |\n4500 |     let expected_index = table.bucket_index(&bucket);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0382]: borrow of moved value: `bucket`\n    --> src/raw/mod.rs:4494:49\n     |\n4492 |         let bucket = table.insert(0, 42, |x| *x as u64);\n     |             ------ move occurs because `bucket` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4493 |         let (value, insert_slot) = table.remove(bucket);\n     |                                                 ------ value moved here\n4494 |         let expected_index = table.bucket_index(&bucket);\n     |                                                 ^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4493 |         let (value, insert_slot) = table.remove(bucket.clone());\n     |                                                       ++++++++\n\nerror[E0382]: borrow of moved value: `bucket`\n    --> src/raw/mod.rs:4500:45\n     |\n4498 |     let bucket = table.insert(0, 42, |x| *x as u64);\n     |         ------ move occurs because `bucket` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4499 |     let (value, insert_slot) = table.remove(bucket);\n     |                                             ------ value moved here\n4500 |     let expected_index = table.bucket_index(&bucket);\n     |                                             ^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4499 |     let (value, insert_slot) = table.remove(bucket.clone());\n     |                                                   ++++++++\n\nSome errors have detailed explanations: E0133, E0382.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 16 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 16 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alloc = Global;",
                "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                "    unsafe {",
                "        let bucket1 = table.insert(0, 10, |x| *x as u64);",
                "        let bucket2 = table.insert(1, 20, |x| *x as u64);",
                "        let (value, insert_slot) = table.remove(bucket1);",
                "        let expected_index = table.bucket_index(&bucket1);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket1);",
                  "    assert_eq!(value, 10);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket1);",
                  "    let expected_index = table.bucket_index(&bucket1);",
                  "    assert_eq!(insert_slot.index, expected_index);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    unsafe {",
                  "        let bucket1 = table.insert(0, 10, |x| *x as u64);",
                  "        let bucket2 = table.insert(1, 20, |x| *x as u64);",
                  "        let (value, insert_slot) = table.remove(bucket1);",
                  "        let expected_index = table.bucket_index(&bucket1);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket1);",
                  "    assert_eq!(value, 10);",
                  "}"
                ],
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    unsafe {",
                  "        let bucket1 = table.insert(0, 10, |x| *x as u64);",
                  "        let bucket2 = table.insert(1, 20, |x| *x as u64);",
                  "        let (value, insert_slot) = table.remove(bucket1);",
                  "        let expected_index = table.bucket_index(&bucket1);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let bucket1 = table.insert(0, 10, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 20, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket1);",
                  "    let expected_index = table.bucket_index(&bucket1);",
                  "    assert_eq!(insert_slot.index, expected_index);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling crossbeam-utils v0.8.21\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling rayon-core v1.12.1\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4493:13\n     |\n4493 |         let bucket2 = table.insert(1, 20, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4494:14\n     |\n4494 |         let (value, insert_slot) = table.remove(bucket1);\n     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4494:21\n     |\n4494 |         let (value, insert_slot) = table.remove(bucket1);\n     |                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nwarning: unused variable: `expected_index`\n    --> src/raw/mod.rs:4495:13\n     |\n4495 |         let expected_index = table.bucket_index(&bucket1);\n     |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_index`\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4500:9\n     |\n4500 |     let bucket2 = table.insert(1, 20, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4501:17\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket1);\n     |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::remove` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4501:32\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket1);\n     |                                ^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0382]: borrow of moved value: `bucket1`\n    --> src/raw/mod.rs:4495:49\n     |\n4492 |         let bucket1 = table.insert(0, 10, |x| *x as u64);\n     |             ------- move occurs because `bucket1` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4493 |         let bucket2 = table.insert(1, 20, |x| *x as u64);\n4494 |         let (value, insert_slot) = table.remove(bucket1);\n     |                                                 ------- value moved here\n4495 |         let expected_index = table.bucket_index(&bucket1);\n     |                                                 ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4494 |         let (value, insert_slot) = table.remove(bucket1.clone());\n     |                                                        ++++++++\n\nSome errors have detailed explanations: E0133, E0382.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 18 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling crossbeam-utils v0.8.21\n   Compiling libc v0.2.172\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling rayon-core v1.12.1\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4493:13\n     |\n4493 |         let bucket2 = table.insert(1, 20, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4494:14\n     |\n4494 |         let (value, insert_slot) = table.remove(bucket1);\n     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4494:21\n     |\n4494 |         let (value, insert_slot) = table.remove(bucket1);\n     |                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nwarning: unused variable: `expected_index`\n    --> src/raw/mod.rs:4495:13\n     |\n4495 |         let expected_index = table.bucket_index(&bucket1);\n     |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_index`\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4500:9\n     |\n4500 |     let bucket2 = table.insert(1, 20, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4501:10\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket1);\n     |          ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::remove` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4501:32\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket1);\n     |                                ^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::bucket_index` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4502:26\n     |\n4502 |     let expected_index = table.bucket_index(&bucket1);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0382]: borrow of moved value: `bucket1`\n    --> src/raw/mod.rs:4495:49\n     |\n4492 |         let bucket1 = table.insert(0, 10, |x| *x as u64);\n     |             ------- move occurs because `bucket1` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4493 |         let bucket2 = table.insert(1, 20, |x| *x as u64);\n4494 |         let (value, insert_slot) = table.remove(bucket1);\n     |                                                 ------- value moved here\n4495 |         let expected_index = table.bucket_index(&bucket1);\n     |                                                 ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4494 |         let (value, insert_slot) = table.remove(bucket1.clone());\n     |                                                        ++++++++\n\nerror[E0382]: borrow of moved value: `bucket1`\n    --> src/raw/mod.rs:4502:45\n     |\n4499 |     let bucket1 = table.insert(0, 10, |x| *x as u64);\n     |         ------- move occurs because `bucket1` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4500 |     let bucket2 = table.insert(1, 20, |x| *x as u64);\n4501 |     let (value, insert_slot) = table.remove(bucket1);\n     |                                             ------- value moved here\n4502 |     let expected_index = table.bucket_index(&bucket1);\n     |                                             ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket1.clone());\n     |                                                    ++++++++\n\nSome errors have detailed explanations: E0133, E0382.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 18 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alloc = Global;",
                "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
                "    unsafe {",
                "        let bucket1 = table.insert(0, 1, |x| *x as u64);",
                "        let bucket2 = table.insert(1, 2, |x| *x as u64);",
                "        let bucket3 = table.insert(2, 3, |x| *x as u64);",
                "        let bucket4 = table.insert(3, 4, |x| *x as u64);",
                "        let (value, insert_slot) = table.remove(bucket4);",
                "        let expected_index = table.bucket_index(&bucket4);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
                  "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
                  "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
                  "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket4);",
                  "    assert_eq!(value, 4);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
                  "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
                  "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
                  "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket4);",
                  "    let expected_index = table.bucket_index(&bucket4);",
                  "    assert_eq!(insert_slot.index, expected_index);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
                  "    unsafe {",
                  "        let bucket1 = table.insert(0, 1, |x| *x as u64);",
                  "        let bucket2 = table.insert(1, 2, |x| *x as u64);",
                  "        let bucket3 = table.insert(2, 3, |x| *x as u64);",
                  "        let bucket4 = table.insert(3, 4, |x| *x as u64);",
                  "        let (value, insert_slot) = table.remove(bucket4);",
                  "        let expected_index = table.bucket_index(&bucket4);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
                  "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
                  "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
                  "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket4);",
                  "    assert_eq!(value, 4);",
                  "}"
                ],
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
                  "    unsafe {",
                  "        let bucket1 = table.insert(0, 1, |x| *x as u64);",
                  "        let bucket2 = table.insert(1, 2, |x| *x as u64);",
                  "        let bucket3 = table.insert(2, 3, |x| *x as u64);",
                  "        let bucket4 = table.insert(3, 4, |x| *x as u64);",
                  "        let (value, insert_slot) = table.remove(bucket4);",
                  "        let expected_index = table.bucket_index(&bucket4);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::with_capacity_in(4, alloc);",
                  "    let bucket1 = table.insert(0, 1, |x| *x as u64);",
                  "    let bucket2 = table.insert(1, 2, |x| *x as u64);",
                  "    let bucket3 = table.insert(2, 3, |x| *x as u64);",
                  "    let bucket4 = table.insert(3, 4, |x| *x as u64);",
                  "    let (value, insert_slot) = table.remove(bucket4);",
                  "    let expected_index = table.bucket_index(&bucket4);",
                  "    assert_eq!(insert_slot.index, expected_index);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling crossbeam-utils v0.8.21\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling serde v1.0.219\n   Compiling rayon-core v1.12.1\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `bucket1`\n    --> src/raw/mod.rs:4492:13\n     |\n4492 |         let bucket1 = table.insert(0, 1, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4493:13\n     |\n4493 |         let bucket2 = table.insert(1, 2, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n\nwarning: unused variable: `bucket3`\n    --> src/raw/mod.rs:4494:13\n     |\n4494 |         let bucket3 = table.insert(2, 3, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket3`\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4496:14\n     |\n4496 |         let (value, insert_slot) = table.remove(bucket4);\n     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4496:21\n     |\n4496 |         let (value, insert_slot) = table.remove(bucket4);\n     |                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nwarning: unused variable: `expected_index`\n    --> src/raw/mod.rs:4497:13\n     |\n4497 |         let expected_index = table.bucket_index(&bucket4);\n     |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_index`\n\nwarning: unused variable: `bucket1`\n    --> src/raw/mod.rs:4501:9\n     |\n4501 |     let bucket1 = table.insert(0, 1, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket1`\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4502:9\n     |\n4502 |     let bucket2 = table.insert(1, 2, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n\nwarning: unused variable: `bucket3`\n    --> src/raw/mod.rs:4503:9\n     |\n4503 |     let bucket3 = table.insert(2, 3, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket3`\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4505:17\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket4);\n     |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::remove` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4505:32\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket4);\n     |                                ^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0382]: borrow of moved value: `bucket4`\n    --> src/raw/mod.rs:4497:49\n     |\n4495 |         let bucket4 = table.insert(3, 4, |x| *x as u64);\n     |             ------- move occurs because `bucket4` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4496 |         let (value, insert_slot) = table.remove(bucket4);\n     |                                                 ------- value moved here\n4497 |         let expected_index = table.bucket_index(&bucket4);\n     |                                                 ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4496 |         let (value, insert_slot) = table.remove(bucket4.clone());\n     |                                                        ++++++++\n\nSome errors have detailed explanations: E0133, E0382.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 22 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 22 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling crossbeam-utils v0.8.21\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling rayon-core v1.12.1\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `bucket1`\n    --> src/raw/mod.rs:4492:13\n     |\n4492 |         let bucket1 = table.insert(0, 1, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4493:13\n     |\n4493 |         let bucket2 = table.insert(1, 2, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n\nwarning: unused variable: `bucket3`\n    --> src/raw/mod.rs:4494:13\n     |\n4494 |         let bucket3 = table.insert(2, 3, |x| *x as u64);\n     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket3`\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4496:14\n     |\n4496 |         let (value, insert_slot) = table.remove(bucket4);\n     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4496:21\n     |\n4496 |         let (value, insert_slot) = table.remove(bucket4);\n     |                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nwarning: unused variable: `expected_index`\n    --> src/raw/mod.rs:4497:13\n     |\n4497 |         let expected_index = table.bucket_index(&bucket4);\n     |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_index`\n\nwarning: unused variable: `bucket1`\n    --> src/raw/mod.rs:4501:9\n     |\n4501 |     let bucket1 = table.insert(0, 1, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket1`\n\nwarning: unused variable: `bucket2`\n    --> src/raw/mod.rs:4502:9\n     |\n4502 |     let bucket2 = table.insert(1, 2, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket2`\n\nwarning: unused variable: `bucket3`\n    --> src/raw/mod.rs:4503:9\n     |\n4503 |     let bucket3 = table.insert(2, 3, |x| *x as u64);\n     |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bucket3`\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4505:10\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket4);\n     |          ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::remove` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4505:32\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket4);\n     |                                ^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::bucket_index` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4506:26\n     |\n4506 |     let expected_index = table.bucket_index(&bucket4);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0382]: borrow of moved value: `bucket4`\n    --> src/raw/mod.rs:4497:49\n     |\n4495 |         let bucket4 = table.insert(3, 4, |x| *x as u64);\n     |             ------- move occurs because `bucket4` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4496 |         let (value, insert_slot) = table.remove(bucket4);\n     |                                                 ------- value moved here\n4497 |         let expected_index = table.bucket_index(&bucket4);\n     |                                                 ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4496 |         let (value, insert_slot) = table.remove(bucket4.clone());\n     |                                                        ++++++++\n\nerror[E0382]: borrow of moved value: `bucket4`\n    --> src/raw/mod.rs:4506:45\n     |\n4504 |     let bucket4 = table.insert(3, 4, |x| *x as u64);\n     |         ------- move occurs because `bucket4` has type `Bucket<i32>`, which does not implement the `Copy` trait\n4505 |     let (value, insert_slot) = table.remove(bucket4);\n     |                                             ------- value moved here\n4506 |     let expected_index = table.bucket_index(&bucket4);\n     |                                             ^^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket4.clone());\n     |                                                    ++++++++\n\nSome errors have detailed explanations: E0133, E0382.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 22 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 22 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let alloc = Global;",
                "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                "    unsafe {",
                "        let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
                "        let _ = table.remove(invalid_bucket);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
                  "    assert!(std::panic::catch_unwind(|| table.remove(invalid_bucket)).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    unsafe {",
                  "        let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
                  "        let _ = table.remove(invalid_bucket);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<i32, _> = RawTable::new_in(alloc);",
                  "    let invalid_bucket = Bucket { ptr: NonNull::dangling() };",
                  "    assert!(std::panic::catch_unwind(|| table.remove(invalid_bucket)).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling crossbeam-utils v0.8.21\n   Compiling libc v0.2.172\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling rayon-core v1.12.1\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0277]: the type `&mut raw::RawTable<i32>` may not be safely transferred across an unwind boundary\n    --> src/raw/mod.rs:4499:38\n     |\n4499 |     assert!(std::panic::catch_unwind(|| table.remove(invalid_bucket)).is_err());\n     |             ------------------------ --^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |             |                        |\n     |             |                        `&mut raw::RawTable<i32>` may not be safely transferred across an unwind boundary\n     |             |                        within this `{closure@src/raw/mod.rs:4499:38: 4499:40}`\n     |             required by a bound introduced by this call\n     |\n     = help: within `{closure@src/raw/mod.rs:4499:38: 4499:40}`, the trait `UnwindSafe` is not implemented for `&mut raw::RawTable<i32>`, which is required by `{closure@src/raw/mod.rs:4499:38: 4499:40}: UnwindSafe`\n     = note: `UnwindSafe` is implemented for `&raw::RawTable<i32>`, but not for `&mut raw::RawTable<i32>`\nnote: required because it's used within this closure\n    --> src/raw/mod.rs:4499:38\n     |\n4499 |     assert!(std::panic::catch_unwind(|| table.remove(invalid_bucket)).is_err());\n     |                                      ^^\nnote: required by a bound in `std::panic::catch_unwind`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:349:40\n     |\n349  | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n     |                                        ^^^^^^^^^^ required by this bound in `catch_unwind`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct ZeroSized;",
                "",
                "    let alloc = Global;",
                "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
                "    unsafe {",
                "        let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
                "        let (value, insert_slot) = table.remove(bucket);",
                "        let expected_index = table.bucket_index(&bucket);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    assert_eq!(value, ZeroSized);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    let expected_index = table.bucket_index(&bucket);",
                  "    assert_eq!(insert_slot.index, expected_index);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct ZeroSized;",
                  "",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
                  "    unsafe {",
                  "        let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
                  "        let (value, insert_slot) = table.remove(bucket);",
                  "        let expected_index = table.bucket_index(&bucket);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    assert_eq!(value, ZeroSized);",
                  "}"
                ],
                [
                  "{",
                  "    struct ZeroSized;",
                  "",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
                  "    unsafe {",
                  "        let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
                  "        let (value, insert_slot) = table.remove(bucket);",
                  "        let expected_index = table.bucket_index(&bucket);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<ZeroSized, _> = RawTable::new_in(alloc);",
                  "    let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);",
                  "    let (value, insert_slot) = table.remove(bucket);",
                  "    let expected_index = table.bucket_index(&bucket);",
                  "    assert_eq!(insert_slot.index, expected_index);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling crossbeam-utils v0.8.21\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling rayon-core v1.12.1\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `ZeroSized`\n    --> src/raw/mod.rs:4502:5\n     |\n4502 |     assert_eq!(value, ZeroSized);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     ZeroSized\n     |     ZeroSized\n     |\nnote: an implementation of `PartialEq` might be missing for `ZeroSized`\n    --> src/raw/mod.rs:4489:5\n     |\n4489 |     struct ZeroSized;\n     |     ^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ZeroSized` with `#[derive(PartialEq)]`\n     |\n4489 +     #[derive(PartialEq)]\n4490 |     struct ZeroSized;\n     |\n\nerror[E0277]: `ZeroSized` doesn't implement `Debug`\n    --> src/raw/mod.rs:4502:5\n     |\n4502 |     assert_eq!(value, ZeroSized);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ZeroSized` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `ZeroSized`\n     = note: add `#[derive(Debug)]` to `ZeroSized` or manually `impl Debug for ZeroSized`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ZeroSized` with `#[derive(Debug)]`\n     |\n4489 +     #[derive(Debug)]\n4490 |     struct ZeroSized;\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 12 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling crossbeam-utils v0.8.21\n   Compiling libc v0.2.172\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling serde v1.0.219\n   Compiling rayon-core v1.12.1\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4495:14\n     |\n4495 |         let (value, insert_slot) = table.remove(bucket);\n     |              ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `insert_slot`\n    --> src/raw/mod.rs:4495:21\n     |\n4495 |         let (value, insert_slot) = table.remove(bucket);\n     |                     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_insert_slot`\n\nwarning: unused variable: `expected_index`\n    --> src/raw/mod.rs:4496:13\n     |\n4496 |         let expected_index = table.bucket_index(&bucket);\n     |             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected_index`\n\nwarning: unused variable: `value`\n    --> src/raw/mod.rs:4501:10\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket);\n     |          ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::remove` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4501:32\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket);\n     |                                ^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTable::<T, A>::bucket_index` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4502:26\n     |\n4502 |     let expected_index = table.bucket_index(&bucket);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0382]: borrow of moved value: `bucket`\n    --> src/raw/mod.rs:4496:49\n     |\n4494 |         let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);\n     |             ------ move occurs because `bucket` has type `Bucket<ZeroSized>`, which does not implement the `Copy` trait\n4495 |         let (value, insert_slot) = table.remove(bucket);\n     |                                                 ------ value moved here\n4496 |         let expected_index = table.bucket_index(&bucket);\n     |                                                 ^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4495 |         let (value, insert_slot) = table.remove(bucket.clone());\n     |                                                       ++++++++\n\nerror[E0382]: borrow of moved value: `bucket`\n    --> src/raw/mod.rs:4502:45\n     |\n4500 |     let bucket = table.insert(0, ZeroSized, |_: &ZeroSized| 0);\n     |         ------ move occurs because `bucket` has type `Bucket<ZeroSized>`, which does not implement the `Copy` trait\n4501 |     let (value, insert_slot) = table.remove(bucket);\n     |                                             ------ value moved here\n4502 |     let expected_index = table.bucket_index(&bucket);\n     |                                             ^^^^^^^ value borrowed here after move\n     |\nnote: consider changing this parameter type in method `remove` to borrow instead if owning the value isn't necessary\n    --> src/raw/mod.rs:882:43\n     |\n882  |     pub unsafe fn remove(&mut self, item: Bucket<T>) -> (T, InsertSlot) {\n     |                   ------ in this method   ^^^^^^^^^ this parameter takes ownership of the value\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n4501 |     let (value, insert_slot) = table.remove(bucket.clone());\n     |                                                   ++++++++\n\nSome errors have detailed explanations: E0133, E0382.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 16 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 16 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alloc = Global;",
                "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                "    unsafe {",
                "        for i in 0..16 {",
                "            table.insert(i, i * 10, |x| *x);",
                "        }",
                "        let bucket_to_remove = table.bucket(0);",
                "        let (value, insert_slot) = table.remove(bucket_to_remove);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(value, 0);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(insert_slot.index, 0);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert!(unsafe { table.is_bucket_full(insert_slot.index) } == false);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(table.len(), 15);"
                ],
                [
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(table.capacity(), 16);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "        for i in 0..16 {",
                  "            table.insert(i, i * 10, |x| *x);",
                  "        }",
                  "        let bucket_to_remove = table.bucket(0);",
                  "        let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(value, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "        for i in 0..16 {",
                  "            table.insert(i, i * 10, |x| *x);",
                  "        }",
                  "        let bucket_to_remove = table.bucket(0);",
                  "        let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(insert_slot.index, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "        for i in 0..16 {",
                  "            table.insert(i, i * 10, |x| *x);",
                  "        }",
                  "        let bucket_to_remove = table.bucket(0);",
                  "        let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert!(unsafe { table.is_bucket_full(insert_slot.index) } == false);",
                  "}"
                ],
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "        for i in 0..16 {",
                  "            table.insert(i, i * 10, |x| *x);",
                  "        }",
                  "        let bucket_to_remove = table.bucket(0);",
                  "        let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(table.len(), 15);",
                  "}"
                ],
                [
                  "{",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "        for i in 0..16 {",
                  "            table.insert(i, i * 10, |x| *x);",
                  "        }",
                  "        let bucket_to_remove = table.bucket(0);",
                  "        let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    let alloc = Global;",
                  "    let mut table: RawTable<u64, _> = RawTable::with_capacity_in(16, alloc);",
                  "    unsafe {",
                  "    for i in 0..16 {",
                  "    table.insert(i, i * 10, |x| *x);",
                  "    }",
                  "    let bucket_to_remove = table.bucket(0);",
                  "    let (value, insert_slot) = table.remove(bucket_to_remove);",
                  "    }",
                  "    assert_eq!(table.capacity(), 16);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling crossbeam-utils v0.8.21\n   Compiling libc v0.2.172\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling serde v1.0.219\n   Compiling rayon-core v1.12.1\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0425]: cannot find value `value` in this scope\n    --> src/raw/mod.rs:4507:16\n     |\n4507 |     assert_eq!(value, 0);\n     |                ^^^^^\n     |\nhelp: the binding `value` is available in a different scope in the same function\n    --> src/raw/mod.rs:4505:10\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket_to_remove);\n     |          ^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling libc v0.2.172\n   Compiling crossbeam-utils v0.8.21\n   Compiling zerocopy v0.8.25\n   Compiling syn v1.0.109\n   Compiling rayon-core v1.12.1\n   Compiling serde v1.0.219\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0425]: cannot find value `insert_slot` in this scope\n    --> src/raw/mod.rs:4507:16\n     |\n4507 |     assert_eq!(insert_slot.index, 0);\n     |                ^^^^^^^^^^^\n     |\nhelp: the binding `insert_slot` is available in a different scope in the same function\n    --> src/raw/mod.rs:4505:17\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket_to_remove);\n     |                 ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling crossbeam-utils v0.8.21\n   Compiling libc v0.2.172\n   Compiling syn v1.0.109\n   Compiling zerocopy v0.8.25\n   Compiling serde v1.0.219\n   Compiling rayon-core v1.12.1\n   Compiling doc-comment v0.3.3\n   Compiling crossbeam-epoch v0.9.18\n   Compiling quote v1.0.40\n   Compiling crossbeam-deque v0.8.6\n   Compiling getrandom v0.2.16\n   Compiling rand_core v0.6.4\n   Compiling rayon v1.10.0\n   Compiling ppv-lite86 v0.2.21\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling serde_test v1.0.177\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0425]: cannot find value `insert_slot` in this scope\n    --> src/raw/mod.rs:4507:43\n     |\n4507 |     assert!(unsafe { table.is_bucket_full(insert_slot.index) } == false);\n     |                                           ^^^^^^^^^^^\n     |\nhelp: the binding `insert_slot` is available in a different scope in the same function\n    --> src/raw/mod.rs:4505:17\n     |\n4505 |     let (value, insert_slot) = table.remove(bucket_to_remove);\n     |                 ^^^^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n    --> src/raw/mod.rs:4485:8\n     |\n4485 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}