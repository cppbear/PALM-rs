{
  "name": "hashbrown::raw::raw::RawTableInner::new_uninitialized",
  "name_with_impl": "hashbrown::raw::{impl#13}::new_uninitialized",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:1525:5:1555:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: buckets.is_power_of_two() is true\n",
        "// constraint: table_layout.calculate_layout_for(buckets) matches Some(lco) is true\n",
        "// constraint: table_layout.calculate_layout_for(buckets) matches Some(lco) is true\n",
        "// constraint: do_alloc(alloc, layout) matches Err(_) is true\n",
        "// expected return value/type: Err(fallibility.alloc_err(layout))\n"
      ],
      "input_infer": "test input ranges: buckets = [2, 4, 8, 16, 32, 64], table_layout = any valid TableLayout, fallibility = Fallibility::Fallible\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        // Mocked implementation that always returns an error",
                "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let allocator = TestAllocator;",
                "    let layout = TableLayout::new::<u8>();",
                "    ",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 2, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 2, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 2, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        // Mocked implementation that always returns an error",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "   let _result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 2, Fallibility::Fallible) };",
                  "   let allocator = TestAllocator;",
                  "   let layout = TableLayout::new::<u8>();",
                  "   let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 2, Fallibility::Fallible) };",
                  "   assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        // Mocked implementation that always returns an error",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 2, Fallibility::Fallible) };",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 2, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4507:23\n     |\n4507 |     assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });\n     |                       ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nerror[E0308]: mismatched types\n    --> src/raw/mod.rs:4507:67\n     |\n4507 |     assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });\n     |                                                                   ^^^^^^ expected `Layout`, found `TableLayout`\n\nSome errors have detailed explanations: E0200, E0277, E0308.\nFor more information about an error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let allocator = TestAllocator;",
                "    let layout = TableLayout::new::<u8>();",
                "    ",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };",
                  "    assert_eq!(result.err().unwrap(), TryReserveError::AllocError { layout });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };",
                  "    assert_eq!(result.err().unwrap(), TryReserveError::AllocError { layout });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nwarning: unused variable: `result`\n    --> src/raw/mod.rs:4502:9\n     |\n4502 |     let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 4, Fallibility::Fallible) };\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nerror[E0308]: mismatched types\n    --> src/raw/mod.rs:4506:69\n     |\n4506 |     assert_eq!(result.err().unwrap(), TryReserveError::AllocError { layout });\n     |                                                                     ^^^^^^ expected `Layout`, found `TableLayout`\n\nSome errors have detailed explanations: E0200, E0308.\nFor more information about an error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let allocator = TestAllocator;",
                "    let layout = TableLayout::new::<u8>();",
                "    ",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 8, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 8, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "   {",
                  "       struct TestAllocator;",
                  "       impl Allocator for TestAllocator {",
                  "           fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "               Err(())",
                  "           }",
                  "       }",
                  "",
                  "       let allocator = TestAllocator;",
                  "       let layout = TableLayout::new::<u8>();",
                  "       ",
                  "       let _result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 8, Fallibility::Fallible) };",
                  "       let allocator = TestAllocator;",
                  "       let layout = TableLayout::new::<u8>();",
                  "       let _result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 8, Fallibility::Fallible) };",
                  "       assert!(_result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:8\n     |\n4493 |        impl Allocator for TestAllocator {\n     |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |        unsafe impl Allocator for TestAllocator {\n     |        ++++++\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let allocator = TestAllocator;",
                "    let layout = TableLayout::new::<u8>();",
                "    ",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nwarning: unused variable: `result`\n    --> src/raw/mod.rs:4502:9\n     |\n4502 |     let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 16, Fallibility::Fallible) };\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4506:23\n     |\n4506 |     assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });\n     |                       ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nerror[E0308]: mismatched types\n    --> src/raw/mod.rs:4506:67\n     |\n4506 |     assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });\n     |                                                                   ^^^^^^ expected `Layout`, found `TableLayout`\n\nSome errors have detailed explanations: E0200, E0277, E0308.\nFor more information about an error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let allocator = TestAllocator;",
                "    let layout = TableLayout::new::<u8>();",
                "    ",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 32, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 32, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 32, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "   let _result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 32, Fallibility::Fallible) };  ",
                  "   let allocator = TestAllocator;  ",
                  "   let layout = TableLayout::new::<u8>();  ",
                  "   let _result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 32, Fallibility::Fallible) };  ",
                  "   assert!(_result.is_err());  ",
                  "}"
                ],
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 32, Fallibility::Fallible) };",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 32, Fallibility::Fallible) };",
                  "   assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout: Layout::from_size_align(0, 1).unwrap() });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4506:22\n     |\n4506 |    assert_eq!(result.unwrap_err(), TryReserveError::AllocError { layout: Layout::from_size_align(0, 1).unwrap() });\n     |                      ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nSome errors have detailed explanations: E0200, E0277.\nFor more information about an error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestAllocator;",
                "    impl Allocator for TestAllocator {",
                "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                "            Err(())",
                "        }",
                "    }",
                "",
                "    let allocator = TestAllocator;",
                "    let layout = TableLayout::new::<u8>();",
                "    ",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 64, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 64, Fallibility::Fallible) };",
                  "    assert!(matches!(result, Err(TryReserveError::AllocError { .. })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestAllocator;",
                  "    impl Allocator for TestAllocator {",
                  "        fn allocate(&self, _: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Err(())",
                  "        }",
                  "    }",
                  "",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    ",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 64, Fallibility::Fallible) };",
                  "    let allocator = TestAllocator;",
                  "    let layout = TableLayout::new::<u8>();",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 64, Fallibility::Fallible) };",
                  "    assert!(matches!(result, Err(TryReserveError::AllocError { .. })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4493:5\n     |\n4493 |     impl Allocator for TestAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4493 |     unsafe impl Allocator for TestAllocator {\n     |     ++++++\n\nwarning: unused variable: `result`\n    --> src/raw/mod.rs:4502:9\n     |\n4502 |     let result = unsafe { RawTableInner::new_uninitialized(&allocator, layout, 64, Fallibility::Fallible) };\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: buckets.is_power_of_two() is true\n",
        "// constraint: table_layout.calculate_layout_for(buckets) matches Some(lco) is true\n",
        "// constraint: table_layout.calculate_layout_for(buckets) matches Some(lco) is true\n",
        "// constraint: do_alloc(alloc, layout) matches Ok(block) is true\n",
        "// constraint: do_alloc(alloc, layout) matches Ok(block) is true\n",
        "// expected return value/type: Ok(Self {\n            ctrl,\n            bucket_mask: buckets - 1,\n            items: 0,\n            growth_left: bucket_mask_to_capacity(buckets - 1),\n        })\n"
      ],
      "input_infer": "1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyAllocator;",
                "",
                "    impl Allocator for DummyAllocator {",
                "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            let size = layout.size();",
                "            let align = layout.align();",
                "            let ptr = alloc::alloc::alloc(layout);",
                "            if !ptr.is_null() {",
                "                Ok(NonNull::new(ptr).unwrap())",
                "            } else {",
                "                Err(())",
                "            }",
                "        }",
                "    }",
                "",
                "    let alloc = DummyAllocator;",
                "    let table_layout = TableLayout::new::<u8>();",
                "",
                "    unsafe {",
                "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    assert!(result_1.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    assert_eq!(inner_table_1.bucket_mask, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    assert_eq!(inner_table_1.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    assert_eq!(inner_table_1.growth_left, bucket_mask_to_capacity(0));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    assert!(result_2.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    assert_eq!(inner_table_2.bucket_mask, 1);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    assert_eq!(inner_table_2.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    assert_eq!(inner_table_2.growth_left, bucket_mask_to_capacity(1));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    assert!(result_4.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    assert_eq!(inner_table_4.bucket_mask, 3);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    assert_eq!(inner_table_4.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    assert_eq!(inner_table_4.growth_left, bucket_mask_to_capacity(3));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    assert!(result_8.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    assert_eq!(inner_table_8.bucket_mask, 7);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    assert_eq!(inner_table_8.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    assert_eq!(inner_table_8.growth_left, bucket_mask_to_capacity(7));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    assert!(result_16.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    assert_eq!(inner_table_16.bucket_mask, 15);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    assert_eq!(inner_table_16.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    assert_eq!(inner_table_16.growth_left, bucket_mask_to_capacity(15));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    assert!(result_32.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    assert_eq!(inner_table_32.bucket_mask, 31);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    assert_eq!(inner_table_32.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    assert_eq!(inner_table_32.growth_left, bucket_mask_to_capacity(31));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    assert!(result_64.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    assert_eq!(inner_table_64.bucket_mask, 63);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    assert_eq!(inner_table_64.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    assert_eq!(inner_table_64.growth_left, bucket_mask_to_capacity(63));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    assert!(result_128.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    assert_eq!(inner_table_128.bucket_mask, 127);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    assert_eq!(inner_table_128.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    assert_eq!(inner_table_128.growth_left, bucket_mask_to_capacity(127));"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    assert!(result_256.is_ok());"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    let inner_table_256 = result_256.unwrap();",
                  "    assert_eq!(inner_table_256.bucket_mask, 255);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    let inner_table_256 = result_256.unwrap();",
                  "    assert_eq!(inner_table_256.items, 0);"
                ],
                [
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    let inner_table_256 = result_256.unwrap();",
                  "    assert_eq!(inner_table_256.growth_left, bucket_mask_to_capacity(255));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    assert!(result_1.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    assert_eq!(inner_table_1.bucket_mask, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    assert_eq!(inner_table_1.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    assert_eq!(inner_table_1.growth_left, bucket_mask_to_capacity(0));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    assert!(result_2.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    assert_eq!(inner_table_2.bucket_mask, 1);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    assert_eq!(inner_table_2.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    assert_eq!(inner_table_2.growth_left, bucket_mask_to_capacity(1));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    assert!(result_4.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    assert_eq!(inner_table_4.bucket_mask, 3);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    assert_eq!(inner_table_4.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    assert_eq!(inner_table_4.growth_left, bucket_mask_to_capacity(3));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    assert!(result_8.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    assert_eq!(inner_table_8.bucket_mask, 7);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    assert_eq!(inner_table_8.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    assert_eq!(inner_table_8.growth_left, bucket_mask_to_capacity(7));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    assert!(result_16.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    assert_eq!(inner_table_16.bucket_mask, 15);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    assert_eq!(inner_table_16.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    assert_eq!(inner_table_16.growth_left, bucket_mask_to_capacity(15));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    assert!(result_32.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    assert_eq!(inner_table_32.bucket_mask, 31);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    assert_eq!(inner_table_32.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    assert_eq!(inner_table_32.growth_left, bucket_mask_to_capacity(31));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    assert!(result_64.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    assert_eq!(inner_table_64.bucket_mask, 63);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    assert_eq!(inner_table_64.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    assert_eq!(inner_table_64.growth_left, bucket_mask_to_capacity(63));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    assert!(result_128.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    assert_eq!(inner_table_128.bucket_mask, 127);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    assert_eq!(inner_table_128.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    assert_eq!(inner_table_128.growth_left, bucket_mask_to_capacity(127));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    assert!(result_256.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    let inner_table_256 = result_256.unwrap();",
                  "    assert_eq!(inner_table_256.bucket_mask, 255);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    let inner_table_256 = result_256.unwrap();",
                  "    assert_eq!(inner_table_256.items, 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            let size = layout.size();",
                  "            let align = layout.align();",
                  "            let ptr = alloc::alloc::alloc(layout);",
                  "            if !ptr.is_null() {",
                  "                Ok(NonNull::new(ptr).unwrap())",
                  "            } else {",
                  "                Err(())",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "        let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "        let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "        let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "        let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "        let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "        let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "        let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "        let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    }",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);",
                  "    let inner_table_1 = result_1.unwrap();",
                  "    let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);",
                  "    let inner_table_2 = result_2.unwrap();",
                  "    let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);",
                  "    let inner_table_4 = result_4.unwrap();",
                  "    let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);",
                  "    let inner_table_8 = result_8.unwrap();",
                  "    let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);",
                  "    let inner_table_16 = result_16.unwrap();",
                  "    let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);",
                  "    let inner_table_32 = result_32.unwrap();",
                  "    let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);",
                  "    let inner_table_64 = result_64.unwrap();",
                  "    let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);",
                  "    let inner_table_128 = result_128.unwrap();",
                  "    let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);",
                  "    let inner_table_256 = result_256.unwrap();",
                  "    assert_eq!(inner_table_256.growth_left, bucket_mask_to_capacity(255));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 20 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 20 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 20 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 20 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 21 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 21 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 21 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 21 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 21 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 21 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 21 warnings\nerror: could not compile `hashbrown` (lib test) due to 4 previous errors; 21 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 22 warnings\nerror: could not compile `hashbrown` (lib test) due to 5 previous errors; 22 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 22 warnings\nerror: could not compile `hashbrown` (lib test) due to 5 previous errors; 22 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 22 warnings\nerror: could not compile `hashbrown` (lib test) due to 5 previous errors; 22 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 22 warnings\nerror: could not compile `hashbrown` (lib test) due to 5 previous errors; 22 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 23 warnings\nerror: could not compile `hashbrown` (lib test) due to 6 previous errors; 23 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 23 warnings\nerror: could not compile `hashbrown` (lib test) due to 6 previous errors; 23 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 23 warnings\nerror: could not compile `hashbrown` (lib test) due to 6 previous errors; 23 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 23 warnings\nerror: could not compile `hashbrown` (lib test) due to 6 previous errors; 23 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 24 warnings\nerror: could not compile `hashbrown` (lib test) due to 7 previous errors; 24 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 24 warnings\nerror: could not compile `hashbrown` (lib test) due to 7 previous errors; 24 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 24 warnings\nerror: could not compile `hashbrown` (lib test) due to 7 previous errors; 24 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 24 warnings\nerror: could not compile `hashbrown` (lib test) due to 7 previous errors; 24 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 25 warnings\nerror: could not compile `hashbrown` (lib test) due to 8 previous errors; 25 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 25 warnings\nerror: could not compile `hashbrown` (lib test) due to 8 previous errors; 25 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 25 warnings\nerror: could not compile `hashbrown` (lib test) due to 8 previous errors; 25 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 25 warnings\nerror: could not compile `hashbrown` (lib test) due to 8 previous errors; 25 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 26 warnings\nerror: could not compile `hashbrown` (lib test) due to 9 previous errors; 26 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 26 warnings\nerror: could not compile `hashbrown` (lib test) due to 9 previous errors; 26 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 26 warnings\nerror: could not compile `hashbrown` (lib test) due to 9 previous errors; 26 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 26 warnings\nerror: could not compile `hashbrown` (lib test) due to 9 previous errors; 26 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 27 warnings\nerror: could not compile `hashbrown` (lib test) due to 10 previous errors; 27 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 27 warnings\nerror: could not compile `hashbrown` (lib test) due to 10 previous errors; 27 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 27 warnings\nerror: could not compile `hashbrown` (lib test) due to 10 previous errors; 27 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 27 warnings\nerror: could not compile `hashbrown` (lib test) due to 10 previous errors; 27 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nwarning: unused variable: `inner_table_128`\n    --> src/raw/mod.rs:4538:9\n     |\n4538 |     let inner_table_128 = result_128.unwrap();\n     |         ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_128`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4539:22\n     |\n4539 |     let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 28 warnings\nerror: could not compile `hashbrown` (lib test) due to 11 previous errors; 28 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nwarning: unused variable: `inner_table_128`\n    --> src/raw/mod.rs:4538:9\n     |\n4538 |     let inner_table_128 = result_128.unwrap();\n     |         ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_128`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4539:22\n     |\n4539 |     let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 28 warnings\nerror: could not compile `hashbrown` (lib test) due to 11 previous errors; 28 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nwarning: unused variable: `inner_table_128`\n    --> src/raw/mod.rs:4538:9\n     |\n4538 |     let inner_table_128 = result_128.unwrap();\n     |         ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_128`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4539:22\n     |\n4539 |     let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 28 warnings\nerror: could not compile `hashbrown` (lib test) due to 11 previous errors; 28 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror[E0433]: failed to resolve: could not find `alloc` in `alloc`\n    --> src/raw/mod.rs:4498:30\n     |\n4498 |             let ptr = alloc::alloc::alloc(layout);\n     |                              ^^^^^ could not find `alloc` in `alloc`\n     |\nhelp: consider importing one of these items\n     |\n4484 +    use crate::alloc;\n     |\n4484 +    use crate::raw::alloc;\n     |\n4484 +    use std::alloc;\n     |\n4484 +    use alloc::alloc;\n     |\n       and 1 other candidate\nhelp: if you import `alloc`, refer to it directly\n     |\n4498 -             let ptr = alloc::alloc::alloc(layout);\n4498 +             let ptr = alloc::alloc(layout);\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4494:5\n     |\n4494 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4494 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `result_1`\n    --> src/raw/mod.rs:4511:13\n     |\n4511 |         let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `result_2`\n    --> src/raw/mod.rs:4512:13\n     |\n4512 |         let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_2`\n\nwarning: unused variable: `result_4`\n    --> src/raw/mod.rs:4513:13\n     |\n4513 |         let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_4`\n\nwarning: unused variable: `result_8`\n    --> src/raw/mod.rs:4514:13\n     |\n4514 |         let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_8`\n\nwarning: unused variable: `result_16`\n    --> src/raw/mod.rs:4515:13\n     |\n4515 |         let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_16`\n\nwarning: unused variable: `result_32`\n    --> src/raw/mod.rs:4516:13\n     |\n4516 |         let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_32`\n\nwarning: unused variable: `result_64`\n    --> src/raw/mod.rs:4517:13\n     |\n4517 |         let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_64`\n\nwarning: unused variable: `result_128`\n    --> src/raw/mod.rs:4518:13\n     |\n4518 |         let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_128`\n\nwarning: unused variable: `result_256`\n    --> src/raw/mod.rs:4519:13\n     |\n4519 |         let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_result_256`\n\nwarning: unused variable: `inner_table_1`\n    --> src/raw/mod.rs:4524:9\n     |\n4524 |     let inner_table_1 = result_1.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_1`\n\nwarning: unused variable: `inner_table_2`\n    --> src/raw/mod.rs:4526:9\n     |\n4526 |     let inner_table_2 = result_2.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_2`\n\nwarning: unused variable: `inner_table_4`\n    --> src/raw/mod.rs:4528:9\n     |\n4528 |     let inner_table_4 = result_4.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_4`\n\nwarning: unused variable: `inner_table_8`\n    --> src/raw/mod.rs:4530:9\n     |\n4530 |     let inner_table_8 = result_8.unwrap();\n     |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_8`\n\nwarning: unused variable: `inner_table_16`\n    --> src/raw/mod.rs:4532:9\n     |\n4532 |     let inner_table_16 = result_16.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_16`\n\nwarning: unused variable: `inner_table_32`\n    --> src/raw/mod.rs:4534:9\n     |\n4534 |     let inner_table_32 = result_32.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_32`\n\nwarning: unused variable: `inner_table_64`\n    --> src/raw/mod.rs:4536:9\n     |\n4536 |     let inner_table_64 = result_64.unwrap();\n     |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_64`\n\nwarning: unused variable: `inner_table_128`\n    --> src/raw/mod.rs:4538:9\n     |\n4538 |     let inner_table_128 = result_128.unwrap();\n     |         ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inner_table_128`\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4523:20\n     |\n4523 |     let result_1 = RawTableInner::new_uninitialized(&alloc, table_layout, 1, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4525:20\n     |\n4525 |     let result_2 = RawTableInner::new_uninitialized(&alloc, table_layout, 2, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4527:20\n     |\n4527 |     let result_4 = RawTableInner::new_uninitialized(&alloc, table_layout, 4, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4529:20\n     |\n4529 |     let result_8 = RawTableInner::new_uninitialized(&alloc, table_layout, 8, Fallibility::Infallible);\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4531:21\n     |\n4531 |     let result_16 = RawTableInner::new_uninitialized(&alloc, table_layout, 16, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4533:21\n     |\n4533 |     let result_32 = RawTableInner::new_uninitialized(&alloc, table_layout, 32, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4535:21\n     |\n4535 |     let result_64 = RawTableInner::new_uninitialized(&alloc, table_layout, 64, Fallibility::Infallible);\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4537:22\n     |\n4537 |     let result_128 = RawTableInner::new_uninitialized(&alloc, table_layout, 128, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4539:22\n     |\n4539 |     let result_256 = RawTableInner::new_uninitialized(&alloc, table_layout, 256, Fallibility::Infallible);\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nSome errors have detailed explanations: E0133, E0200, E0433.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 28 warnings\nerror: could not compile `hashbrown` (lib test) due to 11 previous errors; 28 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    struct DummyAllocator;",
                "",
                "    impl Allocator for DummyAllocator {",
                "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                "        }",
                "    }",
                "    ",
                "    let alloc = DummyAllocator;",
                "    let table_layout = TableLayout::new::<u8>();",
                "",
                "    unsafe {",
                "        let _ = RawTableInner::new_uninitialized(&alloc, table_layout, 3, Fallibility::Infallible);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let buckets = 3;",
                  "    assert!(buckets.is_power_of_two() == false);"
                ],
                [
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    assert!(layout.0.size() > 0);"
                ],
                [
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    assert!(alloc_result.is_ok());"
                ],
                [
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    let ptr = alloc_result.unwrap();",
                  "    assert!(ptr.as_ptr().is_non_null());"
                ],
                [
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    let ptr = alloc_result.unwrap();",
                  "    let ctrl_offset = layout.1;",
                  "    let ctrl_ptr = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));",
                  "    assert_eq!(ctrl_ptr.as_ptr() as usize % layout.0.align(), 0);"
                ],
                [
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    let ptr = alloc_result.unwrap();",
                  "    let ctrl_offset = layout.1;",
                  "    let ctrl_ptr = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));",
                  "    let expected = Ok(RawTableInner { ctrl: ctrl_ptr, bucket_mask: buckets - 1, items: 0, growth_left: bucket_mask_to_capacity(buckets - 1) });",
                  "    assert!(matches!(RawTableInner::new_uninitialized(&alloc, table_layout, buckets, Fallibility::Infallible), expected));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "    ",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let _ = RawTableInner::new_uninitialized(&alloc, table_layout, 3, Fallibility::Infallible);",
                  "    }",
                  "    let buckets = 3;",
                  "    assert!(buckets.is_power_of_two() == false);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "    ",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let _ = RawTableInner::new_uninitialized(&alloc, table_layout, 3, Fallibility::Infallible);",
                  "    }",
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    assert!(layout.0.size() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "    ",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let _ = RawTableInner::new_uninitialized(&alloc, table_layout, 3, Fallibility::Infallible);",
                  "    }",
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    assert!(alloc_result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "    ",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let _ = RawTableInner::new_uninitialized(&alloc, table_layout, 3, Fallibility::Infallible);",
                  "    }",
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    let ptr = alloc_result.unwrap();",
                  "    assert!(ptr.as_ptr().is_non_null());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "    ",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let _ = RawTableInner::new_uninitialized(&alloc, table_layout, 3, Fallibility::Infallible);",
                  "    }",
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    let ptr = alloc_result.unwrap();",
                  "    let ctrl_offset = layout.1;",
                  "    let ctrl_ptr = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));",
                  "    assert_eq!(ctrl_ptr.as_ptr() as usize % layout.0.align(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "    ",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let _ = RawTableInner::new_uninitialized(&alloc, table_layout, 3, Fallibility::Infallible);",
                  "    }",
                  "    let buckets = 3;",
                  "    let layout = table_layout.calculate_layout_for(buckets).unwrap();",
                  "    let alloc_result = do_alloc(&alloc, layout.0);",
                  "    let ptr = alloc_result.unwrap();",
                  "    let ctrl_offset = layout.1;",
                  "    let ctrl_ptr = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));",
                  "    let expected = Ok(RawTableInner { ctrl: ctrl_ptr, bucket_mask: buckets - 1, items: 0, growth_left: bucket_mask_to_capacity(buckets - 1) });",
                  "    assert!(matches!(RawTableInner::new_uninitialized(&alloc, table_layout, buckets, Fallibility::Infallible), expected));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4495:5\n     |\n4495 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4495 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nerror[E0689]: can't call method `is_power_of_two` on ambiguous numeric type `{integer}`\n    --> src/raw/mod.rs:4508:21\n     |\n4508 |     assert!(buckets.is_power_of_two() == false);\n     |                     ^^^^^^^^^^^^^^^\n     |\nhelp: you must specify a type for this binding, like `i32`\n     |\n4507 |     let buckets: i32 = 3;\n     |                +++++\n\nwarning: unused variable: `layout`\n    --> src/raw/mod.rs:4496:28\n     |\n4496 |         fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {\n     |                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_layout`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nSome errors have detailed explanations: E0200, E0689.\nFor more information about an error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4495:5\n     |\n4495 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4495 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `layout`\n    --> src/raw/mod.rs:4496:28\n     |\n4496 |         fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {\n     |                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_layout`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4495:5\n     |\n4495 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4495 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nwarning: unused variable: `layout`\n    --> src/raw/mod.rs:4496:28\n     |\n4496 |         fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {\n     |                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_layout`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nFor more information about this error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4495:5\n     |\n4495 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4495 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nerror[E0599]: no method named `is_non_null` found for raw pointer `*mut u8` in the current scope\n    --> src/raw/mod.rs:4511:26\n     |\n4511 |     assert!(ptr.as_ptr().is_non_null());\n     |                          ^^^^^^^^^^^\n     |\nhelp: there is a method `is_null` with a similar name\n     |\n4511 |     assert!(ptr.as_ptr().is_null());\n     |                          ~~~~~~~\n\nwarning: unused variable: `layout`\n    --> src/raw/mod.rs:4496:28\n     |\n4496 |         fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {\n     |                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_layout`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nSome errors have detailed explanations: E0200, E0599.\nFor more information about an error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4495:5\n     |\n4495 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4495 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nerror[E0133]: call to unsafe function `std::ptr::NonNull::<T>::new_unchecked` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4512:20\n     |\n4512 |     let ctrl_ptr = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));\n     |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nerror[E0133]: call to unsafe function `std::ptr::mut_ptr::<impl *mut T>::add` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4512:43\n     |\n4512 |     let ctrl_ptr = NonNull::new_unchecked(ptr.as_ptr().add(ctrl_offset));\n     |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nwarning: unused variable: `layout`\n    --> src/raw/mod.rs:4496:28\n     |\n4496 |         fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {\n     |                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_layout`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nSome errors have detailed explanations: E0133, E0200.\nFor more information about an error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 12 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0200]: the trait `allocator_api2::alloc::Allocator` requires an `unsafe impl` declaration\n    --> src/raw/mod.rs:4495:5\n     |\n4495 |     impl Allocator for DummyAllocator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: the trait `allocator_api2::alloc::Allocator` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\nhelp: add `unsafe` to this trait implementation\n     |\n4495 |     unsafe impl Allocator for DummyAllocator {\n     |     ++++++\n\nerror[E0282]: type annotations needed for `Result<raw::RawTableInner, _>`\n    --> src/raw/mod.rs:4513:9\n     |\n4513 | ...et expected = Ok(RawTableInner { ctrl: ctrl_ptr, bucket_mask: buckets - 1, items: 0, growth_left: bucket_mask_to_capacity(buckets - 1) ...\n     |       ^^^^^^^^   --------------------------------------------------------------------------------------------------------------------------- type must be known at this point\n     |\nhelp: consider giving `expected` an explicit type, where the type for type parameter `E` is specified\n     |\n4513 |     let expected: Result<raw::RawTableInner, E> = Ok(RawTableInner { ctrl: ctrl_ptr, bucket_mask: buckets - 1, items: 0, growth_left: bucket_mask_to_capacity(buckets - 1) });\n     |                 +++++++++++++++++++++++++++++++\n\nwarning: unused variable: `layout`\n    --> src/raw/mod.rs:4496:28\n     |\n4496 |         fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {\n     |                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_layout`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nSome errors have detailed explanations: E0200, E0282.\nFor more information about an error, try `rustc --explain E0200`.\nwarning: `hashbrown` (lib test) generated 12 warnings\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors; 12 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyAllocator;",
                "",
                "    impl Allocator for DummyAllocator {",
                "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                "        }",
                "    }",
                "",
                "    let alloc = DummyAllocator;",
                "    let table_layout = TableLayout::new::<u8>();",
                "",
                "    unsafe {",
                "        let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                "        let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                "        let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                "        let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    assert_eq!(result_1024, Ok(Self {"
                ],
                [
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    ctrl,",
                  "    bucket_mask: 1023,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(1023),",
                  "    }));",
                  "    assert_eq!(result_2048, Ok(Self {"
                ],
                [
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    ctrl,",
                  "    bucket_mask: 1023,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(1023),",
                  "    }));",
                  "    ctrl,",
                  "    bucket_mask: 2047,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(2047),",
                  "    }));",
                  "    assert_eq!(result_4096, Ok(Self {"
                ],
                [
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    ctrl,",
                  "    bucket_mask: 1023,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(1023),",
                  "    }));",
                  "    ctrl,",
                  "    bucket_mask: 2047,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(2047),",
                  "    }));",
                  "    ctrl,",
                  "    bucket_mask: 4095,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(4095),",
                  "    }));",
                  "    assert_eq!(result_8192, Ok(Self {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "        let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "        let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "        let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    }",
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    assert_eq!(result_1024, Ok(Self {",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "        let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "        let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "        let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    }",
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    ctrl,",
                  "    bucket_mask: 1023,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(1023),",
                  "    }));",
                  "    assert_eq!(result_2048, Ok(Self {",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "        let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "        let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "        let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    }",
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    ctrl,",
                  "    bucket_mask: 1023,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(1023),",
                  "    }));",
                  "    ctrl,",
                  "    bucket_mask: 2047,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(2047),",
                  "    }));",
                  "    assert_eq!(result_4096, Ok(Self {",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyAllocator;",
                  "",
                  "    impl Allocator for DummyAllocator {",
                  "        fn allocate(&self, layout: Layout) -> Result<NonNull<u8>, ()> {",
                  "            Ok(NonNull::new(1 as *mut u8).unwrap())",
                  "        }",
                  "    }",
                  "",
                  "    let alloc = DummyAllocator;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "",
                  "    unsafe {",
                  "        let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "        let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "        let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "        let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    }",
                  "    let result_1024 = RawTableInner::new_uninitialized(&alloc, table_layout, 1024, Fallibility::Infallible);",
                  "    let result_2048 = RawTableInner::new_uninitialized(&alloc, table_layout, 2048, Fallibility::Infallible);",
                  "    let result_4096 = RawTableInner::new_uninitialized(&alloc, table_layout, 4096, Fallibility::Infallible);",
                  "    let result_8192 = RawTableInner::new_uninitialized(&alloc, table_layout, 8192, Fallibility::Infallible);",
                  "    ctrl,",
                  "    bucket_mask: 1023,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(1023),",
                  "    }));",
                  "    ctrl,",
                  "    bucket_mask: 2047,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(2047),",
                  "    }));",
                  "    ctrl,",
                  "    bucket_mask: 4095,",
                  "    items: 0,",
                  "    growth_left: bucket_mask_to_capacity(4095),",
                  "    }));",
                  "    assert_eq!(result_8192, Ok(Self {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `}`\n    --> src/raw/mod.rs:4513:31\n     |\n4491 | {\n     | - closing delimiter possibly meant for this\n...\n4513 |     assert_eq!(result_1024, Ok(Self {\n     |                               ^ unclosed delimiter\n4514 | }\n4515 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> src/raw/mod.rs:4515:3\n     |\n4483 | mod llmtests {\n     |              - unclosed delimiter\n...\n4515 | }\n     |   ^\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `)`\n    --> src/raw/mod.rs:4483:14\n     |\n4483 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n4517 |     }));\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/raw/mod.rs:4517:7\n     |\n4517 |     }));\n     |      -^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `)`\n    --> src/raw/mod.rs:4483:14\n     |\n4483 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n4517 |     }));\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/raw/mod.rs:4517:7\n     |\n4517 |     }));\n     |      -^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `)`\n    --> src/raw/mod.rs:4483:14\n     |\n4483 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n4517 |     }));\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/raw/mod.rs:4517:7\n     |\n4517 |     }));\n     |      -^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: buckets.is_power_of_two() is true\n",
        "// constraint: table_layout.calculate_layout_for(buckets) matches None is true\n",
        "// expected return value/type: Err(fallibility.capacity_overflow())\n"
      ],
      "input_infer": "buckets: 0, 1, 3, 5, 7, 9, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215, 33554431, 67108863, 134217727, 268435455, 536870911, 1073741823, 2147483647, 4294967295, 8589934591, 17179869183, 34359738367, 68719476735, 137438953471, 274877906943, 549755813887, 1099511627775, 2199023255551, 4398046511103, 8796093022207, 17592186044415, 35184372088831, 70368744177663, 140737488355327, 281474976710655, 562949953421311, 1125899906842623, 2251799813685247, 4503599627370495, 9007199254740991, 18014398509481983, 36028797018963967, 72057594037927935, 144115188075855871, 288230376151711743, 576460752303423487, 1152921504606846975, 2305843009213693951, 4611686018427387903, 9223372036854775807\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 0;  // Not a power of two",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 0;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 0;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 0;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 0;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 0;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 0;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4500:23\n     |\n4500 |     assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n     |                       ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 1;  // Is a power of two, but may cause capacity overflow in calculate_layout_for",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 1;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 1;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 1;  // Is a power of two, but may cause capacity overflow in calculate_layout_for",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 1;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 1;  // Is a power of two, but may cause capacity overflow in calculate_layout_for",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 1;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4500:23\n     |\n4500 |     assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n     |                       ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 3;  // Not a power of two",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;",
                  "    assert_eq!(result, Err(Fallibility::Fallible.capacity_overflow()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;",
                  "    assert_eq!(result, Err(Fallibility::Fallible.capacity_overflow()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Result<raw::RawTableInner, TryReserveError>`\n    --> src/raw/mod.rs:4499:5\n     |\n4499 |     assert_eq!(result, Err(Fallibility::Fallible.capacity_overflow()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     Result<raw::RawTableInner, TryReserveError>\n     |     Result<raw::RawTableInner, TryReserveError>\n     |\nnote: an implementation of `PartialEq` might be missing for `raw::RawTableInner`\n    --> src/raw/mod.rs:657:1\n     |\n657  | struct RawTableInner {\n     | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `raw::RawTableInner` with `#[derive(PartialEq)]`\n     |\n657  + #[derive(PartialEq)]\n658  | struct RawTableInner {\n     |\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4499:5\n     |\n4499 |     assert_eq!(result, Err(Fallibility::Fallible.capacity_overflow()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`, which is required by `Result<raw::RawTableInner, TryReserveError>: Debug`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\n     = help: the trait `Debug` is implemented for `Result<T, E>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 5;  // Not a power of two",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4500:23\n     |\n4500 |     assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n     |                       ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 7;  // Not a power of two",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4500:23\n     |\n4500 |     assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n     |                       ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 9;  // Not a power of two",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    if let Err(error) = result {",
                  "    assert_eq!(error, TryReserveError::CapacityOverflow);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    if let Err(error) = result {",
                  "    assert_eq!(error, TryReserveError::CapacityOverflow);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: this file contains an unclosed delimiter\n    --> src/raw/mod.rs:4503:3\n     |\n4483 | mod llmtests {\n     |              - unclosed delimiter\n...\n4503 | }\n     |   ^\n\nerror: could not compile `hashbrown` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 15;  // Not a power of two",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 15;",
                  "    assert_eq!(result, Err(TryReserveError::CapacityOverflow));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 15;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 15;",
                  "    assert_eq!(result, Err(TryReserveError::CapacityOverflow));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Result<raw::RawTableInner, TryReserveError>`\n    --> src/raw/mod.rs:4499:5\n     |\n4499 |     assert_eq!(result, Err(TryReserveError::CapacityOverflow));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     Result<raw::RawTableInner, TryReserveError>\n     |     Result<raw::RawTableInner, TryReserveError>\n     |\nnote: an implementation of `PartialEq` might be missing for `raw::RawTableInner`\n    --> src/raw/mod.rs:657:1\n     |\n657  | struct RawTableInner {\n     | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `raw::RawTableInner` with `#[derive(PartialEq)]`\n     |\n657  + #[derive(PartialEq)]\n658  | struct RawTableInner {\n     |\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4499:5\n     |\n4499 |     assert_eq!(result, Err(TryReserveError::CapacityOverflow));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`, which is required by `Result<raw::RawTableInner, TryReserveError>: Debug`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\n     = help: the trait `Debug` is implemented for `Result<T, E>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let allocator = Global;  // Assuming Global is a valid allocator",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 31;  // Not a power of two",
                "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 31;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 31;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 31;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 31;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global;  // Assuming Global is a valid allocator",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 31;  // Not a power of two",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 31;",
                  "    let result = unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, Fallibility::Fallible) };",
                  "    assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4500:23\n     |\n4500 |     assert_eq!(result.unwrap_err(), TryReserveError::CapacityOverflow);\n     |                       ^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\nnote: required by a bound in `Result::<T, E>::unwrap_err`\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1193:12\n     |\n1191 |     pub fn unwrap_err(self) -> E\n     |            ---------- required by a bound in this associated function\n1192 |     where\n1193 |         T: fmt::Debug,\n     |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap_err`\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: buckets.is_power_of_two() is false\n"
      ],
      "input_infer": "Test input ranges: buckets in the range of [1, 10] excluding powers of two (i.e., 1, 3, 5, 6, 7, 9, 10)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [
                "#[should_panic(expected = \"Hash table capacity overflow\")]"
              ],
              "prefix": [
                "{",
                "    let allocator = Global; ",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 3;",
                "    let fallibility = Fallibility::Infallible;",
                "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_eq!(unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) }, Err(TryReserveError::CapacityOverflow));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 3;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_eq!(unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) }, Err(TryReserveError::CapacityOverflow));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Result<raw::RawTableInner, TryReserveError>`\n    --> src/raw/mod.rs:4502:5\n     |\n4502 |     assert_eq!(unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) }, Err(TryReserveError::CapacityOverflow...\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     Result<raw::RawTableInner, TryReserveError>\n     |     Result<raw::RawTableInner, TryReserveError>\n     |\nnote: an implementation of `PartialEq` might be missing for `raw::RawTableInner`\n    --> src/raw/mod.rs:657:1\n     |\n657  | struct RawTableInner {\n     | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `raw::RawTableInner` with `#[derive(PartialEq)]`\n     |\n657  + #[derive(PartialEq)]\n658  | struct RawTableInner {\n     |\n\nerror[E0277]: `raw::RawTableInner` doesn't implement `Debug`\n    --> src/raw/mod.rs:4502:5\n     |\n4502 |     assert_eq!(unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) }, Err(TryReserveError::CapacityOverflow...\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `raw::RawTableInner` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `raw::RawTableInner`, which is required by `Result<raw::RawTableInner, TryReserveError>: Debug`\n     = note: add `#[derive(Debug)]` to `raw::RawTableInner` or manually `impl Debug for raw::RawTableInner`\n     = help: the trait `Debug` is implemented for `Result<T, E>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `raw::RawTableInner` with `#[derive(Debug)]`\n     |\n657  + #[derive(Debug)]\n658  | struct RawTableInner {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 3 previous errors; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"Hash table capacity overflow\")]"
              ],
              "prefix": [
                "{",
                "    let allocator = Global; ",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 5;",
                "    let fallibility = Fallibility::Infallible;",
                "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert!(std::panic::catch_unwind(|| {"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) }",
                  "    }).is_err());",
                  "    assert_eq!(std::panic::catch_unwind(|| {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 5;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) }",
                  "    }).is_err());",
                  "    assert_eq!(std::panic::catch_unwind(|| {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `}`\n    --> src/raw/mod.rs:4502:37\n     |\n4492 | {\n     | - closing delimiter possibly meant for this\n...\n4502 |     assert!(std::panic::catch_unwind(|| {\n     |                                     ^ unclosed delimiter\n4503 | }\n4504 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> src/raw/mod.rs:4504:3\n     |\n4483 | mod llmtests {\n     |              - unclosed delimiter\n...\n4504 | }\n     |   ^\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `)`\n    --> src/raw/mod.rs:4483:14\n     |\n4483 | mod llmtests {\n     |              ^ unclosed delimiter\n...\n4503 |     }).is_err());\n     |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n    --> src/raw/mod.rs:4503:16\n     |\n4503 |     }).is_err());\n     |      -         ^ unexpected closing delimiter\n     |      |\n     |      missing open `(` for this delimiter\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"Hash table capacity overflow\")]"
              ],
              "prefix": [
                "{",
                "    let allocator = Global; ",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 6;",
                "    let fallibility = Fallibility::Infallible;",
                "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 6;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_eq!(RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility).is_err(), true);"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 6;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert!(std::panic::catch_unwind(|| {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 6;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 6;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_eq!(RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility).is_err(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 6;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 6;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4502:16\n     |\n4502 |     assert_eq!(RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility).is_err(), true);\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `}`\n    --> src/raw/mod.rs:4502:37\n     |\n4492 | {\n     | - closing delimiter possibly meant for this\n...\n4502 |     assert!(std::panic::catch_unwind(|| {\n     |                                     ^ unclosed delimiter\n4503 | }\n4504 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> src/raw/mod.rs:4504:3\n     |\n4483 | mod llmtests {\n     |              - unclosed delimiter\n...\n4504 | }\n     |   ^\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"Hash table capacity overflow\")]"
              ],
              "prefix": [
                "{",
                "    let allocator = Global; ",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 7;",
                "    let fallibility = Fallibility::Infallible;",
                "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    let result = RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    let result = RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility);",
                  "    assert_eq!(result.err(), Some(TryReserveError::CapacityOverflow));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    let result = RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 7;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    let result = RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility);",
                  "    assert_eq!(result.err(), Some(TryReserveError::CapacityOverflow));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4502:18\n     |\n4502 |     let result = RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility);\n     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4502:18\n     |\n4502 |     let result = RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility);\n     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"Hash table capacity overflow\")]"
              ],
              "prefix": [
                "{",
                "    let allocator = Global; ",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 9;",
                "    let fallibility = Fallibility::Infallible;",
                "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert!(std::panic::catch_unwind(|| {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 9;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: mismatched closing delimiter: `}`\n    --> src/raw/mod.rs:4502:37\n     |\n4492 | {\n     | - closing delimiter possibly meant for this\n...\n4502 |     assert!(std::panic::catch_unwind(|| {\n     |                                     ^ unclosed delimiter\n4503 | }\n4504 | }\n     | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n    --> src/raw/mod.rs:4504:3\n     |\n4483 | mod llmtests {\n     |              - unclosed delimiter\n...\n4504 | }\n     |   ^\n\nerror: could not compile `hashbrown` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic(expected = \"Hash table capacity overflow\")]"
              ],
              "prefix": [
                "{",
                "    let allocator = Global; ",
                "    let table_layout = TableLayout::new::<u8>();",
                "    let buckets = 10;",
                "    let fallibility = Fallibility::Infallible;",
                "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                "}"
              ],
              "oracles": [
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 10;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_eq!(RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility).is_err(), true);"
                ],
                [
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 10;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_panics!(unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 10;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 10;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_eq!(RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility).is_err(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let allocator = Global; ",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 10;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) };",
                  "    let allocator = Global;",
                  "    let table_layout = TableLayout::new::<u8>();",
                  "    let buckets = 10;",
                  "    let fallibility = Fallibility::Infallible;",
                  "    assert_panics!(unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nerror[E0133]: call to unsafe function `raw::RawTableInner::new_uninitialized` is unsafe and requires unsafe function or block\n    --> src/raw/mod.rs:4502:16\n     |\n4502 |     assert_eq!(RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility).is_err(), true);\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n     |\n     = note: consult the function's documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                },
                {
                  "Err": "   Compiling hashbrown v0.15.1 (/home/abezbm/rust-utgen-test-crates-new/hashbrown)\nerror: cannot find macro `assert_panics` in this scope\n    --> src/raw/mod.rs:4502:5\n     |\n4502 |     assert_panics!(unsafe { RawTableInner::new_uninitialized(&allocator, table_layout, buckets, fallibility) });\n     |     ^^^^^^^^^^^^^\n     |\nhelp: consider importing this macro\n     |\n4484 +    use ntest::assert_panics;\n     |\n\nwarning: unused imports: `Occupied` and `Vacant`\n    --> src/map.rs:4688:24\n     |\n4688 |     use super::Entry::{Occupied, Vacant};\n     |                        ^^^^^^^^  ^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `super::EntryRef`\n    --> src/map.rs:4689:9\n     |\n4689 |     use super::EntryRef;\n     |         ^^^^^^^^^^^^^^^\n\nwarning: unused import: `ToString`\n    --> src/map.rs:4691:33\n     |\n4691 |     use alloc::string::{String, ToString};\n     |                                 ^^^^^^^^\n\nwarning: unused imports: `Rng`, `SeedableRng`, and `rngs::SmallRng`\n    --> src/map.rs:4697:16\n     |\n4697 |     use rand::{rngs::SmallRng, Rng, SeedableRng};\n     |                ^^^^^^^^^^^^^^  ^^^  ^^^^^^^^^^^\n\nwarning: unused import: `std::borrow::ToOwned`\n    --> src/map.rs:4698:9\n     |\n4698 |     use std::borrow::ToOwned;\n     |         ^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashMap`\n    --> src/raw_entry.rs:1487:9\n     |\n1487 |     use super::HashMap;\n     |         ^^^^^^^^^^^^^^\n\nwarning: unused import: `super::RawEntryMut`\n    --> src/raw_entry.rs:1488:9\n     |\n1488 |     use super::RawEntryMut;\n     |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `Equivalent`, `HashSet`, and `make_hash`\n    --> src/set.rs:2579:17\n     |\n2579 |     use super::{make_hash, Equivalent, HashSet};\n     |                 ^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^\n\nwarning: unused import: `crate::DefaultHashBuilder`\n    --> src/set.rs:2580:9\n     |\n2580 |     use crate::DefaultHashBuilder;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `std::vec::Vec`\n    --> src/set.rs:2581:9\n     |\n2581 |     use std::vec::Vec;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused import: `super::HashTable`\n    --> src/table.rs:2375:9\n     |\n2375 |     use super::HashTable;\n     |         ^^^^^^^^^^^^^^^^\n\nwarning: `hashbrown` (lib test) generated 11 warnings\nerror: could not compile `hashbrown` (lib test) due to 1 previous error; 11 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}