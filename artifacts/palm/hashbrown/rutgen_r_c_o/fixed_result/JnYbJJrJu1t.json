{"function_name":"hashbrown::raw_entry::raw_entry::RawEntryMut<'a, K, V, S, A>::and_replace_entry_with","file_path":"/home/abezbm/rust-utgen-test-crates-new/hashbrown/src/raw_entry.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/hashbrown","tests":11,"tests_lines":[17,17,17,22,26,26,26,30,30,33,23],"oracles":8,"oracles_compiled":2,"oracles_compiled_rate":25.0,"tests_compiled":2,"tests_compiled_rate":18.181818181818183,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":8,"lines_covered":7,"lines_coveraged_rate":87.5,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[893,894,895,896,897,898,899,901],"codes_lines_covered":[[["{","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","","    let entry = map","        .raw_entry_mut()","        .from_key(\"existing_key\")","        .and_replace_entry_with(|k, v| {","            assert_eq!(k, &\"existing_key\");","            assert_eq!(v, 100);","            Some(v + 1)","        });","","    match entry {","        RawEntryMut::Occupied(e) => {","            assert_eq!(e.key(), &\"existing_key\");","            assert_eq!(e.get(), &101);","        },","        RawEntryMut::Vacant(_) => panic!(),","    }","    assert_eq!(map[\"existing_key\"], 101);","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","    let entry = map.raw_entry_mut().from_key(\"existing_key\").and_replace_entry_with(|k, v| {","    Some(v + 1)","    });","    match entry {","    RawEntryMut::Occupied(e) => {","    },","    RawEntryMut::Vacant(_) => panic!(),","    }","    assert_eq!(map[\"existing_key\"], 101);","}"],[893,894,895,896,897,898,901]],[["{","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","","    let entry = map","        .raw_entry_mut()","        .from_key(\"existing_key\")","        .and_replace_entry_with(|_k, _v| None);","    ","    match entry {","        RawEntryMut::Vacant(_) => {},","        RawEntryMut::Occupied(_) => panic!(),","    }","    assert!(!map.contains_key(\"existing_key\"));","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","    let entry = map.raw_entry_mut().from_key(\"existing_key\").and_replace_entry_with(|_k, _v| None);","    match entry {","    RawEntryMut::Vacant(_) => {},","    RawEntryMut::Occupied(_) => panic!(),","    }","    assert!(!map.contains_key(\"existing_key\"));","}"],[893,894,895,896,897,898,901]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","","    let entry = map","        .raw_entry_mut()","        .from_key(\"existing_key\")","        .and_replace_entry_with(|k, v| {","            assert_eq!(k, &\"existing_key\");","            assert_eq!(v, 100);","            Some(v + 1)","        });","","    match entry {","        RawEntryMut::Occupied(e) => {","            assert_eq!(e.key(), &\"existing_key\");","            assert_eq!(e.get(), &101);","        },","        RawEntryMut::Vacant(_) => panic!(),","    }","    assert_eq!(map[\"existing_key\"], 101);","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","    let entry = map.raw_entry_mut().from_key(\"existing_key\").and_replace_entry_with(|k, v| {","    Some(v + 1)","    });","    match entry {","    RawEntryMut::Occupied(e) => {","    },","    RawEntryMut::Vacant(_) => panic!(),","    }","    assert_eq!(map[\"existing_key\"], 101);","}"],[]],[["{","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","","    let entry = map","        .raw_entry_mut()","        .from_key(\"existing_key\")","        .and_replace_entry_with(|_k, _v| None);","    ","    match entry {","        RawEntryMut::Vacant(_) => {},","        RawEntryMut::Occupied(_) => panic!(),","    }","    assert!(!map.contains_key(\"existing_key\"));","    let mut map: HashMap<&str, u32> = HashMap::new();","    map.insert(\"existing_key\", 100);","    let entry = map.raw_entry_mut().from_key(\"existing_key\").and_replace_entry_with(|_k, _v| None);","    match entry {","    RawEntryMut::Vacant(_) => {},","    RawEntryMut::Occupied(_) => panic!(),","    }","    assert!(!map.contains_key(\"existing_key\"));","}"],[]]]}