{"function_name":"hashbrown::raw::raw::RawTable<T, A>::new_uninitialized","file_path":"/home/abezbm/rust-utgen-test-crates-new/hashbrown/src/raw/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/hashbrown","tests":44,"tests_lines":[12,13,13,13,13,13,13,13,13,13,14,14,14,13,18,22,22,22,17,23,24,24,15,15,16,16,17,17,18,19,19,17,21,21,21,12,12,13,13,12,13,13,13,13],"oracles":16,"oracles_compiled":4,"oracles_compiled_rate":25.0,"tests_compiled":15,"tests_compiled_rate":34.090909090909086,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":15,"tests_passed":8,"tests_passed_rate":53.333333333333336,"lines":15,"lines_covered":15,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734],"codes_lines_covered":[[["{","    let alloc = Global;","    let buckets = 1073741825; // Exceeds maximum limit","    let fallibility = Fallibility::Fallible;","    unsafe {","        RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility);","    }","    let alloc = Global;","    let buckets = 1073741825;","    let fallibility = Fallibility::Fallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility) };","    assert!(result.is_err());","}"],[717,718,719,720,721,722]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.unwrap().table.bucket_mask == buckets - 1);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 3);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(!buckets.is_power_of_two());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 1024);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets.is_power_of_two());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let table = result.unwrap();","    assert!(table.capacity() >= buckets);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    assert!(std::panic::catch_unwind(|| { unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) }}).is_err());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().buckets(), buckets);","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().capacity(), bucket_mask_to_capacity(buckets - 1));","}"],[717,718,719,720,721,722,725,726,727,728,729,730,731,732,734]]],"codes_branches":[],"codes_branches_covered":[[["{","    let alloc = Global;","    let buckets = 1073741825; // Exceeds maximum limit","    let fallibility = Fallibility::Fallible;","    unsafe {","        RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility);","    }","    let alloc = Global;","    let buckets = 1073741825;","    let fallibility = Fallibility::Fallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(alloc, buckets, fallibility) };","    assert!(result.is_err());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1; // Minimum power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 1;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.unwrap().table.bucket_mask == buckets - 1);","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 3);","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(!buckets.is_power_of_two());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_err());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets == 1024);","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    assert!(buckets.is_power_of_two());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1024; // Larger power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let table = result.unwrap();","    assert!(table.capacity() >= buckets);","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    assert!(std::panic::catch_unwind(|| { unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) }}).is_err());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert!(result.is_ok());","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().buckets(), buckets);","}"],[]],[["{","#[should_panic]","fn test_new_uninitialized_with_non_power_of_two_buckets() {","    let allocator = Global;","    let buckets = 3; // Non-power of two","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","}","    let allocator = Global;","    let buckets = 1 << 30; // Maximum power of two (2^30)","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    let allocator = Global;","    let buckets = 3;","    let fallibility = Fallibility::Infallible;","    let allocator = Global;","    let buckets = 1 << 30;","    let fallibility = Fallibility::Infallible;","    let result = unsafe { RawTable::<u8, Global>::new_uninitialized(allocator, buckets, fallibility) };","    assert_eq!(result.unwrap().capacity(), bucket_mask_to_capacity(buckets - 1));","}"],[]]]}