{"function_name":"hashbrown::set::set::HashSet<T, foldhash::fast::RandomState, A>::new_in","file_path":"/home/abezbm/rust-utgen-test-crates-new/hashbrown/src/set.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/hashbrown","tests":17,"tests_lines":[11,11,11,11,11,11,11,11,11,11,11,11,13,13,13,13,13],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":8,"tests_compiled_rate":47.05882352941176,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":8,"tests_passed":6,"tests_passed_rate":75.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[220,221,222,223,224],"codes_lines_covered":[[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert_eq!(set.map.table.capacity(), 0);","}"],[220,221,222,223,224]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert!(set.map.table.is_empty());","}"],[220,221,222,223,224]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert!(set.map.table.capacity() > 0);","}"],[220,221,222,223,224]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert!(set.map.table.is_empty());","}"],[220,221,222,223,224]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert_eq!(set.map.table.len(), 0);","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert_eq!(set.map.capacity(), large_capacity);","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert!(set.map.is_empty());","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert!(set.map.table.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert_eq!(set.map.table.capacity(), 0);","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert!(set.map.table.is_empty());","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert!(set.map.table.capacity() > 0);","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    let alloc = Global;","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::new_in(alloc);","    assert!(set.map.table.is_empty());","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert_eq!(set.map.table.len(), 0);","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert_eq!(set.map.capacity(), large_capacity);","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert!(set.map.is_empty());","}"],[]],[["{","#[should_panic]","fn test_hashset_new_in_invalid_allocator() {","    // This test is deliberately left here as a placeholder for invalid allocator case.","} ","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    let alloc = Global;","    let large_capacity = 1 << 30; // 2^30","    let set: HashSet<i32, DefaultHashBuilder, Global> = HashSet::with_capacity_in(large_capacity, alloc);","    assert!(set.map.table.is_empty());","}"],[]]]}