{"function_name":"hashbrown::raw::raw::Bucket<T>::next_n","file_path":"/home/abezbm/rust-utgen-test-crates-new/hashbrown/src/raw/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/hashbrown","tests":22,"tests_lines":[13,14,16,16,18,18,16,13,13,13,12,13,14,14,15,15,15,14,14,14,14,14],"oracles":8,"oracles_compiled":4,"oracles_compiled_rate":50.0,"tests_compiled":8,"tests_compiled_rate":36.36363636363637,"oracles_run":4,"oracles_passed":1,"oracles_passed_rate":25.0,"tests_run":8,"tests_passed":2,"tests_passed_rate":25.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[538,539,541,543,545,546,547,548],"codes_lines_covered":[[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 1; // Valid offset within bounds","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    assert_eq!(bucket.ptr.as_ptr(), base_ptr.as_ptr()); // Ensure original pointer is correct","}"],[]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 1; // Valid offset within bounds","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    assert!(unsafe { bucket.next_n(1).ptr.as_ptr() < bucket.ptr.as_ptr() }); // Check pointer moves back with offset","}"],[]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 1; // Valid offset within bounds","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    assert!(unsafe { bucket.next_n(1).ptr.as_ptr() == invalid_mut(1) }); // Check invalid_mut path for ZST logic is not used (IS_ZERO_SIZED is false)","}"],[]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 10; // Assuming this is equal to RawTableInner.bucket_mask","    let new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    assert!(base_ptr.as_ptr() != ptr::null_mut());","}"],[]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 10; // Assuming this is equal to RawTableInner.bucket_mask","    let new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let offset = 10;","    let new_bucket = unsafe { bucket.next_n(offset) };","    assert!(new_bucket.ptr.as_ptr() != ptr::null_mut());","}"],[]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 5; // Valid offset below RawTableInner.bucket_mask","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 5;","    let new_bucket = unsafe { bucket.next_n(offset) };","    assert!(new_bucket.ptr.as_ptr() != bucket.ptr.as_ptr());","}"],[]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11; // Assuming this exceeds RawTableInner.bucket_mask","    let _new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11;","    assert!(bucket.ptr.as_ptr() != ptr::null_mut());","}"],[]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11; // Assuming this exceeds RawTableInner.bucket_mask","    let _new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11;","    assert!(bucket.ptr.as_ptr() as usize + offset == 11);","}"],[]]],"codes_branches":[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 1; // Valid offset within bounds","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    assert_eq!(bucket.ptr.as_ptr(), base_ptr.as_ptr()); // Ensure original pointer is correct","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 1; // Valid offset within bounds","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    assert!(unsafe { bucket.next_n(1).ptr.as_ptr() < bucket.ptr.as_ptr() }); // Check pointer moves back with offset","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 1; // Valid offset within bounds","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    assert!(unsafe { bucket.next_n(1).ptr.as_ptr() == invalid_mut(1) }); // Check invalid_mut path for ZST logic is not used (IS_ZERO_SIZED is false)","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 10; // Assuming this is equal to RawTableInner.bucket_mask","    let new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    assert!(base_ptr.as_ptr() != ptr::null_mut());","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 10; // Assuming this is equal to RawTableInner.bucket_mask","    let new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let offset = 10;","    let new_bucket = unsafe { bucket.next_n(offset) };","    assert!(new_bucket.ptr.as_ptr() != ptr::null_mut());","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 5; // Valid offset below RawTableInner.bucket_mask","    let new_bucket = unsafe { bucket.next_n(offset) };","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 5;","    let new_bucket = unsafe { bucket.next_n(offset) };","    assert!(new_bucket.ptr.as_ptr() != bucket.ptr.as_ptr());","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11; // Assuming this exceeds RawTableInner.bucket_mask","    let _new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11;","    assert!(bucket.ptr.as_ptr() != ptr::null_mut());","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]],[["{","    struct TestType;","    impl TestType {","        const IS_ZERO_SIZED: bool = false;","    }","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11; // Assuming this exceeds RawTableInner.bucket_mask","    let _new_bucket = unsafe { bucket.next_n(offset) }; ","    let base_ptr = NonNull::new(unsafe { &mut *(0 as *mut TestType) }).unwrap();","    let bucket = Bucket { ptr: base_ptr };","    let offset = 11;","    assert!(bucket.ptr.as_ptr() as usize + offset == 11);","}"],[{"start_line":539,"start_column":22,"end_line":539,"end_column":38,"positive":false,"negative":false}]]]}