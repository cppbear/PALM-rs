{"function_name":"hashbrown::raw::raw::RawTable<T, A>::insert_in_slot","file_path":"/home/abezbm/rust-utgen-test-crates-new/hashbrown/src/raw/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/hashbrown","tests":16,"tests_lines":[17,13,13,17,17,17,13,17,17,18,18,15,26,27,27,27],"oracles":5,"oracles_compiled":2,"oracles_compiled_rate":40.0,"tests_compiled":5,"tests_compiled_rate":31.25,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[1242,1243,1244,1245,1246,1247,1248,1249],"codes_lines_covered":[[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 0; // minimum hash value","    let slot = InsertSlot { index: 0 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 1); // inserting another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    assert_eq!(table.len(), 0);","}"],[1242,1243,1244,1245,1246,1247,1248,1249]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 0; // minimum hash value","    let slot = InsertSlot { index: 0 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 1); // inserting another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    assert!(table.is_empty());","}"],[1242,1243,1244,1245,1246,1247,1248,1249]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000; // maximum hash value","    let slot = InsertSlot { index: 1023 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 67); // inserting yet another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    assert_eq!(table.len(), 0);","}"],[1242,1243,1244,1245,1246,1247,1248,1249]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000; // maximum hash value","    let slot = InsertSlot { index: 1023 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 67); // inserting yet another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000;","    let slot = InsertSlot { index: 1023 };","    unsafe {","    let bucket = table.insert_in_slot(hash, slot, 67);","    }","    assert!(table.buckets() >= 1024);","}"],[1242,1243,1244,1245,1246,1247,1248,1249]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000; // maximum hash value","    let slot = InsertSlot { index: 1023 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 67); // inserting yet another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000;","    let slot = InsertSlot { index: 1023 };","    unsafe {","    let bucket = table.insert_in_slot(hash, slot, 67);","    }","    assert!(!table.is_empty());","}"],[1242,1243,1244,1245,1246,1247,1248,1249]]],"codes_branches":[],"codes_branches_covered":[[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 0; // minimum hash value","    let slot = InsertSlot { index: 0 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 1); // inserting another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    assert_eq!(table.len(), 0);","}"],[]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 0; // minimum hash value","    let slot = InsertSlot { index: 0 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 1); // inserting another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    assert!(table.is_empty());","}"],[]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000; // maximum hash value","    let slot = InsertSlot { index: 1023 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 67); // inserting yet another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    assert_eq!(table.len(), 0);","}"],[]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000; // maximum hash value","    let slot = InsertSlot { index: 1023 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 67); // inserting yet another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000;","    let slot = InsertSlot { index: 1023 };","    unsafe {","    let bucket = table.insert_in_slot(hash, slot, 67);","    }","    assert!(table.buckets() >= 1024);","}"],[]],[["{","    let allocator = Global; // or suitable allocator","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000; // maximum hash value","    let slot = InsertSlot { index: 1023 }; // valid index ","","    unsafe {","        let bucket = table.insert_in_slot(hash, slot, 67); // inserting yet another valid i32 value","    }","    let allocator = Global;","    let mut table: RawTable<i32, Global> = RawTable::with_capacity_in(1024, allocator);","    let hash: u64 = 1_000_000;","    let slot = InsertSlot { index: 1023 };","    unsafe {","    let bucket = table.insert_in_slot(hash, slot, 67);","    }","    assert!(!table.is_empty());","}"],[]]]}