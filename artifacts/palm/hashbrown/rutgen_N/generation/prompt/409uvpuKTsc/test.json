{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/raw/mod.rs\n// crate name is hashbrown\nThe function to be tested is presented as follows:\n/// Sets a control byte, and possibly also the replicated control byte at\n/// the end of the array.\n///\n/// This function does not make any changes to the `data` parts of the table,\n/// or any changes to the `items` or `growth_left` field of the table.\n///\n/// # Safety\n///\n/// You must observe the following safety rules when calling this function:\n///\n/// * The [`RawTableInner`] has already been allocated;\n///\n/// * The `index` must not be greater than the `RawTableInner.bucket_mask`, i.e.\n///   `index <= RawTableInner.bucket_mask` or, in other words, `(index + 1)` must\n///   be no greater than the number returned by the function [`RawTableInner::buckets`].\n///\n/// Calling this function on a table that has not been allocated results in [`undefined behavior`].\n///\n/// See also [`Bucket::as_ptr`] method, for more information about of properly removing\n/// or saving `data element` from / into the [`RawTable`] / [`RawTableInner`].\n///\n/// [`RawTableInner::buckets`]: RawTableInner::buckets\n/// [`Bucket::as_ptr`]: Bucket::as_ptr\n/// [`undefined behavior`]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\nunsafe fn set_ctrl(&mut self, index: usize, ctrl: Tag) {\n    // Replicate the first Group::WIDTH control bytes at the end of\n    // the array without using a branch. If the tables smaller than\n    // the group width (self.buckets() < Group::WIDTH),\n    // `index2 = Group::WIDTH + index`, otherwise `index2` is:\n    //\n    // - If index >= Group::WIDTH then index == index2.\n    // - Otherwise index2 == self.bucket_mask + 1 + index.\n    //\n    // The very last replicated control byte is never actually read because\n    // we mask the initial index for unaligned loads, but we write it\n    // anyways because it makes the set_ctrl implementation simpler.\n    //\n    // If there are fewer buckets than Group::WIDTH then this code will\n    // replicate the buckets at the end of the trailing group. For example\n    // with 2 buckets and a group size of 4, the control bytes will look\n    // like this:\n    //\n    //     Real    |             Replicated\n    // ---------------------------------------------\n    // | [A] | [B] | [Tag::EMPTY] | [EMPTY] | [A] | [B] |\n    // ---------------------------------------------\n\n    // This is the same as `(index.wrapping_sub(Group::WIDTH)) % self.buckets() + Group::WIDTH`\n    // because the number of buckets is a power of two, and `self.bucket_mask = self.buckets() - 1`.\n    let index2 = ((index.wrapping_sub(Group::WIDTH)) & self.bucket_mask) + Group::WIDTH;\n\n    // SAFETY: The caller must uphold the safety rules for the [`RawTableInner::set_ctrl`]\n    *self.ctrl(index) = ctrl;\n    *self.ctrl(index2) = ctrl;\n}\n",
  "depend_pt": ""
}