{
  "name": "hashbrown::raw::raw::RawTableInner::find_insert_slot_in_group",
  "name_with_impl": "hashbrown::raw::{impl#13}::find_insert_slot_in_group",
  "mod_info": {
    "name": "raw",
    "loc": "src/lib.rs:62:1:62:9"
  },
  "visible": false,
  "loc": "src/raw/mod.rs:1698:5:1708:6",
  "fn_tests": [
    {
      "chain_id": 0,
      "prompt_conds": [],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct MockGroup {",
                  "        empty_bit: u64,",
                  "    }",
                  "",
                  "    impl MockGroup {",
                  "        fn match_empty_or_deleted(&self) -> BitSet {",
                  "            BitSet { bits: self.empty_bit }",
                  "        }",
                  "    }",
                  "",
                  "    struct BitSet {",
                  "        bits: u64,",
                  "    }",
                  "",
                  "    impl BitSet {",
                  "        fn lowest_set_bit(&self) -> Option<u64> {",
                  "            if self.bits == 0 {",
                  "                None",
                  "            } else {",
                  "                Some(self.bits.trailing_zeros() as u64)",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct ProbeSeq {",
                  "        pos: usize,",
                  "    }",
                  "",
                  "    struct Container {",
                  "        bucket_mask: usize,",
                  "    }",
                  "",
                  "    impl Container {",
                  "        fn find_insert_slot_in_group(&self, group: &MockGroup, probe_seq: &ProbeSeq) -> Option<usize> {",
                  "            let bit = group.match_empty_or_deleted().lowest_set_bit();",
                  "",
                  "            if let Some(b) = bit {",
                  "                Some((probe_seq.pos + b as usize) & self.bucket_mask)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let container = Container { bucket_mask: 3 };",
                  "    let group = MockGroup { empty_bit: 0b0000_0100 }; // only the second bucket is empty",
                  "    let probe_seq = ProbeSeq { pos: 1 };",
                  "",
                  "    let result = container.find_insert_slot_in_group(&group, &probe_seq);",
                  "    assert_eq!(result, Some(2)); // (1 + 2) & 3 = 2",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct MockGroup {",
                  "        empty_bit: u64,",
                  "    }",
                  "",
                  "    impl MockGroup {",
                  "        fn match_empty_or_deleted(&self) -> BitSet {",
                  "            BitSet { bits: self.empty_bit }",
                  "        }",
                  "    }",
                  "",
                  "    struct BitSet {",
                  "        bits: u64,",
                  "    }",
                  "",
                  "    impl BitSet {",
                  "        fn lowest_set_bit(&self) -> Option<u64> {",
                  "            if self.bits == 0 {",
                  "                None",
                  "            } else {",
                  "                Some(self.bits.trailing_zeros() as u64)",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct ProbeSeq {",
                  "        pos: usize,",
                  "    }",
                  "",
                  "    struct Container {",
                  "        bucket_mask: usize,",
                  "    }",
                  "",
                  "    impl Container {",
                  "        fn find_insert_slot_in_group(&self, group: &MockGroup, probe_seq: &ProbeSeq) -> Option<usize> {",
                  "            let bit = group.match_empty_or_deleted().lowest_set_bit();",
                  "",
                  "            if let Some(b) = bit {",
                  "                Some((probe_seq.pos + b as usize) & self.bucket_mask)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let container = Container { bucket_mask: 3 };",
                  "    let group = MockGroup { empty_bit: 0b1111_1111 }; // no empty buckets",
                  "    let probe_seq = ProbeSeq { pos: 0 };",
                  "",
                  "    let result = container.find_insert_slot_in_group(&group, &probe_seq);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}