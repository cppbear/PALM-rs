{"function_name":"hashbrown::raw::raw::RawTableInner::find_insert_slot_in_group","tests":2,"tests_lines":[52,52],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1698,1699,1700,1701,1704,1706,1708],"codes_lines_covered":[[["{","    struct MockGroup {","        empty_bit: u64,","    }","","    impl MockGroup {","        fn match_empty_or_deleted(&self) -> BitSet {","            BitSet { bits: self.empty_bit }","        }","    }","","    struct BitSet {","        bits: u64,","    }","","    impl BitSet {","        fn lowest_set_bit(&self) -> Option<u64> {","            if self.bits == 0 {","                None","            } else {","                Some(self.bits.trailing_zeros() as u64)","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","    }","","    struct Container {","        bucket_mask: usize,","    }","","    impl Container {","        fn find_insert_slot_in_group(&self, group: &MockGroup, probe_seq: &ProbeSeq) -> Option<usize> {","            let bit = group.match_empty_or_deleted().lowest_set_bit();","","            if let Some(b) = bit {","                Some((probe_seq.pos + b as usize) & self.bucket_mask)","            } else {","                None","            }","        }","    }","","    let container = Container { bucket_mask: 3 };","    let group = MockGroup { empty_bit: 0b0000_0100 }; // only the second bucket is empty","    let probe_seq = ProbeSeq { pos: 1 };","","    let result = container.find_insert_slot_in_group(&group, &probe_seq);","    assert_eq!(result, Some(2)); // (1 + 2) & 3 = 2","}"],[]],[["{","    struct MockGroup {","        empty_bit: u64,","    }","","    impl MockGroup {","        fn match_empty_or_deleted(&self) -> BitSet {","            BitSet { bits: self.empty_bit }","        }","    }","","    struct BitSet {","        bits: u64,","    }","","    impl BitSet {","        fn lowest_set_bit(&self) -> Option<u64> {","            if self.bits == 0 {","                None","            } else {","                Some(self.bits.trailing_zeros() as u64)","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","    }","","    struct Container {","        bucket_mask: usize,","    }","","    impl Container {","        fn find_insert_slot_in_group(&self, group: &MockGroup, probe_seq: &ProbeSeq) -> Option<usize> {","            let bit = group.match_empty_or_deleted().lowest_set_bit();","","            if let Some(b) = bit {","                Some((probe_seq.pos + b as usize) & self.bucket_mask)","            } else {","                None","            }","        }","    }","","    let container = Container { bucket_mask: 3 };","    let group = MockGroup { empty_bit: 0b1111_1111 }; // no empty buckets","    let probe_seq = ProbeSeq { pos: 0 };","","    let result = container.find_insert_slot_in_group(&group, &probe_seq);","    assert_eq!(result, None);","}"],[]]],"codes_branches":[{"start_line":1701,"start_column":12,"end_line":1701,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockGroup {","        empty_bit: u64,","    }","","    impl MockGroup {","        fn match_empty_or_deleted(&self) -> BitSet {","            BitSet { bits: self.empty_bit }","        }","    }","","    struct BitSet {","        bits: u64,","    }","","    impl BitSet {","        fn lowest_set_bit(&self) -> Option<u64> {","            if self.bits == 0 {","                None","            } else {","                Some(self.bits.trailing_zeros() as u64)","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","    }","","    struct Container {","        bucket_mask: usize,","    }","","    impl Container {","        fn find_insert_slot_in_group(&self, group: &MockGroup, probe_seq: &ProbeSeq) -> Option<usize> {","            let bit = group.match_empty_or_deleted().lowest_set_bit();","","            if let Some(b) = bit {","                Some((probe_seq.pos + b as usize) & self.bucket_mask)","            } else {","                None","            }","        }","    }","","    let container = Container { bucket_mask: 3 };","    let group = MockGroup { empty_bit: 0b0000_0100 }; // only the second bucket is empty","    let probe_seq = ProbeSeq { pos: 1 };","","    let result = container.find_insert_slot_in_group(&group, &probe_seq);","    assert_eq!(result, Some(2)); // (1 + 2) & 3 = 2","}"],[{"start_line":1701,"start_column":12,"end_line":1701,"end_column":33,"positive":false,"negative":false}]],[["{","    struct MockGroup {","        empty_bit: u64,","    }","","    impl MockGroup {","        fn match_empty_or_deleted(&self) -> BitSet {","            BitSet { bits: self.empty_bit }","        }","    }","","    struct BitSet {","        bits: u64,","    }","","    impl BitSet {","        fn lowest_set_bit(&self) -> Option<u64> {","            if self.bits == 0 {","                None","            } else {","                Some(self.bits.trailing_zeros() as u64)","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","    }","","    struct Container {","        bucket_mask: usize,","    }","","    impl Container {","        fn find_insert_slot_in_group(&self, group: &MockGroup, probe_seq: &ProbeSeq) -> Option<usize> {","            let bit = group.match_empty_or_deleted().lowest_set_bit();","","            if let Some(b) = bit {","                Some((probe_seq.pos + b as usize) & self.bucket_mask)","            } else {","                None","            }","        }","    }","","    let container = Container { bucket_mask: 3 };","    let group = MockGroup { empty_bit: 0b1111_1111 }; // no empty buckets","    let probe_seq = ProbeSeq { pos: 0 };","","    let result = container.find_insert_slot_in_group(&group, &probe_seq);","    assert_eq!(result, None);","}"],[{"start_line":1701,"start_column":12,"end_line":1701,"end_column":33,"positive":false,"negative":false}]]]}