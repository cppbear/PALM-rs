{"function_name":"hashbrown::raw::raw::RawTable<T, A>::clear_no_drop","tests":2,"tests_lines":[24,24],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[904,905,906],"codes_lines_covered":[[["{","    struct TestTable {","        table: Vec<Option<i32>>,","    }","","    impl TestTable {","        fn new(size: usize) -> Self {","            TestTable {","                table: vec![Some(0); size],","            }","        }","","        fn clear_no_drop(&mut self) {","            for bucket in &mut self.table {","                *bucket = None;","            }","        }","    }","","    let mut test_table = TestTable::new(5);","    test_table.clear_no_drop();","","    assert!(test_table.table.iter().all(|bucket| bucket.is_none()));","}"],[]],[["{","    struct TestTable {","        table: Vec<Option<i32>>,","    }","","    impl TestTable {","        fn new(size: usize) -> Self {","            TestTable {","                table: vec![None; size],","            }","        }","","        fn clear_no_drop(&mut self) {","            for bucket in &mut self.table {","                *bucket = None;","            }","        }","    }","","    let mut test_table = TestTable::new(0);","    test_table.clear_no_drop();","","    assert!(test_table.table.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestTable {","        table: Vec<Option<i32>>,","    }","","    impl TestTable {","        fn new(size: usize) -> Self {","            TestTable {","                table: vec![Some(0); size],","            }","        }","","        fn clear_no_drop(&mut self) {","            for bucket in &mut self.table {","                *bucket = None;","            }","        }","    }","","    let mut test_table = TestTable::new(5);","    test_table.clear_no_drop();","","    assert!(test_table.table.iter().all(|bucket| bucket.is_none()));","}"],[]],[["{","    struct TestTable {","        table: Vec<Option<i32>>,","    }","","    impl TestTable {","        fn new(size: usize) -> Self {","            TestTable {","                table: vec![None; size],","            }","        }","","        fn clear_no_drop(&mut self) {","            for bucket in &mut self.table {","                *bucket = None;","            }","        }","    }","","    let mut test_table = TestTable::new(0);","    test_table.clear_no_drop();","","    assert!(test_table.table.is_empty());","}"],[]]]}