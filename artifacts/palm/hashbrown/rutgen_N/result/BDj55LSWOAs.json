{"function_name":"hashbrown::raw::raw::RawTableInner::probe_seq","tests":2,"tests_lines":[34,34],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[2399,2400,2401,2402,2403,2404,2405,2406],"codes_lines_covered":[[["{","    struct TestTable {","        bucket_mask: usize,","    }","","    impl TestTable {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % (1u64 << 32)) as usize // Example hash function; adjust as needed","    }","","    let table = TestTable { bucket_mask: 15 }; // buckets() would be 16","    let hash_value = 12345;","    let probe_sequence = table.probe_seq(hash_value);","","    assert_eq!(probe_sequence.pos, h1(hash_value) & table.bucket_mask);","    assert_eq!(probe_sequence.stride, 0);","}"],[]],[["{","    struct TestTable {","        bucket_mask: usize,","    }","","    impl TestTable {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % (1u64 << 32)) as usize // Example hash function; adjust as needed","    }","","    let table = TestTable { bucket_mask: 7 }; // buckets() would be 8","    let hash_value = 7; // Edge case to see handling at boundary","","    let probe_sequence = table.probe_seq(hash_value);","    assert_eq!(probe_sequence.pos, h1(hash_value) & table.bucket_mask);","    assert_eq!(probe_sequence.stride, 0);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestTable {","        bucket_mask: usize,","    }","","    impl TestTable {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % (1u64 << 32)) as usize // Example hash function; adjust as needed","    }","","    let table = TestTable { bucket_mask: 15 }; // buckets() would be 16","    let hash_value = 12345;","    let probe_sequence = table.probe_seq(hash_value);","","    assert_eq!(probe_sequence.pos, h1(hash_value) & table.bucket_mask);","    assert_eq!(probe_sequence.stride, 0);","}"],[]],[["{","    struct TestTable {","        bucket_mask: usize,","    }","","    impl TestTable {","        fn buckets(&self) -> usize {","            self.bucket_mask + 1","        }","","        fn probe_seq(&self, hash: u64) -> ProbeSeq {","            ProbeSeq {","                pos: h1(hash) & self.bucket_mask,","                stride: 0,","            }","        }","    }","","    struct ProbeSeq {","        pos: usize,","        stride: usize,","    }","","    fn h1(hash: u64) -> usize {","        (hash % (1u64 << 32)) as usize // Example hash function; adjust as needed","    }","","    let table = TestTable { bucket_mask: 7 }; // buckets() would be 8","    let hash_value = 7; // Edge case to see handling at boundary","","    let probe_sequence = table.probe_seq(hash_value);","    assert_eq!(probe_sequence.pos, h1(hash_value) & table.bucket_mask);","    assert_eq!(probe_sequence.stride, 0);","}"],[]]]}