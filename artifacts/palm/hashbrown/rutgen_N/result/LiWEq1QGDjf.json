{"function_name":"hashbrown::raw::raw::FullBucketsIndices::next_impl","tests":2,"tests_lines":[64,58],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":34,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[3836,3838,3841,3842,3843,3844,3845,3846,3847,3848,3849,3850,3851,3852,3853,3854,3855,3856,3857,3858,3859,3860,3861,3862,3863,3864,3865,3866,3867,3868,3869,3870,3871,3873],"codes_lines_covered":[[["{","    struct RawTableInner {","        ctrl: *const u8,","        current_group: GroupIterator,","        group_first_index: usize,","    }","    ","    struct GroupIterator {","        index: usize,","        limit: usize","    }","","    impl GroupIterator {","        fn new(limit: usize) -> Self {","            GroupIterator { index: 0, limit }","        }","","        fn next(&mut self) -> Option<usize> {","            if self.index < self.limit {","                let value = self.index;","                self.index += 1;","                Some(value)","            } else {","                None","            }","        }","    }","","    impl RawTableInner {","        fn new() -> Self {","            let ctrl = std::ptr::null();","            let current_group = GroupIterator::new(4); // mock limit for the group","            RawTableInner {","                ctrl,","                current_group,","                group_first_index: 0,","            }","        }","","        unsafe fn next_impl(&mut self) -> Option<usize> {","            // Unsafe method code as provided in the original snippet","            loop {","                if let Some(index) = self.current_group.next() {","                    return Some(self.group_first_index + index);","                }","                ","                // Mock logic for advancing control pointer - omitted detail simplifications for clarity","                self.ctrl = self.ctrl.add(4); // simulate moving control","                self.current_group = GroupIterator::new(4); // reset for next iteration","                self.group_first_index += 4;","            }","        }","    }","","    let mut table_inner = RawTableInner::new();","    ","    unsafe {","        assert_eq!(table_inner.next_impl(), Some(0));","        assert_eq!(table_inner.next_impl(), Some(1));","        assert_eq!(table_inner.next_impl(), Some(2));","        assert_eq!(table_inner.next_impl(), Some(3));","        assert_eq!(table_inner.next_impl(), None); // No more elements should be present","    }","}"],[]],[["{","    struct RawTableInner {","        ctrl: *const u8,","        current_group: GroupIterator,","        group_first_index: usize,","    }","    ","    struct GroupIterator {","        index: usize,","        limit: usize","    }","","    impl GroupIterator {","        fn new(limit: usize) -> Self {","            GroupIterator { index: 0, limit }","        }","","        fn next(&mut self) -> Option<usize> {","            if self.index < self.limit {","                let value = self.index;","                self.index += 1;","                Some(value)","            } else {","                None","            }","        }","    }","","    impl RawTableInner {","        fn new() -> Self {","            let ctrl = std::ptr::null();","            let current_group = GroupIterator::new(0); // No elements to iterate","            RawTableInner {","                ctrl,","                current_group,","                group_first_index: 0,","            }","        }","","        unsafe fn next_impl(&mut self) -> Option<usize> {","            loop {","                if let Some(index) = self.current_group.next() {","                    return Some(self.group_first_index + index);","                }","                ","                self.ctrl = self.ctrl.add(4);","                self.current_group = GroupIterator::new(4);","                self.group_first_index += 4;","            }","        }","    }","","    let mut table_inner = RawTableInner::new();","    ","    unsafe {","        table_inner.next_impl(); // Should panic due to no elements","    }","}"],[]]],"codes_branches":[{"start_line":3838,"start_column":20,"end_line":3838,"end_column":31,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct RawTableInner {","        ctrl: *const u8,","        current_group: GroupIterator,","        group_first_index: usize,","    }","    ","    struct GroupIterator {","        index: usize,","        limit: usize","    }","","    impl GroupIterator {","        fn new(limit: usize) -> Self {","            GroupIterator { index: 0, limit }","        }","","        fn next(&mut self) -> Option<usize> {","            if self.index < self.limit {","                let value = self.index;","                self.index += 1;","                Some(value)","            } else {","                None","            }","        }","    }","","    impl RawTableInner {","        fn new() -> Self {","            let ctrl = std::ptr::null();","            let current_group = GroupIterator::new(4); // mock limit for the group","            RawTableInner {","                ctrl,","                current_group,","                group_first_index: 0,","            }","        }","","        unsafe fn next_impl(&mut self) -> Option<usize> {","            // Unsafe method code as provided in the original snippet","            loop {","                if let Some(index) = self.current_group.next() {","                    return Some(self.group_first_index + index);","                }","                ","                // Mock logic for advancing control pointer - omitted detail simplifications for clarity","                self.ctrl = self.ctrl.add(4); // simulate moving control","                self.current_group = GroupIterator::new(4); // reset for next iteration","                self.group_first_index += 4;","            }","        }","    }","","    let mut table_inner = RawTableInner::new();","    ","    unsafe {","        assert_eq!(table_inner.next_impl(), Some(0));","        assert_eq!(table_inner.next_impl(), Some(1));","        assert_eq!(table_inner.next_impl(), Some(2));","        assert_eq!(table_inner.next_impl(), Some(3));","        assert_eq!(table_inner.next_impl(), None); // No more elements should be present","    }","}"],[{"start_line":3838,"start_column":20,"end_line":3838,"end_column":31,"positive":false,"negative":false}]],[["{","    struct RawTableInner {","        ctrl: *const u8,","        current_group: GroupIterator,","        group_first_index: usize,","    }","    ","    struct GroupIterator {","        index: usize,","        limit: usize","    }","","    impl GroupIterator {","        fn new(limit: usize) -> Self {","            GroupIterator { index: 0, limit }","        }","","        fn next(&mut self) -> Option<usize> {","            if self.index < self.limit {","                let value = self.index;","                self.index += 1;","                Some(value)","            } else {","                None","            }","        }","    }","","    impl RawTableInner {","        fn new() -> Self {","            let ctrl = std::ptr::null();","            let current_group = GroupIterator::new(0); // No elements to iterate","            RawTableInner {","                ctrl,","                current_group,","                group_first_index: 0,","            }","        }","","        unsafe fn next_impl(&mut self) -> Option<usize> {","            loop {","                if let Some(index) = self.current_group.next() {","                    return Some(self.group_first_index + index);","                }","                ","                self.ctrl = self.ctrl.add(4);","                self.current_group = GroupIterator::new(4);","                self.group_first_index += 4;","            }","        }","    }","","    let mut table_inner = RawTableInner::new();","    ","    unsafe {","        table_inner.next_impl(); // Should panic due to no elements","    }","}"],[{"start_line":3838,"start_column":20,"end_line":3838,"end_column":31,"positive":false,"negative":false}]]]}