{"function_name":"hashbrown::raw::raw::Bucket<T>::read","tests":2,"tests_lines":[28,28],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[587,588,589],"codes_lines_covered":[[["{","    struct RawTable<T> {","        value: T,","    }","","    impl<T> RawTable<T> {","        fn new(value: T) -> Self {","            RawTable { value }","        }","","        fn as_ptr(&self) -> *const T {","            &self.value","        }","","        unsafe fn read(&self) -> T {","            self.as_ptr().read()","        }","    }","","    let table = RawTable::new(42);","    let value: i32;","","    unsafe {","        value = table.read();","    }","","    assert_eq!(value, 42);","}"],[]],[["{","    struct RawTable<T> {","        value: T,","    }","","    impl<T> RawTable<T> {","        fn new(value: T) -> Self {","            RawTable { value }","        }","","        fn as_ptr(&self) -> *const T {","            &self.value","        }","","        unsafe fn read(&self) -> T {","            self.as_ptr().read()","        }","    }","","    let table = RawTable::new(Box::new(42));","    let _value: Box<i32>;","","    unsafe {","        let leaked_value = Box::into_raw(Box::new(30));","        _value = table.read(); // Will not panic as Box is valid, but causing leakage","        std::mem::forget(Box::from_raw(leaked_value)); // Prevent double free","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct RawTable<T> {","        value: T,","    }","","    impl<T> RawTable<T> {","        fn new(value: T) -> Self {","            RawTable { value }","        }","","        fn as_ptr(&self) -> *const T {","            &self.value","        }","","        unsafe fn read(&self) -> T {","            self.as_ptr().read()","        }","    }","","    let table = RawTable::new(42);","    let value: i32;","","    unsafe {","        value = table.read();","    }","","    assert_eq!(value, 42);","}"],[]],[["{","    struct RawTable<T> {","        value: T,","    }","","    impl<T> RawTable<T> {","        fn new(value: T) -> Self {","            RawTable { value }","        }","","        fn as_ptr(&self) -> *const T {","            &self.value","        }","","        unsafe fn read(&self) -> T {","            self.as_ptr().read()","        }","    }","","    let table = RawTable::new(Box::new(42));","    let _value: Box<i32>;","","    unsafe {","        let leaked_value = Box::into_raw(Box::new(30));","        _value = table.read(); // Will not panic as Box is valid, but causing leakage","        std::mem::forget(Box::from_raw(leaked_value)); // Prevent double free","    }","}"],[]]]}