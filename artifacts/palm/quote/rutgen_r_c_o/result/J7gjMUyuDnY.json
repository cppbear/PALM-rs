{"function_name":"quote::ext::<proc_macro2::TokenStream as ext::TokenStreamExt>::append_separated","tests":14,"tests_lines":[9,9,9,9,9,10,10,10,11,17,21,22,27,27],"oracles":8,"oracles_compiled":4,"oracles_compiled_rate":50.0,"tests_compiled":7,"tests_compiled_rate":50.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":7,"tests_passed":6,"tests_passed_rate":85.71428571428571,"lines":12,"lines_covered":11,"lines_coveraged_rate":91.66666666666666,"branches":2,"branches_covered":1,"branches_coverage_rate":50.0,"codes_lines":[77,78,79,80,81,82,83,84,85,86,87,89],"codes_lines_covered":[[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert!(tokens.is_empty());","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert_eq!(tokens.into_iter().count(), 0);","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    assert!(tokens.is_empty());","}"],[77,78,79,80,81,82,83,89]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.is_empty());","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.to_token_stream().is_empty());","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","    struct SingleToken;","    ","    impl ToTokens for SingleToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {}","    }","    ","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[]]],"codes_branches":[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert_eq!(tokens.into_iter().count(), 0);","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.to_token_stream().is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","    struct SingleToken;","    ","    impl ToTokens for SingleToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {}","    }","    ","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]]]}