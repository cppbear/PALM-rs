{"function_name":"quote::to_tokens::<std::rc::Rc<T> as to_tokens::ToTokens>::to_tokens","tests":6,"tests_lines":[15,17,17,26,27,32],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":4,"tests_passed_rate":66.66666666666666,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[99,100,101],"codes_lines_covered":[[["{","    struct EmptyType;","    ","    impl ToTokens for EmptyType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {}","    }","    ","    let empty_instance = Rc::new(EmptyType);","    let mut tokens = TokenStream::new();","    empty_instance.to_tokens(&mut tokens);","    let empty_instance = Rc::new(EmptyType);","    let mut tokens = TokenStream::new();","    empty_instance.to_tokens(&mut tokens);","    assert!(tokens.is_empty());","}"],[99,100,101]],[["{","    struct SomeType;","","    impl ToTokens for SomeType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            // Implementation to modify tokens if needed","        }","    }","","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    assert!(tokens.is_empty());","}"],[99,100,101]],[["{","    struct SomeType;","","    impl ToTokens for SomeType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            // Implementation to modify tokens if needed","        }","    }","","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    assert_eq!(tokens.to_string(), \"\");","}"],[99,100,101]],[["{","    struct CircleReferenceType {","        other: Option<Rc<CircleReferenceType>>,","    }","    ","    impl ToTokens for CircleReferenceType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            if let Some(ref other) = self.other {","                other.to_tokens(_tokens);","            }","        }","    }","    ","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","","    let circular_ref_instance = Rc::new(CircleReferenceType {","        other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    assert!(tokens.is_empty());","}"],[99,100,101]],[["{","    struct CircleReferenceType {","        other: Option<Rc<CircleReferenceType>>,","    }","    ","    impl ToTokens for CircleReferenceType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            if let Some(ref other) = self.other {","                other.to_tokens(_tokens);","            }","        }","    }","    ","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","","    let circular_ref_instance = Rc::new(CircleReferenceType {","        other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[99,100,101]],[["{","    struct CircleReferenceType {","        other: Option<Rc<CircleReferenceType>>,","    }","    ","    impl ToTokens for CircleReferenceType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            if let Some(ref other) = self.other {","                other.to_tokens(_tokens);","            }","        }","    }","    ","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","","    let circular_ref_instance = Rc::new(CircleReferenceType {","        other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","    let circular_ref_instance = Rc::new(CircleReferenceType {","    other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    assert!(!tokens_circular.is_empty());","}"],[99,100,101]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct EmptyType;","    ","    impl ToTokens for EmptyType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {}","    }","    ","    let empty_instance = Rc::new(EmptyType);","    let mut tokens = TokenStream::new();","    empty_instance.to_tokens(&mut tokens);","    let empty_instance = Rc::new(EmptyType);","    let mut tokens = TokenStream::new();","    empty_instance.to_tokens(&mut tokens);","    assert!(tokens.is_empty());","}"],[]],[["{","    struct SomeType;","","    impl ToTokens for SomeType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            // Implementation to modify tokens if needed","        }","    }","","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    assert!(tokens.is_empty());","}"],[]],[["{","    struct SomeType;","","    impl ToTokens for SomeType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            // Implementation to modify tokens if needed","        }","    }","","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    let some_instance = Rc::new(SomeType);","    let mut tokens = TokenStream::new();","    some_instance.to_tokens(&mut tokens);","    assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","    struct CircleReferenceType {","        other: Option<Rc<CircleReferenceType>>,","    }","    ","    impl ToTokens for CircleReferenceType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            if let Some(ref other) = self.other {","                other.to_tokens(_tokens);","            }","        }","    }","    ","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","","    let circular_ref_instance = Rc::new(CircleReferenceType {","        other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    assert!(tokens.is_empty());","}"],[]],[["{","    struct CircleReferenceType {","        other: Option<Rc<CircleReferenceType>>,","    }","    ","    impl ToTokens for CircleReferenceType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            if let Some(ref other) = self.other {","                other.to_tokens(_tokens);","            }","        }","    }","    ","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","","    let circular_ref_instance = Rc::new(CircleReferenceType {","        other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[]],[["{","    struct CircleReferenceType {","        other: Option<Rc<CircleReferenceType>>,","    }","    ","    impl ToTokens for CircleReferenceType {","        fn to_tokens(&self, _tokens: &mut TokenStream) {","            if let Some(ref other) = self.other {","                other.to_tokens(_tokens);","            }","        }","    }","    ","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","","    let circular_ref_instance = Rc::new(CircleReferenceType {","        other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    let circle_instance = Rc::new(CircleReferenceType { other: None });","    let mut tokens = TokenStream::new();","    circle_instance.to_tokens(&mut tokens);","    let circular_ref_instance = Rc::new(CircleReferenceType {","    other: Some(circle_instance.clone()),","    });","    let mut tokens_circular = TokenStream::new();","    circular_ref_instance.to_tokens(&mut tokens_circular);","    assert!(!tokens_circular.is_empty());","}"],[]]]}