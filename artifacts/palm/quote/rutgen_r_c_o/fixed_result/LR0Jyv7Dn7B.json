{"function_name":"quote::to_tokens::<std::borrow::Cow<'a, T> as to_tokens::ToTokens>::to_tokens","file_path":"/home/abezbm/rust-utgen-test-crates-new/quote/src/to_tokens.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/quote","tests":14,"tests_lines":[16,16,10,11,11,19,19,19,19,19,26,27,12,16],"oracles":5,"oracles_compiled":4,"oracles_compiled_rate":80.0,"tests_compiled":11,"tests_compiled_rate":78.57142857142857,"oracles_run":4,"oracles_passed":2,"oracles_passed_rate":50.0,"tests_run":11,"tests_passed":3,"tests_passed_rate":27.27272727272727,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[87,88,89],"codes_lines_covered":[[["{","    use proc_macro2::{TokenStream, Ident};","","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_unsuffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","   ","   let cow: Cow<Ident> = Cow::Borrowed(&ident);","   cow.to_tokens(&mut tokens);","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_unsuffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[87,88,89]],[["{","   use proc_macro2::{TokenStream, Ident, Literal};","   ","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_suffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","   ","   let cow: Cow<Ident> = Cow::Borrowed(&ident);","   cow.to_tokens(&mut tokens);","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_suffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","   assert_eq!(tokens.to_string(), \"1test_ident\");","}"],[87,88,89]],[["{","    use proc_macro2::{TokenStream, Ident};","","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    assert_eq!(tokens.is_empty(), true);","}"],[]],[["{","    use proc_macro2::{TokenStream, Ident};","","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[]],[["{","    use proc_macro2::{TokenStream, Ident};","","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    assert!(tokens.to_string().contains(\"\"));","}"],[]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};","","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);","   ","   let cow_group: Cow<Group> = Cow::Borrowed(&group);","   cow_group.to_tokens(&mut tokens);","   ","   let cow_punct: Cow<Punct> = Cow::Owned(punct);","   cow_punct.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(!tokens.is_empty());","}"],[87,88,89]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};","   ","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);","   ","   let cow_group: Cow<Group> = Cow::Borrowed(&group);","   cow_group.to_tokens(&mut tokens);","   ","   let cow_punct: Cow<Punct> = Cow::Owned(punct);","   cow_punct.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(tokens.into_iter().count() == 2);","}"],[87,88,89]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};  "," ","   let mut tokens = TokenStream::new();  ","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());  ","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);  ","   ","   let cow_group: Cow<Group> = Cow::Borrowed(&group);  ","   cow_group.to_tokens(&mut tokens);  ","   ","   let cow_punct: Cow<Punct> = Cow::Owned(punct);  ","   cow_punct.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());  ","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(tokens.clone().into_iter().any(|t| matches!(t, TokenTree::Group(_))));","}"],[87,88,89]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};","   ","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    ","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    cow_group.to_tokens(&mut tokens);","    ","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    cow_punct.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(tokens.clone().into_iter().any(|t| matches!(t, TokenTree::Punct(_))));","}"],[87,88,89]],[["{","    use proc_macro2::{TokenStream, Ident, Span};","    ","    let mut tokens = TokenStream::new();","    for i in 0..10 {","        let ident = Ident::new(&format!(\"ident_{}\", i), Span::call_site());","        let cow: Cow<Ident> = Cow::Owned(ident);","        cow.to_tokens(&mut tokens);","    }","    let mut tokens = TokenStream::new();","    assert_eq!(tokens.to_string(), \"\");","}"],[87,88,89]],[["{","   use proc_macro2::{TokenStream, Ident, Span};","   ","   let mut tokens = TokenStream::new();","   for i in 0..10 {","       let ident = Ident::new(&format!(\"ident_{}\", i), Span::call_site());","       let cow: Cow<Ident> = Cow::Owned(ident);","       cow.to_tokens(&mut tokens);","   }","   let mut tokens = TokenStream::new();","   for i in 0..10 {","       let ident = Ident::new(&format!(\"ident_{}\", i), Span::call_site());","       let cow: Cow<Ident> = Cow::Owned(ident);","       cow.to_tokens(&mut tokens);","   }","}"],[87,88,89]]],"codes_branches":[],"codes_branches_covered":[[["{","    use proc_macro2::{TokenStream, Ident};","","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_unsuffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","   ","   let cow: Cow<Ident> = Cow::Borrowed(&ident);","   cow.to_tokens(&mut tokens);","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_unsuffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[]],[["{","   use proc_macro2::{TokenStream, Ident, Literal};","   ","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_suffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","   ","   let cow: Cow<Ident> = Cow::Borrowed(&ident);","   cow.to_tokens(&mut tokens);","   let ident = Ident::new(\"test_ident\", Span::call_site());","   let literal = Literal::u32_suffixed(1);","   let mut tokens = TokenStream::new();","   literal.to_tokens(&mut tokens);","   assert_eq!(tokens.to_string(), \"1test_ident\");","}"],[]],[["{","    use proc_macro2::{TokenStream, Ident};","","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    assert_eq!(tokens.is_empty(), true);","}"],[]],[["{","    use proc_macro2::{TokenStream, Ident};","","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[]],[["{","    use proc_macro2::{TokenStream, Ident};","","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let cow: Cow<Ident> = Cow::Owned(Ident::new(\"\", Span::call_site()));","    cow.to_tokens(&mut tokens);","    assert!(tokens.to_string().contains(\"\"));","}"],[]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};","","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);","   ","   let cow_group: Cow<Group> = Cow::Borrowed(&group);","   cow_group.to_tokens(&mut tokens);","   ","   let cow_punct: Cow<Punct> = Cow::Owned(punct);","   cow_punct.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(!tokens.is_empty());","}"],[]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};","   ","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);","   ","   let cow_group: Cow<Group> = Cow::Borrowed(&group);","   cow_group.to_tokens(&mut tokens);","   ","   let cow_punct: Cow<Punct> = Cow::Owned(punct);","   cow_punct.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(tokens.into_iter().count() == 2);","}"],[]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};  "," ","   let mut tokens = TokenStream::new();  ","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());  ","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);  ","   ","   let cow_group: Cow<Group> = Cow::Borrowed(&group);  ","   cow_group.to_tokens(&mut tokens);  ","   ","   let cow_punct: Cow<Punct> = Cow::Owned(punct);  ","   cow_punct.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());  ","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(tokens.clone().into_iter().any(|t| matches!(t, TokenTree::Group(_))));","}"],[]],[["{","   use proc_macro2::{TokenStream, Group, Punct, Span, Delimiter};","   ","   let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","   let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    ","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    cow_group.to_tokens(&mut tokens);","    ","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    cow_punct.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","   let group = Group::new(Delimiter::Parenthesis, TokenStream::new());","    let punct = Punct::new('!', proc_macro2::Spacing::Alone);","    let cow_group: Cow<Group> = Cow::Borrowed(&group);","    let cow_punct: Cow<Punct> = Cow::Owned(punct);","    assert!(tokens.clone().into_iter().any(|t| matches!(t, TokenTree::Punct(_))));","}"],[]],[["{","    use proc_macro2::{TokenStream, Ident, Span};","    ","    let mut tokens = TokenStream::new();","    for i in 0..10 {","        let ident = Ident::new(&format!(\"ident_{}\", i), Span::call_site());","        let cow: Cow<Ident> = Cow::Owned(ident);","        cow.to_tokens(&mut tokens);","    }","    let mut tokens = TokenStream::new();","    assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","   use proc_macro2::{TokenStream, Ident, Span};","   ","   let mut tokens = TokenStream::new();","   for i in 0..10 {","       let ident = Ident::new(&format!(\"ident_{}\", i), Span::call_site());","       let cow: Cow<Ident> = Cow::Owned(ident);","       cow.to_tokens(&mut tokens);","   }","   let mut tokens = TokenStream::new();","   for i in 0..10 {","       let ident = Ident::new(&format!(\"ident_{}\", i), Span::call_site());","       let cow: Cow<Ident> = Cow::Owned(ident);","       cow.to_tokens(&mut tokens);","   }","}"],[]]]}