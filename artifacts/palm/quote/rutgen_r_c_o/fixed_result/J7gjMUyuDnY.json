{"function_name":"quote::ext::<proc_macro2::TokenStream as ext::TokenStreamExt>::append_separated","file_path":"/home/abezbm/rust-utgen-test-crates-new/quote/src/ext.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/quote","tests":14,"tests_lines":[25,25,25,25,25,26,26,26,11,17,21,22,27,27],"oracles":8,"oracles_compiled":7,"oracles_compiled_rate":87.5,"tests_compiled":11,"tests_compiled_rate":78.57142857142857,"oracles_run":7,"oracles_passed":3,"oracles_passed_rate":42.857142857142854,"tests_run":11,"tests_passed":6,"tests_passed_rate":54.54545454545454,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[77,78,79,80,81,82,83,84,85,86,87,89],"codes_lines_covered":[[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert!(tokens.is_empty());","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert_eq!(tokens.into_iter().count(), 0);","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","   let mut tokens = TokenStream::new();  ","   let items = vec![DummyToken, DummyToken];  ","   tokens.append_separated(items, DummySeparator);  ","   let mut tokens_after = TokenStream::new();  ","   let items_after = vec![DummyToken, DummyToken];  ","   tokens_after.append_separated(items_after, DummySeparator);  ","   assert!(tokens.to_string() != tokens_after.to_string());  ","}"],[77,78,79,80,81,82,83,84,85,86,87,89]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let items = vec![DummyToken, DummyToken];","    tokens.append_separated(items, DummySeparator);","    let mut tokens = TokenStream::new();","    let items = vec![DummyToken, DummyToken];","    tokens.append_separated(items, DummySeparator);","   assert_eq!(tokens.to_string(), \"DummyToken,DummyToken\");","}"],[77,78,79,80,81,82,83,84,85,86,87,89]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    assert!(tokens.is_empty());","}"],[77,78,79,80,81,82,83,89]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.is_empty());","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.to_token_stream().is_empty());","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","    let mut tokens = TokenStream::new();","   let empty_iter: std::vec::IntoIter<TokenTree> = vec![].into_iter();  ","   let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));  ","   tokens.append_separated(empty_iter, separator);  ","   let mut tokens = TokenStream::new();  ","   let empty_iter: std::vec::IntoIter<TokenTree> = vec![].into_iter();  ","   let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));  ","   tokens.append_separated(empty_iter, separator);  ","    assert!(tokens.is_empty());","}"],[]],[["{","    struct SingleToken;","    ","    impl ToTokens for SingleToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {}","    }","    ","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","   struct TokenA;  ","   struct TokenB;  ","   ","   impl ToTokens for TokenA {  ","       fn to_tokens(&self, tokens: &mut TokenStream) {}  ","   }  ","   ","   impl ToTokens for TokenB {  ","       fn to_tokens(&self, tokens: &mut TokenStream) {}  ","   }  ","   ","   let mut tokens = TokenStream::new();  ","   let tokens_iter: Vec<Box<dyn ToTokens>> = vec![Box::new(TokenA), Box::new(TokenB)];  ","   let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));  ","   tokens.append_separated(tokens_iter.into_iter(), separator);  ","   let mut tokens = TokenStream::new();  ","   let tokens_iter: Vec<Box<dyn ToTokens>> = vec![Box::new(TokenA), Box::new(TokenB)];","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    assert_eq!(tokens.is_empty(), true);","}"],[]]],"codes_branches":[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":true,"negative":true}],"codes_branches_covered":[[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    assert_eq!(tokens.into_iter().count(), 0);","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","   let mut tokens = TokenStream::new();  ","   let items = vec![DummyToken, DummyToken];  ","   tokens.append_separated(items, DummySeparator);  ","   let mut tokens_after = TokenStream::new();  ","   let items_after = vec![DummyToken, DummyToken];  ","   tokens_after.append_separated(items_after, DummySeparator);  ","   assert!(tokens.to_string() != tokens_after.to_string());  ","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":true,"negative":true}]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let items = vec![DummyToken, DummyToken];","    tokens.append_separated(items, DummySeparator);","    let mut tokens = TokenStream::new();","    let items = vec![DummyToken, DummyToken];","    tokens.append_separated(items, DummySeparator);","   assert_eq!(tokens.to_string(), \"DummyToken,DummyToken\");","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":true,"negative":true}]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    let mut tokens = TokenStream::new();","    let items: Vec<DummyToken> = vec![];","    tokens.append_separated(items, DummySeparator);","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","// Dummy structures for testing purposes","struct DummyToken;","","impl ToTokens for DummyToken {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","","struct DummySeparator;","","impl ToTokens for DummySeparator {","    fn to_tokens(&self, _: &mut TokenStream) {}","    fn to_token_stream(&self) -> TokenStream { TokenStream::new() }","    fn into_token_stream(self) -> TokenStream { TokenStream::new() }","}","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    tokens.append_separated(vec![item], DummySeparator);","    let mut tokens = TokenStream::new();","    let item = DummyToken;","    let separator = DummySeparator;","    tokens.append_separated(vec![item], separator);","    assert!(tokens.to_token_stream().is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut tokens = TokenStream::new();","   let empty_iter: std::vec::IntoIter<TokenTree> = vec![].into_iter();  ","   let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));  ","   tokens.append_separated(empty_iter, separator);  ","   let mut tokens = TokenStream::new();  ","   let empty_iter: std::vec::IntoIter<TokenTree> = vec![].into_iter();  ","   let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));  ","   tokens.append_separated(empty_iter, separator);  ","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]],[["{","    struct SingleToken;","    ","    impl ToTokens for SingleToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {}","    }","    ","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    let mut tokens = TokenStream::new();","    let single_iter = vec![SingleToken].into_iter();","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    tokens.append_separated(single_iter, separator);","    assert_eq!(tokens.to_string(), \"\");","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]],[["{","   struct TokenA;  ","   struct TokenB;  ","   ","   impl ToTokens for TokenA {  ","       fn to_tokens(&self, tokens: &mut TokenStream) {}  ","   }  ","   ","   impl ToTokens for TokenB {  ","       fn to_tokens(&self, tokens: &mut TokenStream) {}  ","   }  ","   ","   let mut tokens = TokenStream::new();  ","   let tokens_iter: Vec<Box<dyn ToTokens>> = vec![Box::new(TokenA), Box::new(TokenB)];  ","   let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));  ","   tokens.append_separated(tokens_iter.into_iter(), separator);  ","   let mut tokens = TokenStream::new();  ","   let tokens_iter: Vec<Box<dyn ToTokens>> = vec![Box::new(TokenA), Box::new(TokenB)];","    let separator = TokenTree::from(proc_macro2::Ident::new(\",\", proc_macro2::Span::call_site()));","    assert_eq!(tokens.is_empty(), true);","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]]]}