{"function_name":"quote::to_tokens::<proc_macro2::TokenStream as to_tokens::ToTokens>::to_tokens","file_path":"/home/abezbm/rust-utgen-test-crates-new/quote/src/to_tokens.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/quote","tests":17,"tests_lines":[8,9,14,15,16,17,8,9,9,11,12,13,9,13,13,9,9],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":17,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":17,"tests_passed":13,"tests_passed_rate":76.47058823529412,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[264,265,266],"codes_lines_covered":[[["{","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    input.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    input.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    input.to_tokens(&mut tokens);","    assert_eq!(tokens.to_string(), \"test_ident\");","}"],[]],[["{","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42);","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   input1.to_tokens(&mut tokens);","   input2.to_tokens(&mut tokens);","   input3.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42);","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","   input2.to_tokens(&mut tokens);  ","   input3.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","    assert_eq!(tokens.to_string(), \"test_ident1\");","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","   input2.to_tokens(&mut tokens);  ","   input3.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","   input2.to_tokens(&mut tokens);  ","   assert_eq!(tokens.to_string(), \"test_ident1 42\");  ","}"],[]],[["{","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42); // Fixed usage of Literal","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   input1.to_tokens(&mut tokens);","   input2.to_tokens(&mut tokens);","   input3.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42); // Fixed usage of Literal","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   input1.to_tokens(&mut tokens);","   input2.to_tokens(&mut tokens);","    input3.to_tokens(&mut tokens);","    assert_eq!(tokens.to_string(), \"test_ident1 42 ;\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    assert!(tokens.to_string().contains(\"{\"));","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());  ","   inner_group.to_tokens(&mut tokens);  ","   outer_group.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","    let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    assert_eq!(tokens.clone().to_string(), \"\");","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());  ","   inner_group.to_tokens(&mut tokens);  ","   outer_group.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());  ","   inner_group.to_tokens(&mut tokens);  ","   assert_eq!(tokens.clone().to_string(), \"( )\");  ","}"],[]],[["{","    let mut tokens = TokenStream::new();","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","   inner_group.to_tokens(&mut tokens);","   outer_group.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());","    let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    inner_group.to_tokens(&mut tokens);","    outer_group.to_tokens(&mut tokens);","    assert_eq!(tokens.clone().to_string(), \"{ }( )\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    for i in 0..10_000 {","        let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","        input.to_tokens(&mut tokens);","    }","    let mut tokens = TokenStream::new();","    assert_eq!(tokens.is_empty(), true);","}"],[]],[["{","    let mut tokens = TokenStream::new();","    for i in 0..10_000 {","        let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","        input.to_tokens(&mut tokens);","    }","    let mut tokens = TokenStream::new();","    for i in 0..10_000 {","    let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","    input.to_tokens(&mut tokens);","    }","    assert_eq!(tokens.is_empty(), false);","}"],[]],[["{","   let mut tokens = TokenStream::new();","   for i in 0..10_000 {","       let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","       input.to_tokens(&mut tokens);","   }","   let mut tokens = TokenStream::new();","   for i in 0..10_000 {","       let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","       input.to_tokens(&mut tokens);","   }","   assert_eq!(tokens.to_string().matches(\"test_ident\").count(), 10_000);","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    input.to_tokens(&mut tokens); ","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    tokens.extend(iter::once(input.clone()));","    assert!(tokens.is_empty());","}"],[264,265,266]],[["{","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    input.to_tokens(&mut tokens); ","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    tokens.extend(iter::once(input.clone()));","    assert_eq!(tokens.to_string(), \"\");","}"],[264,265,266]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    input.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    input.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let input = Ident::new(\"test_ident\", Span::call_site());","    input.to_tokens(&mut tokens);","    assert_eq!(tokens.to_string(), \"test_ident\");","}"],[]],[["{","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42);","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   input1.to_tokens(&mut tokens);","   input2.to_tokens(&mut tokens);","   input3.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42);","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","   input2.to_tokens(&mut tokens);  ","   input3.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","    assert_eq!(tokens.to_string(), \"test_ident1\");","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","   input2.to_tokens(&mut tokens);  ","   input3.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let input1 = Ident::new(\"test_ident1\", Span::call_site());  ","   let input2 = Literal::u32_unsuffixed(42);  ","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);  ","   input1.to_tokens(&mut tokens);  ","   input2.to_tokens(&mut tokens);  ","   assert_eq!(tokens.to_string(), \"test_ident1 42\");  ","}"],[]],[["{","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42); // Fixed usage of Literal","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   input1.to_tokens(&mut tokens);","   input2.to_tokens(&mut tokens);","   input3.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let input1 = Ident::new(\"test_ident1\", Span::call_site());","   let input2 = Literal::u32_unsuffixed(42); // Fixed usage of Literal","   let input3 = Punct::new(';', proc_macro2::Spacing::Joint);","   input1.to_tokens(&mut tokens);","   input2.to_tokens(&mut tokens);","    input3.to_tokens(&mut tokens);","    assert_eq!(tokens.to_string(), \"test_ident1 42 ;\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    assert_eq!(tokens.to_string(), \"\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    assert!(!tokens.is_empty());","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    let mut tokens = TokenStream::new();","    let group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    group.to_tokens(&mut tokens);","    assert!(tokens.to_string().contains(\"{\"));","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());  ","   inner_group.to_tokens(&mut tokens);  ","   outer_group.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","    let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    assert_eq!(tokens.clone().to_string(), \"\");","}"],[]],[["{","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());  ","   inner_group.to_tokens(&mut tokens);  ","   outer_group.to_tokens(&mut tokens);  ","   let mut tokens = TokenStream::new();  ","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());  ","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());  ","   inner_group.to_tokens(&mut tokens);  ","   assert_eq!(tokens.clone().to_string(), \"( )\");  ","}"],[]],[["{","    let mut tokens = TokenStream::new();","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());","   let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","   inner_group.to_tokens(&mut tokens);","   outer_group.to_tokens(&mut tokens);","   let mut tokens = TokenStream::new();","   let inner_group = Group::new(proc_macro2::Delimiter::Parenthesis, TokenStream::new());","    let outer_group = Group::new(proc_macro2::Delimiter::Brace, TokenStream::new());","    inner_group.to_tokens(&mut tokens);","    outer_group.to_tokens(&mut tokens);","    assert_eq!(tokens.clone().to_string(), \"{ }( )\");","}"],[]],[["{","    let mut tokens = TokenStream::new();","    for i in 0..10_000 {","        let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","        input.to_tokens(&mut tokens);","    }","    let mut tokens = TokenStream::new();","    assert_eq!(tokens.is_empty(), true);","}"],[]],[["{","    let mut tokens = TokenStream::new();","    for i in 0..10_000 {","        let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","        input.to_tokens(&mut tokens);","    }","    let mut tokens = TokenStream::new();","    for i in 0..10_000 {","    let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","    input.to_tokens(&mut tokens);","    }","    assert_eq!(tokens.is_empty(), false);","}"],[]],[["{","   let mut tokens = TokenStream::new();","   for i in 0..10_000 {","       let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","       input.to_tokens(&mut tokens);","   }","   let mut tokens = TokenStream::new();","   for i in 0..10_000 {","       let input = Ident::new(&format!(\"test_ident{}\", i), Span::call_site());","       input.to_tokens(&mut tokens);","   }","   assert_eq!(tokens.to_string().matches(\"test_ident\").count(), 10_000);","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    input.to_tokens(&mut tokens); ","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    tokens.extend(iter::once(input.clone()));","    assert!(tokens.is_empty());","}"],[]],[["{","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    input.to_tokens(&mut tokens); ","    let mut tokens = TokenStream::new();","    let input = TokenStream::new();","    tokens.extend(iter::once(input.clone()));","    assert_eq!(tokens.to_string(), \"\");","}"],[]]]}