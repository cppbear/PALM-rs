{"function_name":"quote::ext::<proc_macro2::TokenStream as ext::TokenStreamExt>::append_terminated","tests":6,"tests_lines":[23,23,35,10,10,10],"oracles":6,"oracles_compiled":2,"oracles_compiled_rate":33.33333333333333,"tests_compiled":2,"tests_compiled_rate":33.33333333333333,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":11,"lines_covered":11,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[91,92,93,94,95,96,97,98,99,100,101],"codes_lines_covered":[[["{","    struct TokenStruct;","","    impl ToTokens for TokenStruct {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Example implementation that would normally convert self to tokens","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut tokens = TokenStream::new();","    let input_iter = vec![TokenStruct, TokenStruct];","    let separator = TokenStruct;","","    tokens.append_terminated(input_iter.iter(), separator);","","    // Add assertions based on expectations of what tokens should have been generated","}"],[91,92,93,94,95,96,97,98,99,100,101]],[["{","    struct TokenStruct;","","    impl ToTokens for TokenStruct {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Example implementation that would normally convert self to tokens","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut tokens = TokenStream::new();","    let input_iter: Vec<TokenStruct> = vec![];","    let separator = TokenStruct;","","    tokens.append_terminated(input_iter.iter(), separator);","","    // Add assertions based on expectations of what tokens should have been generated","}"],[91,92,93,94,95,96,97,101]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TokenStruct;","","    impl ToTokens for TokenStruct {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Example implementation that would normally convert self to tokens","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut tokens = TokenStream::new();","    let input_iter = vec![TokenStruct, TokenStruct];","    let separator = TokenStruct;","","    tokens.append_terminated(input_iter.iter(), separator);","","    // Add assertions based on expectations of what tokens should have been generated","}"],[]],[["{","    struct TokenStruct;","","    impl ToTokens for TokenStruct {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Example implementation that would normally convert self to tokens","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut tokens = TokenStream::new();","    let input_iter: Vec<TokenStruct> = vec![];","    let separator = TokenStruct;","","    tokens.append_terminated(input_iter.iter(), separator);","","    // Add assertions based on expectations of what tokens should have been generated","}"],[]]]}