{"function_name":"quote::ext::<proc_macro2::TokenStream as ext::TokenStreamExt>::append_separated","tests":10,"tests_lines":[41,41,41,25,24,24,29,30,31,32],"oracles":10,"oracles_compiled":6,"oracles_compiled_rate":60.0,"tests_compiled":6,"tests_compiled_rate":60.0,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":6,"tests_passed":5,"tests_passed_rate":83.33333333333334,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[77,78,79,80,81,82,83,84,85,86,87,89],"codes_lines_covered":[[["{","#[should_panic]","fn test_append_separated_one_token() {","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken]; // Prepare a single token","","    token_stream.append_separated(tokens, TestToken); // Should panic because i > 0 is false","}","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken, TestToken]; // Prepare two tokens for testing","","    token_stream.append_separated(tokens, TestToken); // Should not panic","}"],[77,78,79,80,81,82,83,84,85,86,87,89]],[["{","#[should_panic]","fn test_append_separated_one_token() {","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken]; // Prepare a single token","","    token_stream.append_separated(tokens, TestToken); // Should panic because i > 0 is false","}","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens: Vec<TestToken> = Vec::new(); // Prepare an empty vector","","    token_stream.append_separated(tokens, TestToken); // Should not panic","}"],[77,78,79,80,81,82,83,89]],[["{","#[should_panic]","fn test_append_separated_one_token() {","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken]; // Prepare a single token","","    token_stream.append_separated(tokens, TestToken); // Should panic because i > 0 is false","}","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken, TestToken, TestToken]; // Prepare three tokens for testing","","    token_stream.append_separated(tokens, TestToken); // Should not panic","}"],[77,78,79,80,81,82,83,84,85,86,87,89]],[["{","    let mut tokens = TokenStream::new();","    let iter: Vec<&str> = Vec::new();","","    // Creating a struct to implement ToTokens for our test","    struct TestToken<'a>(&'a str);","","    impl ToTokens for TestToken<'_> {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            tokens.extend(self.0.parse::<TokenStream>().unwrap());","        }","        fn to_token_stream(&self) -> TokenStream {","            let mut stream = TokenStream::new();","            self.to_tokens(&mut stream);","            stream","        }","        fn into_token_stream(self) -> TokenStream {","            self.to_token_stream()","        }","    }","","    // No tokens should be appended, as the iterator is empty.","    tokens.append_separated(iter.iter().map(|&s| TestToken(s)), TestToken(\",\"));","    assert!(tokens.is_empty());","}"],[77,78,79,80,81,82,83,89]],[["{","    let mut tokens = TokenStream::new();","    let iter = vec![\"token1\"];","","    struct TestToken<'a>(&'a str);","","    impl ToTokens for TestToken<'_> {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            tokens.extend(self.0.parse::<TokenStream>().unwrap());","        }","        fn to_token_stream(&self) -> TokenStream {","            let mut stream = TokenStream::new();","            self.to_tokens(&mut stream);","            stream","        }","        fn into_token_stream(self) -> TokenStream {","            self.to_token_stream()","        }","    }","","    // Only \"token1\" should be appended without any operator since i == 0","    tokens.append_separated(iter.iter().map(|&s| TestToken(s)), TestToken(\",\"));","    assert_eq!(tokens.to_string(), \"token1\");","}"],[77,78,79,80,81,82,83,84,86,87,89]],[["{","    let mut tokens = TokenStream::new();","    let iter = vec![\"token1\", \"token2\", \"token3\"];","","    struct TestToken<'a>(&'a str);","","    impl ToTokens for TestToken<'_> {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            tokens.extend(self.0.parse::<TokenStream>().unwrap());","        }","        fn to_token_stream(&self) -> TokenStream {","            let mut stream = TokenStream::new();","            self.to_tokens(&mut stream);","            stream","        }","        fn into_token_stream(self) -> TokenStream {","            self.to_token_stream()","        }","    }","","    // Operator should be appended between tokens","    tokens.append_separated(iter.iter().map(|&s| TestToken(s)), TestToken(\",\"));","    assert_eq!(tokens.to_string(), \"token1,token2,token3\");","}"],[77,78,79,80,81,82,83,84,85,86,87,89]]],"codes_branches":[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":true,"negative":true}],"codes_branches_covered":[[["{","#[should_panic]","fn test_append_separated_one_token() {","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken]; // Prepare a single token","","    token_stream.append_separated(tokens, TestToken); // Should panic because i > 0 is false","}","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken, TestToken]; // Prepare two tokens for testing","","    token_stream.append_separated(tokens, TestToken); // Should not panic","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":true,"negative":true}]],[["{","#[should_panic]","fn test_append_separated_one_token() {","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken]; // Prepare a single token","","    token_stream.append_separated(tokens, TestToken); // Should panic because i > 0 is false","}","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens: Vec<TestToken> = Vec::new(); // Prepare an empty vector","","    token_stream.append_separated(tokens, TestToken); // Should not panic","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]],[["{","#[should_panic]","fn test_append_separated_one_token() {","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken]; // Prepare a single token","","    token_stream.append_separated(tokens, TestToken); // Should panic because i > 0 is false","}","    struct TestToken;","","    impl ToTokens for TestToken {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            // Simulate token addition","        }","        fn to_token_stream(&self) -> TokenStream {","            TokenStream::new()","        }","        fn into_token_stream(self) -> TokenStream {","            TokenStream::new()","        }","    }","","    let mut token_stream = TokenStream::new();","    let tokens = vec![TestToken, TestToken, TestToken]; // Prepare three tokens for testing","","    token_stream.append_separated(tokens, TestToken); // Should not panic","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":true,"negative":true}]],[["{","    let mut tokens = TokenStream::new();","    let iter: Vec<&str> = Vec::new();","","    // Creating a struct to implement ToTokens for our test","    struct TestToken<'a>(&'a str);","","    impl ToTokens for TestToken<'_> {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            tokens.extend(self.0.parse::<TokenStream>().unwrap());","        }","        fn to_token_stream(&self) -> TokenStream {","            let mut stream = TokenStream::new();","            self.to_tokens(&mut stream);","            stream","        }","        fn into_token_stream(self) -> TokenStream {","            self.to_token_stream()","        }","    }","","    // No tokens should be appended, as the iterator is empty.","    tokens.append_separated(iter.iter().map(|&s| TestToken(s)), TestToken(\",\"));","    assert!(tokens.is_empty());","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":false}]],[["{","    let mut tokens = TokenStream::new();","    let iter = vec![\"token1\"];","","    struct TestToken<'a>(&'a str);","","    impl ToTokens for TestToken<'_> {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            tokens.extend(self.0.parse::<TokenStream>().unwrap());","        }","        fn to_token_stream(&self) -> TokenStream {","            let mut stream = TokenStream::new();","            self.to_tokens(&mut stream);","            stream","        }","        fn into_token_stream(self) -> TokenStream {","            self.to_token_stream()","        }","    }","","    // Only \"token1\" should be appended without any operator since i == 0","    tokens.append_separated(iter.iter().map(|&s| TestToken(s)), TestToken(\",\"));","    assert_eq!(tokens.to_string(), \"token1\");","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":false,"negative":true}]],[["{","    let mut tokens = TokenStream::new();","    let iter = vec![\"token1\", \"token2\", \"token3\"];","","    struct TestToken<'a>(&'a str);","","    impl ToTokens for TestToken<'_> {","        fn to_tokens(&self, tokens: &mut TokenStream) {","            tokens.extend(self.0.parse::<TokenStream>().unwrap());","        }","        fn to_token_stream(&self) -> TokenStream {","            let mut stream = TokenStream::new();","            self.to_tokens(&mut stream);","            stream","        }","        fn into_token_stream(self) -> TokenStream {","            self.to_token_stream()","        }","    }","","    // Operator should be appended between tokens","    tokens.append_separated(iter.iter().map(|&s| TestToken(s)), TestToken(\",\"));","    assert_eq!(tokens.to_string(), \"token1,token2,token3\");","}"],[{"start_line":84,"start_column":16,"end_line":84,"end_column":21,"positive":true,"negative":true}]]]}