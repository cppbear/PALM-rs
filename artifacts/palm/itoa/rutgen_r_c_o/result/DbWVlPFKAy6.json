{"function_name":"itoa::udiv128::udivmod_1e19","file_path":"/home/abezbm/rust-utgen-test-crates-new/itoa/src/udiv128.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/itoa","tests":22,"tests_lines":[9,9,9,9,9,9,9,9,10,10,8,8,8,8,9,9,9,9,9,9,8,8],"oracles":10,"oracles_compiled":8,"oracles_compiled_rate":80.0,"tests_compiled":16,"tests_compiled_rate":72.72727272727273,"oracles_run":8,"oracles_passed":6,"oracles_passed_rate":75.0,"tests_run":16,"tests_passed":10,"tests_passed_rate":62.5,"lines":10,"lines_covered":10,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[34,35,37,38,40,43,44,45,47,48],"codes_lines_covered":[[["{","    let n: u128 = 0;","    udivmod_1e19(n);","    let n: u128 = 0;","    let expected_quot: u128 = 0;","    let expected_rem: u64 = 0;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n: u128 = 0;","    udivmod_1e19(n);","    let n: u128 = 0;","    let expected_quot: u128 = 0;","    let expected_rem: u64 = 0;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    udivmod_1e19(n);","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    udivmod_1e19(n);","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem as u64);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n: u128 = 4_835_000_000_000_000_000;","    udivmod_1e19(n);","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n: u128 = 4_835_000_000_000_000_000;","    udivmod_1e19(n);","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n: u128 = 1_234_567_890_123_456_789;","    udivmod_1e19(n);","    let n: u128 = 1_234_567_890_123_456_789;","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n: u128 = 1_234_567_890_123_456_789;","    udivmod_1e19(n);","    let n: u128 = 1_234_567_890_123_456_789;","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem);","}"],[34,35,37,38,43,44,45,47,48]],[["{","    let n = 1 << 83; // Edge case where n is equal to the boundary where the condition changes","    let _ = udivmod_1e19(n);","    let n = 1 << 83;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000u128) as u64;","    assert_ne!(expected_quot, n / 10_000_000_000_000_000_000u128);","}"],[34,35,37,40,43,44,45,47,48]],[["{","    let n = 1 << 83; // Edge case where n is equal to the boundary where the condition changes","    let _ = udivmod_1e19(n);","    let n = 1 << 83;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000u128) as u64;","    assert_ne!(expected_rem as u128, n % 10_000_000_000_000_000_000u128);","}"],[34,35,37,40,43,44,45,47,48]],[["{","    let n = (1 << 83) + 1; // Just above the boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 83) + 1;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000_u128) as u64;","    assert_ne!(expected_quot, n / 10_000_000_000_000_000_000_u128);","}"],[34,35,37,40,43,44,45,47,48]],[["{","    let n = (1 << 83) + 1; // Just above the boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 83) + 1;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000_u128) as u64;","    assert_ne!(expected_rem as u128, n % 10_000_000_000_000_000_000_u128);","}"],[34,35,37,40,43,44,45,47,48]],[["{","    let n = u128::MAX; // Maximum value of u128","    let _ = udivmod_1e19(n);","    let n = u128::MAX;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[34,35,37,40,43,44,45,47,48]],[["{","    let n = (1 << 84) - 1; // Just below the next power of two boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 84) - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[34,35,37,40,43,44,45,47,48]],[["{","    let n = (1 << 84) - 1; // Just below the next power of two boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 84) - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert!(quot != n / 10_000_000_000_000_000_000_u128);","}"],[34,35,37,40,43,44,45,47,48]],[["{","    let n = (1 << 84) - 1; // Just below the next power of two boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 84) - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert!(rem as u128 != n % 10_000_000_000_000_000_000_u128);","}"],[34,35,37,40,43,44,45,47,48]]],"codes_branches":[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let n: u128 = 0;","    udivmod_1e19(n);","    let n: u128 = 0;","    let expected_quot: u128 = 0;","    let expected_rem: u64 = 0;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n: u128 = 0;","    udivmod_1e19(n);","    let n: u128 = 0;","    let expected_quot: u128 = 0;","    let expected_rem: u64 = 0;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    udivmod_1e19(n);","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    udivmod_1e19(n);","    let n: u128 = 9_670_000_000_000_000_000 - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem as u64);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n: u128 = 4_835_000_000_000_000_000;","    udivmod_1e19(n);","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n: u128 = 4_835_000_000_000_000_000;","    udivmod_1e19(n);","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n: u128 = 1_234_567_890_123_456_789;","    udivmod_1e19(n);","    let n: u128 = 1_234_567_890_123_456_789;","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n: u128 = 1_234_567_890_123_456_789;","    udivmod_1e19(n);","    let n: u128 = 1_234_567_890_123_456_789;","    let d: u64 = 10_000_000_000_000_000_000;","    let expected_quot: u128 = n / d as u128;","    let expected_rem: u64 = (n % d as u128) as u64;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(rem, expected_rem);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":true,"negative":false}]],[["{","    let n = 1 << 83; // Edge case where n is equal to the boundary where the condition changes","    let _ = udivmod_1e19(n);","    let n = 1 << 83;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000u128) as u64;","    assert_ne!(expected_quot, n / 10_000_000_000_000_000_000u128);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]],[["{","    let n = 1 << 83; // Edge case where n is equal to the boundary where the condition changes","    let _ = udivmod_1e19(n);","    let n = 1 << 83;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000u128) as u64;","    assert_ne!(expected_rem as u128, n % 10_000_000_000_000_000_000u128);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]],[["{","    let n = (1 << 83) + 1; // Just above the boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 83) + 1;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000_u128) as u64;","    assert_ne!(expected_quot, n / 10_000_000_000_000_000_000_u128);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]],[["{","    let n = (1 << 83) + 1; // Just above the boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 83) + 1;","    let expected_quot = u128_mulhi(n, 156927543384667019095894735580191660403) >> 62;","    let expected_rem = (n - expected_quot * 10_000_000_000_000_000_000_u128) as u64;","    assert_ne!(expected_rem as u128, n % 10_000_000_000_000_000_000_u128);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]],[["{","    let n = u128::MAX; // Maximum value of u128","    let _ = udivmod_1e19(n);","    let n = u128::MAX;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]],[["{","    let n = (1 << 84) - 1; // Just below the next power of two boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 84) - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert_eq!(quot, expected_quot);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]],[["{","    let n = (1 << 84) - 1; // Just below the next power of two boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 84) - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert!(quot != n / 10_000_000_000_000_000_000_u128);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]],[["{","    let n = (1 << 84) - 1; // Just below the next power of two boundary","    let _ = udivmod_1e19(n);","    let n = (1 << 84) - 1;","    let expected_quot = n / 10_000_000_000_000_000_000_u128;","    let expected_rem = n % 10_000_000_000_000_000_000_u128;","    let (quot, rem) = udivmod_1e19(n);","    assert!(rem as u128 != n % 10_000_000_000_000_000_000_u128);","}"],[{"start_line":37,"start_column":19,"end_line":37,"end_column":30,"positive":false,"negative":true}]]]}