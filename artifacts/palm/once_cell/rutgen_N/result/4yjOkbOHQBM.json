{"function_name":"once_cell::unsync::unsync::OnceCell<T>::try_insert","tests":3,"tests_lines":[35,33,32],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":13,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[551,552,553,554,555,556,557,558,559,560,561,562,563],"codes_lines_covered":[[["{","    struct OnceCell<T> {","        inner: std::cell::UnsafeCell<Option<T>>,","    }","","    impl<T> OnceCell<T> {","        fn new() -> Self {","            OnceCell {","                inner: std::cell::UnsafeCell::new(None),","            }","        }","","        fn get(&self) -> Option<&T> {","            unsafe { &*self.inner.get() }.as_ref()","        }","","        pub fn try_insert(&self, value: T) -> Result<&T, (&T, T)> {","            if let Some(old) = self.get() {","                return Err((old, value));","            }","","            let slot = unsafe { &mut *self.inner.get() };","            *slot = Some(value);","            Ok(unsafe { slot.as_ref().unwrap_unchecked() })","        }","    }","","    let cell = OnceCell::new();","    assert!(cell.get().is_none());","","    assert_eq!(cell.try_insert(92), Ok(&92));","    assert_eq!(cell.try_insert(62), Err((&92, 62)));","","    assert!(cell.get().is_some());","}"],[]],[["{","    struct OnceCell<T> {","        inner: std::cell::UnsafeCell<Option<T>>,","    }","","    impl<T> OnceCell<T> {","        fn new() -> Self {","            OnceCell {","                inner: std::cell::UnsafeCell::new(None),","            }","        }","","        fn get(&self) -> Option<&T> {","            unsafe { &*self.inner.get() }.as_ref()","        }","","        pub fn try_insert(&self, value: T) -> Result<&T, (&T, T)> {","            if let Some(old) = self.get() {","                return Err((old, value));","            }","","            let slot = unsafe { &mut *self.inner.get() };","            *slot = Some(value);","            Ok(unsafe { slot.as_ref().unwrap_unchecked() })","        }","    }","","    let cell = OnceCell::new();","    assert!(cell.get().is_none());","","    assert_eq!(cell.try_insert(100), Ok(&100));","    assert_eq!(cell.try_insert(200), Err((&100, 200)));","}"],[]],[["{","    struct OnceCell<T> {","        inner: std::cell::UnsafeCell<Option<T>>,","    }","","    impl<T> OnceCell<T> {","        fn new() -> Self {","            OnceCell {","                inner: std::cell::UnsafeCell::new(None),","            }","        }","","        fn get(&self) -> Option<&T> {","            unsafe { &*self.inner.get() }.as_ref()","        }","","        pub fn try_insert(&self, value: T) -> Result<&T, (&T, T)> {","            if let Some(old) = self.get() {","                return Err((old, value));","            }","","            let slot = unsafe { &mut *self.inner.get() };","            *slot = Some(value);","            Ok(unsafe { slot.as_ref().unwrap_unchecked() })","        }","    }","","    let cell = OnceCell::new();","    let value = String::from(\"Hello\");","    ","    assert_eq!(cell.try_insert(value), Ok(&String::from(\"Hello\")));","}"],[]]],"codes_branches":[{"start_line":552,"start_column":20,"end_line":552,"end_column":29,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct OnceCell<T> {","        inner: std::cell::UnsafeCell<Option<T>>,","    }","","    impl<T> OnceCell<T> {","        fn new() -> Self {","            OnceCell {","                inner: std::cell::UnsafeCell::new(None),","            }","        }","","        fn get(&self) -> Option<&T> {","            unsafe { &*self.inner.get() }.as_ref()","        }","","        pub fn try_insert(&self, value: T) -> Result<&T, (&T, T)> {","            if let Some(old) = self.get() {","                return Err((old, value));","            }","","            let slot = unsafe { &mut *self.inner.get() };","            *slot = Some(value);","            Ok(unsafe { slot.as_ref().unwrap_unchecked() })","        }","    }","","    let cell = OnceCell::new();","    assert!(cell.get().is_none());","","    assert_eq!(cell.try_insert(92), Ok(&92));","    assert_eq!(cell.try_insert(62), Err((&92, 62)));","","    assert!(cell.get().is_some());","}"],[{"start_line":552,"start_column":20,"end_line":552,"end_column":29,"positive":false,"negative":false}]],[["{","    struct OnceCell<T> {","        inner: std::cell::UnsafeCell<Option<T>>,","    }","","    impl<T> OnceCell<T> {","        fn new() -> Self {","            OnceCell {","                inner: std::cell::UnsafeCell::new(None),","            }","        }","","        fn get(&self) -> Option<&T> {","            unsafe { &*self.inner.get() }.as_ref()","        }","","        pub fn try_insert(&self, value: T) -> Result<&T, (&T, T)> {","            if let Some(old) = self.get() {","                return Err((old, value));","            }","","            let slot = unsafe { &mut *self.inner.get() };","            *slot = Some(value);","            Ok(unsafe { slot.as_ref().unwrap_unchecked() })","        }","    }","","    let cell = OnceCell::new();","    assert!(cell.get().is_none());","","    assert_eq!(cell.try_insert(100), Ok(&100));","    assert_eq!(cell.try_insert(200), Err((&100, 200)));","}"],[{"start_line":552,"start_column":20,"end_line":552,"end_column":29,"positive":false,"negative":false}]],[["{","    struct OnceCell<T> {","        inner: std::cell::UnsafeCell<Option<T>>,","    }","","    impl<T> OnceCell<T> {","        fn new() -> Self {","            OnceCell {","                inner: std::cell::UnsafeCell::new(None),","            }","        }","","        fn get(&self) -> Option<&T> {","            unsafe { &*self.inner.get() }.as_ref()","        }","","        pub fn try_insert(&self, value: T) -> Result<&T, (&T, T)> {","            if let Some(old) = self.get() {","                return Err((old, value));","            }","","            let slot = unsafe { &mut *self.inner.get() };","            *slot = Some(value);","            Ok(unsafe { slot.as_ref().unwrap_unchecked() })","        }","    }","","    let cell = OnceCell::new();","    let value = String::from(\"Hello\");","    ","    assert_eq!(cell.try_insert(value), Ok(&String::from(\"Hello\")));","}"],[{"start_line":552,"start_column":20,"end_line":552,"end_column":29,"positive":false,"negative":false}]]]}