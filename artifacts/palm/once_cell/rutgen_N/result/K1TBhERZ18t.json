{"function_name":"once_cell::race::once_box::race::once_box::OnceBox<T>::with_value","tests":2,"tests_lines":[24,23],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[394,395,396],"codes_lines_covered":[[["{","    use std::ptr::null_mut;","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::marker::PhantomData;","","    struct Cell<T> {","        inner: AtomicPtr<T>,","        ghost: PhantomData<T>,","    }","","    impl<T> Cell<T> {","        pub fn with_value(value: Box<T>) -> Self {","            Self { inner: AtomicPtr::new(Box::into_raw(value)), ghost: PhantomData }","        }","    }","","    let boxed_value = Box::new(42);","    let cell: Cell<i32> = Cell::with_value(boxed_value);","","    assert!(!cell.inner.load(Ordering::SeqCst).is_null());","    unsafe {","        assert_eq!(*cell.inner.load(Ordering::SeqCst), 42);","    }","}"],[]],[["{","    use std::ptr::null_mut;","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::marker::PhantomData;","","    struct Cell<T> {","        inner: AtomicPtr<T>,","        ghost: PhantomData<T>,","    }","","    impl<T> Cell<T> {","        pub fn with_value(value: Box<T>) -> Self {","            Self { inner: AtomicPtr::new(Box::into_raw(value)), ghost: PhantomData }","        }","    }","","    let cell: Cell<i32> = Cell::with_value(Box::new(0));","    let ptr = cell.inner.load(Ordering::SeqCst);","    unsafe {","        Box::from_raw(ptr); // Prevent memory leak","    }","    assert!(cell.inner.load(Ordering::SeqCst).is_null());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::ptr::null_mut;","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::marker::PhantomData;","","    struct Cell<T> {","        inner: AtomicPtr<T>,","        ghost: PhantomData<T>,","    }","","    impl<T> Cell<T> {","        pub fn with_value(value: Box<T>) -> Self {","            Self { inner: AtomicPtr::new(Box::into_raw(value)), ghost: PhantomData }","        }","    }","","    let boxed_value = Box::new(42);","    let cell: Cell<i32> = Cell::with_value(boxed_value);","","    assert!(!cell.inner.load(Ordering::SeqCst).is_null());","    unsafe {","        assert_eq!(*cell.inner.load(Ordering::SeqCst), 42);","    }","}"],[]],[["{","    use std::ptr::null_mut;","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::marker::PhantomData;","","    struct Cell<T> {","        inner: AtomicPtr<T>,","        ghost: PhantomData<T>,","    }","","    impl<T> Cell<T> {","        pub fn with_value(value: Box<T>) -> Self {","            Self { inner: AtomicPtr::new(Box::into_raw(value)), ghost: PhantomData }","        }","    }","","    let cell: Cell<i32> = Cell::with_value(Box::new(0));","    let ptr = cell.inner.load(Ordering::SeqCst);","    unsafe {","        Box::from_raw(ptr); // Prevent memory leak","    }","    assert!(cell.inner.load(Ordering::SeqCst).is_null());","}"],[]]]}