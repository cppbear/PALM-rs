{"function_name":"once_cell::race::race::OnceRef<'a, T>::compare_exchange","tests":2,"tests_lines":[22,23],"oracles":2,"oracles_compiled":1,"oracles_compiled_rate":50.0,"tests_compiled":1,"tests_compiled_rate":50.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":11,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[320,321,322,323,324,325,326,327,328,329,330],"codes_lines_covered":[[["{","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::ptr;","","    struct Inner {","        inner: AtomicPtr<i32>,","    }","","    impl Inner {","        fn compare_exchange(&self, old: *mut i32, new: *mut i32, success_order: Ordering, failure_order: Ordering) -> Result<*mut i32, *mut i32> {","            self.inner.compare_exchange(old, new, success_order, failure_order)","        }","    }","","    let value = Box::new(10);","    let inner = Inner {","        inner: AtomicPtr::new(ptr::null_mut()),","    };","","    let result = inner.compare_exchange(ptr::null_mut(), Box::into_raw(value), Ordering::Release, Ordering::Acquire);","    assert!(result.is_ok());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::sync::atomic::{AtomicPtr, Ordering};","    use std::ptr;","","    struct Inner {","        inner: AtomicPtr<i32>,","    }","","    impl Inner {","        fn compare_exchange(&self, old: *mut i32, new: *mut i32, success_order: Ordering, failure_order: Ordering) -> Result<*mut i32, *mut i32> {","            self.inner.compare_exchange(old, new, success_order, failure_order)","        }","    }","","    let value = Box::new(10);","    let inner = Inner {","        inner: AtomicPtr::new(ptr::null_mut()),","    };","","    let result = inner.compare_exchange(ptr::null_mut(), Box::into_raw(value), Ordering::Release, Ordering::Acquire);","    assert!(result.is_ok());","}"],[]]]}