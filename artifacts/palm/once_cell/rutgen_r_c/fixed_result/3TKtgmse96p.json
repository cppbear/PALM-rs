{"function_name":"once_cell::sync::sync::OnceCell<T>::get_or_try_init","tests":10,"tests_lines":[8,9,10,11,45,41,42,27,24,20],"oracles":10,"oracles_compiled":6,"oracles_compiled_rate":60.0,"tests_compiled":6,"tests_compiled_rate":60.0,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1152,1153,1154,1155,1157,1158,1159,1160,1161,1164,1165,1166],"codes_lines_covered":[[["{","  #[derive(Debug, PartialEq)]","  struct TestValue(i32);","  ","  let cell = OnceCell::new();","  ","  let result: Result<&TestValue, ()> = cell.get_or_try_init(|| Ok(TestValue(84)));","  ","  assert_eq!(result, Ok(&TestValue(84)));","}"],[1152,1153,1154,1155,1157,1159,1160,1161,1164,1165,1166]],[["{","  #[derive(Debug, PartialEq)]","  struct TestValue(u32);","  struct TestOnceCell(Imp<TestValue>);","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","}"],[]],[["{","  #[derive(Debug, PartialEq)]  ","  struct TestValue(u32);  ","  struct TestOnceCell(Imp<TestValue>);  ","  ","  impl TestOnceCell {  ","      const fn new() -> Self {  ","          TestOnceCell(Imp::new())  ","      }  ","  ","      fn get_or_try_init<F, E>(&self, f: F) -> Result<&TestValue, E>  ","      where  ","          F: FnOnce() -> Result<TestValue, E>,  ","      {  ","          if let Some(value) = self.get() {  ","              return Ok(value);  ","          }  ","          self.0.initialize(f)?;  ","          debug_assert!(self.0.is_initialized());  ","          Ok(unsafe { self.get_unchecked() })  ","      }  ","  ","      fn get(&self) -> Option<&TestValue> {  ","          if self.0.is_initialized() {  ","              Some(unsafe { self.get_unchecked() })  ","          } else {  ","              None  ","          }  ","      }  ","  ","      unsafe fn get_unchecked(&self) -> &TestValue {  ","          self.0.get_unchecked()  ","      }  ","  }  ","  ","  let cell = TestOnceCell::new();  ","  ","  // Call get_or_try_init and expect an Error without initializing it  ","  let result: Result<&TestValue, ()> = cell.get_or_try_init(|| Err(()));  ","  assert_eq!(result, Err(()));  ","}"],[]],[["{","    struct TestOnceCell {","        cell: OnceCell<i32>,","    }","","    impl TestOnceCell {","        fn new() -> Self {","            TestOnceCell {","                cell: OnceCell::new(),","            }","        }","        ","       fn initialize(&self, value: i32) -> Result<&i32, ()> {","           self.cell.set(value).map(|_| self.cell.get().unwrap()).map_err(|_| ())","       }","    }","","    let once_cell = TestOnceCell::new();","    assert!(once_cell.cell.get().is_none());","    ","    let result = once_cell.initialize(42);","    assert!(result.is_ok());","    assert_eq!(once_cell.cell.get(), Some(&42));","    ","   let second_result: Result<&i32, ()> = once_cell.cell.get_or_try_init(|| Ok(100));","   assert_eq!(second_result, Ok(&42)); // Already initialized, should return 42","}"],[1152,1153,1154,1155,1157,1158,1159,1160,1161,1164,1165,1166]],[["{","    struct TestOnceCell {","        cell: OnceCell<i32>,","    }","","    impl TestOnceCell {","        fn new() -> Self {","            TestOnceCell {","                cell: OnceCell::new(),","            }","        }","        ","        fn fail_initialize(&self) -> Result<&i32, ()> {","            Err(())","        }","    }","","    let once_cell = TestOnceCell::new();","    assert!(once_cell.cell.get().is_none());","    ","   let result = once_cell.cell.get_or_try_init(|| once_cell.fail_initialize().map(|_| 0));","   assert_eq!(result, Err(())); // Initialization failed","    assert!(once_cell.cell.get().is_none());","}"],[1152,1153,1154,1155,1157,1159,1160,1161,1166]],[["{","    struct TestOnceCell {","        cell: OnceCell<i32>,","    }","","    impl TestOnceCell {","        fn new() -> Self {","            TestOnceCell {","                cell: OnceCell::new(),","            }","        }","        ","        fn reentrant_init(&self) -> Result<i32, ()> {","            self.cell.get_or_try_init(|| self.reentrant_init()).map(|_| 0)","        }","    }","","    let once_cell = TestOnceCell::new();","    let _ = once_cell.cell.get_or_try_init(|| once_cell.reentrant_init());","}"],[1152,1153,1154,1155,1157,1159,1160,1161,1164]]],"codes_branches":[{"start_line":1157,"start_column":20,"end_line":1157,"end_column":31,"positive":true,"negative":true}],"codes_branches_covered":[[["{","  #[derive(Debug, PartialEq)]","  struct TestValue(i32);","  ","  let cell = OnceCell::new();","  ","  let result: Result<&TestValue, ()> = cell.get_or_try_init(|| Ok(TestValue(84)));","  ","  assert_eq!(result, Ok(&TestValue(84)));","}"],[{"start_line":1157,"start_column":20,"end_line":1157,"end_column":31,"positive":false,"negative":true}]],[["{","  #[derive(Debug, PartialEq)]","  struct TestValue(u32);","  struct TestOnceCell(Imp<TestValue>);","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","}"],[{"start_line":1157,"start_column":20,"end_line":1157,"end_column":31,"positive":false,"negative":false}]],[["{","  #[derive(Debug, PartialEq)]  ","  struct TestValue(u32);  ","  struct TestOnceCell(Imp<TestValue>);  ","  ","  impl TestOnceCell {  ","      const fn new() -> Self {  ","          TestOnceCell(Imp::new())  ","      }  ","  ","      fn get_or_try_init<F, E>(&self, f: F) -> Result<&TestValue, E>  ","      where  ","          F: FnOnce() -> Result<TestValue, E>,  ","      {  ","          if let Some(value) = self.get() {  ","              return Ok(value);  ","          }  ","          self.0.initialize(f)?;  ","          debug_assert!(self.0.is_initialized());  ","          Ok(unsafe { self.get_unchecked() })  ","      }  ","  ","      fn get(&self) -> Option<&TestValue> {  ","          if self.0.is_initialized() {  ","              Some(unsafe { self.get_unchecked() })  ","          } else {  ","              None  ","          }  ","      }  ","  ","      unsafe fn get_unchecked(&self) -> &TestValue {  ","          self.0.get_unchecked()  ","      }  ","  }  ","  ","  let cell = TestOnceCell::new();  ","  ","  // Call get_or_try_init and expect an Error without initializing it  ","  let result: Result<&TestValue, ()> = cell.get_or_try_init(|| Err(()));  ","  assert_eq!(result, Err(()));  ","}"],[{"start_line":1157,"start_column":20,"end_line":1157,"end_column":31,"positive":false,"negative":false}]],[["{","    struct TestOnceCell {","        cell: OnceCell<i32>,","    }","","    impl TestOnceCell {","        fn new() -> Self {","            TestOnceCell {","                cell: OnceCell::new(),","            }","        }","        ","       fn initialize(&self, value: i32) -> Result<&i32, ()> {","           self.cell.set(value).map(|_| self.cell.get().unwrap()).map_err(|_| ())","       }","    }","","    let once_cell = TestOnceCell::new();","    assert!(once_cell.cell.get().is_none());","    ","    let result = once_cell.initialize(42);","    assert!(result.is_ok());","    assert_eq!(once_cell.cell.get(), Some(&42));","    ","   let second_result: Result<&i32, ()> = once_cell.cell.get_or_try_init(|| Ok(100));","   assert_eq!(second_result, Ok(&42)); // Already initialized, should return 42","}"],[{"start_line":1157,"start_column":20,"end_line":1157,"end_column":31,"positive":true,"negative":true}]],[["{","    struct TestOnceCell {","        cell: OnceCell<i32>,","    }","","    impl TestOnceCell {","        fn new() -> Self {","            TestOnceCell {","                cell: OnceCell::new(),","            }","        }","        ","        fn fail_initialize(&self) -> Result<&i32, ()> {","            Err(())","        }","    }","","    let once_cell = TestOnceCell::new();","    assert!(once_cell.cell.get().is_none());","    ","   let result = once_cell.cell.get_or_try_init(|| once_cell.fail_initialize().map(|_| 0));","   assert_eq!(result, Err(())); // Initialization failed","    assert!(once_cell.cell.get().is_none());","}"],[{"start_line":1157,"start_column":20,"end_line":1157,"end_column":31,"positive":false,"negative":true}]],[["{","    struct TestOnceCell {","        cell: OnceCell<i32>,","    }","","    impl TestOnceCell {","        fn new() -> Self {","            TestOnceCell {","                cell: OnceCell::new(),","            }","        }","        ","        fn reentrant_init(&self) -> Result<i32, ()> {","            self.cell.get_or_try_init(|| self.reentrant_init()).map(|_| 0)","        }","    }","","    let once_cell = TestOnceCell::new();","    let _ = once_cell.cell.get_or_try_init(|| once_cell.reentrant_init());","}"],[{"start_line":1157,"start_column":20,"end_line":1157,"end_column":31,"positive":false,"negative":true}]]]}