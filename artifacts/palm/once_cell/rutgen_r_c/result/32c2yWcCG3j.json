{"function_name":"once_cell::race::race::OnceNonZeroUsize::get_unchecked","tests":2,"tests_lines":[45,36],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":21,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[68,70,73,80,81,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100],"codes_lines_covered":[[["{","    use core::num::NonZeroUsize;","    use core::sync::atomic::Ordering;","","    struct OnceNonZeroUsize {","        inner: AtomicUsize,","    }","","    impl OnceNonZeroUsize {","        pub const fn new() -> Self {","            Self { inner: AtomicUsize::new(0) }","        }","","        pub unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () =","                    assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","","        pub fn set(&self, value: NonZeroUsize) -> Result<(), ()> {","            self.inner.store(value.get(), Ordering::SeqCst);","            Ok(())","        }","    }","","    let once = OnceNonZeroUsize::new();","    let non_zero_value = NonZeroUsize::new(5).unwrap();","    once.set(non_zero_value).unwrap();","    ","    // The following should be safe as we ensure it is initialized","    unsafe {","        let result = once.get_unchecked();","        assert_eq!(result.get(), 5);","    }","}"],[]],[["{","    use core::num::NonZeroUsize;","","    struct OnceNonZeroUsize {","        inner: AtomicUsize,","    }","","    impl OnceNonZeroUsize {","        pub const fn new() -> Self {","            Self { inner: AtomicUsize::new(0) }","        }","","        pub unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () =","                    assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","    }","","    let once = OnceNonZeroUsize::new();","","    // The following should panic as we are trying to get an uninitialized value","    unsafe {","        let _ = once.get_unchecked();","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use core::num::NonZeroUsize;","    use core::sync::atomic::Ordering;","","    struct OnceNonZeroUsize {","        inner: AtomicUsize,","    }","","    impl OnceNonZeroUsize {","        pub const fn new() -> Self {","            Self { inner: AtomicUsize::new(0) }","        }","","        pub unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () =","                    assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","","        pub fn set(&self, value: NonZeroUsize) -> Result<(), ()> {","            self.inner.store(value.get(), Ordering::SeqCst);","            Ok(())","        }","    }","","    let once = OnceNonZeroUsize::new();","    let non_zero_value = NonZeroUsize::new(5).unwrap();","    once.set(non_zero_value).unwrap();","    ","    // The following should be safe as we ensure it is initialized","    unsafe {","        let result = once.get_unchecked();","        assert_eq!(result.get(), 5);","    }","}"],[]],[["{","    use core::num::NonZeroUsize;","","    struct OnceNonZeroUsize {","        inner: AtomicUsize,","    }","","    impl OnceNonZeroUsize {","        pub const fn new() -> Self {","            Self { inner: AtomicUsize::new(0) }","        }","","        pub unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () =","                    assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","    }","","    let once = OnceNonZeroUsize::new();","","    // The following should panic as we are trying to get an uninitialized value","    unsafe {","        let _ = once.get_unchecked();","    }","}"],[]]]}