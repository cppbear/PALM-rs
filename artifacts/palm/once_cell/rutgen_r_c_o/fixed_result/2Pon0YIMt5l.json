{"function_name":"once_cell::sync::_dummy","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/lib.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":11,"tests_lines":[24,26,25,28,24,25,25,25,24,25,26],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":3,"tests_compiled_rate":27.27272727272727,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":1,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1408],"codes_lines_covered":[[["   {  ","  #[should_panic]  ","  fn test_once_cell_sync_trait() {  ","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","      fn share<T: Sync>(_: &T) {}  ","      share(&OnceCell::<S>::new());  ","  }  ","  ","  #[should_panic]  ","  fn test_lazy_sync_trait() {  ","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","      fn share<T: Sync>(_: &T) {}  ","      share(&Lazy::<S>::new(|| unimplemented!()));  ","  }  ","      struct S(*mut ());  ","      unsafe impl Sync for S {}  ","      let once_cell = OnceCell::<S>::new();  ","      unsafe { once_cell.set(S(std::ptr::null_mut())); }  ","      // No assertion, just triggering the function call  ","      let once_cell = OnceCell::<S>::new();  ","}"],[]],[["{","  #[should_panic]","  fn test_once_cell_sync_trait() {","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","     fn share<T: Sync>(_: &T) {}","     share(&OnceCell::<S>::new());","  }","  ","  #[should_panic]","   fn test_lazy_sync_trait() {","      struct S(Box<()>);","      unsafe impl Sync for S {}","       ","       fn share<T: Sync>(_: &T) {}","       share(&Lazy::<S>::new(|| unimplemented!()));","   } ","      struct S(*mut ());","      unsafe impl Sync for S {}","      let once_cell = OnceCell::<S>::new();","      unsafe { once_cell.set(S(std::ptr::null_mut())); }","      // No assertion, just triggering the function call","      let lazy = Lazy::<S>::new(|| S(std::ptr::null_mut()));","}"],[]],[["{","  #[should_panic]","  fn test_once_cell_sync_trait() {","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","     fn share<T: Sync>(_: &T) {}","     share(&OnceCell::<S>::new());","  }","  ","  #[should_panic]","  fn test_lazy_sync_trait() {","    struct S(Box<()>,);  ","    // Box<()>'s ownership semantics ensure it is Send and Sync.  ","     ","     fn share<T: Sync>(_: &T) {}  ","     share(&Lazy::<S>::new(|| unimplemented!()));  ","  } "," struct S(*mut ());"," let mut once_cell = OnceCell::<S>::new();"," assert!(once_cell.set(S(std::ptr::null_mut())).is_ok());"," // Transitioning to initialized state"," let result = once_cell.get();"," assert!(result.is_some());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["   {  ","  #[should_panic]  ","  fn test_once_cell_sync_trait() {  ","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","      fn share<T: Sync>(_: &T) {}  ","      share(&OnceCell::<S>::new());  ","  }  ","  ","  #[should_panic]  ","  fn test_lazy_sync_trait() {  ","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","      fn share<T: Sync>(_: &T) {}  ","      share(&Lazy::<S>::new(|| unimplemented!()));  ","  }  ","      struct S(*mut ());  ","      unsafe impl Sync for S {}  ","      let once_cell = OnceCell::<S>::new();  ","      unsafe { once_cell.set(S(std::ptr::null_mut())); }  ","      // No assertion, just triggering the function call  ","      let once_cell = OnceCell::<S>::new();  ","}"],[]],[["{","  #[should_panic]","  fn test_once_cell_sync_trait() {","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","     fn share<T: Sync>(_: &T) {}","     share(&OnceCell::<S>::new());","  }","  ","  #[should_panic]","   fn test_lazy_sync_trait() {","      struct S(Box<()>);","      unsafe impl Sync for S {}","       ","       fn share<T: Sync>(_: &T) {}","       share(&Lazy::<S>::new(|| unimplemented!()));","   } ","      struct S(*mut ());","      unsafe impl Sync for S {}","      let once_cell = OnceCell::<S>::new();","      unsafe { once_cell.set(S(std::ptr::null_mut())); }","      // No assertion, just triggering the function call","      let lazy = Lazy::<S>::new(|| S(std::ptr::null_mut()));","}"],[]],[["{","  #[should_panic]","  fn test_once_cell_sync_trait() {","     struct S(Box<()>);","     unsafe impl Sync for S {}","     ","     fn share<T: Sync>(_: &T) {}","     share(&OnceCell::<S>::new());","  }","  ","  #[should_panic]","  fn test_lazy_sync_trait() {","    struct S(Box<()>,);  ","    // Box<()>'s ownership semantics ensure it is Send and Sync.  ","     ","     fn share<T: Sync>(_: &T) {}  ","     share(&Lazy::<S>::new(|| unimplemented!()));  ","  } "," struct S(*mut ());"," let mut once_cell = OnceCell::<S>::new();"," assert!(once_cell.set(S(std::ptr::null_mut())).is_ok());"," // Transitioning to initialized state"," let result = once_cell.get();"," assert!(result.is_some());","}"],[]]]}