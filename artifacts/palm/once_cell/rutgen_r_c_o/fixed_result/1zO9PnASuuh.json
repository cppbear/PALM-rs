{"function_name":"once_cell::unsync::unsync::OnceCell<T>::get_or_try_init","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/lib.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":30,"tests_lines":[7,7,7,7,7,7,7,9,9,8,8,11,13,13,11,11,25,11,11,7,7,7,10,10,7,7,7,36,37,38],"oracles":13,"oracles_compiled":11,"oracles_compiled_rate":84.61538461538461,"tests_compiled":24,"tests_compiled_rate":80.0,"oracles_run":11,"oracles_passed":9,"oracles_passed_rate":81.81818181818183,"tests_run":24,"tests_passed":20,"tests_passed_rate":83.33333333333334,"lines":11,"lines_covered":11,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[622,623,624,625,626,627,628,629,634,635,636],"codes_lines_covered":[[["{","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert!(cell.get().is_some());","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(cell.get(), Some(&42));","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell = OnceCell::new();  ","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   let cell = OnceCell::new();  ","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   assert_eq!(init_value, Ok(&42));  ","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert_eq!(result, Err(()));  ","}"],[622,623,624,625,626,628,629,636]],[["{","   let cell: OnceCell<Result<(), ()>> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   let cell: OnceCell<Result<(), ()>> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert!(cell.get().is_none());  ","}"],[622,623,624,625,626,628,629,636]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(result, Ok(&100));","}"],[622,623,624,625,626,627,636]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(cell.get(), Some(&100));","}"],[622,623,624,625,626,627,636]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());","   let cell = OnceCell::new();","   let result = cell.set(100);","   assert!(result.is_ok());","}"],[622,623,624,625,626,627,636]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());","   let cell = OnceCell::new();","   let result = cell.set(100);","   assert!(cell.get().is_some());","}"],[622,623,624,625,626,627,636]],[["{","   let cell = OnceCell::new();  ","   let _ = cell.set(100);  ","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());  ","   let cell = OnceCell::new();  ","   let result = cell.set(100);  ","   let panic_occurred = std::panic::catch_unwind(|| {  ","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());  ","   });  ","   assert!(panic_occurred.is_err());  ","}"],[622,623,624,625,626,627,636]],[["{","    // Initialize OnceCell with an existing value","    let cell = OnceCell::new();","    let _ = cell.set(42);","","    // Use a function that returns Ok with a new value","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   // This would normally not panic since the cell already has a value","   let cell = OnceCell::new();","   let _ = cell.set(42);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   assert_eq!(result, Ok(&42));","}"],[622,623,624,625,626,627,636]],[["{","   // Initialize OnceCell with an existing value","   let cell = OnceCell::new();","   let _ = cell.set(42);","","   // Use a function that returns Ok with a new value","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   // This would normally not panic since the cell already has a value","   let cell = OnceCell::new();","   let _ = cell.set(42);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   assert_eq!(cell.get(), Some(&42));","}"],[622,623,624,625,626,627,636]],[["{","    // Initialize OnceCell with no value","    let cell = OnceCell::new();","","    // Use a function that returns Ok","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   // This should succeed and initialize the cell with 99","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   assert_eq!(result, Ok(unsafe { cell.get().unwrap_unchecked() }));","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   // Initialize OnceCell with no value","   let cell = OnceCell::new();","","   // Use a function that returns Ok","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   // This should succeed and initialize the cell with 99","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   assert_eq!(cell.get(), Some(&99));","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","    // Initialize OnceCell with an existing value","    let cell = OnceCell::new();","    let _ = cell.set(42);","","    // Use a closure that also attempts to initialize","    let result = std::panic::catch_unwind(|| {","        cell.get_or_try_init(|| {","            cell.set(43).unwrap(); // Attempting to re-initialize","            Err(())","        })","    });","","    // Expect a panic due to reentrant initialization","    assert!(result.is_err());","    let cell = OnceCell::new();","    let _ = cell.set(42);","    let result = std::panic::catch_unwind(|| {","    cell.get_or_try_init(|| {","    cell.set(43).unwrap();","    Err(())","    })","    });","    assert!(result.is_err());","}"],[622,623,624,625,626,627,636]],[["{","   // Initialize OnceCell with no value  ","   let cell: OnceCell<()> = OnceCell::new();  "," ","   // Use a function that returns an error  ","   let result = cell.get_or_try_init(|| Err(()));  ","   // This will check for failed initialization  ","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert_eq!(result, Err(()));  ","}"],[622,623,624,625,626,628,629,636]],[["{","   // Initialize OnceCell with no value  ","   let cell: OnceCell<()> = OnceCell::new();  "," ","   // Use a function that returns an error  ","   let result = cell.get_or_try_init(|| Err(()));  ","   // This will check for failed initialization  ","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert!(cell.get().is_none());  ","}"],[622,623,624,625,626,628,629,636]],[["{","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   assert!(result.is_ok());  ","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(result.unwrap(), &42);","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(cell.get(), Some(&42));","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));  ","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));  ","   assert!(result.is_ok());  ","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));","   assert_eq!(result.unwrap(), &85);","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, Box<dyn std::error::Error>> = cell.get_or_try_init(|| Ok(85));","   let cell = OnceCell::new();","   let result: Result<&i32, Box<dyn std::error::Error>> = cell.get_or_try_init(|| Ok(85));","   assert_eq!(cell.get(), Some(&85));","}"],[622,623,624,625,626,628,629,634,635,636]],[["{","    struct FailingSet {","        count: usize,","    }","","    impl FailingSet {","        fn new() -> Self {","            FailingSet { count: 0 }","        }","    }","","    impl Deref for FailingSet {","        type Target = usize;","","        fn deref(&self) -> &Self::Target {","            &self.count","        }","    }","","    impl DerefMut for FailingSet {","        fn deref_mut(&mut self) -> &mut Self::Target {","            &mut self.count","        }","    }","","    let cell = OnceCell::new();","    ","    // Simulating failure on set call","    for val in 1..=1000 {","        let _result = cell.set(val); // should fail for all values in this range","    }","    ","   let _first_init: Result<&i32, ()> = cell.get_or_try_init(|| Ok(500));  ","","","}"],[622,623,624,625,626,627,636]]],"codes_branches":[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":true}],"codes_branches_covered":[[["{","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert!(cell.get().is_some());","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(cell.get(), Some(&42));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();  ","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   let cell = OnceCell::new();  ","   let init_value: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   assert_eq!(init_value, Ok(&42));  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert_eq!(result, Err(()));  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell: OnceCell<Result<(), ()>> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   let cell: OnceCell<Result<(), ()>> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert!(cell.get().is_none());  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(result, Ok(&100));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(cell.get(), Some(&100));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());","   let cell = OnceCell::new();","   let result = cell.set(100);","   assert!(result.is_ok());","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","   let cell = OnceCell::new();","   let _ = cell.set(100);","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());","   let cell = OnceCell::new();","   let result = cell.set(100);","   assert!(cell.get().is_some());","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","   let cell = OnceCell::new();  ","   let _ = cell.set(100);  ","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());  ","   let cell = OnceCell::new();  ","   let result = cell.set(100);  ","   let panic_occurred = std::panic::catch_unwind(|| {  ","   let _: Result<&i32, ()> = cell.get_or_try_init(|| panic!());  ","   });  ","   assert!(panic_occurred.is_err());  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","    // Initialize OnceCell with an existing value","    let cell = OnceCell::new();","    let _ = cell.set(42);","","    // Use a function that returns Ok with a new value","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   // This would normally not panic since the cell already has a value","   let cell = OnceCell::new();","   let _ = cell.set(42);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   assert_eq!(result, Ok(&42));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","   // Initialize OnceCell with an existing value","   let cell = OnceCell::new();","   let _ = cell.set(42);","","   // Use a function that returns Ok with a new value","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   // This would normally not panic since the cell already has a value","   let cell = OnceCell::new();","   let _ = cell.set(42);","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(92));","   assert_eq!(cell.get(), Some(&42));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","    // Initialize OnceCell with no value","    let cell = OnceCell::new();","","    // Use a function that returns Ok","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   // This should succeed and initialize the cell with 99","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   assert_eq!(result, Ok(unsafe { cell.get().unwrap_unchecked() }));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   // Initialize OnceCell with no value","   let cell = OnceCell::new();","","   // Use a function that returns Ok","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   // This should succeed and initialize the cell with 99","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(99));","   assert_eq!(cell.get(), Some(&99));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","    // Initialize OnceCell with an existing value","    let cell = OnceCell::new();","    let _ = cell.set(42);","","    // Use a closure that also attempts to initialize","    let result = std::panic::catch_unwind(|| {","        cell.get_or_try_init(|| {","            cell.set(43).unwrap(); // Attempting to re-initialize","            Err(())","        })","    });","","    // Expect a panic due to reentrant initialization","    assert!(result.is_err());","    let cell = OnceCell::new();","    let _ = cell.set(42);","    let result = std::panic::catch_unwind(|| {","    cell.get_or_try_init(|| {","    cell.set(43).unwrap();","    Err(())","    })","    });","    assert!(result.is_err());","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]],[["{","   // Initialize OnceCell with no value  ","   let cell: OnceCell<()> = OnceCell::new();  "," ","   // Use a function that returns an error  ","   let result = cell.get_or_try_init(|| Err(()));  ","   // This will check for failed initialization  ","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert_eq!(result, Err(()));  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   // Initialize OnceCell with no value  ","   let cell: OnceCell<()> = OnceCell::new();  "," ","   // Use a function that returns an error  ","   let result = cell.get_or_try_init(|| Err(()));  ","   // This will check for failed initialization  ","   let cell: OnceCell<()> = OnceCell::new();  ","   let result = cell.get_or_try_init(|| Err(()));  ","   assert!(cell.get().is_none());  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));  ","   assert!(result.is_ok());  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(result.unwrap(), &42);","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(42));","   assert_eq!(cell.get(), Some(&42));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));  ","   let cell = OnceCell::new();  ","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));  ","   assert!(result.is_ok());  ","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));","   let cell = OnceCell::new();","   let result: Result<&i32, ()> = cell.get_or_try_init(|| Ok(85));","   assert_eq!(result.unwrap(), &85);","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","   let cell = OnceCell::new();","   let result: Result<&i32, Box<dyn std::error::Error>> = cell.get_or_try_init(|| Ok(85));","   let cell = OnceCell::new();","   let result: Result<&i32, Box<dyn std::error::Error>> = cell.get_or_try_init(|| Ok(85));","   assert_eq!(cell.get(), Some(&85));","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":false,"negative":true}]],[["{","    struct FailingSet {","        count: usize,","    }","","    impl FailingSet {","        fn new() -> Self {","            FailingSet { count: 0 }","        }","    }","","    impl Deref for FailingSet {","        type Target = usize;","","        fn deref(&self) -> &Self::Target {","            &self.count","        }","    }","","    impl DerefMut for FailingSet {","        fn deref_mut(&mut self) -> &mut Self::Target {","            &mut self.count","        }","    }","","    let cell = OnceCell::new();","    ","    // Simulating failure on set call","    for val in 1..=1000 {","        let _result = cell.set(val); // should fail for all values in this range","    }","    ","   let _first_init: Result<&i32, ()> = cell.get_or_try_init(|| Ok(500));  ","","","}"],[{"start_line":626,"start_column":20,"end_line":626,"end_column":29,"positive":true,"negative":false}]]]}