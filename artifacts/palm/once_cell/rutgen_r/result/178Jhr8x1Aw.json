{"function_name":"once_cell::sync::sync::OnceCell<T>::try_insert","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/lib.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":3,"tests_lines":[37,10,13],"oracles":3,"oracles_compiled":1,"oracles_compiled_rate":33.33333333333333,"tests_compiled":1,"tests_compiled_rate":33.33333333333333,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":7,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1080,1081,1082,1083,1084,1085,1087],"codes_lines_covered":[[["{","    struct TestCell {","        value: Option<i32>,","    }","","    impl TestCell {","        fn new() -> Self {","            TestCell { value: None }","        }","","        fn get(&self) -> Option<&i32> {","            self.value.as_ref()","        }","","        fn try_insert(&mut self, value: i32) -> Result<&i32, (&i32, i32)> {","            if let Some(ref existing) = self.value {","                Err((existing, value))","            } else {","                self.value = Some(value);","                Ok(self.value.as_ref().unwrap())","            }","        }","    }","","    let mut cell = TestCell::new();","    ","    assert!(cell.get().is_none());","    ","    // First insertion should succeed","    assert_eq!(cell.try_insert(92), Ok(&92));","    ","    // Attempting a second insertion should fail and return the expected error","    assert_eq!(cell.try_insert(62), Err((&92, 62)));","    ","    // Verify that the value is still present in the cell","    assert!(cell.get().is_some());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestCell {","        value: Option<i32>,","    }","","    impl TestCell {","        fn new() -> Self {","            TestCell { value: None }","        }","","        fn get(&self) -> Option<&i32> {","            self.value.as_ref()","        }","","        fn try_insert(&mut self, value: i32) -> Result<&i32, (&i32, i32)> {","            if let Some(ref existing) = self.value {","                Err((existing, value))","            } else {","                self.value = Some(value);","                Ok(self.value.as_ref().unwrap())","            }","        }","    }","","    let mut cell = TestCell::new();","    ","    assert!(cell.get().is_none());","    ","    // First insertion should succeed","    assert_eq!(cell.try_insert(92), Ok(&92));","    ","    // Attempting a second insertion should fail and return the expected error","    assert_eq!(cell.try_insert(62), Err((&92, 62)));","    ","    // Verify that the value is still present in the cell","    assert!(cell.get().is_some());","}"],[]]]}