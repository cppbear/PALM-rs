{"function_name":"once_cell::race::race::OnceNonZeroUsize::get_unchecked","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/race.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":3,"tests_lines":[39,35,37],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":21,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[68,70,73,80,81,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100],"codes_lines_covered":[[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct InitializedCell {","        inner: AtomicUsize,","    }","","    impl InitializedCell {","        fn new(value: NonZeroUsize) -> Self {","            let cell = InitializedCell {","                inner: AtomicUsize::new(value.get()),","            };","            cell","        }","","        unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () = assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","    }","","    let non_zero_value = NonZeroUsize::new(42).unwrap();","    let cell = InitializedCell::new(non_zero_value);","","    let result = unsafe { cell.get_unchecked() };","    assert_eq!(result.get(), 42);","}"],[]],[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct UninitializedCell {","        inner: AtomicUsize,","    }","","    impl UninitializedCell {","        fn new() -> Self {","            UninitializedCell {","                inner: AtomicUsize::new(0),","            }","        }","","        unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () = assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) } // This will panic if val is 0","        }","    }","","    let cell = UninitializedCell::new();","","    let _result = unsafe { cell.get_unchecked() }; // Should panic here","}"],[]],[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct MaxValueCell {","        inner: AtomicUsize,","    }","","    impl MaxValueCell {","        fn new(value: NonZeroUsize) -> Self {","            MaxValueCell {","                inner: AtomicUsize::new(value.get()),","            }","        }","","        unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () = assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","    }","","    let max_value = NonZeroUsize::new(usize::MAX).unwrap();","    let cell = MaxValueCell::new(max_value);","","    let result = unsafe { cell.get_unchecked() };","    assert_eq!(result.get(), usize::MAX);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct InitializedCell {","        inner: AtomicUsize,","    }","","    impl InitializedCell {","        fn new(value: NonZeroUsize) -> Self {","            let cell = InitializedCell {","                inner: AtomicUsize::new(value.get()),","            };","            cell","        }","","        unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () = assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","    }","","    let non_zero_value = NonZeroUsize::new(42).unwrap();","    let cell = InitializedCell::new(non_zero_value);","","    let result = unsafe { cell.get_unchecked() };","    assert_eq!(result.get(), 42);","}"],[]],[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct UninitializedCell {","        inner: AtomicUsize,","    }","","    impl UninitializedCell {","        fn new() -> Self {","            UninitializedCell {","                inner: AtomicUsize::new(0),","            }","        }","","        unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () = assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) } // This will panic if val is 0","        }","    }","","    let cell = UninitializedCell::new();","","    let _result = unsafe { cell.get_unchecked() }; // Should panic here","}"],[]],[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct MaxValueCell {","        inner: AtomicUsize,","    }","","    impl MaxValueCell {","        fn new(value: NonZeroUsize) -> Self {","            MaxValueCell {","                inner: AtomicUsize::new(value.get()),","            }","        }","","        unsafe fn get_unchecked(&self) -> NonZeroUsize {","            #[inline(always)]","            fn as_const_ptr(r: &AtomicUsize) -> *const usize {","                use core::mem::align_of;","","                let p: *const AtomicUsize = r;","                const _ALIGNMENT_COMPATIBLE: () = assert!(align_of::<AtomicUsize>() % align_of::<usize>() == 0);","                p.cast::<usize>()","            }","","            let p = as_const_ptr(&self.inner);","            let val = unsafe { p.read() };","            unsafe { NonZeroUsize::new_unchecked(val) }","        }","    }","","    let max_value = NonZeroUsize::new(usize::MAX).unwrap();","    let cell = MaxValueCell::new(max_value);","","    let result = unsafe { cell.get_unchecked() };","    assert_eq!(result.get(), usize::MAX);","}"],[]]]}