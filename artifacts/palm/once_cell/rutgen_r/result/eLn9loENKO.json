{"function_name":"once_cell::race::once_box::race::once_box::OnceBox<T>::init","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/race.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":4,"tests_lines":[41,34,50,44],"oracles":4,"oracles_compiled":1,"oracles_compiled_rate":25.0,"tests_compiled":1,"tests_compiled_rate":25.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":15,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[462,463,464,465,466,467,468,469,470,471,472,473,474,475,476],"codes_lines_covered":[[["{","    struct TestWrapper {","        inner: std::sync::atomic::AtomicPtr<i32>,","    }","","    impl TestWrapper {","        fn new() -> Self {","            Self {","                inner: std::sync::atomic::AtomicPtr::new(std::ptr::null_mut()),","            }","        }","","        fn init<E>(&self, f: impl FnOnce() -> Result<Box<i32>, E>) -> Result<&i32, E> {","            let val = f()?;","            let mut ptr = Box::into_raw(val);","            let exchange = self.inner.compare_exchange(","                std::ptr::null_mut(),","                ptr,","                std::sync::atomic::Ordering::Release,","                std::sync::atomic::Ordering::Acquire,","            );","            if let Err(old) = exchange {","                drop(unsafe { Box::from_raw(ptr) });","                ptr = old;","            }","            Ok(unsafe { &*ptr })","        }","    }","","    let wrapper = TestWrapper::new();","    ","    // Triggers a panic since Result will be Err when None is returned.","    let _result = wrapper.init::<&'static str>(|| Err(\"error\"));","}"],[]]],"codes_branches":[{"start_line":471,"start_column":20,"end_line":471,"end_column":28,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestWrapper {","        inner: std::sync::atomic::AtomicPtr<i32>,","    }","","    impl TestWrapper {","        fn new() -> Self {","            Self {","                inner: std::sync::atomic::AtomicPtr::new(std::ptr::null_mut()),","            }","        }","","        fn init<E>(&self, f: impl FnOnce() -> Result<Box<i32>, E>) -> Result<&i32, E> {","            let val = f()?;","            let mut ptr = Box::into_raw(val);","            let exchange = self.inner.compare_exchange(","                std::ptr::null_mut(),","                ptr,","                std::sync::atomic::Ordering::Release,","                std::sync::atomic::Ordering::Acquire,","            );","            if let Err(old) = exchange {","                drop(unsafe { Box::from_raw(ptr) });","                ptr = old;","            }","            Ok(unsafe { &*ptr })","        }","    }","","    let wrapper = TestWrapper::new();","    ","    // Triggers a panic since Result will be Err when None is returned.","    let _result = wrapper.init::<&'static str>(|| Err(\"error\"));","}"],[{"start_line":471,"start_column":20,"end_line":471,"end_column":28,"positive":false,"negative":false}]]]}