{"function_name":"once_cell::sync::sync::OnceCell<T>::get","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/lib.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":3,"tests_lines":[28,29,29],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[963,964,966,968,970],"codes_lines_covered":[[["{","    struct TestCell<T>(Option<T>);","","    impl<T> TestCell<T> {","        fn new(value: T) -> Self {","            TestCell(Some(value))","        }","","        fn is_initialized(&self) -> bool {","            self.0.is_some()","        }","","        unsafe fn get_unchecked(&self) -> &T {","            self.0.as_ref().unwrap()","        }","","        fn get(&self) -> Option<&T> {","            if self.is_initialized() {","                Some(unsafe { self.get_unchecked() })","            } else {","                None","            }","        }","    }","","    let cell = TestCell::new(42);","    assert_eq!(cell.get(), Some(&42));","}"],[]],[["{","    struct TestCell<T>(Option<T>);","","    impl<T> TestCell<T> {","        fn new() -> Self {","            TestCell(None)","        }","","        fn is_initialized(&self) -> bool {","            self.0.is_some()","        }","","        unsafe fn get_unchecked(&self) -> &T {","            self.0.as_ref().unwrap() // This will trigger panic.","        }","","        fn get(&self) -> Option<&T> {","            if self.is_initialized() {","                Some(unsafe { self.get_unchecked() })","            } else {","                None","            }","        }","    }","","    let empty_cell: TestCell<i32> = TestCell::new();","    let _ = empty_cell.get(); // Should not panic, but gets None.","    // Attempting to call get_unchecked directly will panic.","}"],[]],[["{","    struct TestCell<T>(Option<T>);","","    impl<T> TestCell<T> {","        pub fn new() -> Self {","            TestCell(None)","        }","","        pub fn is_initialized(&self) -> bool {","            self.0.is_some()","        }","","        pub fn get_unchecked(&self) -> &T {","            self.0.as_ref().unwrap()","        }","","        pub fn get(&self) -> Option<&T> {","            if self.is_initialized() {","                Some(unsafe { self.get_unchecked() })","            } else {","                None","            }","        }","    }","","    let cell: TestCell<i32> = TestCell::new();","    let result = cell.get();","    assert!(result.is_none());","}"],[]]],"codes_branches":[{"start_line":964,"start_column":16,"end_line":964,"end_column":39,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestCell<T>(Option<T>);","","    impl<T> TestCell<T> {","        fn new(value: T) -> Self {","            TestCell(Some(value))","        }","","        fn is_initialized(&self) -> bool {","            self.0.is_some()","        }","","        unsafe fn get_unchecked(&self) -> &T {","            self.0.as_ref().unwrap()","        }","","        fn get(&self) -> Option<&T> {","            if self.is_initialized() {","                Some(unsafe { self.get_unchecked() })","            } else {","                None","            }","        }","    }","","    let cell = TestCell::new(42);","    assert_eq!(cell.get(), Some(&42));","}"],[{"start_line":964,"start_column":16,"end_line":964,"end_column":39,"positive":false,"negative":false}]],[["{","    struct TestCell<T>(Option<T>);","","    impl<T> TestCell<T> {","        fn new() -> Self {","            TestCell(None)","        }","","        fn is_initialized(&self) -> bool {","            self.0.is_some()","        }","","        unsafe fn get_unchecked(&self) -> &T {","            self.0.as_ref().unwrap() // This will trigger panic.","        }","","        fn get(&self) -> Option<&T> {","            if self.is_initialized() {","                Some(unsafe { self.get_unchecked() })","            } else {","                None","            }","        }","    }","","    let empty_cell: TestCell<i32> = TestCell::new();","    let _ = empty_cell.get(); // Should not panic, but gets None.","    // Attempting to call get_unchecked directly will panic.","}"],[{"start_line":964,"start_column":16,"end_line":964,"end_column":39,"positive":false,"negative":false}]],[["{","    struct TestCell<T>(Option<T>);","","    impl<T> TestCell<T> {","        pub fn new() -> Self {","            TestCell(None)","        }","","        pub fn is_initialized(&self) -> bool {","            self.0.is_some()","        }","","        pub fn get_unchecked(&self) -> &T {","            self.0.as_ref().unwrap()","        }","","        pub fn get(&self) -> Option<&T> {","            if self.is_initialized() {","                Some(unsafe { self.get_unchecked() })","            } else {","                None","            }","        }","    }","","    let cell: TestCell<i32> = TestCell::new();","    let result = cell.get();","    assert!(result.is_none());","}"],[{"start_line":964,"start_column":16,"end_line":964,"end_column":39,"positive":false,"negative":false}]]]}