{"function_name":"once_cell::race::race::OnceNonZeroUsize::compare_exchange","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/race.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":3,"tests_lines":[25,25,23],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":2,"oracles_passed_rate":66.66666666666666,"tests_run":3,"tests_passed":2,"tests_passed_rate":66.66666666666666,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[160,161,162],"codes_lines_covered":[[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","    ","    struct Inner {","        inner: AtomicUsize,","    }","","    impl Inner {","        fn new(value: usize) -> Self {","            Inner {","                inner: AtomicUsize::new(value),","            }","        }","","        fn compare_exchange(&self, val: NonZeroUsize) -> Result<usize, usize> {","            self.inner.compare_exchange(0, val.get(), Ordering::Release, Ordering::Acquire)","        }","    }","","    let inner = Inner::new(0);","    let non_zero_val = NonZeroUsize::new(42).unwrap();","    assert_eq!(inner.compare_exchange(non_zero_val), Ok(0));","    assert_eq!(inner.inner.load(Ordering::Acquire), 42);","}"],[]],[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct Inner {","        inner: AtomicUsize,","    }","","    impl Inner {","        fn new(value: usize) -> Self {","            Inner {","                inner: AtomicUsize::new(value),","            }","        }","","        fn compare_exchange(&self, val: NonZeroUsize) -> Result<usize, usize> {","            self.inner.compare_exchange(1, val.get(), Ordering::Release, Ordering::Acquire)","        }","    }","","    let inner = Inner::new(1);","    let non_zero_val = NonZeroUsize::new(42).unwrap();","    assert_eq!(inner.compare_exchange(non_zero_val), Err(1));","    assert_eq!(inner.inner.load(Ordering::Acquire), 1);","}"],[]],[["{","    use std::num::NonZeroUsize;","    ","    struct Inner {","        inner: std::sync::atomic::AtomicUsize,","    }","","    impl Inner {","        fn new(value: usize) -> Self {","            Inner {","                inner: std::sync::atomic::AtomicUsize::new(value),","            }","        }","","        fn compare_exchange(&self, val: NonZeroUsize) -> Result<usize, usize> {","            self.inner.compare_exchange(0, val.get(), std::sync::atomic::Ordering::Release, std::sync::atomic::Ordering::Acquire)","        }","    }","","    let inner = Inner::new(0);","    let _non_zero_val = NonZeroUsize::new(0).unwrap(); // This will cause a panic","    inner.compare_exchange(_non_zero_val);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","    ","    struct Inner {","        inner: AtomicUsize,","    }","","    impl Inner {","        fn new(value: usize) -> Self {","            Inner {","                inner: AtomicUsize::new(value),","            }","        }","","        fn compare_exchange(&self, val: NonZeroUsize) -> Result<usize, usize> {","            self.inner.compare_exchange(0, val.get(), Ordering::Release, Ordering::Acquire)","        }","    }","","    let inner = Inner::new(0);","    let non_zero_val = NonZeroUsize::new(42).unwrap();","    assert_eq!(inner.compare_exchange(non_zero_val), Ok(0));","    assert_eq!(inner.inner.load(Ordering::Acquire), 42);","}"],[]],[["{","    use std::num::NonZeroUsize;","    use std::sync::atomic::{AtomicUsize, Ordering};","","    struct Inner {","        inner: AtomicUsize,","    }","","    impl Inner {","        fn new(value: usize) -> Self {","            Inner {","                inner: AtomicUsize::new(value),","            }","        }","","        fn compare_exchange(&self, val: NonZeroUsize) -> Result<usize, usize> {","            self.inner.compare_exchange(1, val.get(), Ordering::Release, Ordering::Acquire)","        }","    }","","    let inner = Inner::new(1);","    let non_zero_val = NonZeroUsize::new(42).unwrap();","    assert_eq!(inner.compare_exchange(non_zero_val), Err(1));","    assert_eq!(inner.inner.load(Ordering::Acquire), 1);","}"],[]],[["{","    use std::num::NonZeroUsize;","    ","    struct Inner {","        inner: std::sync::atomic::AtomicUsize,","    }","","    impl Inner {","        fn new(value: usize) -> Self {","            Inner {","                inner: std::sync::atomic::AtomicUsize::new(value),","            }","        }","","        fn compare_exchange(&self, val: NonZeroUsize) -> Result<usize, usize> {","            self.inner.compare_exchange(0, val.get(), std::sync::atomic::Ordering::Release, std::sync::atomic::Ordering::Acquire)","        }","    }","","    let inner = Inner::new(0);","    let _non_zero_val = NonZeroUsize::new(0).unwrap(); // This will cause a panic","    inner.compare_exchange(_non_zero_val);","}"],[]]]}