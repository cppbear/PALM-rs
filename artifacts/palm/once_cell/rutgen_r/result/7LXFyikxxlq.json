{"function_name":"once_cell::race::race::OnceRef<'a, T>::get_or_try_init","file_path":"/home/abezbm/rust-utgen-test-crates-new/once_cell/src/race.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/once_cell","tests":4,"tests_lines":[31,33,42,42],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":8,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[299,300,301,302,303,304,305,307],"codes_lines_covered":[[["{","    struct Cell<'a>(&'a str);","    ","    impl<'a> Cell<'a> {","        fn get(&self) -> Option<&'a str> {","            Some(self.0)","        }","        ","        fn init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            f()","        }","        ","        fn get_or_try_init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match self.get() {","                Some(val) => Ok(val),","                None => self.init(f),","            }","        }","    }","","    let cell = Cell(\"Test value\");","    let result: Result<&str, &str> = cell.get_or_try_init(|| Ok(\"Initialized value\"));","","    assert_eq!(result, Ok(\"Test value\"));","}"],[]],[["{","    struct Cell<'a>(&'a str);","","    impl<'a> Cell<'a> {","        fn get(&self) -> Option<&'a str> {","            Some(self.0)","        }","        ","        fn init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            f()","        }","        ","        fn get_or_try_init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match self.get() {","                Some(val) => Ok(val),","                None => self.init(f),","            }","        }","    }","","    let cell = Cell(\"Concurrent Test value\");","    let result1: Result<&str, &str> = cell.get_or_try_init(|| Ok(\"Initialized value 1\"));","    let result2: Result<&str, &str> = cell.get_or_try_init(|| Ok(\"Initialized value 2\"));","","    assert_eq!(result1, Ok(\"Concurrent Test value\"));","    assert_eq!(result2, Ok(\"Concurrent Test value\"));","}"],[]],[["{","    struct TestCell<'a> {","        value: Option<&'a str>,","    }","","    impl<'a> TestCell<'a> {","        fn new() -> Self {","            TestCell { value: None }","        }","","        fn get(&self) -> Option<&'a str> {","            self.value","        }","","        fn init<F, E>(&mut self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match f() {","                Ok(val) => {","                    self.value = Some(val);","                    Ok(val)","                }","                Err(err) => Err(err),","            }","        }","","        fn get_or_try_init<F, E>(&mut self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match self.get() {","                Some(val) => Ok(val),","                None => self.init(f),","            }","        }","    }","","    let mut cell = TestCell::new();","    let result: Result<&str, &str> = cell.get_or_try_init(|| Err(\"Initialization Failed\"));","    assert_eq!(result, Err(\"Initialization Failed\"));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Cell<'a>(&'a str);","    ","    impl<'a> Cell<'a> {","        fn get(&self) -> Option<&'a str> {","            Some(self.0)","        }","        ","        fn init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            f()","        }","        ","        fn get_or_try_init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match self.get() {","                Some(val) => Ok(val),","                None => self.init(f),","            }","        }","    }","","    let cell = Cell(\"Test value\");","    let result: Result<&str, &str> = cell.get_or_try_init(|| Ok(\"Initialized value\"));","","    assert_eq!(result, Ok(\"Test value\"));","}"],[]],[["{","    struct Cell<'a>(&'a str);","","    impl<'a> Cell<'a> {","        fn get(&self) -> Option<&'a str> {","            Some(self.0)","        }","        ","        fn init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            f()","        }","        ","        fn get_or_try_init<F, E>(&self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match self.get() {","                Some(val) => Ok(val),","                None => self.init(f),","            }","        }","    }","","    let cell = Cell(\"Concurrent Test value\");","    let result1: Result<&str, &str> = cell.get_or_try_init(|| Ok(\"Initialized value 1\"));","    let result2: Result<&str, &str> = cell.get_or_try_init(|| Ok(\"Initialized value 2\"));","","    assert_eq!(result1, Ok(\"Concurrent Test value\"));","    assert_eq!(result2, Ok(\"Concurrent Test value\"));","}"],[]],[["{","    struct TestCell<'a> {","        value: Option<&'a str>,","    }","","    impl<'a> TestCell<'a> {","        fn new() -> Self {","            TestCell { value: None }","        }","","        fn get(&self) -> Option<&'a str> {","            self.value","        }","","        fn init<F, E>(&mut self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match f() {","                Ok(val) => {","                    self.value = Some(val);","                    Ok(val)","                }","                Err(err) => Err(err),","            }","        }","","        fn get_or_try_init<F, E>(&mut self, f: F) -> Result<&'a str, E>","        where","            F: FnOnce() -> Result<&'a str, E>,","        {","            match self.get() {","                Some(val) => Ok(val),","                None => self.init(f),","            }","        }","    }","","    let mut cell = TestCell::new();","    let result: Result<&str, &str> = cell.get_or_try_init(|| Err(\"Initialization Failed\"));","    assert_eq!(result, Err(\"Initialization Failed\"));","}"],[]]]}