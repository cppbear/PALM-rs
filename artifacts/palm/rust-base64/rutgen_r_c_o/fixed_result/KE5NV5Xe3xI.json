{"function_name":"base64::engine::general_purpose::decode::decode_helper","file_path":"/home/abezbm/rust-utgen-test-crates-new/rust-base64/src/engine/general_purpose/decode.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/rust-base64","tests":205,"tests_lines":[18,18,17,18,20,22,24,17,30,31,31,30,31,31,31,30,31,31,31,30,31,31,30,30,19,27,28,28,28,26,26,26,22,22,22,22,26,26,22,23,23,23,16,17,18,19,20,21,21,21,21,19,20,20,20,21,21,21,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,20,20,20,18,18,18,18,18,18,18,22,22,18,19,19,19,18,19,19,18,19,19,17,17,17,17,17,17,17,20,20,20,20,18,19,19,19,19,23,25,27,29,31,33,36,37,37,17,17,17,17,18,18,17,17,17,17,18,18,14,14,14,14,14,17,18,18,17,18,18,18,17,18,18,12,13,14,14,14,15,15],"oracles":43,"oracles_compiled":16,"oracles_compiled_rate":37.2093023255814,"tests_compiled":115,"tests_compiled_rate":56.09756097560976,"oracles_run":16,"oracles_passed":8,"oracles_passed_rate":50.0,"tests_run":115,"tests_passed":11,"tests_passed_rate":9.565217391304348,"lines":72,"lines_covered":44,"lines_coveraged_rate":61.111111111111114,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,112,113,114,115,116,117,118,119,120,121],"codes_lines_covered":[[["{","    let input: &[u8] = b\"\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 0 };","    let mut output = [0u8; 8];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","    let input: &[u8] = b\"\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 0 };","    let mut output = [0u8; 8];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,112,113,114,115,116,117,118,119,120,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['A' as usize], 0);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['B' as usize], 1);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['C' as usize], 2);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['D' as usize], 3);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['E' as usize], 4);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['F' as usize], 5);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['G' as usize], 6);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['H' as usize], 7);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['I' as usize], 8);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['J' as usize], 9);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['K' as usize], 10);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['L' as usize], 11);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['M' as usize], 12);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['N' as usize], 13);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['O' as usize], 14);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['P' as usize], 15);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['Q' as usize], 16);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['R' as usize], 17);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['S' as usize], 18);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['T' as usize], 19);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['U' as usize], 20);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['V' as usize], 21);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['W' as usize], 22);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['X' as usize], 23);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['Y' as usize], 24);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['Z' as usize], 25);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['a' as usize], 26);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['b' as usize], 27);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['c' as usize], 28);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['d' as usize], 29);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['e' as usize], 30);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['f' as usize], 31);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['g' as usize], 32);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['h' as usize], 33);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['i' as usize], 34);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['j' as usize], 35);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['k' as usize], 36);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['l' as usize], 37);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['m' as usize], 38);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['n' as usize], 39);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['o' as usize], 40);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['p' as usize], 41);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['q' as usize], 42);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['r' as usize], 43);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['s' as usize], 44);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['t' as usize], 45);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['u' as usize], 46);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['v' as usize], 47);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['w' as usize], 48);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['x' as usize], 49);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['y' as usize], 50);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['z' as usize], 51);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['0' as usize], 52);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['1' as usize], 53);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['2' as usize], 54);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['3' as usize], 55);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['4' as usize], 56);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['5' as usize], 57);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['6' as usize], 58);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['7' as usize], 59);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['8' as usize], 60);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['9' as usize], 61);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['+' as usize], 62);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['/' as usize], 63);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['=' as usize], INVALID_VALUE);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_helper(&input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::Indifferent), Ok(DecodeMetadata { decoded_len: 13, padding_offset: None }));","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();  ","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    assert_eq!(decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();  ","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    assert_eq!(output.len(), 13);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();  ","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    assert_eq!(output, b\"Hello, World!\");","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();  // No padding","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(decode_helper(&input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireNone).is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();  // No padding","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(output, b\"Hello, World\");","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();  // No padding","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(output.len() == 12);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_helper(&input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::Indifferent).is_ok(), true);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(output, b\"Some data.\");","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(output.len() == 12);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(input.len() % 4 == 0);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: Vec<u8> = b\"SGVsbG8@\".to_vec(); // Invalid character '@'","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 0 };","    let mut output = vec![0u8; 0]; ","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","","    // Populate the decode_table with values as needed for valid base64 decoding","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","    let input: Vec<u8> = b\"SGVsbG8@\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 0 };","    let mut output = vec![0u8; 0];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 10]; // Output too short","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","","    // Populate the decode_table with values as needed for valid base64 decoding","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 10];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[35,36,37,38,39,40,41,42,44,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 12);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.padding_offset, None);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\"; // \"So long a valid abulance\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\"; // \"So long a valid abulance\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 32);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\"; // \"So long a valid abulance\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert!(metadata.padding_offset.is_none());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // \"Hello\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // \"Hello\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert!(metadata.padding_offset.is_none());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_eq!(output.len(), 36);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_ne!(output[0], 0);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_ne!(output[1], 0);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_eq!(output[24], 0);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert!(output.iter().all(|&b| b != 0));","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 13);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.padding_offset, None);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert!(output[13..24].iter().all(|&b| b == 0));","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_invalid.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_small.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    assert!(result_trailing_invalid.is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    assert!(result_padding_invalid.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_invalid_byte.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_too_small.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";","    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_with_padding.is_ok());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";","    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata_with_padding = result_with_padding.unwrap();","    assert_eq!(metadata_with_padding.decoded_len, 13);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";","    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata_with_padding = result_with_padding.unwrap();","    assert_eq!(metadata_with_padding.padding_offset, Some(17));","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // Invalid Base64 (incomplete)","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err(), true);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // Invalid Base64 (incomplete)","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).unwrap_err(), DecodeSliceError::OutputSliceTooSmall);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12]; // Insufficient output buffer","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12]; // Insufficient output buffer","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(output, vec![0u8; 12]);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\"; // Invalid Base64 input with a bad byte","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\"; // Invalid Base64 input with a bad byte","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert_eq!(result.unwrap_err(), DecodeSliceError::DecodeError(DecodeError::InvalidByte(6, 0x38)));","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(output.len(), 24);","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(&output, b\"Hello World!\");","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,121]]],"codes_branches":[],"codes_branches_covered":[[["{","    let input: &[u8] = b\"\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 0 };","    let mut output = [0u8; 8];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","    let input: &[u8] = b\"\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 0 };","    let mut output = [0u8; 8];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['A' as usize], 0);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['B' as usize], 1);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['C' as usize], 2);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['D' as usize], 3);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['E' as usize], 4);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['F' as usize], 5);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['G' as usize], 6);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['H' as usize], 7);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['I' as usize], 8);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['J' as usize], 9);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['K' as usize], 10);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['L' as usize], 11);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['M' as usize], 12);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['N' as usize], 13);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['O' as usize], 14);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['P' as usize], 15);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['Q' as usize], 16);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['R' as usize], 17);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['S' as usize], 18);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['T' as usize], 19);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['U' as usize], 20);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['V' as usize], 21);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['W' as usize], 22);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['X' as usize], 23);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['Y' as usize], 24);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['Z' as usize], 25);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['a' as usize], 26);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['b' as usize], 27);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['c' as usize], 28);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['d' as usize], 29);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['e' as usize], 30);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['f' as usize], 31);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['g' as usize], 32);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['h' as usize], 33);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['i' as usize], 34);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['j' as usize], 35);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['k' as usize], 36);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['l' as usize], 37);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['m' as usize], 38);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['n' as usize], 39);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['o' as usize], 40);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['p' as usize], 41);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['q' as usize], 42);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['r' as usize], 43);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['s' as usize], 44);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['t' as usize], 45);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['u' as usize], 46);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['v' as usize], 47);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['w' as usize], 48);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['x' as usize], 49);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['y' as usize], 50);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['z' as usize], 51);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['0' as usize], 52);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['1' as usize], 53);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['2' as usize], 54);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['3' as usize], 55);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['4' as usize], 56);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['5' as usize], 57);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['6' as usize], 58);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['7' as usize], 59);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['8' as usize], 60);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['9' as usize], 61);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['+' as usize], 62);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['/' as usize], 63);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_table['=' as usize], INVALID_VALUE);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec(); // \"Hello, World!\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Initialize with appropriate decode table here","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_helper(&input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::Indifferent), Ok(DecodeMetadata { decoded_len: 13, padding_offset: None }));","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();  ","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    assert_eq!(decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();  ","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    assert_eq!(output.len(), 13);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();  ","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 13];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    assert_eq!(output, b\"Hello, World!\");","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();  // No padding","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(decode_helper(&input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireNone).is_ok());","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();  // No padding","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(output, b\"Hello, World\");","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();  // No padding","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxk\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(output.len() == 12);","}"],[]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(decode_helper(&input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::Indifferent).is_ok(), true);","}"],[]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert_eq!(output, b\"Some data.\");","}"],[]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(output.len() == 12);","}"],[]],[["{","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec(); // \"Some data.\" in base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","    ","    // Populate the decode_table with values as needed for valid base64 decoding","     ","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    ","    let _ = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: Vec<u8> = b\"U29tZSBkYXRhLg==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 12 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    assert!(input.len() % 4 == 0);","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8@\".to_vec(); // Invalid character '@'","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 0 };","    let mut output = vec![0u8; 0]; ","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; ","","    // Populate the decode_table with values as needed for valid base64 decoding","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","    let input: Vec<u8> = b\"SGVsbG8@\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 0 };","    let mut output = vec![0u8; 0];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[]],[["{","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 10]; // Output too short","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","","    // Populate the decode_table with values as needed for valid base64 decoding","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","    let input: Vec<u8> = b\"SGVsbG8sIFdvcmxkIQ==\".to_vec();","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 13 };","    let mut output = vec![0u8; 10];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(&input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 12);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.padding_offset, None);","}"],[]],[["{","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\"; // \"So long a valid abulance\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\"; // \"So long a valid abulance\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 32);","}"],[]],[["{","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\"; // \"So long a valid abulance\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U28gbG9uZyBhIHZhbGlkIGFidWxhbmNl\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 32 };","    let mut output = vec![0u8; 48];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert!(metadata.padding_offset.is_none());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // \"Hello\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // \"Hello\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 5 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert!(metadata.padding_offset.is_none());","}"],[]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok());","}"],[]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_eq!(output.len(), 36);","}"],[]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_ne!(output[0], 0);","}"],[]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_ne!(output[1], 0);","}"],[]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert_eq!(output[24], 0);","}"],[]],[["{","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\"; // \"Some long viilation!\"","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Fill with actual decode table data","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"U29tZSBsb25nIHZpbGF0aW9uIQ==\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 36];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","    assert!(output.iter().all(|&b| b != 0));","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 13);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert_eq!(metadata.padding_offset, None);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    assert!(output[13..24].iter().all(|&b| b == 0));","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_invalid.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_small.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    assert!(result_trailing_invalid.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    assert!(result_padding_invalid.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_invalid_byte.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_too_small.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";","    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result_with_padding.is_ok());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";","    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata_with_padding = result_with_padding.unwrap();","    assert_eq!(metadata_with_padding.decoded_len, 13);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata = result.unwrap();","    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";","    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output_invalid = vec![0u8; 24];","    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);","    let output_small: &mut [u8] = &mut [0u8; 5];","    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);","    let decode_allow_trailing_bits_invalid = true;","    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);","    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;","    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);","    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";","    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_too_small: &[u8] = b\"SGVs\";","    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";","    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let metadata_with_padding = result_with_padding.unwrap();","    assert_eq!(metadata_with_padding.padding_offset, Some(17));","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // Invalid Base64 (incomplete)","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err(), true);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8\"; // Invalid Base64 (incomplete)","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8\";","    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).unwrap_err(), DecodeSliceError::OutputSliceTooSmall);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12]; // Insufficient output buffer","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12]; // Insufficient output buffer","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 12];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(output, vec![0u8; 12]);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\"; // Invalid Base64 input with a bad byte","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\"; // Invalid Base64 input with a bad byte","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert_eq!(result.unwrap_err(), DecodeSliceError::DecodeError(DecodeError::InvalidByte(6, 0x38)));","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(output.len(), 24);","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);","    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };","    let mut output = vec![0u8; 24];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","    assert_eq!(&output, b\"Hello World!\");","}"],[]]]}