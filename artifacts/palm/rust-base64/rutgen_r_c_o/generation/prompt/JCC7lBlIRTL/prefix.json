{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. Omit test oracles and assertions; concentrate on generating test inputs and function calls of the focal function; do not use \"_\" for the return values of the focal function.\n3. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides.\n6. If the method under test uses generics, instantiate them with suitable types based on the context.\n7. Define any necessary helper structures or implementations directly within the test function when required.\n8. Create a minimal yet comprehensive set of test functions, ensuring each test input satisfies all given constraints, with some explicitly covering edge scenarios.\n9. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/write/encoder.rs\n// crate name is base64\nuse crate::engine::Engine;\nuse std::{cmp, fmt, io, io::{ErrorKind, Result}};\npub(crate) const BUF_SIZE: usize = 1024;\nconst MAX_INPUT_LEN: usize = BUF_SIZE / 4 * 3;\nconst MIN_ENCODE_CHUNK_SIZE: usize = 3;\npub trait Engine: Send + Sync {\n    type Config: Config;\n    type DecodeEstimate: DecodeEstimate;\n    fn internal_encode(&self, input: &[u8], output: &mut [u8]) -> usize;\n    fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate;\n    fn internal_decode(\n        &self,\n        input: &[u8],\n        output: &mut [u8],\n        decode_estimate: Self::DecodeEstimate,\n    ) -> Result<DecodeMetadata, DecodeSliceError>;\n    fn config(&self) -> &Self::Config;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn encode<T: AsRef<[u8]>>(&self, input: T) -> String;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn encode_string<T: AsRef<[u8]>>(&self, input: T, output_buf: &mut String);\n    #[cfg_attr(feature = \"alloc\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"alloc\"), doc = \"```ignore\")]\n    #[inline]\n    fn encode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output_buf: &mut [u8],\n    ) -> Result<usize, EncodeSliceError>;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn decode<T: AsRef<[u8]>>(&self, input: T) -> Result<Vec<u8>, DecodeError>;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn decode_vec<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        buffer: &mut Vec<u8>,\n    ) -> Result<(), DecodeError>;\n    #[inline]\n    fn decode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeSliceError>;\n    #[inline]\n    fn decode_slice_unchecked<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeError>;\n}\npub struct EncoderWriter<'e, E: Engine, W: io::Write> {\n    engine: &'e E,\n    /// Where encoded data is written to. It's an Option as it's None immediately before Drop is\n    /// called so that `finish()` can return the underlying writer. None implies that `finish()` has\n    /// been called successfully.\n    delegate: Option<W>,\n    /// Holds a partial chunk, if any, after the last `write()`, so that we may then fill the chunk\n    /// with the next `write()`, encode it, then proceed with the rest of the input normally.\n    extra_input: [u8; MIN_ENCODE_CHUNK_SIZE],\n    /// How much of `extra` is occupied, in `[0, MIN_ENCODE_CHUNK_SIZE]`.\n    extra_input_occupied_len: usize,\n    /// Buffer to encode into. May hold leftover encoded bytes from a previous write call that the underlying writer\n    /// did not write last time.\n    output: [u8; BUF_SIZE],\n    /// How much of `output` is occupied with encoded data that couldn't be written last time\n    output_occupied_len: usize,\n    /// panic safety: don't write again in destructor if writer panicked while we were writing to it\n    panicked: bool,\n}\nimpl<'e, E: Engine, W: io::Write> io::Write for EncoderWriter<'e, E, W> {\n    fn write(&mut self, input: &[u8]) -> Result<usize> {\n        assert!(self.delegate.is_some(), \"Cannot write more after calling finish()\");\n        if input.is_empty() {\n            return Ok(0);\n        }\n        if self.output_occupied_len > 0 {\n            let current_len = self.output_occupied_len;\n            return self.write_to_delegate(current_len).map(|()| 0);\n        }\n        debug_assert_eq!(0, self.output_occupied_len);\n        let mut extra_input_read_len = 0;\n        let mut input = input;\n        let orig_extra_len = self.extra_input_occupied_len;\n        let mut encoded_size = 0;\n        let mut max_input_len = MAX_INPUT_LEN;\n        if self.extra_input_occupied_len > 0 {\n            debug_assert!(self.extra_input_occupied_len < 3);\n            if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n                extra_input_read_len = MIN_ENCODE_CHUNK_SIZE\n                    - self.extra_input_occupied_len;\n                debug_assert!(extra_input_read_len > 0);\n                self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n                    .copy_from_slice(&input[0..extra_input_read_len]);\n                let len = self\n                    .engine\n                    .internal_encode(\n                        &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n                        &mut self.output[..],\n                    );\n                debug_assert_eq!(4, len);\n                input = &input[extra_input_read_len..];\n                self.extra_input_occupied_len = 0;\n                encoded_size = 4;\n                max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n            } else {\n                debug_assert_eq!(1, input.len());\n                debug_assert_eq!(1, self.extra_input_occupied_len);\n                self.extra_input[self.extra_input_occupied_len] = input[0];\n                self.extra_input_occupied_len += 1;\n                return Ok(1);\n            };\n        } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n            self.extra_input[0..input.len()].copy_from_slice(input);\n            self.extra_input_occupied_len = input.len();\n            return Ok(input.len());\n        }\n        debug_assert!(encoded_size == 0 || encoded_size == 4);\n        debug_assert!(\n            MAX_INPUT_LEN == max_input_len || MAX_INPUT_LEN == max_input_len +\n            MIN_ENCODE_CHUNK_SIZE\n        );\n        let input_complete_chunks_len = input.len()\n            - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n        let input_chunks_to_encode_len = cmp::min(\n            input_complete_chunks_len,\n            max_input_len,\n        );\n        debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n        debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n        encoded_size\n            += self\n                .engine\n                .internal_encode(\n                    &input[..(input_chunks_to_encode_len)],\n                    &mut self.output[encoded_size..],\n                );\n        self.write_to_delegate(encoded_size)\n            .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n            .map_err(|e| {\n                self.extra_input_occupied_len = orig_extra_len;\n                e\n            })\n    }\n    fn flush(&mut self) -> Result<()> {}\n}\nimpl<'e, E: Engine, W: io::Write> EncoderWriter<'e, E, W> {\n    pub fn new(delegate: W, engine: &'e E) -> EncoderWriter<'e, E, W> {}\n    pub fn finish(&mut self) -> Result<W> {}\n    fn write_final_leftovers(&mut self) -> Result<()> {}\n    fn write_to_delegate(&mut self, current_output_len: usize) -> Result<()> {\n        self.panicked = true;\n        let res = self\n            .delegate\n            .as_mut()\n            .expect(\"Writer must be present\")\n            .write(&self.output[..current_output_len]);\n        self.panicked = false;\n        res.map(|consumed| {\n            debug_assert!(consumed <= current_output_len);\n            if consumed < current_output_len {\n                self.output_occupied_len = current_output_len\n                    .checked_sub(consumed)\n                    .unwrap();\n                self.output.rotate_left(consumed);\n            } else {\n                self.output_occupied_len = 0;\n            }\n        })\n    }\n    fn write_all_encoded_output(&mut self) -> Result<()> {}\n    pub fn into_inner(mut self) -> W {}\n}\n\nThe function to be tested is presented as follows:\n/// Encode input and then write to the delegate writer.\n///\n/// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n/// of `input` consumed. The value may be `0`, which interacts poorly with `write_all`, which\n/// interprets `Ok(0)` as an error, despite it being allowed by the contract of `write`. See\n/// <https://github.com/rust-lang/rust/issues/56889> for more on that.\n///\n/// If the previous call to `write` provided more (encoded) data than the delegate writer could\n/// accept in a single call to its `write`, the remaining data is buffered. As long as buffered\n/// data is present, subsequent calls to `write` will try to write the remaining buffered data\n/// to the delegate and return either `Ok(0)` -- and therefore not consume any of `input` -- or\n/// an error.\n///\n/// # Errors\n///\n/// Any errors emitted by the delegate writer are returned.\nfn write(&mut self, input: &[u8]) -> Result<usize> {\n    assert!(\n        self.delegate.is_some(),\n        \"Cannot write more after calling finish()\"\n    );\n\n    if input.is_empty() {\n        return Ok(0);\n    }\n\n    // The contract of `Write::write` places some constraints on this implementation:\n    // - a call to `write()` represents at most one call to a wrapped `Write`, so we can't\n    // iterate over the input and encode multiple chunks.\n    // - Errors mean that \"no bytes were written to this writer\", so we need to reset the\n    // internal state to what it was before the error occurred\n\n    // before reading any input, write any leftover encoded output from last time\n    if self.output_occupied_len > 0 {\n        let current_len = self.output_occupied_len;\n        return self\n            .write_to_delegate(current_len)\n            // did not read any input\n            .map(|()| 0);\n    }\n\n    debug_assert_eq!(0, self.output_occupied_len);\n\n    // how many bytes, if any, were read into `extra` to create a triple to encode\n    let mut extra_input_read_len = 0;\n    let mut input = input;\n\n    let orig_extra_len = self.extra_input_occupied_len;\n\n    let mut encoded_size = 0;\n    // always a multiple of MIN_ENCODE_CHUNK_SIZE\n    let mut max_input_len = MAX_INPUT_LEN;\n\n    // process leftover un-encoded input from last write\n    if self.extra_input_occupied_len > 0 {\n        debug_assert!(self.extra_input_occupied_len < 3);\n        if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n            // Fill up `extra`, encode that into `output`, and consume as much of the rest of\n            // `input` as possible.\n            // We could write just the encoding of `extra` by itself but then we'd have to\n            // return after writing only 4 bytes, which is inefficient if the underlying writer\n            // would make a syscall.\n            extra_input_read_len = MIN_ENCODE_CHUNK_SIZE - self.extra_input_occupied_len;\n            debug_assert!(extra_input_read_len > 0);\n            // overwrite only bytes that weren't already used. If we need to rollback extra_len\n            // (when the subsequent write errors), the old leading bytes will still be there.\n            self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n                .copy_from_slice(&input[0..extra_input_read_len]);\n\n            let len = self.engine.internal_encode(\n                &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n                &mut self.output[..],\n            );\n            debug_assert_eq!(4, len);\n\n            input = &input[extra_input_read_len..];\n\n            // consider extra to be used up, since we encoded it\n            self.extra_input_occupied_len = 0;\n            // don't clobber where we just encoded to\n            encoded_size = 4;\n            // and don't read more than can be encoded\n            max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n\n        // fall through to normal encoding\n        } else {\n            // `extra` and `input` are non empty, but `|extra| + |input| < 3`, so there must be\n            // 1 byte in each.\n            debug_assert_eq!(1, input.len());\n            debug_assert_eq!(1, self.extra_input_occupied_len);\n\n            self.extra_input[self.extra_input_occupied_len] = input[0];\n            self.extra_input_occupied_len += 1;\n            return Ok(1);\n        };\n    } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n        // `extra` is empty, and `input` fits inside it\n        self.extra_input[0..input.len()].copy_from_slice(input);\n        self.extra_input_occupied_len = input.len();\n        return Ok(input.len());\n    };\n\n    // either 0 or 1 complete chunks encoded from extra\n    debug_assert!(encoded_size == 0 || encoded_size == 4);\n    debug_assert!(\n        // didn't encode extra input\n        MAX_INPUT_LEN == max_input_len\n            // encoded one triple\n            || MAX_INPUT_LEN == max_input_len + MIN_ENCODE_CHUNK_SIZE\n    );\n\n    // encode complete triples only\n    let input_complete_chunks_len = input.len() - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n    let input_chunks_to_encode_len = cmp::min(input_complete_chunks_len, max_input_len);\n    debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n    debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n\n    encoded_size += self.engine.internal_encode(\n        &input[..(input_chunks_to_encode_len)],\n        &mut self.output[encoded_size..],\n    );\n\n    // not updating `self.output_occupied_len` here because if the below write fails, it should\n    // \"never take place\" -- the buffer contents we encoded are ignored and perhaps retried\n    // later, if the consumer chooses.\n\n    self.write_to_delegate(encoded_size)\n        // no matter whether we wrote the full encoded buffer or not, we consumed the same\n        // input\n        .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n        .map_err(|e| {\n            // in case we filled and encoded `extra`, reset extra_len\n            self.extra_input_occupied_len = orig_extra_len;\n\n            e\n        })\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}