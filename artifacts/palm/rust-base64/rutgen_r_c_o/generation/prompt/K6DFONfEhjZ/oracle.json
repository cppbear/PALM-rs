{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/engine/general_purpose/mod.rs\n// crate name is base64\nuse crate::{\n    alphabet, alphabet::Alphabet, engine::{Config, DecodeMetadata, DecodePaddingMode},\n    DecodeSliceError,\n};\nuse core::convert::TryInto;\npub use decode::GeneralPurposeEstimate;\npub(crate) const INVALID_VALUE: u8 = 255;\npub const STANDARD: GeneralPurpose = GeneralPurpose::new(&alphabet::STANDARD, PAD);\npub const STANDARD_PAD_INDIFFERENT: GeneralPurpose = GeneralPurpose::new(\n    &alphabet::STANDARD,\n    PAD_INDIFFERENT,\n);\npub const STANDARD_NO_PAD: GeneralPurpose = GeneralPurpose::new(\n    &alphabet::STANDARD,\n    NO_PAD,\n);\npub const STANDARD_NO_PAD_INDIFFERENT: GeneralPurpose = GeneralPurpose::new(\n    &alphabet::STANDARD,\n    NO_PAD_INDIFFERENT,\n);\npub const URL_SAFE: GeneralPurpose = GeneralPurpose::new(&alphabet::URL_SAFE, PAD);\npub const URL_SAFE_PAD_INDIFFERENT: GeneralPurpose = GeneralPurpose::new(\n    &alphabet::URL_SAFE,\n    PAD_INDIFFERENT,\n);\npub const URL_SAFE_NO_PAD: GeneralPurpose = GeneralPurpose::new(\n    &alphabet::URL_SAFE,\n    NO_PAD,\n);\npub const URL_SAFE_NO_PAD_INDIFFERENT: GeneralPurpose = GeneralPurpose::new(\n    &alphabet::URL_SAFE,\n    NO_PAD_INDIFFERENT,\n);\npub const PAD: GeneralPurposeConfig = GeneralPurposeConfig::new();\npub const PAD_INDIFFERENT: GeneralPurposeConfig = GeneralPurposeConfig::new()\n    .with_encode_padding(true)\n    .with_decode_padding_mode(DecodePaddingMode::Indifferent);\npub const NO_PAD: GeneralPurposeConfig = GeneralPurposeConfig::new()\n    .with_encode_padding(false)\n    .with_decode_padding_mode(DecodePaddingMode::RequireNone);\npub const NO_PAD_INDIFFERENT: GeneralPurposeConfig = GeneralPurposeConfig::new()\n    .with_encode_padding(false)\n    .with_decode_padding_mode(DecodePaddingMode::Indifferent);\npub trait Config {\n    fn encode_padding(&self) -> bool;\n}\n#[derive(Clone, Copy, Debug)]\npub struct GeneralPurposeConfig {\n    encode_padding: bool,\n    decode_allow_trailing_bits: bool,\n    decode_padding_mode: DecodePaddingMode,\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum DecodePaddingMode {\n    /// Canonical padding is allowed, but any fewer padding bytes than that is also allowed.\n    Indifferent,\n    /// Padding must be canonical (0, 1, or 2 `=` as needed to produce a 4 byte suffix).\n    RequireCanonical,\n    /// Padding must be absent -- for when you want predictable padding, without any wasted bytes.\n    RequireNone,\n}\nimpl GeneralPurposeConfig {\n    #[must_use]\n    pub const fn new() -> Self {\n        Self {\n            encode_padding: true,\n            decode_allow_trailing_bits: false,\n            decode_padding_mode: DecodePaddingMode::RequireCanonical,\n        }\n    }\n    #[must_use]\n    pub const fn with_encode_padding(self, padding: bool) -> Self {\n        Self {\n            encode_padding: padding,\n            ..self\n        }\n    }\n    #[must_use]\n    pub const fn with_decode_allow_trailing_bits(self, allow: bool) -> Self {\n        Self {\n            decode_allow_trailing_bits: allow,\n            ..self\n        }\n    }\n    #[must_use]\n    pub const fn with_decode_padding_mode(self, mode: DecodePaddingMode) -> Self {\n        Self {\n            decode_padding_mode: mode,\n            ..self\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Create a new config based on `self` with an updated `padding` setting.\n///\n/// If `padding` is `true`, encoding will append either 1 or 2 `=` padding characters as needed\n/// to produce an output whose length is a multiple of 4.\n///\n/// Padding is not needed for correct decoding and only serves to waste bytes, but it's in the\n/// [spec](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2).\n///\n/// For new applications, consider not using padding if the decoders you're using don't require\n/// padding to be present.\npub const fn with_encode_padding(self, padding: bool) -> Self {\n    Self {\n        encode_padding: padding,\n        ..self\n    }\n}\n",
  "depend_pt": ""
}