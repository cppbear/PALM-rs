{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/write/encoder.rs\n// crate name is base64\nuse crate::engine::Engine;\nuse std::{cmp, fmt, io, io::{ErrorKind, Result}};\npub(crate) const BUF_SIZE: usize = 1024;\nconst MAX_INPUT_LEN: usize = BUF_SIZE / 4 * 3;\nconst MIN_ENCODE_CHUNK_SIZE: usize = 3;\npub trait Engine: Send + Sync {\n    type Config: Config;\n    type DecodeEstimate: DecodeEstimate;\n    fn internal_encode(&self, input: &[u8], output: &mut [u8]) -> usize;\n    fn internal_decoded_len_estimate(&self, input_len: usize) -> Self::DecodeEstimate;\n    fn internal_decode(\n        &self,\n        input: &[u8],\n        output: &mut [u8],\n        decode_estimate: Self::DecodeEstimate,\n    ) -> Result<DecodeMetadata, DecodeSliceError>;\n    fn config(&self) -> &Self::Config;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn encode<T: AsRef<[u8]>>(&self, input: T) -> String;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn encode_string<T: AsRef<[u8]>>(&self, input: T, output_buf: &mut String);\n    #[cfg_attr(feature = \"alloc\", doc = \"```\")]\n    #[cfg_attr(not(feature = \"alloc\"), doc = \"```ignore\")]\n    #[inline]\n    fn encode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output_buf: &mut [u8],\n    ) -> Result<usize, EncodeSliceError>;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn decode<T: AsRef<[u8]>>(&self, input: T) -> Result<Vec<u8>, DecodeError>;\n    #[cfg(any(feature = \"alloc\", test))]\n    #[inline]\n    fn decode_vec<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        buffer: &mut Vec<u8>,\n    ) -> Result<(), DecodeError>;\n    #[inline]\n    fn decode_slice<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeSliceError>;\n    #[inline]\n    fn decode_slice_unchecked<T: AsRef<[u8]>>(\n        &self,\n        input: T,\n        output: &mut [u8],\n    ) -> Result<usize, DecodeError>;\n}\npub struct EncoderWriter<'e, E: Engine, W: io::Write> {\n    engine: &'e E,\n    /// Where encoded data is written to. It's an Option as it's None immediately before Drop is\n    /// called so that `finish()` can return the underlying writer. None implies that `finish()` has\n    /// been called successfully.\n    delegate: Option<W>,\n    /// Holds a partial chunk, if any, after the last `write()`, so that we may then fill the chunk\n    /// with the next `write()`, encode it, then proceed with the rest of the input normally.\n    extra_input: [u8; MIN_ENCODE_CHUNK_SIZE],\n    /// How much of `extra` is occupied, in `[0, MIN_ENCODE_CHUNK_SIZE]`.\n    extra_input_occupied_len: usize,\n    /// Buffer to encode into. May hold leftover encoded bytes from a previous write call that the underlying writer\n    /// did not write last time.\n    output: [u8; BUF_SIZE],\n    /// How much of `output` is occupied with encoded data that couldn't be written last time\n    output_occupied_len: usize,\n    /// panic safety: don't write again in destructor if writer panicked while we were writing to it\n    panicked: bool,\n}\nimpl<'e, E: Engine, W: io::Write> EncoderWriter<'e, E, W> {\n    pub fn new(delegate: W, engine: &'e E) -> EncoderWriter<'e, E, W> {}\n    pub fn finish(&mut self) -> Result<W> {\n        assert!(self.delegate.is_some(), \"Encoder has already had finish() called\");\n        self.write_final_leftovers()?;\n        let writer = self.delegate.take().expect(\"Writer must be present\");\n        Ok(writer)\n    }\n    fn write_final_leftovers(&mut self) -> Result<()> {\n        if self.delegate.is_none() {\n            return Ok(());\n        }\n        self.write_all_encoded_output()?;\n        if self.extra_input_occupied_len > 0 {\n            let encoded_len = self\n                .engine\n                .encode_slice(\n                    &self.extra_input[..self.extra_input_occupied_len],\n                    &mut self.output[..],\n                )\n                .expect(\"buffer is large enough\");\n            self.output_occupied_len = encoded_len;\n            self.write_all_encoded_output()?;\n            self.extra_input_occupied_len = 0;\n        }\n        Ok(())\n    }\n    fn write_to_delegate(&mut self, current_output_len: usize) -> Result<()> {}\n    fn write_all_encoded_output(&mut self) -> Result<()> {}\n    pub fn into_inner(mut self) -> W {}\n}\n\nThe function to be tested is presented as follows:\n/// Encode all remaining buffered data and write it, including any trailing incomplete input\n/// triples and associated padding.\n///\n/// Once this succeeds, no further writes or calls to this method are allowed.\n///\n/// This may write to the delegate writer multiple times if the delegate writer does not accept\n/// all input provided to its `write` each invocation.\n///\n/// If you don't care about error handling, it is not necessary to call this function, as the\n/// equivalent finalization is done by the Drop impl.\n///\n/// Returns the writer that this was constructed around.\n///\n/// # Errors\n///\n/// The first error that is not of `ErrorKind::Interrupted` will be returned.\npub fn finish(&mut self) -> Result<W> {\n    // If we could consume self in finish(), we wouldn't have to worry about this case, but\n    // finish() is retryable in the face of I/O errors, so we can't consume here.\n    assert!(\n        self.delegate.is_some(),\n        \"Encoder has already had finish() called\"\n    );\n\n    self.write_final_leftovers()?;\n\n    let writer = self.delegate.take().expect(\"Writer must be present\");\n\n    Ok(writer)\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}