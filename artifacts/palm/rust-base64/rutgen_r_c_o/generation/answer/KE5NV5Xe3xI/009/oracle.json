[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
          "    let mut output = vec![0u8; 24];",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireNone;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracles": [
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert_eq!(metadata.decoded_len, 13);"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert_eq!(metadata.padding_offset, None);"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert_eq!(output[..13], b\"Hello World!\");"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert!(output[13..24].iter().all(|&b| b == 0));"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_invalid.is_err());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_small.is_err());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    assert!(result_trailing_invalid.is_ok());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    assert!(result_padding_invalid.is_err());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_invalid_byte.is_err());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_too_small.is_err());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";",
            "    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_with_padding.is_ok());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";",
            "    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata_with_padding = result_with_padding.unwrap();",
            "    assert_eq!(metadata_with_padding.decoded_len, 13);"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";",
            "    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata_with_padding = result_with_padding.unwrap();",
            "    assert_eq!(metadata_with_padding.padding_offset, Some(17));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert_eq!(metadata.decoded_len, 13);",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert_eq!(metadata.padding_offset, None);",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert_eq!(output[..13], b\"Hello World!\");",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    assert!(output[13..24].iter().all(|&b| b == 0));",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_invalid.is_err());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_small.is_err());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    assert!(result_trailing_invalid.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    assert!(result_padding_invalid.is_err());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_invalid_byte.is_err());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_too_small.is_err());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";",
            "    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result_with_padding.is_ok());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";",
            "    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata_with_padding = result_with_padding.unwrap();",
            "    assert_eq!(metadata_with_padding.decoded_len, 13);",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // \"Hello World!\" in Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata = result.unwrap();",
            "    let invalid_input: &[u8] = b\"SGVsbG8gV29ybGQ\";",
            "    let estimate_invalid = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output_invalid = vec![0u8; 24];",
            "    let result_invalid = decode_helper(invalid_input, &estimate_invalid, &mut output_invalid, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let output_small: &mut [u8] = &mut [0u8; 5];",
            "    let result_small = decode_helper(input, &estimate, output_small, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let decode_allow_trailing_bits_invalid = true;",
            "    let result_trailing_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits_invalid, padding_mode);",
            "    let padding_mode_invalid = DecodePaddingMode::RequireCanonical;",
            "    let result_padding_invalid = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode_invalid);",
            "    let input_invalid_byte: &[u8] = b\"SGVsbG8g#{V29ybGQh\";",
            "    let result_invalid_byte = decode_helper(input_invalid_byte, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_too_small: &[u8] = b\"SGVs\";",
            "    let result_too_small = decode_helper(input_too_small, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input_with_padding: &[u8] = b\"SGVsbG8gV29ybGQh=\";",
            "    let estimate_with_padding = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let result_with_padding = decode_helper(input_with_padding, &estimate_with_padding, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let metadata_with_padding = result_with_padding.unwrap();",
            "    assert_eq!(metadata_with_padding.padding_offset, Some(17));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"SGVsbG8\"; // Invalid Base64 (incomplete)",
          "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
          "    let mut output = vec![0u8; 24];",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireNone;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracles": [
          [
            "    let input: &[u8] = b\"SGVsbG8\";",
            "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err(), true);"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8\";",
            "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).unwrap_err(), DecodeSliceError::OutputSliceTooSmall);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8\"; // Invalid Base64 (incomplete)",
            "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8\";",
            "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err(), true);",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8\"; // Invalid Base64 (incomplete)",
            "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8\";",
            "    let estimate = GeneralPurposeEstimate { rem: 1, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).unwrap_err(), DecodeSliceError::OutputSliceTooSmall);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
          "    let mut output = vec![0u8; 12]; // Insufficient output buffer",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireNone;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracles": [
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 12];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 12];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(output, vec![0u8; 12]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 12]; // Insufficient output buffer",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 12];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_err());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 12]; // Insufficient output buffer",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 12];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(output, vec![0u8; 12]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\"; // Invalid Base64 input with a bad byte",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
          "    let mut output = vec![0u8; 24];",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
          "    let decode_allow_trailing_bits = false;",
          "    let padding_mode = DecodePaddingMode::RequireNone;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracles": [
          [
            "    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result.is_err());"
          ],
          [
            "    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert_eq!(result.unwrap_err(), DecodeSliceError::DecodeError(DecodeError::InvalidByte(6, 0x38)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\"; // Invalid Base64 input with a bad byte",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\"; // Invalid Base64 input with a bad byte",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbEG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = false;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    let result = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    assert_eq!(result.unwrap_err(), DecodeSliceError::DecodeError(DecodeError::InvalidByte(6, 0x38)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64",
          "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
          "    let mut output = vec![0u8; 24];",
          "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
          "    let decode_allow_trailing_bits = true;",
          "    let padding_mode = DecodePaddingMode::RequireNone;",
          "",
          "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
          "}"
        ],
        "oracles": [
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(output.len(), 24);"
          ],
          [
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(&output, b\"Hello World!\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(output.len(), 24);",
            "}"
          ],
          [
            "{",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\"; // Valid Base64",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Simplified decode table setup",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "",
            "    let _ = decode_helper(input, &estimate, &mut output, &decode_table, decode_allow_trailing_bits, padding_mode);",
            "    let input: &[u8] = b\"SGVsbG8gV29ybGQh\";",
            "    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 24 };",
            "    let mut output = vec![0u8; 24];",
            "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
            "    let decode_allow_trailing_bits = true;",
            "    let padding_mode = DecodePaddingMode::RequireNone;",
            "    assert_eq!(&output, b\"Hello World!\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]