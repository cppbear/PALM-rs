{"function_name":"base64::engine::general_purpose::decode::decode_chunk_8","tests":29,"tests_lines":[9,9,9,9,9,9,9,9,18,21,20,27,30,30,15,20,24,24,18,25,25,18,23,23,28,79,16,15,18],"oracles":29,"oracles_compiled":22,"oracles_compiled_rate":75.86206896551724,"tests_compiled":22,"tests_compiled_rate":75.86206896551724,"oracles_run":22,"oracles_passed":8,"oracles_passed_rate":36.36363636363637,"tests_run":22,"tests_passed":8,"tests_passed_rate":36.36363636363637,"lines":79,"lines_covered":67,"lines_coveraged_rate":84.81012658227847,"branches":16,"branches_covered":13,"branches_coverage_rate":81.25,"codes_lines":[174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252],"codes_lines_covered":[[["{","    let input: &[u8] = &[255, b'A', b'B', b'C', b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input, input[0])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: &[u8] = &[b'A', 255, b'B', b'C', b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 1, input[1])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: &[u8] = &[b'A', b'B', 255, b'C', b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 2, input[2])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', 255, b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 3, input[3])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', 255, b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 4, input[4])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', b'E', 255, b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 5, input[5])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', b'E', b'F', 255, b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 6, input[6])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', b'E', b'F', b'G', 255];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 7, input[7])));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, c) in b\"A-Za-z0-9+/\".iter().enumerate() {","            table[*c as usize] = i as u8;","        }","        table","    };","","    let input = b\"QUJDRE*\";  // '*' is an invalid byte for base64","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input[..8], 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(index, byte)) = result {","        assert_eq!(index, 6);","        assert_eq!(byte, b'*');","    } else {","        panic!(\"Expected invalid byte error\");","    }","}"],[]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, c) in b\"A-Za-z0-9+/\".iter().enumerate() {","            table[*c as usize] = i as u8;","        }","        table","    };","","    let input = b\"QUJDRE\";  // Length of input is less than required for full decode","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input[..6], 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidLength(len)) = result {","        assert_eq!(len, 6);","    } else {","        panic!(\"Expected invalid length error\");","    }","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: [u8; 8] = [0b000000, 0b000001, 0b000010, 0b000011, 0b000100, 0b000101, 0b000110, 0b000111]; // valid input symbols","    let index_at_start_of_input: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for i in 0..64 {","            table[i + 65] = i as u8; // A-Z, a-z, 0-9, +, /","        }","        table","    };","    let mut output: [u8; 6] = [0; 6];","    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);","    assert!(result.is_ok());","    assert_eq!(&output, &[0b00000001, 0b00000010, 0b00000011, 0b00000100, 0b00000101, 0b00000110]); // expected output","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let input: [u8; 8] = [0b000000, 0b000001, 0b000010, 0b111111, 0b000100, 0b000101, 0b000110, 0b000111]; // invalid 4th symbol","    let index_at_start_of_input: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for i in 0..64 {","            table[i + 65] = i as u8; // A-Z, a-z, 0-9, +, /","        }","        table","    };","    let mut output: [u8; 6] = [0; 6];","    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(offset, byte)) = result {","        assert_eq!(offset, index_at_start_of_input + 3);","        assert_eq!(byte, input[3]);","    } else {","        panic!(\"Unexpected result type\");","    }","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [0; 256];","        for i in 0..64 {","            table[i + b'A' as usize] = i as u8; // A-Z","        }","        for i in 0..26 {","            table[i + b'a' as usize + 26] = (i + 26) as u8; // a-z","        }","        for i in 0..10 {","            table[i + b'0' as usize + 52] = (i + 52) as u8; // 0-9","        }","        table[b'+' as usize] = 62; // +","        table[b'/' as usize] = 63; // /","        table","    };","    ","    let input: &[u8] = b\"ABCDEFGH\";","    let index_at_start_of_input = 0;","    let mut output = [0u8; 6];","    ","    assert_eq!(decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output), Ok(()));","    assert_eq!(&output, b\"\\xF0\\x00\\x00\\x00\\x00\\x00\");","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,228,229,230,231,232,237,238,239,240,241,246,247,248,249,250,251,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [0; 256];","        for i in 0..64 {","            table[i + b'A' as usize] = i as u8; // A-Z","        }","        for i in 0..26 {","            table[i + b'a' as usize + 26] = (i + 26) as u8; // a-z","        }","        for i in 0..10 {","            table[i + b'0' as usize + 52] = (i + 52) as u8; // 0-9","        }","        table[b'+' as usize] = 62; // +","        table[b'/' as usize] = 63; // /","        table","    };","    ","    let input: &[u8] = b\"ABCD$EFG\";","    let index_at_start_of_input = 4; // the index of the invalid byte ($)","    let mut output = [0u8; 6];","    ","    assert_eq!(decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output),","               Err(DecodeError::InvalidByte(index_at_start_of_input, input[4])));","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,228,229,230,231,232,237,238,239,240,241,246,247,248,249,250,251,252]],[["{","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H'];","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table","    };","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    assert!(result.is_ok());","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,228,229,230,231,232,237,238,239,240,241,246,247,248,249,250,251,252]],[["{","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'X', b'G', b'H']; // 'X' is invalid","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        // 'X' has no valid value","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table","    };","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(pos, byte)) = result {","        assert_eq!(pos, 5);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,224,225,226,227,252]],[["{","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'F', b'X', b'H']; // 'X' is invalid","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        // 'X' has no valid value","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table","    };","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(pos, byte)) = result {","        assert_eq!(pos, 6);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,228,229,230,231,232,233,234,235,236,252]],[["{","    let input: &[u8] = b\"ABCDEFGH\"; // All valid base64 characters","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        // Fill other base64 characters appropriately...","        table","    };","    ","    let mut output = [0u8; 6];","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    ","    assert!(result.is_ok());","    // Add more assertions here to check the values of output if necessary.","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,228,229,230,231,232,237,238,239,240,241,246,247,248,249,250,251,252]],[["{","    let input: &[u8] = b\"ABCDEFGX\"; // 'X' is invalid in the context of this decode table","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        // 'X' is left as INVALID_VALUE","        table","    };","    ","    let mut output = [0u8; 6];","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(offset, byte)) = result {","        assert_eq!(offset, 7);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected an InvalidByte error\");","    }","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,228,229,230,231,232,237,238,239,240,241,242,243,244,245,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assuming a simple mapping for the sake of this test","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","","    let input: &[u8] = b\"ABCDEFGH\";","    let index_at_start = 0;","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start, &decode_table, &mut output);","","    assert!(result.is_ok());","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,219,220,221,222,223,228,229,230,231,232,237,238,239,240,241,246,247,248,249,250,251,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assuming only some mappings for the sake of this test","        table[b'A' as usize] = 0;","        table","    };","","    let input: &[u8] = b\"@BCDEFGH\"; // '@' is invalid","    let index_at_start = 0;","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start, &decode_table, &mut output);","","    assert!(matches!(result, Err(DecodeError::InvalidByte(0, b'@'))));","}"],[174,175,176,177,178,179,180,181,182,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // Assume this is valid","        table","    };","","    let input: &[u8] = b\"ABCDE#GH\"; // '#' is invalid","    let index_at_start = 0;","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start, &decode_table, &mut output);","","    assert!(matches!(result, Err(DecodeError::InvalidByte(5, b'#'))));","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,188,189,190,191,252]]],"codes_branches":[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":true,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":true,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":true,"negative":true},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let input: &[u8] = &[255, b'A', b'B', b'C', b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input, input[0])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', 255, b'B', b'C', b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 1, input[1])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', 255, b'C', b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 2, input[2])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', 255, b'D', b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 3, input[3])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', 255, b'E', b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 4, input[4])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', b'E', 255, b'F', b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 5, input[5])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', b'E', b'F', 255, b'G'];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 6, input[6])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D', b'E', b'F', b'G', 255];","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All values set to INVALID_VALUE","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 7, input[7])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, c) in b\"A-Za-z0-9+/\".iter().enumerate() {","            table[*c as usize] = i as u8;","        }","        table","    };","","    let input = b\"QUJDRE*\";  // '*' is an invalid byte for base64","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input[..8], 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(index, byte)) = result {","        assert_eq!(index, 6);","        assert_eq!(byte, b'*');","    } else {","        panic!(\"Expected invalid byte error\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, c) in b\"A-Za-z0-9+/\".iter().enumerate() {","            table[*c as usize] = i as u8;","        }","        table","    };","","    let input = b\"QUJDRE\";  // Length of input is less than required for full decode","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input[..6], 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidLength(len)) = result {","        assert_eq!(len, 6);","    } else {","        panic!(\"Expected invalid length error\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: [u8; 8] = [0b000000, 0b000001, 0b000010, 0b000011, 0b000100, 0b000101, 0b000110, 0b000111]; // valid input symbols","    let index_at_start_of_input: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for i in 0..64 {","            table[i + 65] = i as u8; // A-Z, a-z, 0-9, +, /","        }","        table","    };","    let mut output: [u8; 6] = [0; 6];","    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);","    assert!(result.is_ok());","    assert_eq!(&output, &[0b00000001, 0b00000010, 0b00000011, 0b00000100, 0b00000101, 0b00000110]); // expected output","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: [u8; 8] = [0b000000, 0b000001, 0b000010, 0b111111, 0b000100, 0b000101, 0b000110, 0b000111]; // invalid 4th symbol","    let index_at_start_of_input: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for i in 0..64 {","            table[i + 65] = i as u8; // A-Z, a-z, 0-9, +, /","        }","        table","    };","    let mut output: [u8; 6] = [0; 6];","    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(offset, byte)) = result {","        assert_eq!(offset, index_at_start_of_input + 3);","        assert_eq!(byte, input[3]);","    } else {","        panic!(\"Unexpected result type\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [0; 256];","        for i in 0..64 {","            table[i + b'A' as usize] = i as u8; // A-Z","        }","        for i in 0..26 {","            table[i + b'a' as usize + 26] = (i + 26) as u8; // a-z","        }","        for i in 0..10 {","            table[i + b'0' as usize + 52] = (i + 52) as u8; // 0-9","        }","        table[b'+' as usize] = 62; // +","        table[b'/' as usize] = 63; // /","        table","    };","    ","    let input: &[u8] = b\"ABCDEFGH\";","    let index_at_start_of_input = 0;","    let mut output = [0u8; 6];","    ","    assert_eq!(decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output), Ok(()));","    assert_eq!(&output, b\"\\xF0\\x00\\x00\\x00\\x00\\x00\");","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":true},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":true}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [0; 256];","        for i in 0..64 {","            table[i + b'A' as usize] = i as u8; // A-Z","        }","        for i in 0..26 {","            table[i + b'a' as usize + 26] = (i + 26) as u8; // a-z","        }","        for i in 0..10 {","            table[i + b'0' as usize + 52] = (i + 52) as u8; // 0-9","        }","        table[b'+' as usize] = 62; // +","        table[b'/' as usize] = 63; // /","        table","    };","    ","    let input: &[u8] = b\"ABCD$EFG\";","    let index_at_start_of_input = 4; // the index of the invalid byte ($)","    let mut output = [0u8; 6];","    ","    assert_eq!(decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output),","               Err(DecodeError::InvalidByte(index_at_start_of_input, input[4])));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":true},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":true}]],[["{","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H'];","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table","    };","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    assert!(result.is_ok());","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":true},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":true}]],[["{","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'X', b'G', b'H']; // 'X' is invalid","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        // 'X' has no valid value","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table","    };","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(pos, byte)) = result {","        assert_eq!(pos, 5);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":true,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'F', b'X', b'H']; // 'X' is invalid","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        // 'X' has no valid value","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table","    };","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(pos, byte)) = result {","        assert_eq!(pos, 6);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":true,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"ABCDEFGH\"; // All valid base64 characters","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        // Fill other base64 characters appropriately...","        table","    };","    ","    let mut output = [0u8; 6];","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    ","    assert!(result.is_ok());","    // Add more assertions here to check the values of output if necessary.","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":true},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":true}]],[["{","    let input: &[u8] = b\"ABCDEFGX\"; // 'X' is invalid in the context of this decode table","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        // 'X' is left as INVALID_VALUE","        table","    };","    ","    let mut output = [0u8; 6];","    let result = decode_chunk_8(input, index_at_start_of_input, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(offset, byte)) = result {","        assert_eq!(offset, 7);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected an InvalidByte error\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":true},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":true,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assuming a simple mapping for the sake of this test","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","","    let input: &[u8] = b\"ABCDEFGH\";","    let index_at_start = 0;","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start, &decode_table, &mut output);","","    assert!(result.is_ok());","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":true},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":true},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":true},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":true}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assuming only some mappings for the sake of this test","        table[b'A' as usize] = 0;","        table","    };","","    let input: &[u8] = b\"@BCDEFGH\"; // '@' is invalid","    let index_at_start = 0;","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start, &decode_table, &mut output);","","    assert!(matches!(result, Err(DecodeError::InvalidByte(0, b'@'))));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":true,"negative":false},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // Assume this is valid","        table","    };","","    let input: &[u8] = b\"ABCDE#GH\"; // '#' is invalid","    let index_at_start = 0;","    let mut output = [0u8; 6];","","    let result = decode_chunk_8(input, index_at_start, &decode_table, &mut output);","","    assert!(matches!(result, Err(DecodeError::InvalidByte(5, b'#'))));","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":true,"negative":false},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":false},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]]]}