{"function_name":"base64::engine::general_purpose::decode::decode_chunk_4","tests":15,"tests_lines":[9,9,9,9,18,15,15,15,15,25,23,31,29,11,13],"oracles":15,"oracles_compiled":11,"oracles_compiled_rate":73.33333333333333,"tests_compiled":11,"tests_compiled_rate":73.33333333333333,"oracles_run":11,"oracles_passed":5,"oracles_passed_rate":45.45454545454545,"tests_run":11,"tests_passed":5,"tests_passed_rate":45.45454545454545,"lines":43,"lines_covered":43,"lines_coveraged_rate":100.0,"branches":8,"branches_covered":8,"branches_coverage_rate":100.0,"codes_lines":[256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298],"codes_lines_covered":[[["{","    let input: &[u8] = &[255, b'A', b'B', b'C']; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input, input[0])));","}"],[256,257,258,259,260,261,262,263,264,298]],[["{","    let input: &[u8] = &[b'A', 255, b'B', b'C']; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 1, input[1])));","}"],[256,257,258,259,260,261,262,263,264,298]],[["{","    let input: &[u8] = &[b'A', b'B', 255, b'C']; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 2, input[2])));","}"],[256,257,258,259,260,261,262,263,264,298]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', 255]; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 3, input[3])));","}"],[256,257,258,259,260,261,262,263,264,298]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assuming some valid Base64 mappings","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // .... Fill in the rest as needed","        table[b'/' as usize] = 63; // Example of a value for the last Base64 character","        table","    };","    let input = b\"ABCD\";","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Ok(()));","    assert_eq!(output, [0, 1, 2]); // Example of expected output based on valid input","}"],[256,257,258,259,260,261,262,263,265,266,267,268,269,274,275,276,277,278,283,284,285,286,287,292,293,294,295,296,297,298]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'A' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(0, b'A')));","}"],[256,257,258,259,260,261,262,263,264,298]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'A' as usize] = 0;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'B' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(1, b'B')));","}"],[256,257,258,259,260,261,262,263,265,266,267,268,269,270,271,272,273,298]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'D' as usize] = 3;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'C' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(2, b'C')));","}"],[256,257,258,259,260,261,262,263,265,266,267,268,269,274,275,276,277,278,279,280,281,282,298]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'D' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(3, b'D')));","}"],[256,257,258,259,260,261,262,263,265,266,267,268,269,274,275,276,277,278,283,284,285,286,287,288,289,290,291,298]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [0; 256];","        for i in 0..=25 {","            table[i + b'A' as usize] = i as u8; // A-Z","        }","        for i in 0..=25 {","            table[i + b'a' as usize] = (i + 26) as u8; // a-z","        }","        for i in 0..=9 {","            table[i + b'0' as usize] = (i + 52) as u8; // 0-9","        }","        table[b'+' as usize] = 62; // +","        table[b'/' as usize] = 63; // /","        table","    };","","    let input: &[u8] = &[b'A', b'B', b'C', b'X']; // X is not a valid Base64 character","    let index_at_start_of_input = 0;","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    ","    match result {","        Err(DecodeError::InvalidByte(offset, byte)) => {","            assert_eq!(offset, index_at_start_of_input + 3);","            assert_eq!(byte, b'X');","        },","        _ => panic!(\"Expected an InvalidByte error for input byte 'X'\"),","    }","}"],[256,257,258,259,260,261,262,263,265,266,267,268,269,274,275,276,277,278,283,284,285,286,287,292,293,294,295,296,297,298]],[["{","    let decode_table: [u8; 256] = [","        255; 256 // All initialized to INVALID_VALUE","    ];","","    let input: &[u8] = &[b'A', b'B', b'C', b'D'];","    let mut output = [0u8; 3];","    let index = 0;","","    let _ = decode_chunk_4(input, index, &decode_table, &mut output);","}"],[256,257,258,259,260,261,262,263,264,298]]],"codes_branches":[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":true,"negative":true},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":true,"negative":true},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":true,"negative":true},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let input: &[u8] = &[255, b'A', b'B', b'C']; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input, input[0])));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":true,"negative":false},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":false},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', 255, b'B', b'C']; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 1, input[1])));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":true,"negative":false},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":false},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', 255, b'C']; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 2, input[2])));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":true,"negative":false},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":false},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', 255]; // 255 is invalid, should return an error for this byte","    let index_at_start_of_input = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all to INVALID_VALUE","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(index_at_start_of_input + 3, input[3])));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":true,"negative":false},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":false},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assuming some valid Base64 mappings","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // .... Fill in the rest as needed","        table[b'/' as usize] = 63; // Example of a value for the last Base64 character","        table","    };","    let input = b\"ABCD\";","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Ok(()));","    assert_eq!(output, [0, 1, 2]); // Example of expected output based on valid input","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":false,"negative":true},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":true},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":true},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":true}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'A' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(0, b'A')));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":true,"negative":false},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":false},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'A' as usize] = 0;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'B' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(1, b'B')));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":false,"negative":true},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":true,"negative":false},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'D' as usize] = 3;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'C' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(2, b'C')));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":false,"negative":true},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":true},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":true,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Only mapping valid Base64 characters","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        // .... Fill in other characters","        table","    };","    let input = b\"ABCD\"; // 'D' is not valid","    let mut output = [0u8; 3];","    let result = decode_chunk_4(input, 0, &decode_table, &mut output);","    assert_eq!(result, Err(DecodeError::InvalidByte(3, b'D')));","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":false,"negative":true},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":true},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":true},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":true,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [0; 256];","        for i in 0..=25 {","            table[i + b'A' as usize] = i as u8; // A-Z","        }","        for i in 0..=25 {","            table[i + b'a' as usize] = (i + 26) as u8; // a-z","        }","        for i in 0..=9 {","            table[i + b'0' as usize] = (i + 52) as u8; // 0-9","        }","        table[b'+' as usize] = 62; // +","        table[b'/' as usize] = 63; // /","        table","    };","","    let input: &[u8] = &[b'A', b'B', b'C', b'X']; // X is not a valid Base64 character","    let index_at_start_of_input = 0;","    let mut output = [0u8; 3];","","    let result = decode_chunk_4(input, index_at_start_of_input, &decode_table, &mut output);","    ","    match result {","        Err(DecodeError::InvalidByte(offset, byte)) => {","            assert_eq!(offset, index_at_start_of_input + 3);","            assert_eq!(byte, b'X');","        },","        _ => panic!(\"Expected an InvalidByte error for input byte 'X'\"),","    }","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":false,"negative":true},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":true},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":true},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":true}]],[["{","    let decode_table: [u8; 256] = [","        255; 256 // All initialized to INVALID_VALUE","    ];","","    let input: &[u8] = &[b'A', b'B', b'C', b'D'];","    let mut output = [0u8; 3];","    let index = 0;","","    let _ = decode_chunk_4(input, index, &decode_table, &mut output);","}"],[{"start_line":263,"start_column":8,"end_line":263,"end_column":31,"positive":true,"negative":false},{"start_line":269,"start_column":8,"end_line":269,"end_column":31,"positive":false,"negative":false},{"start_line":278,"start_column":8,"end_line":278,"end_column":31,"positive":false,"negative":false},{"start_line":287,"start_column":8,"end_line":287,"end_column":31,"positive":false,"negative":false}]]]}