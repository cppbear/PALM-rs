{"function_name":"base64::engine::general_purpose::decode_suffix::decode_suffix","tests":47,"tests_lines":[15,15,15,10,10,82,11,14,83,78,83,86,81,20,29,26,29,27,30,30,20,17,35,29,35,15,13,18,18,31,25,32,28,29,31,30,30,32,31,31,32,28,33,13,11,20,21],"oracles":47,"oracles_compiled":33,"oracles_compiled_rate":70.2127659574468,"tests_compiled":33,"tests_compiled_rate":70.2127659574468,"oracles_run":33,"oracles_passed":8,"oracles_passed_rate":24.242424242424242,"tests_run":33,"tests_passed":8,"tests_passed_rate":24.242424242424242,"lines":98,"lines_covered":94,"lines_coveraged_rate":95.91836734693877,"branches":30,"branches_covered":23,"branches_coverage_rate":76.66666666666667,"codes_lines":[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,50,51,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,90,91,92,93,94,95,98,99,100,103,106,107,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,155,156,157,159,162],"codes_lines_covered":[[["{","    let input: &[u8] = b\"ABCD===\"; // 4 valid base64 symbols followed by invalid padding","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // small output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [","        INVALID_VALUE; 256 // using the invalid value for all bytes","    ];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(4, b'='))));","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = b\"ABCDxyz\"; // 4 valid symbols followed by invalid base64 symbols","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // small output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [","        INVALID_VALUE; 256 // all invalid for this case","    ];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(4, b'y'))));","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = b\"AB\"; // only 2 valid symbols which is insufficient","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // ensure we have a reasonable output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [","        INVALID_VALUE; 256 // same invalid setup","    ];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidLength(2))));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = &[0xFF, PAD_BYTE, PAD_BYTE, 0x00]; // 4 bytes, with padding at the start","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // empty decode table for testing","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, false, DecodePaddingMode::Indifferent);","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(1, PAD_BYTE))));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = &[PAD_BYTE, PAD_BYTE, 0xAC, 0x00]; // 4 bytes, with padding at the start","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // empty decode table for testing","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, false, DecodePaddingMode::Indifferent);","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(0, PAD_BYTE))));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,50,51,53,54,162]],[["{","    let input: &[u8] = b\"c3\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'a' as usize] = 0;","        table[b'b' as usize] = 1;","        table[b'c' as usize] = 2;","        table[b'd' as usize] = 3;","        table[b'e' as usize] = 4;","        table[b'f' as usize] = 5;","        table[b'g' as usize] = 6;","        table[b'h' as usize] = 7;","        table[b'i' as usize] = 8;","        table[b'j' as usize] = 9;","        table[b'k' as usize] = 10;","        table[b'l' as usize] = 11;","        table[b'm' as usize] = 12;","        table[b'n' as usize] = 13;","        table[b'o' as usize] = 14;","        table[b'p' as usize] = 15;","        table[b'q' as usize] = 16;","        table[b'r' as usize] = 17;","        table[b's' as usize] = 18;","        table[b't' as usize] = 19;","        table[b'u' as usize] = 20;","        table[b'v' as usize] = 21;","        table[b'w' as usize] = 22;","        table[b'x' as usize] = 23;","        table[b'y' as usize] = 24;","        table[b'z' as usize] = 25;","        table[b'A' as usize] = 26;","        table[b'B' as usize] = 27;","        table[b'C' as usize] = 28;","        table[b'D' as usize] = 29;","        table[b'E' as usize] = 30;","        table[b'F' as usize] = 31;","        table[b'G' as usize] = 32;","        table[b'H' as usize] = 33;","        table[b'I' as usize] = 34;","        table[b'J' as usize] = 35;","        table[b'K' as usize] = 36;","        table[b'L' as usize] = 37;","        table[b'M' as usize] = 38;","        table[b'N' as usize] = 39;","        table[b'O' as usize] = 40;","        table[b'P' as usize] = 41;","        table[b'Q' as usize] = 42;","        table[b'R' as usize] = 43;","        table[b'S' as usize] = 44;","        table[b'T' as usize] = 45;","        table[b'U' as usize] = 46;","        table[b'V' as usize] = 47;","        table[b'W' as usize] = 48;","        table[b'X' as usize] = 49;","        table[b'Y' as usize] = 50;","        table[b'Z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 2);","    assert!(metadata.padding_offset.is_none());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,99,162]],[["{","    let input: &[u8] = b\"c3==\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'a' as usize] = 0;","        table[b'b' as usize] = 1;","        table[b'c' as usize] = 2;","        table[b'd' as usize] = 3;","        table[b'e' as usize] = 4;","        table[b'f' as usize] = 5;","        table[b'g' as usize] = 6;","        table[b'h' as usize] = 7;","        table[b'i' as usize] = 8;","        table[b'j' as usize] = 9;","        table[b'k' as usize] = 10;","        table[b'l' as usize] = 11;","        table[b'm' as usize] = 12;","        table[b'n' as usize] = 13;","        table[b'o' as usize] = 14;","        table[b'p' as usize] = 15;","        table[b'q' as usize] = 16;","        table[b'r' as usize] = 17;","        table[b's' as usize] = 18;","        table[b't' as usize] = 19;","        table[b'u' as usize] = 20;","        table[b'v' as usize] = 21;","        table[b'w' as usize] = 22;","        table[b'x' as usize] = 23;","        table[b'y' as usize] = 24;","        table[b'z' as usize] = 25;","        table[b'A' as usize] = 26;","        table[b'B' as usize] = 27;","        table[b'C' as usize] = 28;","        table[b'D' as usize] = 29;","        table[b'E' as usize] = 30;","        table[b'F' as usize] = 31;","        table[b'G' as usize] = 32;","        table[b'H' as usize] = 33;","        table[b'I' as usize] = 34;","        table[b'J' as usize] = 35;","        table[b'K' as usize] = 36;","        table[b'L' as usize] = 37;","        table[b'M' as usize] = 38;","        table[b'N' as usize] = 39;","        table[b'O' as usize] = 40;","        table[b'P' as usize] = 41;","        table[b'Q' as usize] = 42;","        table[b'R' as usize] = 43;","        table[b'S' as usize] = 44;","        table[b'T' as usize] = 45;","        table[b'U' as usize] = 46;","        table[b'V' as usize] = 47;","        table[b'W' as usize] = 48;","        table[b'X' as usize] = 49;","        table[b'Y' as usize] = 50;","        table[b'Z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,100,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    let input: &[u8] = b\"c3\\xFF\"; // Trailing bits should be okay for this test","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'a' as usize] = 0;","        table[b'b' as usize] = 1;","        table[b'c' as usize] = 2;","        table[b'd' as usize] = 3;","        table[b'e' as usize] = 4;","        table[b'f' as usize] = 5;","        table[b'g' as usize] = 6;","        table[b'h' as usize] = 7;","        table[b'i' as usize] = 8;","        table[b'j' as usize] = 9;","        table[b'k' as usize] = 10;","        table[b'l' as usize] = 11;","        table[b'm' as usize] = 12;","        table[b'n' as usize] = 13;","        table[b'o' as usize] = 14;","        table[b'p' as usize] = 15;","        table[b'q' as usize] = 16;","        table[b'r' as usize] = 17;","        table[b's' as usize] = 18;","        table[b't' as usize] = 19;","        table[b'u' as usize] = 20;","        table[b'v' as usize] = 21;","        table[b'w' as usize] = 22;","        table[b'x' as usize] = 23;","        table[b'y' as usize] = 24;","        table[b'z' as usize] = 25;","        table[b'A' as usize] = 26;","        table[b'B' as usize] = 27;","        table[b'C' as usize] = 28;","        table[b'D' as usize] = 29;","        table[b'E' as usize] = 30;","        table[b'F' as usize] = 31;","        table[b'G' as usize] = 32;","        table[b'H' as usize] = 33;","        table[b'I' as usize] = 34;","        table[b'J' as usize] = 35;","        table[b'K' as usize] = 36;","        table[b'L' as usize] = 37;","        table[b'M' as usize] = 38;","        table[b'N' as usize] = 39;","        table[b'O' as usize] = 40;","        table[b'P' as usize] = 41;","        table[b'Q' as usize] = 42;","        table[b'R' as usize] = 43;","        table[b'S' as usize] = 44;","        table[b'T' as usize] = 45;","        table[b'U' as usize] = 46;","        table[b'V' as usize] = 47;","        table[b'W' as usize] = 48;","        table[b'X' as usize] = 49;","        table[b'Y' as usize] = 50;","        table[b'Z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 2);","    assert!(metadata.padding_offset.is_none());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    let input: &[u8] = b\"Y2F0\"; // Base64 for \"cat\" with no padding","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 3; // Assume we have already written 3 bytes","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Filling some values for simplicity (the real table must include all base64","        // characters mapped to their values)","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_ok());","    ","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 4); // Output index should be 4 after decoding `cat`","    assert!(metadata.padding_offset.is_none());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,162]],[["{","    let input: &[u8] = b\"Y2F0==\"; // Base64 for \"cat\" with non-canonical padding","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 2; // Assume we have already written 2 bytes","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Filling the decode table as before...","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = b\"Y2F0\"; // Base64 for \"cat\"","    let input_index = 0;","    let mut output = [0u8; 1]; // Output buffer too small","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Filling the decode table as before...","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        // ... continued for rest of base64 characters","        table","    };","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(matches!(result, Err(DecodeSliceError::OutputSliceTooSmall)));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D']; // Valid base64 input","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table // Add other values as needed for full coverage","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert_eq!(result, Ok(DecodeMetadata::new(4, None)));","    assert_eq!(output[0..4], [0, 1, 2, 3]); // Check the output values","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,155,156,159,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'@', b'D']; // Invalid base64 input with '@'","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table // Define decode table for valid characters only","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'=' ]; // Valid base64 with padding","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'=' as usize] = INVALID_VALUE;","        table // Define decode table adequately","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert_eq!(result, Ok(DecodeMetadata::new(3, Some(3)))); // Check return value","    assert_eq!(output[0..3], [0, 1, 2]); // Check the output values","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,100,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'=', b'=']; // Too much padding","    let input_index = 1;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table // Other valid characters should be added to the table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding)));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,100,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    let input: &[u8] = &[0x00, 0x01, 0x02, 0x03]; // Length is 4","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Fill parts of the decode table for valid base64 (for example)","        table[b'A' as usize] = 0; // Assuming 'A' decodes to 0","        table[b'B' as usize] = 1; // Assuming 'B' decodes to 1","        // ... continue filling for other valid characters","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(input_index + 0, 0x00))));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = &[0x80, 0x81, 0x82, 0x83]; // Length is 4","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Simulating that higher values are invalid","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(input_index + 0, 0x80))));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = &[];","    let input_index = 0;","    let mut output = [0u8; 0];","    let output_index = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // should be filled appropriately for real decoding","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,90,92,93,94,103,107,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,155,156,159,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'Z']; // Assuming 'Z' is invalid","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];","    decode_table[b'A' as usize] = 0; // Assuming 'A' decodes to 0","    decode_table[b'B' as usize] = 1; // Assuming 'B' decodes to 1","    decode_table[b'C' as usize] = 2; // Assuming 'C' decodes to 2","    // 'Z' remains INVALID_VALUE","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(3, b'Z'))));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'=', b'='];","    let input_index = 0;","    let mut output: [u8; 2] = [0; 2];","    let output_index = 0;","    let decode_table: [u8; 256] = { ","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(","        result,","        Err(DecodeSliceError::DecodeError(DecodeError::InvalidLength(","            input_index + 1","        )))","    );","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'Z', b'C'];","    let input_index = 0;","    let mut output: [u8; 2] = [0; 2];","    let output_index = 2; // Intentionally set to go out of bounds","    let decode_table: [u8; 256] = { ","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    // This should panic","    let _ = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    let input: &[u8] = &[b'A', b'B', b'C'];","    let input_index = 0;","    let mut output: [u8; 2] = [0; 2];","    let output_index = 0;","    let decode_table: [u8; 256] = { ","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(","        result,","        Err(DecodeSliceError::DecodeError(DecodeError::InvalidLength(","            input_index + 1","        )))","    );","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    let input: &[u8] = b\"ABCD==\"; // Invalid padding (two padding bytes)","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table","    };","    let decode_allow_trailing_bits: bool = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding)));","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'=']; // 4 bytes, last byte is padding","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // Fill decode table as needed","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding)));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,100,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    let input: &[u8] = b\"ABCD\"; // 4 bytes input","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assume A, B, C, D can be decoded to some values","        table[b'A' as usize] = 0; // Assume valid decoding value","        table[b'B' as usize] = 1; // Assume valid decoding value","        table[b'C' as usize] = 2; // Assume valid decoding value","        table[b'D' as usize] = 3; // Assume valid decoding value","        table","    };","    ","    let mut output = [0u8; 4];","    let input_index = 0;","    let output_index = 0;","    ","    // Set decode_allow_trailing_bits to false and padding_mode to Indifferent","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    // Add a last symbol that triggers the InvalidLastSymbol error.","    // Assuming D (3) last symbol has trailing bits set.","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert_eq!(","        result,","        Err(DecodeSliceError::DecodeError(DecodeError::InvalidLastSymbol(","            input_index + 2, // morsels_in_leftover is 2, thus input_index + morsels_in_leftover - 1 = 0 + 2","            b'D' // last_symbol is b'D'","        )))","    );","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,155,156,159,162]],[["{","    let input: &[u8] = &[65, 66, 67, 68]; // base64 encoded \"ABCD\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3]; // expects to decode 3 bytes.","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 3);","    assert!(metadata.padding_offset.is_none());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,155,156,159,162]],[["{","    let input: &[u8] = &[65, 66, 67, b'=']; // base64 encoded \"ABC=\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3]; // expects to decode 3 bytes.","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'=' as usize] = INVALID_VALUE; // treat '=' as padding","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 3);","    assert!(metadata.padding_offset.is_some());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    let input: &[u8] = &[65, 66, 255, 68]; // invalid byte 255","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3]; // expects to decode 3 bytes.","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","    if let DecodeSliceError::DecodeError(DecodeError::InvalidByte(offset, byte)) = result.unwrap_err() {","        assert_eq!(offset, 2);","        assert_eq!(byte, 255);","    }","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    let input: &[u8] = &[65]; // only one byte \"A\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","    if let DecodeSliceError::DecodeError(DecodeError::InvalidLength(offset)) = result.unwrap_err() {","        assert_eq!(offset, 1);","    }","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,91,162]],[["{","    let input: &[u8] = &[65, 66, 67, 68, b'=']; // \"ABCD=\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'=' as usize] = INVALID_VALUE; // treat '=' as padding","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","    if let DecodeSliceError::DecodeError(DecodeError::InvalidPadding) = result.unwrap_err() {","    } else {","        panic!(\"Expected an invalid padding error\");","    }","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = b\"testdata\"; // Length is greater than 4","    let input_index = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = b\"test==\"; // Trailing padding = ","    let input_index = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index = 0;","    let decode_table = {","        let mut dt = [INVALID_VALUE; 256];","        dt[b't' as usize] = 19; // valid value","        dt[b'e' as usize] = 4;  // valid value","        dt[b's' as usize] = 18; // valid value","        dt[b'=' as usize] = INVALID_VALUE; // This should trigger an invalid byte error","        dt","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = b\"AA==\"; // Valid base64 input","    let input_index = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index = 0;","    let decode_table = {","        let mut dt = [INVALID_VALUE; 256];","        dt[b'A' as usize] = 0; // valid value","        dt[b'=' as usize] = INVALID_VALUE; // padding character","        dt","    };","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 1);","    assert_eq!(metadata.padding_offset, Some(input_index + 2));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,155,156,157,162]]],"codes_branches":[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":true,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":true,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":true},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":true,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":true,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":true},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":true},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let input: &[u8] = b\"ABCD===\"; // 4 valid base64 symbols followed by invalid padding","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // small output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [","        INVALID_VALUE; 256 // using the invalid value for all bytes","    ];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(4, b'='))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"ABCDxyz\"; // 4 valid symbols followed by invalid base64 symbols","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // small output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [","        INVALID_VALUE; 256 // all invalid for this case","    ];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(4, b'y'))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"AB\"; // only 2 valid symbols which is insufficient","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // ensure we have a reasonable output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [","        INVALID_VALUE; 256 // same invalid setup","    ];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidLength(2))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[0xFF, PAD_BYTE, PAD_BYTE, 0x00]; // 4 bytes, with padding at the start","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // empty decode table for testing","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, false, DecodePaddingMode::Indifferent);","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(1, PAD_BYTE))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[PAD_BYTE, PAD_BYTE, 0xAC, 0x00]; // 4 bytes, with padding at the start","    let input_index: usize = 0;","    let mut output: [u8; 3] = [0; 3]; // output buffer","    let output_index: usize = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // empty decode table for testing","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, false, DecodePaddingMode::Indifferent);","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(0, PAD_BYTE))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":true,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":true,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"c3\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'a' as usize] = 0;","        table[b'b' as usize] = 1;","        table[b'c' as usize] = 2;","        table[b'd' as usize] = 3;","        table[b'e' as usize] = 4;","        table[b'f' as usize] = 5;","        table[b'g' as usize] = 6;","        table[b'h' as usize] = 7;","        table[b'i' as usize] = 8;","        table[b'j' as usize] = 9;","        table[b'k' as usize] = 10;","        table[b'l' as usize] = 11;","        table[b'm' as usize] = 12;","        table[b'n' as usize] = 13;","        table[b'o' as usize] = 14;","        table[b'p' as usize] = 15;","        table[b'q' as usize] = 16;","        table[b'r' as usize] = 17;","        table[b's' as usize] = 18;","        table[b't' as usize] = 19;","        table[b'u' as usize] = 20;","        table[b'v' as usize] = 21;","        table[b'w' as usize] = 22;","        table[b'x' as usize] = 23;","        table[b'y' as usize] = 24;","        table[b'z' as usize] = 25;","        table[b'A' as usize] = 26;","        table[b'B' as usize] = 27;","        table[b'C' as usize] = 28;","        table[b'D' as usize] = 29;","        table[b'E' as usize] = 30;","        table[b'F' as usize] = 31;","        table[b'G' as usize] = 32;","        table[b'H' as usize] = 33;","        table[b'I' as usize] = 34;","        table[b'J' as usize] = 35;","        table[b'K' as usize] = 36;","        table[b'L' as usize] = 37;","        table[b'M' as usize] = 38;","        table[b'N' as usize] = 39;","        table[b'O' as usize] = 40;","        table[b'P' as usize] = 41;","        table[b'Q' as usize] = 42;","        table[b'R' as usize] = 43;","        table[b'S' as usize] = 44;","        table[b'T' as usize] = 45;","        table[b'U' as usize] = 46;","        table[b'V' as usize] = 47;","        table[b'W' as usize] = 48;","        table[b'X' as usize] = 49;","        table[b'Y' as usize] = 50;","        table[b'Z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 2);","    assert!(metadata.padding_offset.is_none());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":true,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"c3==\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'a' as usize] = 0;","        table[b'b' as usize] = 1;","        table[b'c' as usize] = 2;","        table[b'd' as usize] = 3;","        table[b'e' as usize] = 4;","        table[b'f' as usize] = 5;","        table[b'g' as usize] = 6;","        table[b'h' as usize] = 7;","        table[b'i' as usize] = 8;","        table[b'j' as usize] = 9;","        table[b'k' as usize] = 10;","        table[b'l' as usize] = 11;","        table[b'm' as usize] = 12;","        table[b'n' as usize] = 13;","        table[b'o' as usize] = 14;","        table[b'p' as usize] = 15;","        table[b'q' as usize] = 16;","        table[b'r' as usize] = 17;","        table[b's' as usize] = 18;","        table[b't' as usize] = 19;","        table[b'u' as usize] = 20;","        table[b'v' as usize] = 21;","        table[b'w' as usize] = 22;","        table[b'x' as usize] = 23;","        table[b'y' as usize] = 24;","        table[b'z' as usize] = 25;","        table[b'A' as usize] = 26;","        table[b'B' as usize] = 27;","        table[b'C' as usize] = 28;","        table[b'D' as usize] = 29;","        table[b'E' as usize] = 30;","        table[b'F' as usize] = 31;","        table[b'G' as usize] = 32;","        table[b'H' as usize] = 33;","        table[b'I' as usize] = 34;","        table[b'J' as usize] = 35;","        table[b'K' as usize] = 36;","        table[b'L' as usize] = 37;","        table[b'M' as usize] = 38;","        table[b'N' as usize] = 39;","        table[b'O' as usize] = 40;","        table[b'P' as usize] = 41;","        table[b'Q' as usize] = 42;","        table[b'R' as usize] = 43;","        table[b'S' as usize] = 44;","        table[b'T' as usize] = 45;","        table[b'U' as usize] = 46;","        table[b'V' as usize] = 47;","        table[b'W' as usize] = 48;","        table[b'X' as usize] = 49;","        table[b'Y' as usize] = 50;","        table[b'Z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let _ = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"c3\\xFF\"; // Trailing bits should be okay for this test","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'a' as usize] = 0;","        table[b'b' as usize] = 1;","        table[b'c' as usize] = 2;","        table[b'd' as usize] = 3;","        table[b'e' as usize] = 4;","        table[b'f' as usize] = 5;","        table[b'g' as usize] = 6;","        table[b'h' as usize] = 7;","        table[b'i' as usize] = 8;","        table[b'j' as usize] = 9;","        table[b'k' as usize] = 10;","        table[b'l' as usize] = 11;","        table[b'm' as usize] = 12;","        table[b'n' as usize] = 13;","        table[b'o' as usize] = 14;","        table[b'p' as usize] = 15;","        table[b'q' as usize] = 16;","        table[b'r' as usize] = 17;","        table[b's' as usize] = 18;","        table[b't' as usize] = 19;","        table[b'u' as usize] = 20;","        table[b'v' as usize] = 21;","        table[b'w' as usize] = 22;","        table[b'x' as usize] = 23;","        table[b'y' as usize] = 24;","        table[b'z' as usize] = 25;","        table[b'A' as usize] = 26;","        table[b'B' as usize] = 27;","        table[b'C' as usize] = 28;","        table[b'D' as usize] = 29;","        table[b'E' as usize] = 30;","        table[b'F' as usize] = 31;","        table[b'G' as usize] = 32;","        table[b'H' as usize] = 33;","        table[b'I' as usize] = 34;","        table[b'J' as usize] = 35;","        table[b'K' as usize] = 36;","        table[b'L' as usize] = 37;","        table[b'M' as usize] = 38;","        table[b'N' as usize] = 39;","        table[b'O' as usize] = 40;","        table[b'P' as usize] = 41;","        table[b'Q' as usize] = 42;","        table[b'R' as usize] = 43;","        table[b'S' as usize] = 44;","        table[b'T' as usize] = 45;","        table[b'U' as usize] = 46;","        table[b'V' as usize] = 47;","        table[b'W' as usize] = 48;","        table[b'X' as usize] = 49;","        table[b'Y' as usize] = 50;","        table[b'Z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 2);","    assert!(metadata.padding_offset.is_none());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"Y2F0\"; // Base64 for \"cat\" with no padding","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 3; // Assume we have already written 3 bytes","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Filling some values for simplicity (the real table must include all base64","        // characters mapped to their values)","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_ok());","    ","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 4); // Output index should be 4 after decoding `cat`","    assert!(metadata.padding_offset.is_none());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"Y2F0==\"; // Base64 for \"cat\" with non-canonical padding","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 2; // Assume we have already written 2 bytes","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Filling the decode table as before...","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"Y2F0\"; // Base64 for \"cat\"","    let input_index = 0;","    let mut output = [0u8; 1]; // Output buffer too small","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Filling the decode table as before...","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        // ... continued for rest of base64 characters","        table","    };","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(matches!(result, Err(DecodeSliceError::OutputSliceTooSmall)));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'D']; // Valid base64 input","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table // Add other values as needed for full coverage","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert_eq!(result, Ok(DecodeMetadata::new(4, None)));","    assert_eq!(output[0..4], [0, 1, 2, 3]); // Check the output values","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":true}]],[["{","    let input: &[u8] = &[b'A', b'B', b'@', b'D']; // Invalid base64 input with '@'","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table // Define decode table for valid characters only","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'=' ]; // Valid base64 with padding","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'=' as usize] = INVALID_VALUE;","        table // Define decode table adequately","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert_eq!(result, Ok(DecodeMetadata::new(3, Some(3)))); // Check return value","    assert_eq!(output[0..3], [0, 1, 2]); // Check the output values","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'=', b'=']; // Too much padding","    let input_index = 1;","    let mut output = [0u8; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table // Other valid characters should be added to the table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding)));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[0x00, 0x01, 0x02, 0x03]; // Length is 4","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Fill parts of the decode table for valid base64 (for example)","        table[b'A' as usize] = 0; // Assuming 'A' decodes to 0","        table[b'B' as usize] = 1; // Assuming 'B' decodes to 1","        // ... continue filling for other valid characters","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(input_index + 0, 0x00))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[0x80, 0x81, 0x82, 0x83]; // Length is 4","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Simulating that higher values are invalid","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(input_index + 0, 0x80))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[];","    let input_index = 0;","    let mut output = [0u8; 0];","    let output_index = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // should be filled appropriately for real decoding","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":true},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":true},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":true},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":true}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'Z']; // Assuming 'Z' is invalid","    let input_index = 0;","    let mut output = [0u8; 4];","    let output_index = 0;","    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];","    decode_table[b'A' as usize] = 0; // Assuming 'A' decodes to 0","    decode_table[b'B' as usize] = 1; // Assuming 'B' decodes to 1","    decode_table[b'C' as usize] = 2; // Assuming 'C' decodes to 2","    // 'Z' remains INVALID_VALUE","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(3, b'Z'))));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'=', b'='];","    let input_index = 0;","    let mut output: [u8; 2] = [0; 2];","    let output_index = 0;","    let decode_table: [u8; 256] = { ","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(","        result,","        Err(DecodeSliceError::DecodeError(DecodeError::InvalidLength(","            input_index + 1","        )))","    );","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'Z', b'C'];","    let input_index = 0;","    let mut output: [u8; 2] = [0; 2];","    let output_index = 2; // Intentionally set to go out of bounds","    let decode_table: [u8; 256] = { ","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    // This should panic","    let _ = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C'];","    let input_index = 0;","    let mut output: [u8; 2] = [0; 2];","    let output_index = 0;","    let decode_table: [u8; 256] = { ","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(","        result,","        Err(DecodeSliceError::DecodeError(DecodeError::InvalidLength(","            input_index + 1","        )))","    );","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"ABCD==\"; // Invalid padding (two padding bytes)","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table","    };","    let decode_allow_trailing_bits: bool = true;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding)));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[b'A', b'B', b'C', b'=']; // 4 bytes, last byte is padding","    let input_index: usize = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index: usize = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        // Fill decode table as needed","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidPadding)));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"ABCD\"; // 4 bytes input","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assume A, B, C, D can be decoded to some values","        table[b'A' as usize] = 0; // Assume valid decoding value","        table[b'B' as usize] = 1; // Assume valid decoding value","        table[b'C' as usize] = 2; // Assume valid decoding value","        table[b'D' as usize] = 3; // Assume valid decoding value","        table","    };","    ","    let mut output = [0u8; 4];","    let input_index = 0;","    let output_index = 0;","    ","    // Set decode_allow_trailing_bits to false and padding_mode to Indifferent","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    // Add a last symbol that triggers the InvalidLastSymbol error.","    // Assuming D (3) last symbol has trailing bits set.","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert_eq!(","        result,","        Err(DecodeSliceError::DecodeError(DecodeError::InvalidLastSymbol(","            input_index + 2, // morsels_in_leftover is 2, thus input_index + morsels_in_leftover - 1 = 0 + 2","            b'D' // last_symbol is b'D'","        )))","    );","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":true}]],[["{","    let input: &[u8] = &[65, 66, 67, 68]; // base64 encoded \"ABCD\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3]; // expects to decode 3 bytes.","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 3);","    assert!(metadata.padding_offset.is_none());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":true}]],[["{","    let input: &[u8] = &[65, 66, 67, b'=']; // base64 encoded \"ABC=\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3]; // expects to decode 3 bytes.","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'=' as usize] = INVALID_VALUE; // treat '=' as padding","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 3);","    assert!(metadata.padding_offset.is_some());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[65, 66, 255, 68]; // invalid byte 255","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3]; // expects to decode 3 bytes.","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","    if let DecodeSliceError::DecodeError(DecodeError::InvalidByte(offset, byte)) = result.unwrap_err() {","        assert_eq!(offset, 2);","        assert_eq!(byte, 255);","    }","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[65]; // only one byte \"A\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","    if let DecodeSliceError::DecodeError(DecodeError::InvalidLength(offset)) = result.unwrap_err() {","        assert_eq!(offset, 1);","    }","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":true,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[65, 66, 67, 68, b'=']; // \"ABCD=\"","    let input_index = 0;","    let mut output: [u8; 3] = [0; 3];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'=' as usize] = INVALID_VALUE; // treat '=' as padding","        table","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","    if let DecodeSliceError::DecodeError(DecodeError::InvalidPadding) = result.unwrap_err() {","    } else {","        panic!(\"Expected an invalid padding error\");","    }","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"testdata\"; // Length is greater than 4","    let input_index = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index = 0;","    let decode_table: [u8; 256] = [INVALID_VALUE; 256];","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"test==\"; // Trailing padding = ","    let input_index = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index = 0;","    let decode_table = {","        let mut dt = [INVALID_VALUE; 256];","        dt[b't' as usize] = 19; // valid value","        dt[b'e' as usize] = 4;  // valid value","        dt[b's' as usize] = 18; // valid value","        dt[b'=' as usize] = INVALID_VALUE; // This should trigger an invalid byte error","        dt","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"AA==\"; // Valid base64 input","    let input_index = 0;","    let mut output: [u8; 4] = [0; 4];","    let output_index = 0;","    let decode_table = {","        let mut dt = [INVALID_VALUE; 256];","        dt[b'A' as usize] = 0; // valid value","        dt[b'=' as usize] = INVALID_VALUE; // padding character","        dt","    };","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert!(result.is_ok());","    let metadata = result.unwrap();","    assert_eq!(metadata.decoded_len, 1);","    assert_eq!(metadata.padding_offset, Some(input_index + 2));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":true},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":true,"negative":false}]]]}