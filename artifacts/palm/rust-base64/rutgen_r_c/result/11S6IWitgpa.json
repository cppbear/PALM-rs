{"function_name":"base64::encode::add_padding","tests":11,"tests_lines":[6,6,6,6,7,4,8,9,8,7,5],"oracles":11,"oracles_compiled":10,"oracles_compiled_rate":90.9090909090909,"tests_compiled":10,"tests_compiled_rate":90.9090909090909,"oracles_run":10,"oracles_passed":9,"oracles_passed_rate":90.0,"tests_run":10,"tests_passed":9,"tests_passed_rate":90.0,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[133,134,138,139,140,142,143],"codes_lines_covered":[[["{","    let mut output = [0u8; 4];","    let result = add_padding(4, &mut output);","    assert_eq!(result, 0);","    assert_eq!(output, [0, 0, 0, 0]);","}"],[133,134,138,142,143]],[["{","    let mut output = [0u8; 4];","    let result = add_padding(5, &mut output);","    assert_eq!(result, 3);","    assert_eq!(output, [PAD_BYTE, PAD_BYTE, PAD_BYTE, 0]);","}"],[133,134,138,139,140,142,143]],[["{","    let mut output = [0u8; 4];","    let result = add_padding(6, &mut output);","    assert_eq!(result, 2);","    assert_eq!(output, [PAD_BYTE, PAD_BYTE, 0, 0]);","}"],[133,134,138,139,140,142,143]],[["{","    let mut output = [0u8; 4];","    let result = add_padding(7, &mut output);","    assert_eq!(result, 1);","    assert_eq!(output, [PAD_BYTE, 0, 0, 0]);","}"],[133,134,138,139,140,142,143]],[["{","    // This test ensures we don't actually exceed the bounds of the given slice","    let mut output = [0u8; 2]; // Smaller than required","    let result = add_padding(2, &mut output);","    assert_eq!(result, 2); // We expect it to try writing 2 bytes","    assert_eq!(output, [PAD_BYTE, PAD_BYTE]); // Should pad it with two padding bytes","}"],[133,134,138,139,140,142,143]],[["{","    let mut output = []; // Empty output slice","    let _ = add_padding(2, &mut output); // This should panic as the buffer is insufficient","}"],[133,134,138,139,140]],[["{","    let unpadded_output_len = 0;","    let mut output = [0u8; 2];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 0);","    assert_eq!(output[0], PAD_BYTE);","    assert_eq!(output[1], 0);","}"],[133,134,138,142,143]],[["{","    let unpadded_output_len = 1;","    let mut output = [0u8; 3];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 3);","    assert_eq!(output[0], PAD_BYTE);","    assert_eq!(output[1], PAD_BYTE);","    assert_eq!(output[2], PAD_BYTE);","}"],[133,134,138,139,140,142,143]],[["{","    let unpadded_output_len = 2;","    let mut output = [0u8; 2];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 2);","    assert_eq!(output[0], PAD_BYTE);","    assert_eq!(output[1], PAD_BYTE);","}"],[133,134,138,139,140,142,143]],[["{","    let unpadded_output_len = 3;","    let mut output = [0u8; 1];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 1);","    assert_eq!(output[0], PAD_BYTE);","}"],[133,134,138,139,140,142,143]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut output = [0u8; 4];","    let result = add_padding(4, &mut output);","    assert_eq!(result, 0);","    assert_eq!(output, [0, 0, 0, 0]);","}"],[]],[["{","    let mut output = [0u8; 4];","    let result = add_padding(5, &mut output);","    assert_eq!(result, 3);","    assert_eq!(output, [PAD_BYTE, PAD_BYTE, PAD_BYTE, 0]);","}"],[]],[["{","    let mut output = [0u8; 4];","    let result = add_padding(6, &mut output);","    assert_eq!(result, 2);","    assert_eq!(output, [PAD_BYTE, PAD_BYTE, 0, 0]);","}"],[]],[["{","    let mut output = [0u8; 4];","    let result = add_padding(7, &mut output);","    assert_eq!(result, 1);","    assert_eq!(output, [PAD_BYTE, 0, 0, 0]);","}"],[]],[["{","    // This test ensures we don't actually exceed the bounds of the given slice","    let mut output = [0u8; 2]; // Smaller than required","    let result = add_padding(2, &mut output);","    assert_eq!(result, 2); // We expect it to try writing 2 bytes","    assert_eq!(output, [PAD_BYTE, PAD_BYTE]); // Should pad it with two padding bytes","}"],[]],[["{","    let mut output = []; // Empty output slice","    let _ = add_padding(2, &mut output); // This should panic as the buffer is insufficient","}"],[]],[["{","    let unpadded_output_len = 0;","    let mut output = [0u8; 2];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 0);","    assert_eq!(output[0], PAD_BYTE);","    assert_eq!(output[1], 0);","}"],[]],[["{","    let unpadded_output_len = 1;","    let mut output = [0u8; 3];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 3);","    assert_eq!(output[0], PAD_BYTE);","    assert_eq!(output[1], PAD_BYTE);","    assert_eq!(output[2], PAD_BYTE);","}"],[]],[["{","    let unpadded_output_len = 2;","    let mut output = [0u8; 2];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 2);","    assert_eq!(output[0], PAD_BYTE);","    assert_eq!(output[1], PAD_BYTE);","}"],[]],[["{","    let unpadded_output_len = 3;","    let mut output = [0u8; 1];","    let result = add_padding(unpadded_output_len, &mut output);","    assert_eq!(result, 1);","    assert_eq!(output[0], PAD_BYTE);","}"],[]]]}