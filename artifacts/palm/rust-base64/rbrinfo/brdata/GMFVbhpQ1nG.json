{
  "name": "base64::alphabet::alphabet::Alphabet::new",
  "name_with_impl": "base64::alphabet::{impl#0}::new",
  "mod_info": {
    "name": "alphabet",
    "loc": "src/lib.rs:284:1:284:18"
  },
  "visible": true,
  "loc": "src/alphabet.rs:79:5:125:6",
  "doc": "/// Create an `Alphabet` from a string of 64 unique printable ASCII bytes.\n///\n/// The `=` byte is not allowed as it is used for padding.\n",
  "code": [
    "pub const fn new(alphabet: &str) -> Result<Self, ParseAlphabetError> {",
    "    let bytes = alphabet.as_bytes();",
    "    if bytes.len() != ALPHABET_SIZE {",
    "        return Err(ParseAlphabetError::InvalidLength);",
    "    }",
    "",
    "    {",
    "        let mut index = 0;",
    "        while index < ALPHABET_SIZE {",
    "            let byte = bytes[index];",
    "",
    "            // must be ascii printable. 127 (DEL) is commonly considered printable",
    "            // for some reason but clearly unsuitable for base64.",
    "            if !(byte >= 32_u8 && byte <= 126_u8) {",
    "                return Err(ParseAlphabetError::UnprintableByte(byte));",
    "            }",
    "            // = is assumed to be padding, so cannot be used as a symbol",
    "            if byte == PAD_BYTE {",
    "                return Err(ParseAlphabetError::ReservedByte(byte));",
    "            }",
    "",
    "            // Check for duplicates while staying within what const allows.",
    "            // It's n^2, but only over 64 hot bytes, and only once, so it's likely in the single digit",
    "            // microsecond range.",
    "",
    "            let mut probe_index = 0;",
    "            while probe_index < ALPHABET_SIZE {",
    "                if probe_index == index {",
    "                    probe_index += 1;",
    "                    continue;",
    "                }",
    "",
    "                let probe_byte = bytes[probe_index];",
    "",
    "                if byte == probe_byte {",
    "                    return Err(ParseAlphabetError::DuplicatedByte(byte));",
    "                }",
    "",
    "                probe_index += 1;",
    "            }",
    "",
    "            index += 1;",
    "        }",
    "    }",
    "",
    "    Ok(Self::from_str_unchecked(alphabet))",
    "}"
  ],
  "size": {
    "chain": 9,
    "contra": 3,
    "min_set": 8
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "true",
          "line": 81,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Err(ParseAlphabetError::InvalidLength)",
      "path": [
        0,
        1,
        2,
        3,
        31,
        32
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte >= 32_u8",
          "norm": "32_u8 <= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 32_u8",
          "may_panic": false
        },
        {
          "cond": "byte <= 126_u8",
          "norm": "126_u8 >= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 126_u8",
          "may_panic": false
        },
        {
          "cond": "byte == PAD_BYTE",
          "norm": "PAD_BYTE == byte",
          "value": "true",
          "line": 96,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Err(ParseAlphabetError::ReservedByte(byte))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        14,
        30,
        31,
        32
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte >= 32_u8",
          "norm": "32_u8 <= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 32_u8",
          "may_panic": false
        },
        {
          "cond": "byte <= 126_u8",
          "norm": "126_u8 >= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 126_u8",
          "may_panic": false
        },
        {
          "cond": "byte == PAD_BYTE",
          "norm": "PAD_BYTE == byte",
          "value": "false",
          "line": 96,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > probe_index",
          "value": "true",
          "line": 105,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index == index",
          "norm": "index == probe_index",
          "value": "true",
          "line": 106,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > probe_index",
          "value": "false",
          "line": 105,
          "bound": "probe_index == ALPHABET_SIZE",
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "false",
          "line": 87,
          "bound": "index == ALPHABET_SIZE",
          "may_panic": false
        }
      ],
      "ret": "Ok(Self::from_str_unchecked(alphabet))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        15,
        16,
        17,
        18,
        19,
        20,
        16,
        17,
        26,
        27,
        5,
        6,
        28,
        29,
        32
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte >= 32_u8",
          "norm": "32_u8 <= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 32_u8",
          "may_panic": false
        },
        {
          "cond": "byte <= 126_u8",
          "norm": "126_u8 >= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 126_u8",
          "may_panic": false
        },
        {
          "cond": "byte == PAD_BYTE",
          "norm": "PAD_BYTE == byte",
          "value": "false",
          "line": 96,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > probe_index",
          "value": "true",
          "line": 105,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index == index",
          "norm": "index == probe_index",
          "value": "false",
          "line": 106,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte == probe_byte",
          "norm": null,
          "value": "true",
          "line": 113,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Err(ParseAlphabetError::DuplicatedByte(byte))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        15,
        16,
        17,
        18,
        21,
        22,
        23,
        30,
        31,
        32
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte >= 32_u8",
          "norm": "32_u8 <= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 32_u8",
          "may_panic": false
        },
        {
          "cond": "byte <= 126_u8",
          "norm": "126_u8 >= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 126_u8",
          "may_panic": false
        },
        {
          "cond": "byte == PAD_BYTE",
          "norm": "PAD_BYTE == byte",
          "value": "false",
          "line": 96,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > probe_index",
          "value": "true",
          "line": 105,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index == index",
          "norm": "index == probe_index",
          "value": "false",
          "line": 106,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte == probe_byte",
          "norm": null,
          "value": "false",
          "line": 113,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > probe_index",
          "value": "false",
          "line": 105,
          "bound": "probe_index == ALPHABET_SIZE",
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "false",
          "line": 87,
          "bound": "index == ALPHABET_SIZE",
          "may_panic": false
        }
      ],
      "ret": "Ok(Self::from_str_unchecked(alphabet))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        15,
        16,
        17,
        18,
        21,
        22,
        24,
        25,
        16,
        17,
        26,
        27,
        5,
        6,
        28,
        29,
        32
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte >= 32_u8",
          "norm": "32_u8 <= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 32_u8",
          "may_panic": false
        },
        {
          "cond": "byte <= 126_u8",
          "norm": "126_u8 >= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 126_u8",
          "may_panic": false
        },
        {
          "cond": "byte == PAD_BYTE",
          "norm": "PAD_BYTE == byte",
          "value": "false",
          "line": 96,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "probe_index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > probe_index",
          "value": "false",
          "line": 105,
          "bound": "probe_index == ALPHABET_SIZE",
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "false",
          "line": 87,
          "bound": "index == ALPHABET_SIZE",
          "may_panic": false
        }
      ],
      "ret": "Ok(Self::from_str_unchecked(alphabet))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        15,
        16,
        17,
        26,
        27,
        5,
        6,
        28,
        29,
        32
      ],
      "may_contra": true,
      "min_set": false
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte >= 32_u8",
          "norm": "32_u8 <= byte",
          "value": "true",
          "line": 92,
          "bound": "byte == 32_u8",
          "may_panic": false
        },
        {
          "cond": "byte <= 126_u8",
          "norm": "126_u8 >= byte",
          "value": "false",
          "line": 92,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Err(ParseAlphabetError::UnprintableByte(byte))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        13,
        30,
        31,
        32
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "true",
          "line": 87,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "byte >= 32_u8",
          "norm": "32_u8 <= byte",
          "value": "false",
          "line": 92,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Err(ParseAlphabetError::UnprintableByte(byte))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        7,
        8,
        12,
        13,
        30,
        31,
        32
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "bytes.len() != ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE != bytes.len()",
          "value": "false",
          "line": 81,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index < ALPHABET_SIZE",
          "norm": "ALPHABET_SIZE > index",
          "value": "false",
          "line": 87,
          "bound": "index == ALPHABET_SIZE",
          "may_panic": false
        }
      ],
      "ret": "Ok(Self::from_str_unchecked(alphabet))",
      "path": [
        0,
        1,
        2,
        4,
        5,
        6,
        28,
        29,
        32
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}