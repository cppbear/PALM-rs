{"function_name":"base64::read::decoder::read::decoder::DecoderReader<'e, E, R>::flush_decoded_buf","tests":18,"tests_lines":[18,21,21,53,53,21,18,21,7,7,7,5,6,6,48,45,45,44],"oracles":18,"oracles_compiled":4,"oracles_compiled_rate":22.22222222222222,"tests_compiled":4,"tests_compiled_rate":22.22222222222222,"oracles_run":4,"oracles_passed":4,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":4,"tests_passed_rate":100.0,"lines":16,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[96,97,98,100,101,102,104,105,106,107,108,109,110,111,113,114],"codes_lines_covered":[[["{","    let mut decoder = Decoder::new(vec![1, 2, 3, 4, 5], 5);","    let mut buf = [0u8; 3];","    let result = decoder.flush_decoded_buf(&mut buf);","    assert_eq!(result.unwrap(), 3);","    assert_eq!(buf, [1, 2, 3]);","}"],[]],[["{","    let mut decoder = Decoder::new(vec![1, 2, 3, 4], 4);","    let mut buf = [0u8; 4];","    let result = decoder.flush_decoded_buf(&mut buf);","    assert_eq!(result.unwrap(), 4);","    assert_eq!(buf, [1, 2, 3, 4]);","}"],[]],[["{","    let mut decoder = Decoder::new(vec![1, 2, 3, 4, 5, 6], 6);","    let mut buf = [0u8; 2];","    let result = decoder.flush_decoded_buf(&mut buf);","    assert_eq!(result.unwrap(), 2);","    assert_eq!(buf, [1, 2]);","}"],[]],[["{","    struct Decoder {","        decoded_len: usize,","        decoded_offset: usize,","        decoded_chunk_buffer: Vec<u8>,","    }","","    impl Decoder {","        fn new(data: &[u8]) -> Self {","            Self {","                decoded_len: data.len(),","                decoded_offset: 0,","                decoded_chunk_buffer: data.to_vec(),","            }","        }","","        fn flush_decoded_buf(&mut self, buf: &mut [u8]) -> io::Result<usize> {","            debug_assert!(self.decoded_len > 0);","            debug_assert!(!buf.is_empty());","","            let copy_len = cmp::min(self.decoded_len, buf.len());","            debug_assert!(copy_len > 0);","            debug_assert!(copy_len <= self.decoded_len);","","            buf[..copy_len].copy_from_slice(","                &self.decoded_chunk_buffer[self.decoded_offset..self.decoded_offset + copy_len],","            );","","            self.decoded_offset += copy_len;","            self.decoded_len -= copy_len;","","            debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);","","            Ok(copy_len)","        }","    }","","    const DECODED_CHUNK_SIZE: usize = 8;","","    let data = vec![1, 2, 3, 4, 5, 6, 7, 8];","    let mut decoder = Decoder::new(&data);","    let mut buffer = [0; 4];","","    let result = decoder.flush_decoded_buf(&mut buffer).unwrap();","","    assert_eq!(result, 4);","    assert_eq!(&buffer[..result], &[1, 2, 3, 4]);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut decoder = Decoder::new(vec![1, 2, 3, 4, 5], 5);","    let mut buf = [0u8; 3];","    let result = decoder.flush_decoded_buf(&mut buf);","    assert_eq!(result.unwrap(), 3);","    assert_eq!(buf, [1, 2, 3]);","}"],[]],[["{","    let mut decoder = Decoder::new(vec![1, 2, 3, 4], 4);","    let mut buf = [0u8; 4];","    let result = decoder.flush_decoded_buf(&mut buf);","    assert_eq!(result.unwrap(), 4);","    assert_eq!(buf, [1, 2, 3, 4]);","}"],[]],[["{","    let mut decoder = Decoder::new(vec![1, 2, 3, 4, 5, 6], 6);","    let mut buf = [0u8; 2];","    let result = decoder.flush_decoded_buf(&mut buf);","    assert_eq!(result.unwrap(), 2);","    assert_eq!(buf, [1, 2]);","}"],[]],[["{","    struct Decoder {","        decoded_len: usize,","        decoded_offset: usize,","        decoded_chunk_buffer: Vec<u8>,","    }","","    impl Decoder {","        fn new(data: &[u8]) -> Self {","            Self {","                decoded_len: data.len(),","                decoded_offset: 0,","                decoded_chunk_buffer: data.to_vec(),","            }","        }","","        fn flush_decoded_buf(&mut self, buf: &mut [u8]) -> io::Result<usize> {","            debug_assert!(self.decoded_len > 0);","            debug_assert!(!buf.is_empty());","","            let copy_len = cmp::min(self.decoded_len, buf.len());","            debug_assert!(copy_len > 0);","            debug_assert!(copy_len <= self.decoded_len);","","            buf[..copy_len].copy_from_slice(","                &self.decoded_chunk_buffer[self.decoded_offset..self.decoded_offset + copy_len],","            );","","            self.decoded_offset += copy_len;","            self.decoded_len -= copy_len;","","            debug_assert!(self.decoded_len < DECODED_CHUNK_SIZE);","","            Ok(copy_len)","        }","    }","","    const DECODED_CHUNK_SIZE: usize = 8;","","    let data = vec![1, 2, 3, 4, 5, 6, 7, 8];","    let mut decoder = Decoder::new(&data);","    let mut buffer = [0; 4];","","    let result = decoder.flush_decoded_buf(&mut buffer).unwrap();","","    assert_eq!(result, 4);","    assert_eq!(&buffer[..result], &[1, 2, 3, 4]);","}"],[]]]}