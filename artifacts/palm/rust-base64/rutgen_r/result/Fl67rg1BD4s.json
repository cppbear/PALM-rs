{"function_name":"base64::engine::general_purpose::decode_suffix::decode_suffix","tests":51,"tests_lines":[19,19,18,19,14,19,19,18,19,20,18,18,17,20,13,12,19,15,43,35,40,28,23,28,25,33,38,34,34,95,91,91,91,12,11,12,12,12,70,94,62,24,19,24,19,75,33,28,30,13,13],"oracles":51,"oracles_compiled":16,"oracles_compiled_rate":31.372549019607842,"tests_compiled":16,"tests_compiled_rate":31.372549019607842,"oracles_run":16,"oracles_passed":9,"oracles_passed_rate":56.25,"tests_run":16,"tests_passed":9,"tests_passed_rate":56.25,"lines":98,"lines_covered":93,"lines_coveraged_rate":94.89795918367348,"branches":30,"branches_covered":20,"branches_coverage_rate":66.66666666666666,"codes_lines":[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,50,51,53,54,55,56,57,58,59,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,90,91,92,93,94,95,98,99,100,103,106,107,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,155,156,157,159,162],"codes_lines_covered":[[["{","    let input: &[u8] = b\"AAAB\"; // 4 valid bytes","    let input_index = 0;","    let mut output = [0u8; 2]; // Output slice is too small","    let output_index = 0;","    let decode_table = [INVALID_VALUE; 256]; // All INVALID_VALUE","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert!(result.is_err());","    assert!(matches!(result, Err(DecodeSliceError::OutputSliceTooSmall)));","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = b\"AA==\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        // Assume 'A' -> 0, 'B' -> 1, etc. for test purposes","        tbl[b'A' as usize] = 0;","        tbl[b'B' as usize] = 1;","        tbl[b'=' as usize] = PAD_BYTE; // Assuming this represents padding","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","    assert_eq!(output[..1], [0]); // Expecting 'A' = 0","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,100,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,155,156,157,162]],[["{","    let input: &[u8] = b\"AAB\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        tbl[b'A' as usize] = 0;","        tbl[b'B' as usize] = 1;","        tbl[b'=' as usize] = PAD_BYTE;","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,99,162]],[["{","    let input: &[u8] = b\"AA\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        tbl[b'A' as usize] = 0;","        tbl[b'B' as usize] = 1;","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","    assert_eq!(output[..1], [0]); // Expecting 'A' = 0","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,103,107,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,155,156,159,162]],[["{","    let input: &[u8] = b\"AA\\xFF\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        tbl[b'A' as usize] = 0;","        tbl[b'=' as usize] = PAD_BYTE;","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    const DECODE_TABLE: [u8; 256] = [","        // Fill with dummy values for testing","        INVALID_VALUE; 256","    ];","","    let input: &[u8] = b\"xyz$\"; // Invalid last symbol","    let input_index = 0; // Start decoding from the beginning","    let mut output = [0u8; 4]; // Prepare output buffer","    let mut output_index = 0; // Output index starts at 0","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &DECODE_TABLE,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    const PAD_BYTE: u8 = b'='; // Define PAD_BYTE as expected in the function","    const INVALID_VALUE: u8 = 255; // Assuming invalid value is 255","    const INPUT_INDEX: usize = 0;","    const DECODE_ALLOW_TRAILING_BITS: bool = false; // Set according to the context","    const DECODE_PADDING_MODE: DecodePaddingMode = DecodePaddingMode::RequireCanonical; ","","    let input: [u8; 4] = [b'A', b'B', PAD_BYTE, PAD_BYTE]; // 4 bytes input with improper padding","    let mut output: [u8; 2] = [0; 2]; // output buffer","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Populate decode_table as necessary","        table[b'A' as usize] = 0; // Example for A","        table[b'B' as usize] = 1; // Example for B","        table","    };","","    let result = decode_suffix(","        &input,","        INPUT_INDEX,","        &mut output,","        0,","        &decode_table,","        DECODE_ALLOW_TRAILING_BITS,","        DECODE_PADDING_MODE,","    );","","    // Check if the expected error matches","    assert!(result.is_err());","    if let Err(decode_error) = result {","        assert_eq!(decode_error, DecodeError::InvalidByte(INPUT_INDEX + 2, PAD_BYTE).into()); // Check expected error type and value","    }","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,98,100,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,162]],[["{","    const PAD_BYTE: u8 = b'='; // Define PAD_BYTE as expected in the function","    const INVALID_VALUE: u8 = 255; // Assuming invalid value is 255","    const INPUT_INDEX: usize = 0;","    const DECODE_ALLOW_TRAILING_BITS: bool = false; // Disallow trailing bits for testing valid last symbol","    const DECODE_PADDING_MODE: DecodePaddingMode = DecodePaddingMode::RequireNone; ","","    let input: [u8; 4] = [b'A', b'B', b'=', b'W']; // Test case with invalid last symbol ('W' should not be valid)","    let mut output: [u8; 2] = [0; 2]; // Output buffer","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Populate decode_table as necessary","        table[b'A' as usize] = 0; ","        table[b'B' as usize] = 1; ","        table[b'=' as usize] = PAD_BYTE; // Treat pad byte as currently","        table","    };","","    let result = decode_suffix(","        &input,","        INPUT_INDEX,","        &mut output,","        0,","        &decode_table,","        DECODE_ALLOW_TRAILING_BITS,","        DECODE_PADDING_MODE,","    );","","    // Check if the expected error matches for invalid last symbol","    assert!(result.is_err());","    if let Err(decode_error) = result {","        assert_eq!(decode_error, DecodeError::InvalidLastSymbol(INPUT_INDEX + 3, b'W').into()); // Last byte is W","    }","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,46,55,56,57,58,59,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,82,83,84,85,162]],[["{","    const INPUT: &[u8] = b\"ABCD\"; // valid base64 input, 4 bytes long","    const DECODE_TABLE: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assume 'A', 'B', 'C', 'D', and '=' have valid decode values","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'=' as usize] = PAD_BYTE; // Assuming PAD_BYTE is defined","        table","    };","    let mut output = [0u8; 3]; // Output buffer, size for decoded bytes","    let input_index = 0; // Start index","    let mut output_index = 0; // Initial output index","    let decode_allow_trailing_bits = true; // Allow trailing bits","    let padding_mode = DecodePaddingMode::RequireCanonical; // Padding mode","    ","    // Testing an invalid byte scenario by introducing a bad symbol in input","    // Modify last byte to introduce an invalid symbol","    let input_with_invalid_byte = [INPUT[0], INPUT[1], INPUT[2], 0xFF]; // 0xFF is assumed to be invalid","","    let result = decode_suffix(","        &input_with_invalid_byte,","        input_index,","        &mut output,","        output_index,","        &DECODE_TABLE,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    let input: &[u8] = b\"YWI\"; // Base64 for \"ab\" with one trailing bit ","    let input_index = 0;","    let mut output = [0u8; 2]; // Expected output size","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table[b'=' as usize] = PAD_BYTE;","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,92,93,94,95,123,124,125,126,127,128,129,130,131,132,133,134,141,142,143,144,145,146,147,148,149,150,151,155,156,159,162]],[["{","    let input: &[u8] = b\"Y#I\"; // Invalid character '#'","    let input_index = 0;","    let mut output = [0u8; 2]; // Expected output size","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table[b'=' as usize] = PAD_BYTE;","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,82,83,84,85,162]],[["{","    let input: &[u8] = b\"Y\"; // Short input","    let input_index = 0;","    let mut output = [0u8; 2]; // Expected output size","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table[b'=' as usize] = PAD_BYTE;","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,82,83,84,85,90,91,162]],[["{","    let input: &[u8] = &[0b11000000, 0b11000001, 0b10110000]; // Only 3 bytes","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, &byte) in b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".iter().enumerate() {","            table[byte as usize] = i as u8;","        }","        table[b'=' as usize] = PAD_BYTE; // Set the padding byte","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = &[0b11000000, 0b11000001, 0b10110000, 0b11111111]; // Invalid last symbol","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, &byte) in b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".iter().enumerate() {","            table[byte as usize] = i as u8;","        }","        table[b'=' as usize] = PAD_BYTE; // Set the padding byte","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err()); // Expect an error due to invalid last symbol","}"],[11,12,13,14,15,16,17,18,19,20,24,25,26,27,28,29,31,33,63,64,65,66,67,68,69,73,74,75,76,77,78,79,80,81,162]],[["{","    let input: &[u8] = &[0, 1, 2, 3, 4, 5]; // length is 6","    let input_index: usize = 0;","    let mut output = [0u8; 4];","    let mut output_index: usize = 0;","    let decode_table: [u8; 256] = [0; 256]; // Assuming a mock decode table","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20]],[["{","    let input: &[u8] = &[0, 1, 2]; // length is 3","    let input_index: usize = 4; // out of bounds","    let mut output = [0u8; 4];","    let mut output_index: usize = 0;","    let decode_table: [u8; 256] = [0; 256]; // Assuming a mock decode table","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[11,12,13,14,15,16,17,18,19,20]]],"codes_branches":[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":true,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":true,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":true,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":true},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let input: &[u8] = b\"AAAB\"; // 4 valid bytes","    let input_index = 0;","    let mut output = [0u8; 2]; // Output slice is too small","    let output_index = 0;","    let decode_table = [INVALID_VALUE; 256]; // All INVALID_VALUE","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","","    assert!(result.is_err());","    assert!(matches!(result, Err(DecodeSliceError::OutputSliceTooSmall)));","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"AA==\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        // Assume 'A' -> 0, 'B' -> 1, etc. for test purposes","        tbl[b'A' as usize] = 0;","        tbl[b'B' as usize] = 1;","        tbl[b'=' as usize] = PAD_BYTE; // Assuming this represents padding","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","    assert_eq!(output[..1], [0]); // Expecting 'A' = 0","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":true,"negative":false}]],[["{","    let input: &[u8] = b\"AAB\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        tbl[b'A' as usize] = 0;","        tbl[b'B' as usize] = 1;","        tbl[b'=' as usize] = PAD_BYTE;","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":true,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"AA\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        tbl[b'A' as usize] = 0;","        tbl[b'B' as usize] = 1;","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_ok());","    assert_eq!(output[..1], [0]); // Expecting 'A' = 0","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":true},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":true}]],[["{","    let input: &[u8] = b\"AA\\xFF\";","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","    let decode_table: [u8; 256] = {","        let mut tbl = [INVALID_VALUE; 256];","        tbl[b'A' as usize] = 0;","        tbl[b'=' as usize] = PAD_BYTE;","        tbl","    };","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireNone;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    const DECODE_TABLE: [u8; 256] = [","        // Fill with dummy values for testing","        INVALID_VALUE; 256","    ];","","    let input: &[u8] = b\"xyz$\"; // Invalid last symbol","    let input_index = 0; // Start decoding from the beginning","    let mut output = [0u8; 4]; // Prepare output buffer","    let mut output_index = 0; // Output index starts at 0","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &DECODE_TABLE,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    const PAD_BYTE: u8 = b'='; // Define PAD_BYTE as expected in the function","    const INVALID_VALUE: u8 = 255; // Assuming invalid value is 255","    const INPUT_INDEX: usize = 0;","    const DECODE_ALLOW_TRAILING_BITS: bool = false; // Set according to the context","    const DECODE_PADDING_MODE: DecodePaddingMode = DecodePaddingMode::RequireCanonical; ","","    let input: [u8; 4] = [b'A', b'B', PAD_BYTE, PAD_BYTE]; // 4 bytes input with improper padding","    let mut output: [u8; 2] = [0; 2]; // output buffer","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Populate decode_table as necessary","        table[b'A' as usize] = 0; // Example for A","        table[b'B' as usize] = 1; // Example for B","        table","    };","","    let result = decode_suffix(","        &input,","        INPUT_INDEX,","        &mut output,","        0,","        &decode_table,","        DECODE_ALLOW_TRAILING_BITS,","        DECODE_PADDING_MODE,","    );","","    // Check if the expected error matches","    assert!(result.is_err());","    if let Err(decode_error) = result {","        assert_eq!(decode_error, DecodeError::InvalidByte(INPUT_INDEX + 2, PAD_BYTE).into()); // Check expected error type and value","    }","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":true},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":true},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":true,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    const PAD_BYTE: u8 = b'='; // Define PAD_BYTE as expected in the function","    const INVALID_VALUE: u8 = 255; // Assuming invalid value is 255","    const INPUT_INDEX: usize = 0;","    const DECODE_ALLOW_TRAILING_BITS: bool = false; // Disallow trailing bits for testing valid last symbol","    const DECODE_PADDING_MODE: DecodePaddingMode = DecodePaddingMode::RequireNone; ","","    let input: [u8; 4] = [b'A', b'B', b'=', b'W']; // Test case with invalid last symbol ('W' should not be valid)","    let mut output: [u8; 2] = [0; 2]; // Output buffer","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Populate decode_table as necessary","        table[b'A' as usize] = 0; ","        table[b'B' as usize] = 1; ","        table[b'=' as usize] = PAD_BYTE; // Treat pad byte as currently","        table","    };","","    let result = decode_suffix(","        &input,","        INPUT_INDEX,","        &mut output,","        0,","        &decode_table,","        DECODE_ALLOW_TRAILING_BITS,","        DECODE_PADDING_MODE,","    );","","    // Check if the expected error matches for invalid last symbol","    assert!(result.is_err());","    if let Err(decode_error) = result {","        assert_eq!(decode_error, DecodeError::InvalidLastSymbol(INPUT_INDEX + 3, b'W').into()); // Last byte is W","    }","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":true,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":true},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":true,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":true,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    const INPUT: &[u8] = b\"ABCD\"; // valid base64 input, 4 bytes long","    const DECODE_TABLE: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Assume 'A', 'B', 'C', 'D', and '=' have valid decode values","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'=' as usize] = PAD_BYTE; // Assuming PAD_BYTE is defined","        table","    };","    let mut output = [0u8; 3]; // Output buffer, size for decoded bytes","    let input_index = 0; // Start index","    let mut output_index = 0; // Initial output index","    let decode_allow_trailing_bits = true; // Allow trailing bits","    let padding_mode = DecodePaddingMode::RequireCanonical; // Padding mode","    ","    // Testing an invalid byte scenario by introducing a bad symbol in input","    // Modify last byte to introduce an invalid symbol","    let input_with_invalid_byte = [INPUT[0], INPUT[1], INPUT[2], 0xFF]; // 0xFF is assumed to be invalid","","    let result = decode_suffix(","        &input_with_invalid_byte,","        input_index,","        &mut output,","        output_index,","        &DECODE_TABLE,","        decode_allow_trailing_bits,","        padding_mode","    );","","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"YWI\"; // Base64 for \"ab\" with one trailing bit ","    let input_index = 0;","    let mut output = [0u8; 2]; // Expected output size","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table[b'=' as usize] = PAD_BYTE;","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":true},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":true,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":true},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":true}]],[["{","    let input: &[u8] = b\"Y#I\"; // Invalid character '#'","    let input_index = 0;","    let mut output = [0u8; 2]; // Expected output size","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table[b'=' as usize] = PAD_BYTE;","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = b\"Y\"; // Short input","    let input_index = 0;","    let mut output = [0u8; 2]; // Expected output size","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0;","        table[b'B' as usize] = 1;","        table[b'C' as usize] = 2;","        table[b'D' as usize] = 3;","        table[b'E' as usize] = 4;","        table[b'F' as usize] = 5;","        table[b'G' as usize] = 6;","        table[b'H' as usize] = 7;","        table[b'I' as usize] = 8;","        table[b'J' as usize] = 9;","        table[b'K' as usize] = 10;","        table[b'L' as usize] = 11;","        table[b'M' as usize] = 12;","        table[b'N' as usize] = 13;","        table[b'O' as usize] = 14;","        table[b'P' as usize] = 15;","        table[b'Q' as usize] = 16;","        table[b'R' as usize] = 17;","        table[b'S' as usize] = 18;","        table[b'T' as usize] = 19;","        table[b'U' as usize] = 20;","        table[b'V' as usize] = 21;","        table[b'W' as usize] = 22;","        table[b'X' as usize] = 23;","        table[b'Y' as usize] = 24;","        table[b'Z' as usize] = 25;","        table[b'a' as usize] = 26;","        table[b'b' as usize] = 27;","        table[b'c' as usize] = 28;","        table[b'd' as usize] = 29;","        table[b'e' as usize] = 30;","        table[b'f' as usize] = 31;","        table[b'g' as usize] = 32;","        table[b'h' as usize] = 33;","        table[b'i' as usize] = 34;","        table[b'j' as usize] = 35;","        table[b'k' as usize] = 36;","        table[b'l' as usize] = 37;","        table[b'm' as usize] = 38;","        table[b'n' as usize] = 39;","        table[b'o' as usize] = 40;","        table[b'p' as usize] = 41;","        table[b'q' as usize] = 42;","        table[b'r' as usize] = 43;","        table[b's' as usize] = 44;","        table[b't' as usize] = 45;","        table[b'u' as usize] = 46;","        table[b'v' as usize] = 47;","        table[b'w' as usize] = 48;","        table[b'x' as usize] = 49;","        table[b'y' as usize] = 50;","        table[b'z' as usize] = 51;","        table[b'0' as usize] = 52;","        table[b'1' as usize] = 53;","        table[b'2' as usize] = 54;","        table[b'3' as usize] = 55;","        table[b'4' as usize] = 56;","        table[b'5' as usize] = 57;","        table[b'6' as usize] = 58;","        table[b'7' as usize] = 59;","        table[b'8' as usize] = 60;","        table[b'9' as usize] = 61;","        table[b'+' as usize] = 62;","        table[b'/' as usize] = 63;","        table[b'=' as usize] = PAD_BYTE;","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":true},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":true,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":true,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[0b11000000, 0b11000001, 0b10110000]; // Only 3 bytes","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, &byte) in b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".iter().enumerate() {","            table[byte as usize] = i as u8;","        }","        table[b'=' as usize] = PAD_BYTE; // Set the padding byte","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let _ = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[0b11000000, 0b11000001, 0b10110000, 0b11111111]; // Invalid last symbol","    let input_index = 0;","    let mut output = [0u8; 4];","    let mut output_index = 0;","","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        for (i, &byte) in b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".iter().enumerate() {","            table[byte as usize] = i as u8;","        }","        table[b'=' as usize] = PAD_BYTE; // Set the padding byte","        table","    };","","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(","        input,","        input_index,","        &mut output,","        output_index,","        &decode_table,","        decode_allow_trailing_bits,","        padding_mode,","    );","","    assert!(result.is_err()); // Expect an error due to invalid last symbol","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":true},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":true},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":true,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[0, 1, 2, 3, 4, 5]; // length is 6","    let input_index: usize = 0;","    let mut output = [0u8; 4];","    let mut output_index: usize = 0;","    let decode_table: [u8; 256] = [0; 256]; // Assuming a mock decode table","    let decode_allow_trailing_bits = false;","    let padding_mode = DecodePaddingMode::RequireCanonical;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]],[["{","    let input: &[u8] = &[0, 1, 2]; // length is 3","    let input_index: usize = 4; // out of bounds","    let mut output = [0u8; 4];","    let mut output_index: usize = 0;","    let decode_table: [u8; 256] = [0; 256]; // Assuming a mock decode table","    let decode_allow_trailing_bits = true;","    let padding_mode = DecodePaddingMode::Indifferent;","","    let result = decode_suffix(input, input_index, &mut output, output_index, &decode_table, decode_allow_trailing_bits, padding_mode);","    ","    assert!(result.is_err());","}"],[{"start_line":33,"start_column":12,"end_line":33,"end_column":25,"positive":false,"negative":false},{"start_line":46,"start_column":16,"end_line":46,"end_column":34,"positive":false,"negative":false},{"start_line":51,"start_column":21,"end_line":51,"end_column":40,"positive":false,"negative":false},{"start_line":51,"start_column":45,"end_line":51,"end_column":64,"positive":false,"negative":false},{"start_line":51,"start_column":68,"end_line":51,"end_column":92,"positive":false,"negative":false},{"start_line":57,"start_column":16,"end_line":57,"end_column":40,"positive":false,"negative":false},{"start_line":69,"start_column":12,"end_line":69,"end_column":35,"positive":false,"negative":false},{"start_line":80,"start_column":12,"end_line":80,"end_column":35,"positive":false,"negative":false},{"start_line":90,"start_column":8,"end_line":90,"end_column":25,"positive":false,"negative":false},{"start_line":90,"start_column":29,"end_line":90,"end_column":52,"positive":false,"negative":false},{"start_line":98,"start_column":16,"end_line":98,"end_column":68,"positive":false,"negative":false},{"start_line":103,"start_column":16,"end_line":103,"end_column":39,"positive":false,"negative":false},{"start_line":134,"start_column":8,"end_line":134,"end_column":35,"positive":false,"negative":false},{"start_line":134,"start_column":39,"end_line":134,"end_column":65,"positive":false,"negative":false},{"start_line":156,"start_column":12,"end_line":156,"end_column":35,"positive":false,"negative":false}]]]}