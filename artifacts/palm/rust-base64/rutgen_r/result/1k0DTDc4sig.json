{"function_name":"base64::alphabet::alphabet::Alphabet::from_str_unchecked","tests":5,"tests_lines":[23,22,17,4,4],"oracles":5,"oracles_compiled":2,"oracles_compiled_rate":40.0,"tests_compiled":2,"tests_compiled_rate":40.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":12,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[62,63,64,65,66,67,68,69,70,71,73,74],"codes_lines_covered":[[["{","    const ALPHABET_SIZE: usize = 64; // assuming a base64-like alphabet size","    struct Alphabet {","        symbols: [u8; ALPHABET_SIZE],","    }","","    const fn from_str_unchecked(alphabet: &str) -> Alphabet {","        let mut symbols = [0_u8; ALPHABET_SIZE];","        let source_bytes = alphabet.as_bytes();","","        let mut index = 0;","        while index < ALPHABET_SIZE {","            symbols[index] = source_bytes[index];","            index += 1;","        }","","        Alphabet { symbols }","    }","","    let valid_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // A valid base64 alphabet","    let result = from_str_unchecked(valid_alphabet);","    assert_eq!(result.symbols, valid_alphabet.as_bytes());","}"],[]],[["{","    let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";","    let expected = Alphabet {","        symbols: [","            b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H',","            b'I', b'J', b'K', b'L', b'M', b'N', b'O', b'P',","            b'Q', b'R', b'S', b'T', b'U', b'V', b'W', b'X',","            b'Y', b'Z', b'a', b'b', b'c', b'd', b'e', b'f',","            b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n',","            b'o', b'p', b'q', b'r', b's', b't', b'u', b'v',","            b'w', b'x', b'y', b'z', b'0', b'1', b'2', b'3',","            b'4', b'5', b'6', b'7', b'8', b'9', b'+', b'/',","        ],","    };","    let result = Alphabet::from_str_unchecked(alphabet);","    assert_eq!(result.symbols, expected.symbols);","}"],[]]],"codes_branches":[{"start_line":68,"start_column":15,"end_line":68,"end_column":36,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    const ALPHABET_SIZE: usize = 64; // assuming a base64-like alphabet size","    struct Alphabet {","        symbols: [u8; ALPHABET_SIZE],","    }","","    const fn from_str_unchecked(alphabet: &str) -> Alphabet {","        let mut symbols = [0_u8; ALPHABET_SIZE];","        let source_bytes = alphabet.as_bytes();","","        let mut index = 0;","        while index < ALPHABET_SIZE {","            symbols[index] = source_bytes[index];","            index += 1;","        }","","        Alphabet { symbols }","    }","","    let valid_alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // A valid base64 alphabet","    let result = from_str_unchecked(valid_alphabet);","    assert_eq!(result.symbols, valid_alphabet.as_bytes());","}"],[{"start_line":68,"start_column":15,"end_line":68,"end_column":36,"positive":false,"negative":false}]],[["{","    let alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";","    let expected = Alphabet {","        symbols: [","            b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H',","            b'I', b'J', b'K', b'L', b'M', b'N', b'O', b'P',","            b'Q', b'R', b'S', b'T', b'U', b'V', b'W', b'X',","            b'Y', b'Z', b'a', b'b', b'c', b'd', b'e', b'f',","            b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n',","            b'o', b'p', b'q', b'r', b's', b't', b'u', b'v',","            b'w', b'x', b'y', b'z', b'0', b'1', b'2', b'3',","            b'4', b'5', b'6', b'7', b'8', b'9', b'+', b'/',","        ],","    };","    let result = Alphabet::from_str_unchecked(alphabet);","    assert_eq!(result.symbols, expected.symbols);","}"],[{"start_line":68,"start_column":15,"end_line":68,"end_column":36,"positive":false,"negative":false}]]]}