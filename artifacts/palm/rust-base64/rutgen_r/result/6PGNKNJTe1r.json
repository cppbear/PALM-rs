{"function_name":"base64::engine::general_purpose::decode::complete_quads_len","tests":14,"tests_lines":[21,13,13,13,21,21,20,21,9,17,17,9,14,9],"oracles":14,"oracles_compiled":7,"oracles_compiled_rate":50.0,"tests_compiled":7,"tests_compiled_rate":50.0,"oracles_run":7,"oracles_passed":1,"oracles_passed_rate":14.285714285714285,"tests_run":7,"tests_passed":1,"tests_passed_rate":14.285714285714285,"lines":26,"lines_covered":25,"lines_coveraged_rate":96.15384615384616,"branches":12,"branches_covered":8,"branches_coverage_rate":66.66666666666666,"codes_lines":[131,132,133,134,135,136,137,140,141,142,143,144,145,146,149,150,151,152,153,154,155,159,160,161,162,163],"codes_lines_covered":[[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        //... fill out remaining valid characters as needed","        table","    };","    ","    let input: &[u8] = b\"ABCD\"; // len = 4, thus input.len() % 4 == 0 which matches with input_len_rem = 0","    let input_len_rem: usize = 0; // input_len_rem = 0, thus should not trigger the last_byte check","    let output_len: usize = 3; // output len required to decode should be 3","","    // This should not panic and return the complete quads length","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert_eq!(result, Ok(4)); // Complete input has a length of 4, hence should return 4","}"],[131,132,133,134,135,136,137,140,146,149,150,151,152,153,154,155,159,161,162,163]],[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        //... fill out remaining valid characters as needed","        table","    };","    ","    let input: &[u8] = b\"ABCD\"; // len = 4","    let input_len_rem: usize = 0; // input_len_rem = 0","    let output_len: usize = 2; // Insufficient output length to decode (needs 3)","","    // This should return an error due to insufficient output length","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall)); // Expecting an insufficient slice error","}"],[131,132,133,134,135,136,137,140,146,149,150,151,152,153,154,155,159,161,162,163]],[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        table //... other valid characters","    };","    ","    let input: &[u8] = b\"ABCDX\"; // len = 5, not a complete set of 4 (input_len_rem = 1)","    let input_len_rem: usize = 1; // % 4 == 1 implies last byte check should occur","    let output_len: usize = 4; // Just an arbitrary output length","","    // This should return an error due to an invalid last byte that is not a pad byte","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err());","}"],[131,132,133,134,135,136,137,140,141,142,143,144,163]],[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        //... other valid characters","        table","    };","    ","    let input: &[u8] = b\"A\"; // len = 1, should be not empty","    let input_len_rem: usize = 1; // % 4 == 1","    let output_len: usize = 0; // output length is not considered as we will not check valid output here","","    // This should return an error due to last byte and should not be PAD_BYTE","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err()); // Expecting an error due to invalid last byte","}"],[131,132,133,134,135,136,137,140,141,142,143,145,149,150,151,152,153,154,155,159,161,162,163]],[["{","    let input = b\"QUJD\"; // Length is 4, so input.len() % 4 == 0, input_len_rem should be 1 for the test","    let input_len_rem = 1; // Incorrect remainder","    let output_len = 3; // Sufficient output length for valid decode","    let decode_table = [0; 256]; // Dummy decode table","","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err());","}"],[131,132,133,134,135,136,137]],[["{","    let input = b\"QUJD\"; // Length is 4, valid base64 input","    let input_len_rem = 1; // Incorrect remainder","    let output_len = 3; // Sufficient output length for valid decode","    let decode_table = {","        let mut table = [0; 256];","        table[usize::from(b'D')] = 64; // Making 'D' a valid base64 character","        table[usize::from(b'\\n')] = 255; // Making newline invalid","        table","    };","","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err()); // Expecting an error due to invalid last byte","}"],[131,132,133,134,135,136,137]],[["{","    let input = b\"QUJD\"; // Length is 4, valid base64 input","    let input_len_rem = 0; // Should be 0 for complete input","    let output_len = 0; // Output length is not sufficient","    let decode_table = [0; 256]; // Dummy decode table","","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err()); // Expecting an error due to output slice being too small","}"],[131,132,133,134,135,136,137,140,146,149,150,151,152,153,154,155,159,161,162,163]]],"codes_branches":[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":true,"negative":true},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":true,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":true,"negative":true},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":true},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":true,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":true}],"codes_branches_covered":[[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        //... fill out remaining valid characters as needed","        table","    };","    ","    let input: &[u8] = b\"ABCD\"; // len = 4, thus input.len() % 4 == 0 which matches with input_len_rem = 0","    let input_len_rem: usize = 0; // input_len_rem = 0, thus should not trigger the last_byte check","    let output_len: usize = 3; // output len required to decode should be 3","","    // This should not panic and return the complete quads length","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert_eq!(result, Ok(4)); // Complete input has a length of 4, hence should return 4","}"],[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":false,"negative":true},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":false,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":false,"negative":false},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":true},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":true,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":true}]],[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        //... fill out remaining valid characters as needed","        table","    };","    ","    let input: &[u8] = b\"ABCD\"; // len = 4","    let input_len_rem: usize = 0; // input_len_rem = 0","    let output_len: usize = 2; // Insufficient output length to decode (needs 3)","","    // This should return an error due to insufficient output length","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall)); // Expecting an insufficient slice error","}"],[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":false,"negative":true},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":false,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":false,"negative":false},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":true},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":true,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":true}]],[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        table //... other valid characters","    };","    ","    let input: &[u8] = b\"ABCDX\"; // len = 5, not a complete set of 4 (input_len_rem = 1)","    let input_len_rem: usize = 1; // % 4 == 1 implies last byte check should occur","    let output_len: usize = 4; // Just an arbitrary output length","","    // This should return an error due to an invalid last byte that is not a pad byte","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err());","}"],[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":true,"negative":false},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":true,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":true,"negative":false},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":false},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":false,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":false}]],[["{","    const PAD_BYTE: u8 = b'='; // assuming '=' is the pad byte","    const INVALID_VALUE: u8 = 0xFF; // assuming an invalid decode value","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        table[b'A' as usize] = 0; // valid for 'A'","        table[b'B' as usize] = 1; // valid for 'B'","        table[b'C' as usize] = 2; // valid for 'C'","        table[b'D' as usize] = 3; // valid for 'D'","        //... other valid characters","        table","    };","    ","    let input: &[u8] = b\"A\"; // len = 1, should be not empty","    let input_len_rem: usize = 1; // % 4 == 1","    let output_len: usize = 0; // output length is not considered as we will not check valid output here","","    // This should return an error due to last byte and should not be PAD_BYTE","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err()); // Expecting an error due to invalid last byte","}"],[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":true,"negative":false},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":true,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":false,"negative":true},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":true},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":true,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":true}]],[["{","    let input = b\"QUJD\"; // Length is 4, so input.len() % 4 == 0, input_len_rem should be 1 for the test","    let input_len_rem = 1; // Incorrect remainder","    let output_len = 3; // Sufficient output length for valid decode","    let decode_table = [0; 256]; // Dummy decode table","","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err());","}"],[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":false,"negative":false},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":false,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":false,"negative":false},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":false},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":false,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":false}]],[["{","    let input = b\"QUJD\"; // Length is 4, valid base64 input","    let input_len_rem = 1; // Incorrect remainder","    let output_len = 3; // Sufficient output length for valid decode","    let decode_table = {","        let mut table = [0; 256];","        table[usize::from(b'D')] = 64; // Making 'D' a valid base64 character","        table[usize::from(b'\\n')] = 255; // Making newline invalid","        table","    };","","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err()); // Expecting an error due to invalid last byte","}"],[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":false,"negative":false},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":false,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":false,"negative":false},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":false},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":false,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":false}]],[["{","    let input = b\"QUJD\"; // Length is 4, valid base64 input","    let input_len_rem = 0; // Should be 0 for complete input","    let output_len = 0; // Output length is not sufficient","    let decode_table = [0; 256]; // Dummy decode table","","    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);","    assert!(result.is_err()); // Expecting an error due to output slice being too small","}"],[{"start_line":140,"start_column":8,"end_line":140,"end_column":26,"positive":false,"negative":true},{"start_line":143,"start_column":12,"end_line":143,"end_column":33,"positive":false,"negative":false},{"start_line":143,"start_column":37,"end_line":143,"end_column":90,"positive":false,"negative":false},{"start_line":155,"start_column":9,"end_line":155,"end_column":25,"positive":false,"negative":true},{"start_line":155,"start_column":29,"end_line":155,"end_column":100,"positive":true,"negative":false},{"start_line":159,"start_column":8,"end_line":159,"end_column":65,"positive":false,"negative":true}]]]}