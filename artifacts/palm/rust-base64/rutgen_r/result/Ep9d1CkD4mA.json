{"function_name":"base64::write::encoder::write::encoder::EncoderWriter<'e, E, W>::write_all_encoded_output","tests":14,"tests_lines":[6,6,11,6,5,5,12,9,35,8,31,35,6,9],"oracles":14,"oracles_compiled":2,"oracles_compiled_rate":14.285714285714285,"tests_compiled":2,"tests_compiled_rate":14.285714285714285,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":10,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[212,213,214,215,217,219,221,225,226,227],"codes_lines_covered":[[["{","    struct TestWriter {","        output_occupied_len: usize,","    }","","    impl TestWriter {","        fn write_all_encoded_output(&mut self) -> Result<()> {","            while self.output_occupied_len > 0 {","                let remaining_len = self.output_occupied_len;","                match self.write_to_delegate(remaining_len) {","                    Err(ref e) if e.kind() == std::io::ErrorKind::Interrupted => {}","                    Err(e) => return Err(e),","                    Ok(()) => {}","                };","            }","","            debug_assert_eq!(0, self.output_occupied_len);","            Ok(())","        }","","        fn write_to_delegate(&mut self, _: usize) -> Result<()> {","            // Simulate successful write","            self.output_occupied_len = 0; // Ensuring we reach the termination condition","            Ok(())","        }","    }","","    let mut writer = TestWriter { output_occupied_len: 0 };","    let result = writer.write_all_encoded_output();","    assert!(result.is_ok());","}"],[]],[["{","    struct TestWriter {","        output_occupied_len: usize,","        interrupted: bool,","    }","","    impl TestWriter {","        fn write_all_encoded_output(&mut self) -> Result<()> {","            while self.output_occupied_len > 0 {","                let remaining_len = self.output_occupied_len;","                match self.write_to_delegate(remaining_len) {","                    Err(ref e) if e.kind() == std::io::ErrorKind::Interrupted => {}","                    Err(e) => return Err(e),","                    Ok(()) => {}","                };","            }","","            debug_assert_eq!(0, self.output_occupied_len);","            Ok(())","        }","","        fn write_to_delegate(&mut self, _: usize) -> Result<()> {","            if self.interrupted {","                return Err(std::io::Error::new(std::io::ErrorKind::Interrupted, \"Interrupted\"));","            }","            self.output_occupied_len = 0; // Writing simulates completing the write","            Ok(())","        }","    }","","    let mut writer = TestWriter { output_occupied_len: 1, interrupted: true };","    let result = writer.write_all_encoded_output();","    assert!(result.is_ok());","    assert_eq!(writer.output_occupied_len, 0);","}"],[]]],"codes_branches":[{"start_line":213,"start_column":15,"end_line":213,"end_column":43,"positive":false,"negative":false},{"start_line":217,"start_column":31,"end_line":217,"end_column":65,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestWriter {","        output_occupied_len: usize,","    }","","    impl TestWriter {","        fn write_all_encoded_output(&mut self) -> Result<()> {","            while self.output_occupied_len > 0 {","                let remaining_len = self.output_occupied_len;","                match self.write_to_delegate(remaining_len) {","                    Err(ref e) if e.kind() == std::io::ErrorKind::Interrupted => {}","                    Err(e) => return Err(e),","                    Ok(()) => {}","                };","            }","","            debug_assert_eq!(0, self.output_occupied_len);","            Ok(())","        }","","        fn write_to_delegate(&mut self, _: usize) -> Result<()> {","            // Simulate successful write","            self.output_occupied_len = 0; // Ensuring we reach the termination condition","            Ok(())","        }","    }","","    let mut writer = TestWriter { output_occupied_len: 0 };","    let result = writer.write_all_encoded_output();","    assert!(result.is_ok());","}"],[{"start_line":213,"start_column":15,"end_line":213,"end_column":43,"positive":false,"negative":false},{"start_line":217,"start_column":31,"end_line":217,"end_column":65,"positive":false,"negative":false}]],[["{","    struct TestWriter {","        output_occupied_len: usize,","        interrupted: bool,","    }","","    impl TestWriter {","        fn write_all_encoded_output(&mut self) -> Result<()> {","            while self.output_occupied_len > 0 {","                let remaining_len = self.output_occupied_len;","                match self.write_to_delegate(remaining_len) {","                    Err(ref e) if e.kind() == std::io::ErrorKind::Interrupted => {}","                    Err(e) => return Err(e),","                    Ok(()) => {}","                };","            }","","            debug_assert_eq!(0, self.output_occupied_len);","            Ok(())","        }","","        fn write_to_delegate(&mut self, _: usize) -> Result<()> {","            if self.interrupted {","                return Err(std::io::Error::new(std::io::ErrorKind::Interrupted, \"Interrupted\"));","            }","            self.output_occupied_len = 0; // Writing simulates completing the write","            Ok(())","        }","    }","","    let mut writer = TestWriter { output_occupied_len: 1, interrupted: true };","    let result = writer.write_all_encoded_output();","    assert!(result.is_ok());","    assert_eq!(writer.output_occupied_len, 0);","}"],[{"start_line":213,"start_column":15,"end_line":213,"end_column":43,"positive":false,"negative":false},{"start_line":217,"start_column":31,"end_line":217,"end_column":65,"positive":false,"negative":false}]]]}