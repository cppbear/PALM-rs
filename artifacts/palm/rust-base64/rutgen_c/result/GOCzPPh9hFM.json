{"function_name":"base64::engine::general_purpose::decode::decode_chunk_8","tests":3,"tests_lines":[19,22,22],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":1,"oracles_passed_rate":33.33333333333333,"tests_run":3,"tests_passed":1,"tests_passed_rate":33.33333333333333,"lines":79,"lines_covered":37,"lines_coveraged_rate":46.835443037974684,"branches":16,"branches_covered":6,"branches_coverage_rate":37.5,"codes_lines":[174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252],"codes_lines_covered":[[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Setting up a basic Base64 decode table for valid characters only","        b\"A\".iter().for_each(|&c| table[c as usize] = 0);","        b\"B\".iter().for_each(|&c| table[c as usize] = 1);","        b\"C\".iter().for_each(|&c| table[c as usize] = 2);","        b\"D\".iter().for_each(|&c| table[c as usize] = 3);","        // Fill in other valid base64 characters ...","        table","    };","","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H'];","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    ","    assert!(result.is_ok());","    assert_eq!(&output, &[0, 0, 0, 0, 0, 0]); // Expected output will depend on your decode table setup","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,215,216,217,218,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        b\"A\".iter().for_each(|&c| table[c as usize] = 0);","        b\"B\".iter().for_each(|&c| table[c as usize] = 1);","        b\"C\".iter().for_each(|&c| table[c as usize] = 2);","        b\"D\".iter().for_each(|&c| table[c as usize] = 3);","        table","    };","","    let input: [u8; 8] = [b'A', b'B', b'C', b'X', b'E', b'F', b'G', b'H']; // X is invalid","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(index, byte)) = result {","        assert_eq!(index, 3);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,206,207,208,209,252]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        b\"A\".iter().for_each(|&c| table[c as usize] = 0);","        b\"B\".iter().for_each(|&c| table[c as usize] = 1);","        b\"C\".iter().for_each(|&c| table[c as usize] = 2);","        b\"D\".iter().for_each(|&c| table[c as usize] = 3);","        table","    };","","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'F', b'G', b'H', b'I']; // Last symbol problematic","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(index, byte)) = result {","        assert_eq!(index, 6);","        assert_eq!(byte, b'H');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[174,175,176,177,178,179,180,181,183,184,185,186,187,192,193,194,195,196,201,202,203,204,205,210,211,212,213,214,215,216,217,218,252]]],"codes_branches":[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":true,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":true,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        // Setting up a basic Base64 decode table for valid characters only","        b\"A\".iter().for_each(|&c| table[c as usize] = 0);","        b\"B\".iter().for_each(|&c| table[c as usize] = 1);","        b\"C\".iter().for_each(|&c| table[c as usize] = 2);","        b\"D\".iter().for_each(|&c| table[c as usize] = 3);","        // Fill in other valid base64 characters ...","        table","    };","","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'E', b'F', b'G', b'H'];","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    ","    assert!(result.is_ok());","    assert_eq!(&output, &[0, 0, 0, 0, 0, 0]); // Expected output will depend on your decode table setup","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":true,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        b\"A\".iter().for_each(|&c| table[c as usize] = 0);","        b\"B\".iter().for_each(|&c| table[c as usize] = 1);","        b\"C\".iter().for_each(|&c| table[c as usize] = 2);","        b\"D\".iter().for_each(|&c| table[c as usize] = 3);","        table","    };","","    let input: [u8; 8] = [b'A', b'B', b'C', b'X', b'E', b'F', b'G', b'H']; // X is invalid","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(index, byte)) = result {","        assert_eq!(index, 3);","        assert_eq!(byte, b'X');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":true,"negative":false},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":false,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]],[["{","    let decode_table: [u8; 256] = {","        let mut table = [INVALID_VALUE; 256];","        b\"A\".iter().for_each(|&c| table[c as usize] = 0);","        b\"B\".iter().for_each(|&c| table[c as usize] = 1);","        b\"C\".iter().for_each(|&c| table[c as usize] = 2);","        b\"D\".iter().for_each(|&c| table[c as usize] = 3);","        table","    };","","    let input: [u8; 8] = [b'A', b'B', b'C', b'D', b'F', b'G', b'H', b'I']; // Last symbol problematic","    let mut output = [0u8; 6];","    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);","    ","    assert!(result.is_err());","    if let Err(DecodeError::InvalidByte(index, byte)) = result {","        assert_eq!(index, 6);","        assert_eq!(byte, b'H');","    } else {","        panic!(\"Expected InvalidByte error\");","    }","}"],[{"start_line":181,"start_column":8,"end_line":181,"end_column":31,"positive":false,"negative":true},{"start_line":187,"start_column":8,"end_line":187,"end_column":31,"positive":false,"negative":true},{"start_line":196,"start_column":8,"end_line":196,"end_column":31,"positive":false,"negative":true},{"start_line":205,"start_column":8,"end_line":205,"end_column":31,"positive":false,"negative":true},{"start_line":214,"start_column":8,"end_line":214,"end_column":31,"positive":true,"negative":false},{"start_line":223,"start_column":8,"end_line":223,"end_column":31,"positive":false,"negative":false},{"start_line":232,"start_column":8,"end_line":232,"end_column":31,"positive":false,"negative":false},{"start_line":241,"start_column":8,"end_line":241,"end_column":31,"positive":false,"negative":false}]]]}