{"function_name":"base64::engine::general_purpose::decode::decode_helper","tests":5,"tests_lines":[11,9,9,9,9],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":5,"tests_passed":0,"tests_passed_rate":0.0,"lines":72,"lines_covered":18,"lines_coveraged_rate":25.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,91,92,93,94,96,97,98,99,101,102,103,104,105,106,107,108,112,113,114,115,116,117,118,119,120,121],"codes_lines_covered":[[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ==\"; // \"Hello, World!\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Setup a valid decode table","    // Assume decode_table is filled properly with valid values for base64 decoding.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_ok());","    assert_eq!(&output[..13], b\"Hello, World!\");","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ==\"; // \"Hello, World!\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 5]; // Small output buffer","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_err());","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ==!!!\"; // Invalid characters \"!!!\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_err()); // Must produce an error due to invalid byte","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkI\"; // Invalid length","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_err()); // Must produce an error due to invalid length","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ===\"; // Invalid padding","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireNone);","    assert!(result.is_err()); // Must produce an error due to invalid padding","}"],[35,36,37,38,39,40,41,42,43,44,49,50,51,52,53,56,57,58]]],"codes_branches":[],"codes_branches_covered":[[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ==\"; // \"Hello, World!\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Setup a valid decode table","    // Assume decode_table is filled properly with valid values for base64 decoding.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_ok());","    assert_eq!(&output[..13], b\"Hello, World!\");","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ==\"; // \"Hello, World!\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 5]; // Small output buffer","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_err());","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ==!!!\"; // Invalid characters \"!!!\"","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_err()); // Must produce an error due to invalid byte","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkI\"; // Invalid length","    let estimate = GeneralPurposeEstimate { rem: 0, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireCanonical);","    assert!(result.is_err()); // Must produce an error due to invalid length","}"],[]],[["{","    let input: &[u8] = b\"SGVsbG8sIFdvcmxkIQ===\"; // Invalid padding","    let estimate = GeneralPurposeEstimate { rem: 2, conservative_decoded_len: 16 };","    let mut output = vec![0u8; 16];","    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Assume decode_table is filled properly.","","    let result = decode_helper(input, &estimate, &mut output, &decode_table, false, DecodePaddingMode::RequireNone);","    assert!(result.is_err()); // Must produce an error due to invalid padding","}"],[]]]}