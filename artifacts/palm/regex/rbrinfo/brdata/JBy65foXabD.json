{
  "name": "regex::prog::prog::Program::approximate_size",
  "name_with_impl": "regex::prog::{impl#0}::approximate_size",
  "mod_info": {
    "name": "prog",
    "loc": "src/lib.rs:660:1:660:10"
  },
  "visible": true,
  "loc": "src/prog.rs:147:5:158:6",
  "doc": "/// Return the approximate heap usage of this instruction sequence in\n/// bytes.\n",
  "code": [
    "pub fn approximate_size(&self) -> usize {",
    "    // The only instruction that uses heap space is Ranges (for",
    "    // Unicode codepoint programs) to store non-overlapping codepoint",
    "    // ranges. To keep this operation constant time, we ignore them.",
    "    (self.len() * mem::size_of::<Inst>())",
    "    + (self.matches.len() * mem::size_of::<InstPtr>())",
    "    + (self.captures.len() * mem::size_of::<Option<String>>())",
    "    + (self.capture_name_idx.len() *",
    "       (mem::size_of::<String>() + mem::size_of::<usize>()))",
    "    + (self.byte_classes.len() * mem::size_of::<u8>())",
    "    + self.prefixes.approximate_size()",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": "(self.len() * mem::size_of::<Inst>())\n        + (self.matches.len() * mem::size_of::<InstPtr>())\n        + (self.captures.len() * mem::size_of::<Option<String>>())\n        + (self.capture_name_idx.len() *\n           (mem::size_of::<String>() + mem::size_of::<usize>()))\n        + (self.byte_classes.len() * mem::size_of::<u8>())\n        + self.prefixes.approximate_size()",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}