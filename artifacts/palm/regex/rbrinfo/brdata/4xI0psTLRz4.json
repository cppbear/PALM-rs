{
  "name": "regex::dfa::dfa::Fsm<'a>::start_state",
  "name_with_impl": "regex::dfa::{impl#5}::start_state",
  "mod_info": {
    "name": "dfa",
    "loc": "src/lib.rs:650:1:650:9"
  },
  "visible": false,
  "loc": "src/dfa.rs:1380:5:1419:6",
  "doc": "/// Computes and returns the start state, where searching begins at\n/// position `at` in `text`. If the state has already been computed,\n/// then it is pulled from the cache. If the state hasn't been cached,\n/// then it is computed, cached and a pointer to it is returned.\n///\n/// This may return STATE_DEAD but never STATE_UNKNOWN.\n",
  "code": [
    "fn start_state(",
    "    &mut self,",
    "    q: &mut SparseSet,",
    "    empty_flags: EmptyFlags,",
    "    state_flags: StateFlags,",
    ") -> Option<StatePtr> {",
    "    // Compute an index into our cache of start states based on the set",
    "    // of empty/state flags set at the current position in the input. We",
    "    // don't use every flag since not all flags matter. For example, since",
    "    // matches are delayed by one byte, start states can never be match",
    "    // states.",
    "    let flagi = {",
    "        (((empty_flags.start as u8) << 0) |",
    "         ((empty_flags.end as u8) << 1) |",
    "         ((empty_flags.start_line as u8) << 2) |",
    "         ((empty_flags.end_line as u8) << 3) |",
    "         ((empty_flags.word_boundary as u8) << 4) |",
    "         ((empty_flags.not_word_boundary as u8) << 5) |",
    "         ((state_flags.is_word() as u8) << 6))",
    "        as usize",
    "    };",
    "    match self.cache.start_states[flagi] {",
    "        STATE_UNKNOWN => {}",
    "        STATE_DEAD => return Some(STATE_DEAD),",
    "        si => return Some(si),",
    "    }",
    "    q.clear();",
    "    let start = usize_to_u32(self.prog.start);",
    "    self.follow_epsilons(start, q, empty_flags);",
    "    // Start states can never be match states because we delay every match",
    "    // by one byte. Given an empty string and an empty match, the match",
    "    // won't actually occur until the DFA processes the special EOF",
    "    // sentinel byte.",
    "    let sp = match self.cached_state(q, state_flags, None) {",
    "        None => return None,",
    "        Some(sp) => self.start_ptr(sp),",
    "    };",
    "    self.cache.start_states[flagi] = sp;",
    "    Some(sp)",
    "}"
  ],
  "size": {
    "chain": 4,
    "contra": 0,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.cache.start_states[flagi] matches si",
          "norm": null,
          "value": "true",
          "line": 1404,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(si)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.cache.start_states[flagi] matches STATE_DEAD",
          "norm": null,
          "value": "true",
          "line": 1401,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(STATE_DEAD)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        12,
        14,
        25,
        26,
        27
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "self.cache.start_states[flagi] matches STATE_UNKNOWN",
          "norm": null,
          "value": "true",
          "line": 1401,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cached_state(q, state_flags, None) matches Some(sp)",
          "norm": null,
          "value": "true",
          "line": 1413,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cache.start_states[flagi]",
          "norm": null,
          "value": "",
          "line": 1417,
          "bound": null,
          "may_panic": true
        }
      ],
      "ret": "Some(sp)",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        13,
        15,
        16,
        17,
        18,
        21,
        23,
        24,
        27
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "self.cache.start_states[flagi] matches STATE_UNKNOWN",
          "norm": null,
          "value": "true",
          "line": 1401,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cached_state(q, state_flags, None) matches None",
          "norm": null,
          "value": "true",
          "line": 1413,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cached_state(q, state_flags, None) matches None",
          "norm": null,
          "value": "true",
          "line": 1413,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        13,
        15,
        16,
        17,
        18,
        20,
        22,
        26,
        27
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}