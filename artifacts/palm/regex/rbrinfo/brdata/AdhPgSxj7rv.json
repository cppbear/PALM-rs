{
  "name": "regex::re_unicode::re_unicode::Regex::captures",
  "name_with_impl": "regex::re_unicode::{impl#6}::captures",
  "mod_info": {
    "name": "re_unicode",
    "loc": "src/lib.rs:665:1:665:16"
  },
  "visible": true,
  "loc": "src/re_unicode.rs:311:5:318:6",
  "doc": "/// Returns the capture groups corresponding to the leftmost-first\n/// match in `text`. Capture group `0` always corresponds to the entire\n/// match. If no match is found, then `None` is returned.\n///\n/// You should only use `captures` if you need access to the location of\n/// capturing group matches. Otherwise, `find` is faster for discovering\n/// the location of the overall match.\n///\n/// # Examples\n///\n/// Say you have some text with movie names and their release years,\n/// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n/// looking like that, while also extracting the movie name and its release\n/// year separately.\n///\n/// ```rust\n/// # extern crate regex; use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n/// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(text).unwrap();\n/// assert_eq!(caps.get(1).unwrap().as_str(), \"Citizen Kane\");\n/// assert_eq!(caps.get(2).unwrap().as_str(), \"1941\");\n/// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n/// // You can also access the groups by index using the Index notation.\n/// // Note that this will panic on an invalid index.\n/// assert_eq!(&caps[1], \"Citizen Kane\");\n/// assert_eq!(&caps[2], \"1941\");\n/// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n/// # }\n/// ```\n///\n/// Note that the full match is at capture group `0`. Each subsequent\n/// capture group is indexed by the order of its opening `(`.\n///\n/// We can make this example a bit clearer by using *named* capture groups:\n///\n/// ```rust\n/// # extern crate regex; use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n///                .unwrap();\n/// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(text).unwrap();\n/// assert_eq!(&caps[\"title\"], \"Citizen Kane\");\n/// assert_eq!(&caps[\"year\"], \"1941\");\n/// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n/// // You can also access the groups by name using the Index notation.\n/// // Note that this will panic on an invalid group name.\n/// assert_eq!(&caps[\"title\"], \"Citizen Kane\");\n/// assert_eq!(&caps[\"year\"], \"1941\");\n/// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n///\n/// # }\n/// ```\n///\n/// Here we name the capture groups, which we can access with the `name`\n/// method or the `Index` notation with a `&str`. Note that the named\n/// capture groups are still accessible with `get` or the `Index` notation\n/// with a `usize`.\n///\n/// The `0`th capture group is always unnamed, so it must always be\n/// accessed with `get(0)` or `[0]`.\n",
  "code": [
    "pub fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>> {",
    "    let mut locs = self.locations();",
    "    self.read_captures_at(&mut locs, text, 0).map(|_| Captures {",
    "        text: text,",
    "        locs: locs,",
    "        named_groups: self.0.capture_name_idx().clone(),",
    "    })",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}