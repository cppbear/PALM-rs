{
  "name": "regex::re_bytes::re_bytes::Regex::replace",
  "name_with_impl": "regex::re_bytes::{impl#5}::replace",
  "mod_info": {
    "name": "re_bytes",
    "loc": "src/lib.rs:662:1:662:14"
  },
  "visible": true,
  "loc": "src/re_bytes.rs:462:5:468:6",
  "doc": "/// Replaces the leftmost-first match with the replacement provided. The\n/// replacement can be a regular byte string (where `$N` and `$name` are\n/// expanded to match capture groups) or a function that takes the matches'\n/// `Captures` and returns the replaced byte string.\n///\n/// If no match is found, then a copy of the byte string is returned\n/// unchanged.\n///\n/// # Replacement string syntax\n///\n/// All instances of `$name` in the replacement text is replaced with the\n/// corresponding capture group `name`.\n///\n/// `name` may be an integer corresponding to the index of the\n/// capture group (counted by order of opening parenthesis where `0` is the\n/// entire match) or it can be a name (consisting of letters, digits or\n/// underscores) corresponding to a named capture group.\n///\n/// If `name` isn't a valid capture group (whether the name doesn't exist\n/// or isn't a valid index), then it is replaced with the empty string.\n///\n/// The longest possible name is used. e.g., `$1a` looks up the capture\n/// group named `1a` and not the capture group at index `1`. To exert more\n/// precise control over the name, use braces, e.g., `${1}a`.\n///\n/// To write a literal `$` use `$$`.\n///\n/// # Examples\n///\n/// Note that this function is polymorphic with respect to the replacement.\n/// In typical usage, this can just be a normal byte string:\n///\n/// ```rust\n/// # extern crate regex; use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(\"[^01]+\").unwrap();\n/// assert_eq!(re.replace(b\"1078910\", &b\"\"[..]), &b\"1010\"[..]);\n/// # }\n/// ```\n///\n/// But anything satisfying the `Replacer` trait will work. For example, a\n/// closure of type `|&Captures| -> Vec<u8>` provides direct access to the\n/// captures corresponding to a match. This allows one to access capturing\n/// group matches easily:\n///\n/// ```rust\n/// # extern crate regex; use regex::bytes::Regex;\n/// # use regex::bytes::Captures; fn main() {\n/// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(b\"Springsteen, Bruce\", |caps: &Captures| {\n///     let mut replacement = caps[2].to_owned();\n///     replacement.push(b' ');\n///     replacement.extend(&caps[1]);\n///     replacement\n/// });\n/// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n/// # }\n/// ```\n///\n/// But this is a bit cumbersome to use all the time. Instead, a simple\n/// syntax is supported that expands `$name` into the corresponding capture\n/// group. Here's the last example, but using this expansion technique\n/// with named capture groups:\n///\n/// ```rust\n/// # extern crate regex; use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n/// let result = re.replace(b\"Springsteen, Bruce\", &b\"$first $last\"[..]);\n/// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n/// # }\n/// ```\n///\n/// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n/// would produce the same result. To write a literal `$` use `$$`.\n///\n/// Sometimes the replacement string requires use of curly braces to\n/// delineate a capture group replacement and surrounding literal text.\n/// For example, if we wanted to join two words together with an\n/// underscore:\n///\n/// ```rust\n/// # extern crate regex; use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n/// let result = re.replace(b\"deep fried\", &b\"${first}_$second\"[..]);\n/// assert_eq!(result, &b\"deep_fried\"[..]);\n/// # }\n/// ```\n///\n/// Without the curly braces, the capture group name `first_` would be\n/// used, and since it doesn't exist, it would be replaced with the empty\n/// string.\n///\n/// Finally, sometimes you just want to replace a literal string with no\n/// regard for capturing group expansion. This can be done by wrapping a\n/// byte string with `NoExpand`:\n///\n/// ```rust\n/// # extern crate regex; use regex::bytes::Regex;\n/// # fn main() {\n/// use regex::bytes::NoExpand;\n///\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(b\"Springsteen, Bruce\", NoExpand(b\"$2 $last\"));\n/// assert_eq!(result, &b\"$2 $last\"[..]);\n/// # }\n/// ```\n",
  "code": [
    "pub fn replace<'t, R: Replacer>(",
    "    &self,",
    "    text: &'t [u8],",
    "    rep: R,",
    ") -> Cow<'t, [u8]> {",
    "    self.replacen(text, 1, rep)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}