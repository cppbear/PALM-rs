{
  "name": "regex::dfa::dfa::Fsm<'a>::next_state",
  "name_with_impl": "regex::dfa::{impl#5}::next_state",
  "mod_info": {
    "name": "dfa",
    "loc": "src/lib.rs:650:1:650:9"
  },
  "visible": false,
  "loc": "src/dfa.rs:1355:5:1371:6",
  "doc": "/// Returns the next state given the current state si and current byte\n/// b. {qcur,qnext} are used as scratch space for storing ordered NFA\n/// states.\n///\n/// This tries to fetch the next state from the cache, but if that fails,\n/// it computes the next state, caches it and returns a pointer to it.\n///\n/// The pointer can be to a real state, or it can be STATE_DEAD.\n/// STATE_UNKNOWN cannot be returned.\n///\n/// None is returned if a new state could not be allocated (i.e., the DFA\n/// ran out of space and thinks it's running too slowly).\n",
  "code": [
    "fn next_state(",
    "    &mut self,",
    "    qcur: &mut SparseSet,",
    "    qnext: &mut SparseSet,",
    "    si: StatePtr,",
    "    b: Byte,",
    ") -> Option<StatePtr> {",
    "    if si == STATE_DEAD {",
    "        return Some(STATE_DEAD);",
    "    }",
    "    match self.cache.trans.next(si, self.byte_class(b)) {",
    "        STATE_UNKNOWN => self.exec_byte(qcur, qnext, si, b),",
    "        STATE_QUIT => None,",
    "        STATE_DEAD => Some(STATE_DEAD),",
    "        nsi => Some(nsi),",
    "    }",
    "}"
  ],
  "size": {
    "chain": 5,
    "contra": 0,
    "min_set": 5
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "si == STATE_DEAD",
          "norm": "STATE_DEAD == si",
          "value": "true",
          "line": 1362,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(STATE_DEAD)",
      "path": [
        0,
        1,
        14
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "si == STATE_DEAD",
          "norm": "STATE_DEAD == si",
          "value": "false",
          "line": 1362,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cache.trans.next(si, self.byte_class(b)) matches nsi",
          "norm": null,
          "value": "true",
          "line": 1369,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(nsi)",
      "path": [
        0,
        2,
        3,
        4,
        5,
        13,
        14
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "si == STATE_DEAD",
          "norm": "STATE_DEAD == si",
          "value": "false",
          "line": 1362,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cache.trans.next(si, self.byte_class(b)) matches STATE_DEAD",
          "norm": null,
          "value": "true",
          "line": 1365,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(STATE_DEAD)",
      "path": [
        0,
        2,
        3,
        4,
        8,
        12,
        13,
        14
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "si == STATE_DEAD",
          "norm": "STATE_DEAD == si",
          "value": "false",
          "line": 1362,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cache.trans.next(si, self.byte_class(b)) matches STATE_QUIT",
          "norm": null,
          "value": "true",
          "line": 1365,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "None",
      "path": [
        0,
        2,
        3,
        4,
        7,
        11,
        13,
        14
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "si == STATE_DEAD",
          "norm": "STATE_DEAD == si",
          "value": "false",
          "line": 1362,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cache.trans.next(si, self.byte_class(b)) matches STATE_UNKNOWN",
          "norm": null,
          "value": "true",
          "line": 1365,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        2,
        3,
        4,
        6,
        9,
        10,
        13,
        14
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}