{
  "name": "regex::compile::compile::Compiler::c",
  "name_with_impl": "regex::compile::{impl#0}::c",
  "mod_info": {
    "name": "compile",
    "loc": "src/lib.rs:649:1:649:13"
  },
  "visible": false,
  "loc": "src/compile.rs:258:5:363:6",
  "doc": "/// Compile expr into self.insts, returning a patch on success,\n/// or an error if we run out of memory.\n///\n/// All of the c_* methods of the compiler share the contract outlined\n/// here.\n///\n/// The main thing that a c_* method does is mutate `self.insts`\n/// to add a list of mostly compiled instructions required to execute\n/// the given expression. `self.insts` contains MaybeInsts rather than\n/// Insts because there is some backpatching required.\n///\n/// The `Patch` value returned by each c_* method provides metadata\n/// about the compiled instructions emitted to `self.insts`. The\n/// `entry` member of the patch refers to the first instruction\n/// (the entry point), while the `hole` member contains zero or\n/// more offsets to partial instructions that need to be backpatched.\n/// The c_* routine can't know where its list of instructions are going to\n/// jump to after execution, so it is up to the caller to patch\n/// these jumps to point to the right place. So compiling some\n/// expression, e, we would end up with a situation that looked like:\n///\n/// ```text\n/// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n///                     ^              ^             ^\n///                     |                \\         /\n///                   entry                \\     /\n///                                         hole\n/// ```\n///\n/// To compile two expressions, e1 and e2, concatinated together we\n/// would do:\n///\n/// ```ignore\n/// let patch1 = self.c(e1);\n/// let patch2 = self.c(e2);\n/// ```\n///\n/// while leaves us with a situation that looks like\n///\n/// ```text\n/// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n///                     ^        ^            ^        ^\n///                     |        |            |        |\n///                entry1        hole1   entry2        hole2\n/// ```\n///\n/// Then to merge the two patches together into one we would backpatch\n/// hole1 with entry2 and return a new patch that enters at entry1\n/// and has hole2 for a hole. In fact, if you look at the c_concat\n/// method you will see that it does exactly this, though it handles\n/// a list of expressions rather than just the two that we use for\n/// an example.\n",
  "code": [
    "fn c(&mut self, expr: &Hir) -> Result {",
    "    use prog;",
    "    use syntax::hir::HirKind::*;",
    "",
    "    self.check_size()?;",
    "    match *expr.kind() {",
    "        Empty => Ok(Patch { hole: Hole::None, entry: self.insts.len() }),",
    "        Literal(hir::Literal::Unicode(c)) => {",
    "            self.c_literal(&[c])",
    "        }",
    "        Literal(hir::Literal::Byte(b)) => {",
    "            assert!(self.compiled.uses_bytes());",
    "            self.c_bytes(&[b])",
    "        }",
    "        Class(hir::Class::Unicode(ref cls)) => {",
    "            self.c_class(cls.ranges())",
    "        }",
    "        Class(hir::Class::Bytes(ref cls)) => {",
    "            if self.compiled.uses_bytes() {",
    "                self.c_class_bytes(cls.ranges())",
    "            } else {",
    "                assert!(cls.is_all_ascii());",
    "                let mut char_ranges = vec![];",
    "                for r in cls.iter() {",
    "                    let (s, e) = (r.start() as char, r.end() as char);",
    "                    char_ranges.push(hir::ClassUnicodeRange::new(s, e));",
    "                }",
    "                self.c_class(&char_ranges)",
    "            }",
    "        }",
    "        Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {",
    "            self.byte_classes.set_range(b'\\n', b'\\n');",
    "            self.c_empty_look(prog::EmptyLook::EndLine)",
    "        }",
    "        Anchor(hir::Anchor::StartLine) => {",
    "            self.byte_classes.set_range(b'\\n', b'\\n');",
    "            self.c_empty_look(prog::EmptyLook::StartLine)",
    "        }",
    "        Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {",
    "            self.byte_classes.set_range(b'\\n', b'\\n');",
    "            self.c_empty_look(prog::EmptyLook::StartLine)",
    "        }",
    "        Anchor(hir::Anchor::EndLine) => {",
    "            self.byte_classes.set_range(b'\\n', b'\\n');",
    "            self.c_empty_look(prog::EmptyLook::EndLine)",
    "        }",
    "        Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {",
    "            self.c_empty_look(prog::EmptyLook::EndText)",
    "        }",
    "        Anchor(hir::Anchor::StartText) => {",
    "            self.c_empty_look(prog::EmptyLook::StartText)",
    "        }",
    "        Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {",
    "            self.c_empty_look(prog::EmptyLook::StartText)",
    "        }",
    "        Anchor(hir::Anchor::EndText) => {",
    "            self.c_empty_look(prog::EmptyLook::EndText)",
    "        }",
    "        WordBoundary(hir::WordBoundary::Unicode) => {",
    "            self.compiled.has_unicode_word_boundary = true;",
    "            self.byte_classes.set_word_boundary();",
    "            self.c_empty_look(prog::EmptyLook::WordBoundary)",
    "        }",
    "        WordBoundary(hir::WordBoundary::UnicodeNegate) => {",
    "            self.compiled.has_unicode_word_boundary = true;",
    "            self.byte_classes.set_word_boundary();",
    "            self.c_empty_look(prog::EmptyLook::NotWordBoundary)",
    "        }",
    "        WordBoundary(hir::WordBoundary::Ascii) => {",
    "            self.byte_classes.set_word_boundary();",
    "            self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)",
    "        }",
    "        WordBoundary(hir::WordBoundary::AsciiNegate) => {",
    "            self.byte_classes.set_word_boundary();",
    "            self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)",
    "        }",
    "        Group(ref g) => {",
    "            match g.kind {",
    "                hir::GroupKind::NonCapturing => self.c(&g.hir),",
    "                hir::GroupKind::CaptureIndex(index) => {",
    "                    if index as usize >= self.compiled.captures.len() {",
    "                        self.compiled.captures.push(None);",
    "                    }",
    "                    self.c_capture(2 * index as usize, &g.hir)",
    "                }",
    "                hir::GroupKind::CaptureName { index, ref name } => {",
    "                    if index as usize >= self.compiled.captures.len() {",
    "                        let n = name.to_string();",
    "                        self.compiled.captures.push(Some(n.clone()));",
    "                        self.capture_name_idx.insert(n, index as usize);",
    "                    }",
    "                    self.c_capture(2 * index as usize, &g.hir)",
    "                }",
    "            }",
    "        }",
    "        Concat(ref es) => {",
    "            if self.compiled.is_reverse {",
    "                self.c_concat(es.iter().rev())",
    "            } else {",
    "                self.c_concat(es)",
    "            }",
    "        }",
    "        Alternation(ref es) => self.c_alternate(&**es),",
    "        Repetition(ref rep) => self.c_repeat(rep),",
    "    }",
    "}"
  ],
  "size": {
    "chain": 31,
    "contra": 1,
    "min_set": 30
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Err/None",
          "line": 262,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        6,
        7,
        159,
        160,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Alternation(ref es)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Alternation(ref es)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        34,
        154,
        155,
        156,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Concat(ref es)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Concat(ref es)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "true",
          "line": 354,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        33,
        145,
        146,
        147,
        148,
        149,
        150,
        153,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Concat(ref es)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Concat(ref es)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "false",
          "line": 354,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        33,
        145,
        151,
        152,
        153,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::NonCapturing",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::NonCapturing",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        32,
        117,
        119,
        122,
        123,
        144,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::CaptureName { index, ref name }",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index as usize >= self.compiled.captures.len()",
          "norm": null,
          "value": "true",
          "line": 344,
          "bound": "index as usize == self.compiled.captures.len()",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        32,
        117,
        121,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        141,
        142,
        143,
        144,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::CaptureName { index, ref name }",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index as usize >= self.compiled.captures.len()",
          "norm": null,
          "value": "false",
          "line": 344,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        32,
        117,
        121,
        132,
        140,
        141,
        142,
        143,
        144,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::CaptureIndex(index)",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::CaptureIndex(index)",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index as usize >= self.compiled.captures.len()",
          "norm": null,
          "value": "true",
          "line": 338,
          "bound": "index as usize == self.compiled.captures.len()",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        32,
        117,
        120,
        124,
        125,
        126,
        127,
        129,
        130,
        131,
        144,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Group(ref g)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::CaptureIndex(index)",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "g.kind matches hir::GroupKind::CaptureIndex(index)",
          "norm": null,
          "value": "true",
          "line": 335,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "index as usize >= self.compiled.captures.len()",
          "norm": null,
          "value": "false",
          "line": 338,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        32,
        117,
        120,
        124,
        125,
        128,
        129,
        130,
        131,
        144,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Repetition(ref rep)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        35,
        157,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::Ascii) or WordBoundary(hir::WordBoundary::AsciiNegate) or WordBoundary(hir::WordBoundary::Unicode) or WordBoundary(hir::WordBoundary::UnicodeNegate)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::AsciiNegate)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        27,
        31,
        114,
        115,
        116,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::Ascii) or WordBoundary(hir::WordBoundary::AsciiNegate) or WordBoundary(hir::WordBoundary::Unicode) or WordBoundary(hir::WordBoundary::UnicodeNegate)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::Ascii)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        27,
        30,
        111,
        112,
        113,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::Ascii) or WordBoundary(hir::WordBoundary::AsciiNegate) or WordBoundary(hir::WordBoundary::Unicode) or WordBoundary(hir::WordBoundary::UnicodeNegate)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::UnicodeNegate)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        27,
        29,
        108,
        109,
        110,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 14,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::Ascii) or WordBoundary(hir::WordBoundary::AsciiNegate) or WordBoundary(hir::WordBoundary::Unicode) or WordBoundary(hir::WordBoundary::UnicodeNegate)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Empty",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches WordBoundary(hir::WordBoundary::Unicode)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        27,
        28,
        105,
        106,
        107,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 15,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndText)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "true",
          "line": 310,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        25,
        99,
        100,
        102,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 16,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndText)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "false",
          "line": 310,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndText)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        25,
        99,
        101,
        26,
        103,
        104,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 17,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::StartText)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "true",
          "line": 304,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        23,
        93,
        94,
        96,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 18,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::StartText)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "false",
          "line": 304,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::StartText)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        23,
        93,
        95,
        24,
        97,
        98,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 19,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "true",
          "line": 296,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        21,
        85,
        86,
        88,
        89,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 20,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "false",
          "line": 296,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        21,
        85,
        87,
        22,
        90,
        91,
        92,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 21,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Empty",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "true",
          "line": 288,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        19,
        77,
        78,
        80,
        81,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 22,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::EndLine) or Anchor(hir::Anchor::StartText) or Anchor(hir::Anchor::EndText) or Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Empty",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.is_reverse",
          "norm": null,
          "value": "false",
          "line": 288,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Anchor(hir::Anchor::StartLine)",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        18,
        19,
        77,
        79,
        20,
        82,
        83,
        84,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 23,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.uses_bytes()",
          "norm": null,
          "value": "true",
          "line": 276,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        15,
        17,
        50,
        51,
        52,
        53,
        54,
        76,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 24,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.uses_bytes()",
          "norm": null,
          "value": "false",
          "line": 276,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "cls.is_all_ascii()",
          "norm": null,
          "value": "true",
          "line": 279,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "true",
          "line": 281,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 281,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        15,
        17,
        50,
        51,
        55,
        56,
        57,
        59,
        60,
        61,
        62,
        63,
        64,
        67,
        69,
        70,
        71,
        72,
        62,
        63,
        64,
        66,
        68,
        73,
        74,
        75,
        76,
        158,
        161
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 25,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.uses_bytes()",
          "norm": null,
          "value": "false",
          "line": 276,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "cls.is_all_ascii()",
          "norm": null,
          "value": "true",
          "line": 279,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "r in cls.iter()",
          "norm": null,
          "value": "false",
          "line": 281,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        15,
        17,
        50,
        51,
        55,
        56,
        57,
        59,
        60,
        61,
        62,
        63,
        64,
        66,
        68,
        73,
        74,
        75,
        76,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 26,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.uses_bytes()",
          "norm": null,
          "value": "false",
          "line": 276,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "cls.is_all_ascii()",
          "norm": null,
          "value": "false",
          "line": 279,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        15,
        17,
        50,
        51,
        55,
        56,
        58,
        173
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 27,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Bytes(ref cls)) or Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Empty",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Class(hir::Class::Unicode(ref cls))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        15,
        16,
        47,
        48,
        49,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 28,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.uses_bytes()",
          "norm": null,
          "value": "true",
          "line": 269,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        12,
        14,
        42,
        43,
        44,
        46,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 29,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.compiled.uses_bytes()",
          "norm": null,
          "value": "false",
          "line": 269,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        12,
        14,
        42,
        43,
        45,
        173
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 30,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c)) or Literal(hir::Literal::Byte(b))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Empty",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Literal(hir::Literal::Unicode(c))",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        12,
        13,
        40,
        41,
        158,
        161
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 31,
      "conds": [
        {
          "cond": "self.check_size()?",
          "norm": null,
          "value": "Ok/Some",
          "line": 262,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Empty",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "*expr.kind() matches Empty",
          "norm": null,
          "value": "true",
          "line": 263,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Ok(Patch { hole: Hole::None, entry: self.insts.len() })",
      "path": [
        0,
        1,
        2,
        5,
        8,
        9,
        11,
        36,
        37,
        38,
        39,
        158,
        161
      ],
      "may_contra": false,
      "min_set": false
    }
  ]
}