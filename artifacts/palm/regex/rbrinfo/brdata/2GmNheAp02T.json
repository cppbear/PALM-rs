{
  "name": "regex::re_unicode::re_unicode::Regex::replace",
  "name_with_impl": "regex::re_unicode::{impl#6}::replace",
  "mod_info": {
    "name": "re_unicode",
    "loc": "src/lib.rs:665:1:665:16"
  },
  "visible": true,
  "loc": "src/re_unicode.rs:509:5:515:6",
  "doc": "/// Replaces the leftmost-first match with the replacement provided.\n/// The replacement can be a regular string (where `$N` and `$name` are\n/// expanded to match capture groups) or a function that takes the matches'\n/// `Captures` and returns the replaced string.\n///\n/// If no match is found, then a copy of the string is returned unchanged.\n///\n/// # Replacement string syntax\n///\n/// All instances of `$name` in the replacement text is replaced with the\n/// corresponding capture group `name`.\n///\n/// `name` may be an integer corresponding to the index of the\n/// capture group (counted by order of opening parenthesis where `0` is the\n/// entire match) or it can be a name (consisting of letters, digits or\n/// underscores) corresponding to a named capture group.\n///\n/// If `name` isn't a valid capture group (whether the name doesn't exist\n/// or isn't a valid index), then it is replaced with the empty string.\n///\n/// The longest possible name is used. e.g., `$1a` looks up the capture\n/// group named `1a` and not the capture group at index `1`. To exert more\n/// precise control over the name, use braces, e.g., `${1}a`.\n///\n/// To write a literal `$` use `$$`.\n///\n/// # Examples\n///\n/// Note that this function is polymorphic with respect to the replacement.\n/// In typical usage, this can just be a normal string:\n///\n/// ```rust\n/// # extern crate regex; use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(\"[^01]+\").unwrap();\n/// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n/// # }\n/// ```\n///\n/// But anything satisfying the `Replacer` trait will work. For example,\n/// a closure of type `|&Captures| -> String` provides direct access to the\n/// captures corresponding to a match. This allows one to access\n/// capturing group matches easily:\n///\n/// ```rust\n/// # extern crate regex; use regex::Regex;\n/// # use regex::Captures; fn main() {\n/// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n///     format!(\"{} {}\", &caps[2], &caps[1])\n/// });\n/// assert_eq!(result, \"Bruce Springsteen\");\n/// # }\n/// ```\n///\n/// But this is a bit cumbersome to use all the time. Instead, a simple\n/// syntax is supported that expands `$name` into the corresponding capture\n/// group. Here's the last example, but using this expansion technique\n/// with named capture groups:\n///\n/// ```rust\n/// # extern crate regex; use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n/// assert_eq!(result, \"Bruce Springsteen\");\n/// # }\n/// ```\n///\n/// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n/// would produce the same result. To write a literal `$` use `$$`.\n///\n/// Sometimes the replacement string requires use of curly braces to\n/// delineate a capture group replacement and surrounding literal text.\n/// For example, if we wanted to join two words together with an\n/// underscore:\n///\n/// ```rust\n/// # extern crate regex; use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n/// let result = re.replace(\"deep fried\", \"${first}_$second\");\n/// assert_eq!(result, \"deep_fried\");\n/// # }\n/// ```\n///\n/// Without the curly braces, the capture group name `first_` would be\n/// used, and since it doesn't exist, it would be replaced with the empty\n/// string.\n///\n/// Finally, sometimes you just want to replace a literal string with no\n/// regard for capturing group expansion. This can be done by wrapping a\n/// byte string with `NoExpand`:\n///\n/// ```rust\n/// # extern crate regex; use regex::Regex;\n/// # fn main() {\n/// use regex::NoExpand;\n///\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n/// assert_eq!(result, \"$2 $last\");\n/// # }\n/// ```\n",
  "code": [
    "pub fn replace<'t, R: Replacer>(",
    "    &self,",
    "    text: &'t str,",
    "    rep: R,",
    ") -> Cow<'t, str> {",
    "    self.replacen(text, 1, rep)",
    "}"
  ],
  "size": {
    "chain": 1,
    "contra": 0,
    "min_set": 1
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [],
      "ret": null,
      "path": [
        0,
        1,
        2
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}