{
  "name": "regex::dfa::dfa::Fsm<'a>::follow_epsilons",
  "name_with_impl": "regex::dfa::{impl#5}::follow_epsilons",
  "mod_info": {
    "name": "dfa",
    "loc": "src/lib.rs:650:1:650:9"
  },
  "visible": false,
  "loc": "src/dfa.rs:1073:5:1144:6",
  "doc": "/// Follows the epsilon transitions starting at (and including) `ip`. The\n/// resulting states are inserted into the ordered set `q`.\n///\n/// Conditional epsilon transitions (i.e., empty width assertions) are only\n/// followed if they are satisfied by the given flags, which should\n/// represent the flags set at the current location in the input.\n///\n/// If the current location corresponds to the empty string, then only the\n/// end line and/or end text flags may be set. If the current location\n/// corresponds to a real byte in the input, then only the start line\n/// and/or start text flags may be set.\n///\n/// As an exception to the above, when finding the initial state, any of\n/// the above flags may be set:\n///\n/// If matching starts at the beginning of the input, then start text and\n/// start line should be set. If the input is empty, then end text and end\n/// line should also be set.\n///\n/// If matching starts after the beginning of the input, then only start\n/// line should be set if the preceding byte is `\\n`. End line should never\n/// be set in this case. (Even if the proceding byte is a `\\n`, it will\n/// be handled in a subsequent DFA state.)\n",
  "code": [
    "fn follow_epsilons(",
    "    &mut self,",
    "    ip: InstPtr,",
    "    q: &mut SparseSet,",
    "    flags: EmptyFlags,",
    ") {",
    "    use prog::Inst::*;",
    "    use prog::EmptyLook::*;",
    "",
    "    // We need to traverse the NFA to follow epsilon transitions, so avoid",
    "    // recursion with an explicit stack.",
    "    self.cache.stack.push(ip);",
    "    while let Some(mut ip) = self.cache.stack.pop() {",
    "        // Try to munch through as many states as possible without",
    "        // pushes/pops to the stack.",
    "        loop {",
    "            // Don't visit states we've already added.",
    "            if q.contains(ip as usize) {",
    "                break;",
    "            }",
    "            q.insert(ip as usize);",
    "            match self.prog[ip as usize] {",
    "                Char(_) | Ranges(_) => unreachable!(),",
    "                Match(_) | Bytes(_) => {",
    "                    break;",
    "                }",
    "                EmptyLook(ref inst) => {",
    "                    // Only follow empty assertion states if our flags",
    "                    // satisfy the assertion.",
    "                    match inst.look {",
    "                        StartLine if flags.start_line => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        EndLine if flags.end_line => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        StartText if flags.start => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        EndText if flags.end => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        WordBoundaryAscii if flags.word_boundary => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        NotWordBoundaryAscii if flags.not_word_boundary => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        WordBoundary if flags.word_boundary => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        NotWordBoundary if flags.not_word_boundary => {",
    "                            ip = inst.goto as InstPtr;",
    "                        }",
    "                        StartLine | EndLine | StartText | EndText",
    "                        | WordBoundaryAscii | NotWordBoundaryAscii",
    "                        | WordBoundary | NotWordBoundary => {",
    "                            break;",
    "                        }",
    "                    }",
    "                }",
    "                Save(ref inst) => {",
    "                    ip = inst.goto as InstPtr;",
    "                }",
    "                Split(ref inst) => {",
    "                    self.cache.stack.push(inst.goto2 as InstPtr);",
    "                    ip = inst.goto1 as InstPtr;",
    "                }",
    "            }",
    "        }",
    "    }",
    "}"
  ],
  "size": {
    "chain": 24,
    "contra": 10,
    "min_set": 23
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Bytes(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Bytes(_) or Match(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        20,
        22,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Ranges(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Ranges(_) or Char(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        19,
        21,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Char(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Ranges(_) or Char(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        19,
        21,
        65
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 6,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundaryAscii or NotWordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.not_word_boundary",
          "norm": null,
          "value": "true",
          "line": 1118,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        30,
        49,
        50,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 7,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundaryAscii or NotWordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.not_word_boundary",
          "norm": null,
          "value": "false",
          "line": 1118,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        30,
        49,
        51,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 8,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundaryAscii or WordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.word_boundary",
          "norm": null,
          "value": "true",
          "line": 1115,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        29,
        46,
        47,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 9,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundaryAscii or WordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundaryAscii",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.word_boundary",
          "norm": null,
          "value": "false",
          "line": 1115,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        29,
        46,
        48,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 10,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundary or NotWordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.not_word_boundary",
          "norm": null,
          "value": "true",
          "line": 1124,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        32,
        55,
        56,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 11,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundary or NotWordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches NotWordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.not_word_boundary",
          "norm": null,
          "value": "false",
          "line": 1124,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        32,
        55,
        57,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 12,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundary or WordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.word_boundary",
          "norm": null,
          "value": "true",
          "line": 1121,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        31,
        52,
        53,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 13,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundary or WordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches WordBoundary",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.word_boundary",
          "norm": null,
          "value": "false",
          "line": 1121,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        31,
        52,
        54,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 14,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndText or EndText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.end",
          "norm": null,
          "value": "true",
          "line": 1112,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        28,
        43,
        44,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 15,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndText or EndText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.end",
          "norm": null,
          "value": "false",
          "line": 1112,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        28,
        43,
        45,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 16,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartText or StartText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.start",
          "norm": null,
          "value": "true",
          "line": 1109,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        27,
        40,
        41,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 17,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartText or StartText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartText",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.start",
          "norm": null,
          "value": "false",
          "line": 1109,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        27,
        40,
        42,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 18,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndLine or EndLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.end_line",
          "norm": null,
          "value": "true",
          "line": 1106,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        26,
        37,
        38,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 19,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndLine or EndLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches EndLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.end_line",
          "norm": null,
          "value": "false",
          "line": 1106,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        26,
        37,
        39,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 20,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartLine or StartLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.start_line",
          "norm": null,
          "value": "true",
          "line": 1103,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        25,
        34,
        35,
        58,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 21,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches EmptyLook(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartLine or StartLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "inst.look matches StartLine",
          "norm": null,
          "value": "true",
          "line": 1102,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "flags.start_line",
          "norm": null,
          "value": "false",
          "line": 1103,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        16,
        23,
        25,
        34,
        36,
        33,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 22,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Split(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        18,
        60,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 23,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Save(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Save(ref inst)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "true",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        17,
        59,
        61,
        7,
        8,
        9,
        10,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": true,
      "min_set": true
    },
    {
      "id": 24,
      "conds": [
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "q.contains(ip as usize)",
          "norm": null,
          "value": "false",
          "line": 1090,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Match(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog[ip as usize] matches Bytes(_) or Match(_)",
          "norm": null,
          "value": "true",
          "line": 1094,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(mut ip) = self.cache.stack.pop()",
          "norm": null,
          "value": "true",
          "line": 1085,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        11,
        12,
        13,
        14,
        20,
        22,
        62,
        63,
        2,
        3,
        4,
        64
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}