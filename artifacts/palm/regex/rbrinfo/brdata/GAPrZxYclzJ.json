{
  "name": "regex::dfa::dfa::Fsm<'a>::next_si",
  "name_with_impl": "regex::dfa::{impl#5}::next_si",
  "mod_info": {
    "name": "dfa",
    "loc": "src/lib.rs:650:1:650:9"
  },
  "visible": false,
  "loc": "src/dfa.rs:873:5:900:6",
  "doc": "/// next_si transitions to the next state, where the transition input\n/// corresponds to text[i].\n///\n/// This elides bounds checks, and is therefore unsafe.\n",
  "code": [
    "unsafe fn next_si(&self, si: StatePtr, text: &[u8], i: usize) -> StatePtr {",
    "    // What is the argument for safety here?",
    "    // We have three unchecked accesses that could possibly violate safety:",
    "    //",
    "    //   1. The given byte of input (`text[i]`).",
    "    //   2. The class of the byte of input (`classes[text[i]]`).",
    "    //   3. The transition for the class (`trans[si + cls]`).",
    "    //",
    "    // (1) is only safe when calling next_si is guarded by",
    "    // `i < text.len()`.",
    "    //",
    "    // (2) is the easiest case to guarantee since `text[i]` is always a",
    "    // `u8` and `self.prog.byte_classes` always has length `u8::MAX`.",
    "    // (See `ByteClassSet.byte_classes` in `compile.rs`.)",
    "    //",
    "    // (3) is only safe if (1)+(2) are safe. Namely, the transitions",
    "    // of every state are defined to have length equal to the number of",
    "    // byte classes in the program. Therefore, a valid class leads to a",
    "    // valid transition. (All possible transitions are valid lookups, even",
    "    // if it points to a state that hasn't been computed yet.) (3) also",
    "    // relies on `si` being correct, but StatePtrs should only ever be",
    "    // retrieved from the transition table, which ensures they are correct.",
    "    debug_assert!(i < text.len());",
    "    let b = *text.get_unchecked(i);",
    "    debug_assert!((b as usize) < self.prog.byte_classes.len());",
    "    let cls = *self.prog.byte_classes.get_unchecked(b as usize);",
    "    self.cache.trans.next_unchecked(si, cls as usize)",
    "}"
  ],
  "size": {
    "chain": 3,
    "contra": 0,
    "min_set": 3
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "i < text.len()",
          "norm": null,
          "value": "true",
          "line": 895,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "text.get_unchecked(i)",
          "norm": null,
          "value": "",
          "line": 896,
          "bound": null,
          "may_panic": true
        },
        {
          "cond": "(b as usize) < self.prog.byte_classes.len()",
          "norm": null,
          "value": "true",
          "line": 897,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.prog.byte_classes.get_unchecked(b as usize)",
          "norm": null,
          "value": "",
          "line": 898,
          "bound": null,
          "may_panic": true
        },
        {
          "cond": "self.cache.trans.next_unchecked(si, cls as usize)",
          "norm": null,
          "value": "",
          "line": 899,
          "bound": null,
          "may_panic": true
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        10,
        13,
        14,
        15,
        16
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "i < text.len()",
          "norm": null,
          "value": "true",
          "line": 895,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "text.get_unchecked(i)",
          "norm": null,
          "value": "",
          "line": 896,
          "bound": null,
          "may_panic": true
        },
        {
          "cond": "(b as usize) < self.prog.byte_classes.len()",
          "norm": null,
          "value": "false",
          "line": 897,
          "bound": "(b as usize) == self.prog.byte_classes.len()",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        3,
        6,
        7,
        8,
        9,
        11,
        17
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "i < text.len()",
          "norm": null,
          "value": "false",
          "line": 895,
          "bound": "i == text.len()",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        2,
        4,
        17
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}