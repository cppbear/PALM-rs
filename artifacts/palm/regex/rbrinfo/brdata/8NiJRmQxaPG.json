{
  "name": "regex::dfa::dfa::Fsm<'a>::cached_state",
  "name_with_impl": "regex::dfa::{impl#5}::cached_state",
  "mod_info": {
    "name": "dfa",
    "loc": "src/lib.rs:650:1:650:9"
  },
  "visible": false,
  "loc": "src/dfa.rs:1164:5:1194:6",
  "doc": "/// Find a previously computed state matching the given set of instructions\n/// and is_match bool.\n///\n/// The given set of instructions should represent a single state in the\n/// NFA along with all states reachable without consuming any input.\n///\n/// The is_match bool should be true if and only if the preceding DFA state\n/// contains an NFA matching state. The cached state produced here will\n/// then signify a match. (This enables us to delay a match by one byte,\n/// in order to account for the EOF sentinel byte.)\n///\n/// If the cache is full, then it is wiped before caching a new state.\n///\n/// The current state should be specified if it exists, since it will need\n/// to be preserved if the cache clears itself. (Start states are\n/// always saved, so they should not be passed here.) It takes a mutable\n/// pointer to the index because if the cache is cleared, the state's\n/// location may change.\n",
  "code": [
    "fn cached_state(",
    "    &mut self,",
    "    q: &SparseSet,",
    "    mut state_flags: StateFlags,",
    "    current_state: Option<&mut StatePtr>,",
    ") -> Option<StatePtr> {",
    "    // If we couldn't come up with a non-empty key to represent this state,",
    "    // then it is dead and can never lead to a match.",
    "    //",
    "    // Note that inst_flags represent the set of empty width assertions",
    "    // in q. We use this as an optimization in exec_byte to determine when",
    "    // we should follow epsilon transitions at the empty string preceding",
    "    // the current byte.",
    "    let key = match self.cached_state_key(q, &mut state_flags) {",
    "        None => return Some(STATE_DEAD),",
    "        Some(v) => v,",
    "    };",
    "    // In the cache? Cool. Done.",
    "    if let Some(&si) = self.cache.compiled.get(&key) {",
    "        return Some(si);",
    "    }",
    "    // If the cache has gotten too big, wipe it.",
    "    if self.approximate_size() > self.prog.dfa_size_limit",
    "        && !self.clear_cache_and_save(current_state)",
    "        {",
    "            // Ooops. DFA is giving up.",
    "            return None;",
    "        }",
    "    // Allocate room for our state and add it.",
    "    self.add_state(key)",
    "}"
  ],
  "size": {
    "chain": 5,
    "contra": 0,
    "min_set": 4
  },
  "cond_chains": [
    {
      "id": 1,
      "conds": [
        {
          "cond": "self.cached_state_key(q, &mut state_flags) matches Some(v)",
          "norm": null,
          "value": "true",
          "line": 1177,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(&si) = self.cache.compiled.get(&key)",
          "norm": null,
          "value": "true",
          "line": 1182,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.approximate_size() > self.prog.dfa_size_limit",
          "norm": null,
          "value": "true",
          "line": 1186,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.clear_cache_and_save(current_state)",
          "norm": null,
          "value": "true",
          "line": 1187,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        4,
        6,
        7,
        8,
        11,
        12,
        13,
        14,
        15,
        18,
        19,
        20,
        24
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 2,
      "conds": [
        {
          "cond": "self.cached_state_key(q, &mut state_flags) matches Some(v)",
          "norm": null,
          "value": "true",
          "line": 1177,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(&si) = self.cache.compiled.get(&key)",
          "norm": null,
          "value": "true",
          "line": 1182,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.approximate_size() > self.prog.dfa_size_limit",
          "norm": null,
          "value": "true",
          "line": 1186,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.clear_cache_and_save(current_state)",
          "norm": null,
          "value": "false",
          "line": 1187,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "None",
      "path": [
        0,
        1,
        4,
        6,
        7,
        8,
        11,
        12,
        13,
        14,
        16,
        21,
        23,
        24
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 3,
      "conds": [
        {
          "cond": "self.cached_state_key(q, &mut state_flags) matches Some(v)",
          "norm": null,
          "value": "true",
          "line": 1177,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(&si) = self.cache.compiled.get(&key)",
          "norm": null,
          "value": "true",
          "line": 1182,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.approximate_size() > self.prog.dfa_size_limit",
          "norm": null,
          "value": "false",
          "line": 1186,
          "bound": "self.approximate_size() == self.prog.dfa_size_limit",
          "may_panic": false
        }
      ],
      "ret": null,
      "path": [
        0,
        1,
        4,
        6,
        7,
        8,
        11,
        12,
        17,
        18,
        19,
        20,
        24
      ],
      "may_contra": false,
      "min_set": true
    },
    {
      "id": 4,
      "conds": [
        {
          "cond": "self.cached_state_key(q, &mut state_flags) matches Some(v)",
          "norm": null,
          "value": "true",
          "line": 1177,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "let Some(&si) = self.cache.compiled.get(&key)",
          "norm": null,
          "value": "true",
          "line": 1182,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(si)",
      "path": [
        0,
        1,
        4,
        6,
        7,
        8,
        9,
        10,
        21,
        23,
        24
      ],
      "may_contra": false,
      "min_set": false
    },
    {
      "id": 5,
      "conds": [
        {
          "cond": "self.cached_state_key(q, &mut state_flags) matches None",
          "norm": null,
          "value": "true",
          "line": 1177,
          "bound": null,
          "may_panic": false
        },
        {
          "cond": "self.cached_state_key(q, &mut state_flags) matches None",
          "norm": null,
          "value": "true",
          "line": 1177,
          "bound": null,
          "may_panic": false
        }
      ],
      "ret": "Some(STATE_DEAD)",
      "path": [
        0,
        1,
        3,
        5,
        22,
        23,
        24
      ],
      "may_contra": false,
      "min_set": true
    }
  ]
}