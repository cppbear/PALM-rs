{"function_name":"regex::dfa::write_varu32","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":6,"tests_lines":[6,6,5,5,5,5],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":2,"oracles_passed_rate":33.33333333333333,"tests_run":6,"tests_passed":2,"tests_passed_rate":33.33333333333333,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1821,1822,1823,1824,1825,1826,1827],"codes_lines_covered":[[["{","    let mut data = Vec::new();","    let n = 0b1000_0000; // boundary condition where n is exactly 128","    write_varu32(&mut data, n);","    assert_eq!(data, vec![0b1000_0000, 0]); // First byte has the continuation bit set, second byte is 0","}"],[1821,1822,1823,1824,1825,1826,1827]],[["{","    let mut data = Vec::new();","    let n = 0b0111_1111; // boundary condition where n is 127 (less than 128)","    write_varu32(&mut data, n);","    assert_eq!(data, vec![127]); // Only one byte without continuation bit","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b0111_1111);","    assert_eq!(data, vec![0b0111_1111]);","}"],[1821,1822,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b1000_0000);","    assert_eq!(data, vec![0b1000_0000 | 0b0000_0000, 0b0000_0000]);","}"],[1821,1822,1823,1824,1825,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b1000_0001);","    assert_eq!(data, vec![0b1000_0000 | 0b0000_0001, 0b0000_0000]);","}"],[1821,1822,1823,1824,1825,1826,1827]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0xFFFFFFFF);","    assert_eq!(data, vec![0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1111_1111]);","}"],[1821,1822,1823,1824,1825,1826,1827]]],"codes_branches":[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut data = Vec::new();","    let n = 0b1000_0000; // boundary condition where n is exactly 128","    write_varu32(&mut data, n);","    assert_eq!(data, vec![0b1000_0000, 0]); // First byte has the continuation bit set, second byte is 0","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}]],[["{","    let mut data = Vec::new();","    let n = 0b0111_1111; // boundary condition where n is 127 (less than 128)","    write_varu32(&mut data, n);","    assert_eq!(data, vec![127]); // Only one byte without continuation bit","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b0111_1111);","    assert_eq!(data, vec![0b0111_1111]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":false,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b1000_0000);","    assert_eq!(data, vec![0b1000_0000 | 0b0000_0000, 0b0000_0000]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0b1000_0001);","    assert_eq!(data, vec![0b1000_0000 | 0b0000_0001, 0b0000_0000]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}]],[["{","    let mut data = Vec::new();","    write_varu32(&mut data, 0xFFFFFFFF);","    assert_eq!(data, vec![0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1000_0000 | 0b1111_1111, 0b1111_1111]);","}"],[{"start_line":1822,"start_column":11,"end_line":1822,"end_column":27,"positive":true,"negative":true}]]]}