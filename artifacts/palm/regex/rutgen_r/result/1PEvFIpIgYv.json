{"function_name":"regex::pikevm::pikevm::Fsm<'r, I>::add","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/pikevm.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[13,8,62,48],"oracles":4,"oracles_compiled":1,"oracles_compiled_rate":25.0,"tests_compiled":1,"tests_compiled_rate":25.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":17,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,302],"codes_lines_covered":[[["{","    struct MockThreads;","","    impl MockThreads {","        fn new() -> Self {","            MockThreads","        }","    }","","    struct EpsilonFollower {","        stack: Vec<FollowEpsilon>,","    }","","    impl EpsilonFollower {","        fn new() -> Self {","            EpsilonFollower { stack: vec![] }","        }","","        fn add(","            &mut self,","            nlist: &mut MockThreads,","            thread_caps: &mut [Option<usize>],","            ip: usize,","            at: InputAt,","        ) {","            // Trying to pop from an empty stack to trigger panic","            self.stack.pop().unwrap();","        }","    }","","    #[derive(Debug)]","    enum FollowEpsilon {","        IP(usize),","        Capture { slot: usize, pos: usize },","    }","","    struct InputAt;","","    let mut follower = EpsilonFollower::new();","    let mut nlist = MockThreads::new();","    let mut thread_caps = vec![None; 10];","","    let ip = 0;","    let at = InputAt;","","    // This call should panic since there are no items in the stack","    follower.add(&mut nlist, &mut thread_caps, ip, at);","}"],[]]],"codes_branches":[{"start_line":292,"start_column":19,"end_line":292,"end_column":30,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct MockThreads;","","    impl MockThreads {","        fn new() -> Self {","            MockThreads","        }","    }","","    struct EpsilonFollower {","        stack: Vec<FollowEpsilon>,","    }","","    impl EpsilonFollower {","        fn new() -> Self {","            EpsilonFollower { stack: vec![] }","        }","","        fn add(","            &mut self,","            nlist: &mut MockThreads,","            thread_caps: &mut [Option<usize>],","            ip: usize,","            at: InputAt,","        ) {","            // Trying to pop from an empty stack to trigger panic","            self.stack.pop().unwrap();","        }","    }","","    #[derive(Debug)]","    enum FollowEpsilon {","        IP(usize),","        Capture { slot: usize, pos: usize },","    }","","    struct InputAt;","","    let mut follower = EpsilonFollower::new();","    let mut nlist = MockThreads::new();","    let mut thread_caps = vec![None; 10];","","    let ip = 0;","    let at = InputAt;","","    // This call should panic since there are no items in the stack","    follower.add(&mut nlist, &mut thread_caps, ip, at);","}"],[{"start_line":292,"start_column":19,"end_line":292,"end_column":30,"positive":false,"negative":false}]]]}