{"function_name":"regex::dfa::dfa::Result<T>::set_non_match","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[13,13,17,17],"oracles":4,"oracles_compiled":3,"oracles_compiled_rate":75.0,"tests_compiled":3,"tests_compiled_rate":75.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":5,"lines_covered":5,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[247,248,249,250,252],"codes_lines_covered":[[["{","    // Given a Result that is not NoMatch","    let result = Result::Match(\"some match data\");","    ","    // When calling set_non_match","    let new_result = result.set_non_match(5);","    ","    // Then it should return the original Result without any changes","    match new_result {","        Result::Match(data) => assert_eq!(data, \"some match data\"),","        _ => panic!(\"Expected Result::Match but got a different variant.\"),","    }","}"],[247,248,250,252]],[["{","    struct TestResult;","","    impl TestResult {","        fn no_match(at: usize) -> Result<usize> {","            Result::NoMatch(at)","        }","    }","","    let input = TestResult::no_match(5);","    let result = input.set_non_match(10);","","    match result {","        Result::NoMatch(value) => assert_eq!(value, 10),","        _ => panic!(\"Expected Result::NoMatch, got a different result\"),","    }","}"],[247,248,249,252]],[["{","    struct TestResult;","","    impl TestResult {","        fn no_match(at: usize) -> Result<usize> {","            Result::NoMatch(at)","        }","    }","","    let input = TestResult::no_match(20);","    let result = input.set_non_match(30);","","    match result {","        Result::NoMatch(value) => assert_eq!(value, 30),","        _ => panic!(\"Expected Result::NoMatch, got a different result\"),","    }","}"],[247,248,249,252]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Given a Result that is not NoMatch","    let result = Result::Match(\"some match data\");","    ","    // When calling set_non_match","    let new_result = result.set_non_match(5);","    ","    // Then it should return the original Result without any changes","    match new_result {","        Result::Match(data) => assert_eq!(data, \"some match data\"),","        _ => panic!(\"Expected Result::Match but got a different variant.\"),","    }","}"],[]],[["{","    struct TestResult;","","    impl TestResult {","        fn no_match(at: usize) -> Result<usize> {","            Result::NoMatch(at)","        }","    }","","    let input = TestResult::no_match(5);","    let result = input.set_non_match(10);","","    match result {","        Result::NoMatch(value) => assert_eq!(value, 10),","        _ => panic!(\"Expected Result::NoMatch, got a different result\"),","    }","}"],[]],[["{","    struct TestResult;","","    impl TestResult {","        fn no_match(at: usize) -> Result<usize> {","            Result::NoMatch(at)","        }","    }","","    let input = TestResult::no_match(20);","    let result = input.set_non_match(30);","","    match result {","        Result::NoMatch(value) => assert_eq!(value, 30),","        _ => panic!(\"Expected Result::NoMatch, got a different result\"),","    }","}"],[]]]}