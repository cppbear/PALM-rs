{"function_name":"regex::input::<input::CharInput<'t> as input::Input>::previous_char","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[41,39],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[172,173,174],"codes_lines_covered":[[["{","    struct InputAt {","        pos: usize,","    }","","    impl InputAt {","        fn pos(&self) -> usize {","            self.pos","        }","    }","","    struct TestInput {","        data: Vec<u8>,","    }","","    impl std::ops::Deref for TestInput {","        type Target = [u8];","","        fn deref(&self) -> &Self::Target {","            &self.data","        }","    }","","    fn decode_last_utf8(input: &[u8]) -> Option<(char, usize)> {","        // Dummy implementation for testing purpose","        if input.is_empty() {","            None","        } else {","            Some((input[input.len() - 1] as char, 1))","        }","    }","","    fn previous_char(input: &TestInput, at: InputAt) -> char {","        decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).unwrap_or('\\0')","    }","","    let input_data = TestInput { data: b\"hello\".to_vec() };","    let at = InputAt { pos: 5 };","    let result = previous_char(&input_data, at);","    assert_eq!(result, 'o');","}"],[]],[["{","    struct InputAt {","        pos: usize,","    }","","    impl InputAt {","        fn pos(&self) -> usize {","            self.pos","        }","    }","","    struct TestInput {","        data: Vec<u8>,","    }","","    impl std::ops::Deref for TestInput {","        type Target = [u8];","","        fn deref(&self) -> &Self::Target {","            &self.data","        }","    }","","    fn decode_last_utf8(input: &[u8]) -> Option<(char, usize)> {","        if input.is_empty() {","            None","        } else {","            Some((input[input.len() - 1] as char, 1))","        }","    }","","    fn previous_char(input: &TestInput, at: InputAt) -> char {","        decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).unwrap_or('\\0')","    }","","    let input_data = TestInput { data: b\"hello\".to_vec() };","    let at = InputAt { pos: 6 }; // Out of bounds","    previous_char(&input_data, at);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct InputAt {","        pos: usize,","    }","","    impl InputAt {","        fn pos(&self) -> usize {","            self.pos","        }","    }","","    struct TestInput {","        data: Vec<u8>,","    }","","    impl std::ops::Deref for TestInput {","        type Target = [u8];","","        fn deref(&self) -> &Self::Target {","            &self.data","        }","    }","","    fn decode_last_utf8(input: &[u8]) -> Option<(char, usize)> {","        // Dummy implementation for testing purpose","        if input.is_empty() {","            None","        } else {","            Some((input[input.len() - 1] as char, 1))","        }","    }","","    fn previous_char(input: &TestInput, at: InputAt) -> char {","        decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).unwrap_or('\\0')","    }","","    let input_data = TestInput { data: b\"hello\".to_vec() };","    let at = InputAt { pos: 5 };","    let result = previous_char(&input_data, at);","    assert_eq!(result, 'o');","}"],[]],[["{","    struct InputAt {","        pos: usize,","    }","","    impl InputAt {","        fn pos(&self) -> usize {","            self.pos","        }","    }","","    struct TestInput {","        data: Vec<u8>,","    }","","    impl std::ops::Deref for TestInput {","        type Target = [u8];","","        fn deref(&self) -> &Self::Target {","            &self.data","        }","    }","","    fn decode_last_utf8(input: &[u8]) -> Option<(char, usize)> {","        if input.is_empty() {","            None","        } else {","            Some((input[input.len() - 1] as char, 1))","        }","    }","","    fn previous_char(input: &TestInput, at: InputAt) -> char {","        decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).unwrap_or('\\0')","    }","","    let input_data = TestInput { data: b\"hello\".to_vec() };","    let at = InputAt { pos: 6 }; // Out of bounds","    previous_char(&input_data, at);","}"],[]]]}