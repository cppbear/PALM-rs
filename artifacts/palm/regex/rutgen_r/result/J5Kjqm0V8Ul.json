{"function_name":"regex::literal::literal::FreqyPacked::find","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[48,48,48,49],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":2,"tests_compiled_rate":50.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":23,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":12,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,518,519],"codes_lines_covered":[[["{","    struct Pattern {","        pat: Vec<u8>,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    impl Pattern {","        pub fn find(&self, haystack: &[u8]) -> Option<usize> {","            let pat = &*self.pat;","            if haystack.len() < pat.len() || pat.is_empty() {","                return None;","            }","            let mut i = self.rare1i;","            while i < haystack.len() {","                i += match memchr(self.rare1, &haystack[i..]) {","                    None => return None,","                    Some(i) => i,","                };","                let start = i - self.rare1i;","                let end = start + pat.len();","                if end > haystack.len() {","                    return None;","                }","                let aligned = &haystack[start..end];","                if aligned[self.rare2i] == self.rare2 && aligned == &*self.pat {","                    return Some(start);","                }","                i += 1;","            }","            None","        }","    }","","    let pattern = Pattern {","        pat: vec![1, 2, 3],","        rare1: 4,","        rare1i: 0,","        rare2: 5,","        rare2i: 0,","    };","","    let haystack = vec![4]; // haystack has length 1, pattern has length 3","    let result = pattern.find(&haystack);","    assert_eq!(result, None);","}"],[]],[["{","    struct Regex {","        pat: Box<[u8]>,","        rare1i: usize,","        rare1: u8,","        rare2i: usize,","        rare2: u8,","    }","","    impl Regex {","        pub fn find(&self, haystack: &[u8]) -> Option<usize> {","            let pat = &*self.pat;","            if haystack.len() < pat.len() || pat.is_empty() {","                return None;","            }","            let mut i = self.rare1i;","            while i < haystack.len() {","                i += match memchr::memchr(self.rare1, &haystack[i..]) {","                    None => return None,","                    Some(i) => i,","                };","                let start = i - self.rare1i;","                let end = start + pat.len();","                if end > haystack.len() {","                    return None;","                }","                let aligned = &haystack[start..end];","                if aligned[self.rare2i] == self.rare2 && aligned == &*self.pat {","                    return Some(start);","                }","                i += 1;","            }","            None","        }","    }","","    let regex = Regex {","        pat: Box::new([]), // empty pattern","        rare1i: 0,","        rare1: b'x',","        rare2i: 0,","        rare2: b'y',","    };","    let haystack = b\"xyz\";","","    let result = regex.find(haystack);","    assert_eq!(result, None);","}"],[]]],"codes_branches":[{"start_line":498,"start_column":12,"end_line":498,"end_column":38,"positive":false,"negative":false},{"start_line":498,"start_column":42,"end_line":498,"end_column":56,"positive":false,"negative":false},{"start_line":502,"start_column":15,"end_line":502,"end_column":33,"positive":false,"negative":false},{"start_line":509,"start_column":16,"end_line":509,"end_column":36,"positive":false,"negative":false},{"start_line":513,"start_column":16,"end_line":513,"end_column":50,"positive":false,"negative":false},{"start_line":513,"start_column":54,"end_line":513,"end_column":75,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct Pattern {","        pat: Vec<u8>,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    impl Pattern {","        pub fn find(&self, haystack: &[u8]) -> Option<usize> {","            let pat = &*self.pat;","            if haystack.len() < pat.len() || pat.is_empty() {","                return None;","            }","            let mut i = self.rare1i;","            while i < haystack.len() {","                i += match memchr(self.rare1, &haystack[i..]) {","                    None => return None,","                    Some(i) => i,","                };","                let start = i - self.rare1i;","                let end = start + pat.len();","                if end > haystack.len() {","                    return None;","                }","                let aligned = &haystack[start..end];","                if aligned[self.rare2i] == self.rare2 && aligned == &*self.pat {","                    return Some(start);","                }","                i += 1;","            }","            None","        }","    }","","    let pattern = Pattern {","        pat: vec![1, 2, 3],","        rare1: 4,","        rare1i: 0,","        rare2: 5,","        rare2i: 0,","    };","","    let haystack = vec![4]; // haystack has length 1, pattern has length 3","    let result = pattern.find(&haystack);","    assert_eq!(result, None);","}"],[{"start_line":498,"start_column":12,"end_line":498,"end_column":38,"positive":false,"negative":false},{"start_line":498,"start_column":42,"end_line":498,"end_column":56,"positive":false,"negative":false},{"start_line":502,"start_column":15,"end_line":502,"end_column":33,"positive":false,"negative":false},{"start_line":509,"start_column":16,"end_line":509,"end_column":36,"positive":false,"negative":false},{"start_line":513,"start_column":16,"end_line":513,"end_column":50,"positive":false,"negative":false},{"start_line":513,"start_column":54,"end_line":513,"end_column":75,"positive":false,"negative":false}]],[["{","    struct Regex {","        pat: Box<[u8]>,","        rare1i: usize,","        rare1: u8,","        rare2i: usize,","        rare2: u8,","    }","","    impl Regex {","        pub fn find(&self, haystack: &[u8]) -> Option<usize> {","            let pat = &*self.pat;","            if haystack.len() < pat.len() || pat.is_empty() {","                return None;","            }","            let mut i = self.rare1i;","            while i < haystack.len() {","                i += match memchr::memchr(self.rare1, &haystack[i..]) {","                    None => return None,","                    Some(i) => i,","                };","                let start = i - self.rare1i;","                let end = start + pat.len();","                if end > haystack.len() {","                    return None;","                }","                let aligned = &haystack[start..end];","                if aligned[self.rare2i] == self.rare2 && aligned == &*self.pat {","                    return Some(start);","                }","                i += 1;","            }","            None","        }","    }","","    let regex = Regex {","        pat: Box::new([]), // empty pattern","        rare1i: 0,","        rare1: b'x',","        rare2i: 0,","        rare2: b'y',","    };","    let haystack = b\"xyz\";","","    let result = regex.find(haystack);","    assert_eq!(result, None);","}"],[{"start_line":498,"start_column":12,"end_line":498,"end_column":38,"positive":false,"negative":false},{"start_line":498,"start_column":42,"end_line":498,"end_column":56,"positive":false,"negative":false},{"start_line":502,"start_column":15,"end_line":502,"end_column":33,"positive":false,"negative":false},{"start_line":509,"start_column":16,"end_line":509,"end_column":36,"positive":false,"negative":false},{"start_line":513,"start_column":16,"end_line":513,"end_column":50,"positive":false,"negative":false},{"start_line":513,"start_column":54,"end_line":513,"end_column":75,"positive":false,"negative":false}]]]}