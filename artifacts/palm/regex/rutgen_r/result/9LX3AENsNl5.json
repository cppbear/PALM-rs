{"function_name":"regex::dfa::usize_to_u32","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":6,"tests_lines":[4,5,5,5,5,4],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":6,"tests_compiled_rate":100.0,"oracles_run":6,"oracles_passed":6,"oracles_passed_rate":100.0,"tests_run":6,"tests_passed":6,"tests_passed_rate":100.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1773,1774,1775,1776,1777,1778],"codes_lines_covered":[[["{","    let n: usize = 4294967296; // This value is just over the u32::MAX","    usize_to_u32(n);","}"],[1773,1774,1775]],[["{","    let n: usize = 4294967295; // This value is equal to u32::MAX","    let result = usize_to_u32(n);","    assert_eq!(result, 4294967295);","}"],[1773,1774,1776,1777,1778]],[["{","    let n: usize = 0; // Lower boundary value","    let result = usize_to_u32(n);","    assert_eq!(result, 0);","}"],[1773,1774,1776,1777,1778]],[["{","    let n: usize = 123; // A small value within u32 range","    let result = usize_to_u32(n);","    assert_eq!(result, 123);","}"],[1773,1774,1776,1777,1778]],[["{","    let n: usize = std::u32::MAX as usize;","    let result = usize_to_u32(n);","    assert_eq!(result, std::u32::MAX);","}"],[1773,1774,1776,1777,1778]],[["{","    let n: usize = std::u32::MAX as usize + 1;","    usize_to_u32(n);","}"],[1773,1774,1775]]],"codes_branches":[{"start_line":1774,"start_column":8,"end_line":1774,"end_column":45,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let n: usize = 4294967296; // This value is just over the u32::MAX","    usize_to_u32(n);","}"],[{"start_line":1774,"start_column":8,"end_line":1774,"end_column":45,"positive":true,"negative":false}]],[["{","    let n: usize = 4294967295; // This value is equal to u32::MAX","    let result = usize_to_u32(n);","    assert_eq!(result, 4294967295);","}"],[{"start_line":1774,"start_column":8,"end_line":1774,"end_column":45,"positive":false,"negative":true}]],[["{","    let n: usize = 0; // Lower boundary value","    let result = usize_to_u32(n);","    assert_eq!(result, 0);","}"],[{"start_line":1774,"start_column":8,"end_line":1774,"end_column":45,"positive":false,"negative":true}]],[["{","    let n: usize = 123; // A small value within u32 range","    let result = usize_to_u32(n);","    assert_eq!(result, 123);","}"],[{"start_line":1774,"start_column":8,"end_line":1774,"end_column":45,"positive":false,"negative":true}]],[["{","    let n: usize = std::u32::MAX as usize;","    let result = usize_to_u32(n);","    assert_eq!(result, std::u32::MAX);","}"],[{"start_line":1774,"start_column":8,"end_line":1774,"end_column":45,"positive":false,"negative":true}]],[["{","    let n: usize = std::u32::MAX as usize + 1;","    usize_to_u32(n);","}"],[{"start_line":1774,"start_column":8,"end_line":1774,"end_column":45,"positive":true,"negative":false}]]]}