{"function_name":"regex::re_trait::re_trait::Locations::pos","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/re_trait.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":7,"tests_lines":[16,16,17,17,17,17,17],"oracles":7,"oracles_compiled":7,"oracles_compiled_rate":100.0,"tests_compiled":7,"tests_compiled_rate":100.0,"oracles_run":7,"oracles_passed":5,"oracles_passed_rate":71.42857142857143,"tests_run":7,"tests_passed":5,"tests_passed_rate":71.42857142857143,"lines":6,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[28,29,30,31,32,34],"codes_lines_covered":[[["{","    struct CaptureGroups(Vec<Option<usize>>);","    ","    impl CaptureGroups {","        fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","    ","    let capture_groups = CaptureGroups(vec![Some(0), Some(1)]); // Only two capture groups","    assert_eq!(capture_groups.pos(3), None); // Testing with index 3 which is out of bounds","}"],[]],[["{","    struct CaptureGroups(Vec<Option<usize>>);","","    impl CaptureGroups {","        fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","    ","    let capture_groups = CaptureGroups(vec![]); // Empty capture group","    assert_eq!(capture_groups.pos(0), None); // Index 0 should return None since it's empty","}"],[]],[["{","    struct CaptureGroups(Vec<Option<usize>>);","","    impl CaptureGroups {","        fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let capture_groups = CaptureGroups(vec![Some(0), None]); // Missing end index for capture group 1","    assert_eq!(capture_groups.pos(0), Some((0, 1))); // Valid capture group","    assert_eq!(capture_groups.pos(1), None); // Invalid as end index is None","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![Some(0), Some(5), Some(10), Some(15)]);","    ","    assert_eq!(cg.pos(1), Some((5, 10)));","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![None, Some(5), Some(10), Some(15)]);","    ","    assert_eq!(cg.pos(0), None);","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![Some(0), Some(5)]); // Only 2 capture groups","    ","    assert_eq!(cg.pos(2), None);","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![Some(0), Some(5), Some(10), None]); // Third group has no match","    ","    assert_eq!(cg.pos(3), None);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct CaptureGroups(Vec<Option<usize>>);","    ","    impl CaptureGroups {","        fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","    ","    let capture_groups = CaptureGroups(vec![Some(0), Some(1)]); // Only two capture groups","    assert_eq!(capture_groups.pos(3), None); // Testing with index 3 which is out of bounds","}"],[]],[["{","    struct CaptureGroups(Vec<Option<usize>>);","","    impl CaptureGroups {","        fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","    ","    let capture_groups = CaptureGroups(vec![]); // Empty capture group","    assert_eq!(capture_groups.pos(0), None); // Index 0 should return None since it's empty","}"],[]],[["{","    struct CaptureGroups(Vec<Option<usize>>);","","    impl CaptureGroups {","        fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let capture_groups = CaptureGroups(vec![Some(0), None]); // Missing end index for capture group 1","    assert_eq!(capture_groups.pos(0), Some((0, 1))); // Valid capture group","    assert_eq!(capture_groups.pos(1), None); // Invalid as end index is None","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![Some(0), Some(5), Some(10), Some(15)]);","    ","    assert_eq!(cg.pos(1), Some((5, 10)));","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![None, Some(5), Some(10), Some(15)]);","    ","    assert_eq!(cg.pos(0), None);","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![Some(0), Some(5)]); // Only 2 capture groups","    ","    assert_eq!(cg.pos(2), None);","}"],[]],[["{","    struct CaptureGroup(Vec<Option<usize>>);","    ","    impl CaptureGroup {","        pub fn pos(&self, i: usize) -> Option<(usize, usize)> {","            let (s, e) = (i * 2, i * 2 + 1);","            match (self.0.get(s), self.0.get(e)) {","                (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),","                _ => None,","            }","        }","    }","","    let cg = CaptureGroup(vec![Some(0), Some(5), Some(10), None]); // Third group has no match","    ","    assert_eq!(cg.pos(3), None);","}"],[]]]}