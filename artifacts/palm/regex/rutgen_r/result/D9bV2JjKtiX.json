{"function_name":"regex::backtrack::backtrack::Bounded<'a, 'm, 'r, 's, I>::backtrack","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/backtrack.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":13,"tests_lines":[11,13,13,9,9,10,62,65,65,9,9,12,8],"oracles":13,"oracles_compiled":11,"oracles_compiled_rate":84.61538461538461,"tests_compiled":11,"tests_compiled_rate":84.61538461538461,"oracles_run":11,"oracles_passed":7,"oracles_passed_rate":63.63636363636363,"tests_run":11,"tests_passed":7,"tests_passed_rate":63.63636363636363,"lines":22,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":8,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[182,183,184,185,186,187,188,189,190,191,192,196,197,198,199,200,202,203,204,205,209,210],"codes_lines_covered":[[["{","    let mut regex = Regex {","        m: Machine { jobs: vec![] },","        slots: vec![0, 1, 2],","        prog: Program { matches: vec![0] },","    };","","    let input = InputAt;","    let result = regex.backtrack(input);","    assert_eq!(result, true);","}"],[]],[["{","    let mut regex = Regex {","        m: Machine {","            jobs: vec![Job::SaveRestore { slot: 1, old_pos: 2 }],","        },","        slots: vec![0, 1, 2],","        prog: Program { matches: vec![0] },","    };","","    let input = InputAt;","    let result = regex.backtrack(input);","    assert_eq!(result, true);","}"],[]],[["{","    let mut regex = Regex {","        m: Machine {","            jobs: vec![Job::Inst { ip: 0, at: InputAt }],","        },","        slots: vec![0],","        prog: Program { matches: vec![] },","    };","","    let input = InputAt;","    let result = regex.backtrack(input);","    assert_eq!(result, false);","}"],[]],[["{","    let start = InputAt { position: 0 };","    let matcher = Matcher { jobs: Vec::new() };","    let program = Program { matches: vec![0] };","    let mut regex = Regex { m: matcher, slots: vec![0], prog: program };","","    let result = regex.backtrack(start);","    assert!(result);","}"],[]],[["{","    let start = InputAt { position: 1 };","    let matcher = Matcher { jobs: Vec::new() };","    let program = Program { matches: vec![0, 1] };","    let mut regex = Regex { m: matcher, slots: vec![0], prog: program };","","    let result = regex.backtrack(start);","    assert!(result);","}"],[]],[["{","    let start = InputAt { position: 2 };","    let matcher = Matcher { jobs: Vec::new() };","    let program = Program { matches: vec![0] };","    let mut regex = Regex { m: matcher, slots: vec![], prog: program };","","    // This will trigger a panic due to the slot being out of bounds","    regex.m.jobs.push(Job { kind: JobKind::SaveRestore { slot: 0, old_pos: 1 } });","    regex.backtrack(start);","}"],[]],[["{","    struct MockProg {","        matches: Vec<String>,","    }","","    struct MockManager {","        jobs: Vec<Job>,","    }","","    struct MockRegex {","        m: MockManager,","        slots: Vec<usize>,","        prog: MockProg,","    }","","    enum Job {","        Inst { ip: usize, at: InputAt },","        SaveRestore { slot: usize, old_pos: usize },","    }","","    struct InputAt {","        position: usize,","    }","","    impl MockRegex {","        fn step(&mut self, _ip: usize, _at: InputAt) -> bool {","            // Simulate successful step for testing","            true","        }","","        fn backtrack(&mut self, start: InputAt) -> bool {","            let mut matched = false;","            self.m.jobs.push(Job::Inst { ip: 0, at: start });","            while let Some(job) = self.m.jobs.pop() {","                match job {","                    Job::Inst { ip, at } => {","                        if self.step(ip, at) {","                            // We want to ensure this is false for the test","                            if self.prog.matches.len() == 1 {","                                return true;","                            }","                            matched = true;","                        }","                    }","                    Job::SaveRestore { slot, old_pos } => {","                        if slot < self.slots.len() {","                            self.slots[slot] = old_pos;","                        }","                    }","                }","            }","            matched","        }","    }","","    let prog = MockProg { matches: vec![\"match1\".to_string()] }; // Add a match to ensure it is treated as one","    let manager = MockManager { jobs: Vec::new() };","    let slots = vec![0; 10]; // Initialize slots","    let mut regex = MockRegex { m: manager, slots, prog };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), true);","}"],[]],[["{","    let start = InputAt { position: 0 };","    let jobs = vec![Job::Inst { ip: 0, at: start }];","    let program = Program { matches: vec![] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs }, prog: program, slots };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), false);","}"],[]],[["{","    let start = InputAt { position: 0 };","    let jobs = vec![Job::Inst { ip: 0, at: start }];","    let program = Program { matches: vec![()] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs }, prog: program, slots };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), true);","}"],[]],[["{","    let start = InputAt { position: 0 };","    let jobs = vec![","        Job::Inst { ip: 0, at: start },","        Job::Inst { ip: 1, at: InputAt { position: 1 } }","    ];","    let program = Program { matches: vec![] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs }, prog: program, slots };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), false);","}"],[]],[["{","    let start = InputAt { position: 0 };","    let program = Program { matches: vec![] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs: vec![] }, prog: program, slots };","","    regex.backtrack(start);","}"],[]]],"codes_branches":[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut regex = Regex {","        m: Machine { jobs: vec![] },","        slots: vec![0, 1, 2],","        prog: Program { matches: vec![0] },","    };","","    let input = InputAt;","    let result = regex.backtrack(input);","    assert_eq!(result, true);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let mut regex = Regex {","        m: Machine {","            jobs: vec![Job::SaveRestore { slot: 1, old_pos: 2 }],","        },","        slots: vec![0, 1, 2],","        prog: Program { matches: vec![0] },","    };","","    let input = InputAt;","    let result = regex.backtrack(input);","    assert_eq!(result, true);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let mut regex = Regex {","        m: Machine {","            jobs: vec![Job::Inst { ip: 0, at: InputAt }],","        },","        slots: vec![0],","        prog: Program { matches: vec![] },","    };","","    let input = InputAt;","    let result = regex.backtrack(input);","    assert_eq!(result, false);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let start = InputAt { position: 0 };","    let matcher = Matcher { jobs: Vec::new() };","    let program = Program { matches: vec![0] };","    let mut regex = Regex { m: matcher, slots: vec![0], prog: program };","","    let result = regex.backtrack(start);","    assert!(result);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let start = InputAt { position: 1 };","    let matcher = Matcher { jobs: Vec::new() };","    let program = Program { matches: vec![0, 1] };","    let mut regex = Regex { m: matcher, slots: vec![0], prog: program };","","    let result = regex.backtrack(start);","    assert!(result);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let start = InputAt { position: 2 };","    let matcher = Matcher { jobs: Vec::new() };","    let program = Program { matches: vec![0] };","    let mut regex = Regex { m: matcher, slots: vec![], prog: program };","","    // This will trigger a panic due to the slot being out of bounds","    regex.m.jobs.push(Job { kind: JobKind::SaveRestore { slot: 0, old_pos: 1 } });","    regex.backtrack(start);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    struct MockProg {","        matches: Vec<String>,","    }","","    struct MockManager {","        jobs: Vec<Job>,","    }","","    struct MockRegex {","        m: MockManager,","        slots: Vec<usize>,","        prog: MockProg,","    }","","    enum Job {","        Inst { ip: usize, at: InputAt },","        SaveRestore { slot: usize, old_pos: usize },","    }","","    struct InputAt {","        position: usize,","    }","","    impl MockRegex {","        fn step(&mut self, _ip: usize, _at: InputAt) -> bool {","            // Simulate successful step for testing","            true","        }","","        fn backtrack(&mut self, start: InputAt) -> bool {","            let mut matched = false;","            self.m.jobs.push(Job::Inst { ip: 0, at: start });","            while let Some(job) = self.m.jobs.pop() {","                match job {","                    Job::Inst { ip, at } => {","                        if self.step(ip, at) {","                            // We want to ensure this is false for the test","                            if self.prog.matches.len() == 1 {","                                return true;","                            }","                            matched = true;","                        }","                    }","                    Job::SaveRestore { slot, old_pos } => {","                        if slot < self.slots.len() {","                            self.slots[slot] = old_pos;","                        }","                    }","                }","            }","            matched","        }","    }","","    let prog = MockProg { matches: vec![\"match1\".to_string()] }; // Add a match to ensure it is treated as one","    let manager = MockManager { jobs: Vec::new() };","    let slots = vec![0; 10]; // Initialize slots","    let mut regex = MockRegex { m: manager, slots, prog };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), true);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let start = InputAt { position: 0 };","    let jobs = vec![Job::Inst { ip: 0, at: start }];","    let program = Program { matches: vec![] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs }, prog: program, slots };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), false);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let start = InputAt { position: 0 };","    let jobs = vec![Job::Inst { ip: 0, at: start }];","    let program = Program { matches: vec![()] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs }, prog: program, slots };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), true);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let start = InputAt { position: 0 };","    let jobs = vec![","        Job::Inst { ip: 0, at: start },","        Job::Inst { ip: 1, at: InputAt { position: 1 } }","    ];","    let program = Program { matches: vec![] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs }, prog: program, slots };","","    assert_eq!(regex.backtrack(InputAt { position: 0 }), false);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]],[["{","    let start = InputAt { position: 0 };","    let program = Program { matches: vec![] };","    let slots = vec![InputAt { position: 1 }];","    let mut regex = Regex { m: Machine { jobs: vec![] }, prog: program, slots };","","    regex.backtrack(start);","}"],[{"start_line":189,"start_column":19,"end_line":189,"end_column":28,"positive":false,"negative":false},{"start_line":192,"start_column":24,"end_line":192,"end_column":41,"positive":false,"negative":false},{"start_line":196,"start_column":28,"end_line":196,"end_column":56,"positive":false,"negative":false},{"start_line":203,"start_column":24,"end_line":203,"end_column":47,"positive":false,"negative":false}]]]}