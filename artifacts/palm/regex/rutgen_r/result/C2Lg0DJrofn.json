{"function_name":"regex::dfa::dfa::Fsm<'a>::has_prefix","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":12,"tests_lines":[21,21,21,21,10,10,10,10,29,29,29,29],"oracles":12,"oracles_compiled":8,"oracles_compiled_rate":66.66666666666666,"tests_compiled":8,"tests_compiled_rate":66.66666666666666,"oracles_run":8,"oracles_passed":8,"oracles_passed_rate":100.0,"tests_run":8,"tests_passed":8,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1572,1573,1574,1575,1576],"codes_lines_covered":[[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"abc\".to_string()],","            is_anchored_start: false,","        },","    };","    assert_eq!(regex.has_prefix(), true);","}"],[]],[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: true,","            prefixes: vec![\"abc\".to_string()],","            is_anchored_start: false,","        },","    };","    assert_eq!(regex.has_prefix(), false);","}"],[]],[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![],","            is_anchored_start: false,","        },","    };","    assert_eq!(regex.has_prefix(), false);","}"],[]],[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"abc\".to_string()],","            is_anchored_start: true,","        },","    };","    assert_eq!(regex.has_prefix(), false);","}"],[]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"pre\".to_string()],","            is_anchored_start: false,","        },","    };","    ","    assert!(regex.has_prefix());","}"],[]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![],","            is_anchored_start: false,","        },","    };","    ","    assert!(!regex.has_prefix());","}"],[]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: true,","            prefixes: vec![\"pre\".to_string()],","            is_anchored_start: false,","        },","    };","    ","    assert!(!regex.has_prefix());","}"],[]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"pre\".to_string()],","            is_anchored_start: true,","        },","    };","    ","    assert!(!regex.has_prefix());","}"],[]]],"codes_branches":[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"abc\".to_string()],","            is_anchored_start: false,","        },","    };","    assert_eq!(regex.has_prefix(), true);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: true,","            prefixes: vec![\"abc\".to_string()],","            is_anchored_start: false,","        },","    };","    assert_eq!(regex.has_prefix(), false);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![],","            is_anchored_start: false,","        },","    };","    assert_eq!(regex.has_prefix(), false);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"abc\".to_string()],","            is_anchored_start: true,","        },","    };","    assert_eq!(regex.has_prefix(), false);","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"pre\".to_string()],","            is_anchored_start: false,","        },","    };","    ","    assert!(regex.has_prefix());","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![],","            is_anchored_start: false,","        },","    };","    ","    assert!(!regex.has_prefix());","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: true,","            prefixes: vec![\"pre\".to_string()],","            is_anchored_start: false,","        },","    };","    ","    assert!(!regex.has_prefix());","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]],[["{","    struct Prog {","        is_reverse: bool,","        prefixes: Vec<String>,","        is_anchored_start: bool,","    }","","    struct Regex {","        prog: Prog,","    }","","    impl Regex {","        fn has_prefix(&self) -> bool {","            !self.prog.is_reverse","            && !self.prog.prefixes.is_empty()","            && !self.prog.is_anchored_start","        }","    }","","    let regex = Regex {","        prog: Prog {","            is_reverse: false,","            prefixes: vec![\"pre\".to_string()],","            is_anchored_start: true,","        },","    };","    ","    assert!(!regex.has_prefix());","}"],[{"start_line":1573,"start_column":9,"end_line":1573,"end_column":30,"positive":false,"negative":false},{"start_line":1574,"start_column":12,"end_line":1574,"end_column":42,"positive":false,"negative":false}]]]}