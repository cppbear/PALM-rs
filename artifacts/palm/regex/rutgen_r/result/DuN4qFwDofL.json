{"function_name":"regex::compile::compile::Compiler::fill_split","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":16,"tests_lines":[19,8,13,30,30,6,6,15,8,19,14,9,11,9,71,82],"oracles":16,"oracles_compiled":2,"oracles_compiled_rate":12.5,"tests_compiled":2,"tests_compiled_rate":12.5,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":32,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[693,694,695,696,697,698,699,700,701,702,703,704,705,707,708,709,711,712,713,715,716,719,720,721,722,723,724,725,726,727,729,733],"codes_lines_covered":[[["{","    let mut compiler = Compiler {","        insts: vec![Inst {}, Inst {}, Inst {}],","    };","    ","    let hole_to_fill = Hole::Many(vec![","        Hole::One(0),","        Hole::One(1),","        Hole::One(2),","    ]);","    ","    let result = compiler.fill_split(hole_to_fill, Some(10), None);","    match result {","        Hole::Many(holes) => {","            assert!(holes.len() > 1);","        },","        _ => panic!(\"Expected Hole::Many, found a different variant\"),","    }","}"],[]],[["{","    let mut compiler = Compiler {","        insts: vec![Inst {}, Inst {}, Inst {}],","    };","","    let hole_to_fill = Hole::Many(vec![","        Hole::One(0),","    ]);","","    let result = compiler.fill_split(hole_to_fill, Some(10), Some(20));","    if let Hole::None = result {","        panic!(\"Expected something other than Hole::None\");","    }","}"],[]]],"codes_branches":[{"start_line":724,"start_column":20,"end_line":724,"end_column":40,"positive":false,"negative":false},{"start_line":726,"start_column":27,"end_line":726,"end_column":47,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut compiler = Compiler {","        insts: vec![Inst {}, Inst {}, Inst {}],","    };","    ","    let hole_to_fill = Hole::Many(vec![","        Hole::One(0),","        Hole::One(1),","        Hole::One(2),","    ]);","    ","    let result = compiler.fill_split(hole_to_fill, Some(10), None);","    match result {","        Hole::Many(holes) => {","            assert!(holes.len() > 1);","        },","        _ => panic!(\"Expected Hole::Many, found a different variant\"),","    }","}"],[{"start_line":724,"start_column":20,"end_line":724,"end_column":40,"positive":false,"negative":false},{"start_line":726,"start_column":27,"end_line":726,"end_column":47,"positive":false,"negative":false}]],[["{","    let mut compiler = Compiler {","        insts: vec![Inst {}, Inst {}, Inst {}],","    };","","    let hole_to_fill = Hole::Many(vec![","        Hole::One(0),","    ]);","","    let result = compiler.fill_split(hole_to_fill, Some(10), Some(20));","    if let Hole::None = result {","        panic!(\"Expected something other than Hole::None\");","    }","}"],[{"start_line":724,"start_column":20,"end_line":724,"end_column":40,"positive":false,"negative":false},{"start_line":726,"start_column":27,"end_line":726,"end_column":47,"positive":false,"negative":false}]]]}