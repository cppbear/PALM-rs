{"function_name":"regex::dfa::read_vari32","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":9,"tests_lines":[6,6,6,6,6,6,6,6,6],"oracles":9,"oracles_compiled":9,"oracles_compiled_rate":100.0,"tests_compiled":9,"tests_compiled_rate":100.0,"oracles_run":9,"oracles_passed":3,"oracles_passed_rate":33.33333333333333,"tests_run":9,"tests_passed":3,"tests_passed_rate":33.33333333333333,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1811,1812,1813,1814,1815,1816,1817,1818],"codes_lines_covered":[[["{","    let data: &[u8] = &[0b00000001]; // Encoding representing a positive varint (1)","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, 1);","    assert_eq!(bytes_read, 1);","}"],[1811,1812,1813,1814,1815,1816,1817,1818]],[["{","    let data: &[u8] = &[0b00000011]; // Encoding representing a negative varint (-1)","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, -1);","    assert_eq!(bytes_read, 1);","}"],[1811,1812,1813,1814,1815,1816,1817,1818]],[["{","    let data: &[u8] = &[0b00000010, 0b00000001]; // Encoding for 1 in two bytes","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, 2);","    assert_eq!(bytes_read, 2);","}"],[1811,1812,1813,1814,1816,1817,1818]],[["{","    let data: &[u8] = &[0b11111111, 0b11111111, 0b11111111, 0b11111111]; // Encoding for the negative largest value","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, -2147483647 - 1); // corresponds to -2147483648","    assert_eq!(bytes_read, 4);","}"],[1811,1812,1813,1814,1816,1817,1818]],[["{","    let data: &[u8] = &[0b00000010, 0b11111111, 0b11111111, 0b11111111]; // Encoding for a large positive value","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, 2147483647);","    assert_eq!(bytes_read, 4);","}"],[1811,1812,1813,1814,1816,1817,1818]],[["{","    let data = [0b00000000]; // This will produce (0, 1)","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 0);","    assert_eq!(i, 1);","}"],[1811,1812,1813,1814,1816,1817,1818]],[["{","    let data = [0b00000010]; // This will produce (1, 1)","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 1);","    assert_eq!(i, 1);","}"],[1811,1812,1813,1814,1816,1817,1818]],[["{","    let data = [0b11111110]; // Encoding a large positive number","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 63);","    assert_eq!(i, 1);","}"],[1811,1812,1813,1814,1816,1817,1818]],[["{","    let data = [0b00000010, 0b00000000]; // Minimum two-byte input","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 1);","    assert_eq!(i, 1); // `i` should still reflect the same byte count","}"],[1811,1812,1813,1814,1816,1817,1818]]],"codes_branches":[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let data: &[u8] = &[0b00000001]; // Encoding representing a positive varint (1)","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, 1);","    assert_eq!(bytes_read, 1);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":true,"negative":false}]],[["{","    let data: &[u8] = &[0b00000011]; // Encoding representing a negative varint (-1)","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, -1);","    assert_eq!(bytes_read, 1);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":true,"negative":false}]],[["{","    let data: &[u8] = &[0b00000010, 0b00000001]; // Encoding for 1 in two bytes","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, 2);","    assert_eq!(bytes_read, 2);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[0b11111111, 0b11111111, 0b11111111, 0b11111111]; // Encoding for the negative largest value","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, -2147483647 - 1); // corresponds to -2147483648","    assert_eq!(bytes_read, 4);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[0b00000010, 0b11111111, 0b11111111, 0b11111111]; // Encoding for a large positive value","    let (result, bytes_read) = read_vari32(data);","    assert_eq!(result, 2147483647);","    assert_eq!(bytes_read, 4);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":false,"negative":true}]],[["{","    let data = [0b00000000]; // This will produce (0, 1)","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 0);","    assert_eq!(i, 1);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":false,"negative":true}]],[["{","    let data = [0b00000010]; // This will produce (1, 1)","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 1);","    assert_eq!(i, 1);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":false,"negative":true}]],[["{","    let data = [0b11111110]; // Encoding a large positive number","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 63);","    assert_eq!(i, 1);","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":false,"negative":true}]],[["{","    let data = [0b00000010, 0b00000000]; // Minimum two-byte input","    let (n, i) = read_vari32(&data);","    assert_eq!(n, 1);","    assert_eq!(i, 1); // `i` should still reflect the same byte count","}"],[{"start_line":1814,"start_column":8,"end_line":1814,"end_column":19,"positive":false,"negative":true}]]]}