{"function_name":"regex::dfa::read_varu32","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":16,"tests_lines":[6,6,6,6,6,6,6,6,6,6,7,5,5,5,5,5],"oracles":16,"oracles_compiled":16,"oracles_compiled_rate":100.0,"tests_compiled":16,"tests_compiled_rate":100.0,"oracles_run":16,"oracles_passed":8,"oracles_passed_rate":50.0,"tests_run":16,"tests_passed":8,"tests_passed_rate":50.0,"lines":11,"lines_covered":11,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[1830,1831,1832,1833,1834,1835,1836,1837,1838,1840,1841],"codes_lines_covered":[[["{","    let data: &[u8] = &[0b0000_0011]; // Represents the value 3","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 3);","    assert_eq!(bytes_read, 1);","}"],[1830,1831,1832,1833,1834,1835,1841]],[["{","    let data: &[u8] = &[0b1000_0001, 0b0000_0001]; // Represents the value 129 (1 * 128 + 1)","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 129);","    assert_eq!(bytes_read, 2);","}"],[1830,1831,1832,1833,1834,1835,1836,1837,1838,1841]],[["{","    let data: &[u8] = &[0b1000_0001, 0b1000_0010, 0b0000_0011]; // Represents the value 13185 (1 * 128 * 128 + 2 * 128 + 3)","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 13185);","    assert_eq!(bytes_read, 3);","}"],[1830,1831,1832,1833,1834,1835,1836,1837,1838,1841]],[["{","    let data: &[u8] = &[0b1111_1111]; // Should continue to read expecting more bytes","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 0);","    assert_eq!(bytes_read, 0);","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]],[["{","    let data: &[u8] = &[]; // Input is empty","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 0);","    assert_eq!(bytes_read, 0);","}"],[1830,1831,1832,1833,1840,1841]],[["{","    let data = [0b0000_0001, 0b0000_0010]; // Expected to read the varint correctly","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 0b0000_0001 | (0b0000_0010 << 7)); // 0b0000_0001 + (0b0000_0010 << 7) = 128 + 1 = 129","    assert_eq!(bytes_read, 2); // Should read 2 bytes","}"],[1830,1831,1832,1833,1834,1835,1841]],[["{","    let data = [0b1000_0000]; // The first byte is set to zero","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 0); // Should return 0 since the first byte indicates continuation","    assert_eq!(bytes_read, 1); // Should read 1 byte","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]],[["{","    let data: &[u8] = &[]; // An empty input to check the function's response","    let (result, bytes_read) = read_varu32(data);","    assert_eq!(result, 0); // Should return 0","    assert_eq!(bytes_read, 0); // Should indicate no bytes read","}"],[1830,1831,1832,1833,1840,1841]],[["{","    let data = [0b1000_0001]; // First byte continues; should result in the original value","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 1); // Should read a value of 1 after processing","    assert_eq!(bytes_read, 1); // Should read 1 byte","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]],[["{","    let data = [0b1000_0001, 0b0100_0001]; // Should process two bytes correctly","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 1 | (1 << 7)); // Result should represent the value encoded","    assert_eq!(bytes_read, 2); // Should read 2 bytes","}"],[1830,1831,1832,1833,1834,1835,1836,1837,1838,1841]],[["{","    let data = [0b1000_0000]; // ...","","    // Trigger panic condition","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 0); // This result should not apply; expecting a panic instead","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]],[["{","    let data: &[u8] = &[];","    let result = read_varu32(data);","    assert_eq!(result, (0, 0));","}"],[1830,1831,1832,1833,1840,1841]],[["{","    let data: &[u8] = &[0b1000_0000];","    let result = read_varu32(data);","    assert_eq!(result, (0, 0));","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]],[["{","    let data: &[u8] = &[0b1000_0000, 0b1000_0000];","    let result = read_varu32(data);","    assert_eq!(result, (0, 0));","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]],[["{","    let data: &[u8] = &[0b1111_1111];","    let result = read_varu32(data);","    assert_eq!(result, (0b1111_1111, 1));","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]],[["{","    let data: &[u8] = &[0b1010_1010, 0b1000_0001];","    let result = read_varu32(data);","    assert_eq!(result, (0b0000_0001_0101_010, 2));","}"],[1830,1831,1832,1833,1834,1836,1837,1838,1840,1841]]],"codes_branches":[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let data: &[u8] = &[0b0000_0011]; // Represents the value 3","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 3);","    assert_eq!(bytes_read, 1);","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":true,"negative":false}]],[["{","    let data: &[u8] = &[0b1000_0001, 0b0000_0001]; // Represents the value 129 (1 * 128 + 1)","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 129);","    assert_eq!(bytes_read, 2);","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":true,"negative":true}]],[["{","    let data: &[u8] = &[0b1000_0001, 0b1000_0010, 0b0000_0011]; // Represents the value 13185 (1 * 128 * 128 + 2 * 128 + 3)","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 13185);","    assert_eq!(bytes_read, 3);","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":true,"negative":true}]],[["{","    let data: &[u8] = &[0b1111_1111]; // Should continue to read expecting more bytes","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 0);","    assert_eq!(bytes_read, 0);","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[]; // Input is empty","    let (value, bytes_read) = read_varu32(data);","    assert_eq!(value, 0);","    assert_eq!(bytes_read, 0);","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":false}]],[["{","    let data = [0b0000_0001, 0b0000_0010]; // Expected to read the varint correctly","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 0b0000_0001 | (0b0000_0010 << 7)); // 0b0000_0001 + (0b0000_0010 << 7) = 128 + 1 = 129","    assert_eq!(bytes_read, 2); // Should read 2 bytes","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":true,"negative":false}]],[["{","    let data = [0b1000_0000]; // The first byte is set to zero","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 0); // Should return 0 since the first byte indicates continuation","    assert_eq!(bytes_read, 1); // Should read 1 byte","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[]; // An empty input to check the function's response","    let (result, bytes_read) = read_varu32(data);","    assert_eq!(result, 0); // Should return 0","    assert_eq!(bytes_read, 0); // Should indicate no bytes read","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":false}]],[["{","    let data = [0b1000_0001]; // First byte continues; should result in the original value","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 1); // Should read a value of 1 after processing","    assert_eq!(bytes_read, 1); // Should read 1 byte","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]],[["{","    let data = [0b1000_0001, 0b0100_0001]; // Should process two bytes correctly","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 1 | (1 << 7)); // Result should represent the value encoded","    assert_eq!(bytes_read, 2); // Should read 2 bytes","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":true,"negative":true}]],[["{","    let data = [0b1000_0000]; // ...","","    // Trigger panic condition","    let (result, bytes_read) = read_varu32(&data);","    assert_eq!(result, 0); // This result should not apply; expecting a panic instead","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[];","    let result = read_varu32(data);","    assert_eq!(result, (0, 0));","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":false}]],[["{","    let data: &[u8] = &[0b1000_0000];","    let result = read_varu32(data);","    assert_eq!(result, (0, 0));","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[0b1000_0000, 0b1000_0000];","    let result = read_varu32(data);","    assert_eq!(result, (0, 0));","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[0b1111_1111];","    let result = read_varu32(data);","    assert_eq!(result, (0b1111_1111, 1));","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]],[["{","    let data: &[u8] = &[0b1010_1010, 0b1000_0001];","    let result = read_varu32(data);","    assert_eq!(result, (0b0000_0001_0101_010, 2));","}"],[{"start_line":1834,"start_column":12,"end_line":1834,"end_column":27,"positive":false,"negative":true}]]]}