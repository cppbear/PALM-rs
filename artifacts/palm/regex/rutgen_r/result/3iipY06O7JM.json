{"function_name":"regex::exec::exec::ExecBuilder::automatic","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/exec.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[22,16],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[152,153,154,155],"codes_lines_covered":[[["{","    struct Regex {","        match_type: Option<()>,","    }","","    impl Regex {","        pub fn automatic(mut self) -> Self {","            self.match_type = None;","            self","        }","    }","","    // Testing the automatic function when match_type is initially Some","    let regex_with_some = Regex { match_type: Some(()) };","    let result_with_some = regex_with_some.automatic();","    assert_eq!(result_with_some.match_type, None);","","    // Testing the automatic function when match_type is initially None","    let regex_with_none = Regex { match_type: None };","    let result_with_none = regex_with_none.automatic();","    assert_eq!(result_with_none.match_type, None);","}"],[]],[["{","    struct Regex {","        match_type: Option<()>,","    }","","    impl Regex {","        pub fn automatic(mut self) -> Self {","            self.match_type = None;","            self","        }","    }","","    // Creating an instance of Regex with some invalid state that might be expected to cause a panic.","    let regex_with_invalid = Regex { match_type: Some(()) };","    let _result = regex_with_invalid.automatic(); // Assert logic can be extended if more properties were checked.","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Regex {","        match_type: Option<()>,","    }","","    impl Regex {","        pub fn automatic(mut self) -> Self {","            self.match_type = None;","            self","        }","    }","","    // Testing the automatic function when match_type is initially Some","    let regex_with_some = Regex { match_type: Some(()) };","    let result_with_some = regex_with_some.automatic();","    assert_eq!(result_with_some.match_type, None);","","    // Testing the automatic function when match_type is initially None","    let regex_with_none = Regex { match_type: None };","    let result_with_none = regex_with_none.automatic();","    assert_eq!(result_with_none.match_type, None);","}"],[]],[["{","    struct Regex {","        match_type: Option<()>,","    }","","    impl Regex {","        pub fn automatic(mut self) -> Self {","            self.match_type = None;","            self","        }","    }","","    // Creating an instance of Regex with some invalid state that might be expected to cause a panic.","    let regex_with_invalid = Regex { match_type: Some(()) };","    let _result = regex_with_invalid.automatic(); // Assert logic can be extended if more properties were checked.","}"],[]]]}