{"function_name":"regex::utf8::is_start_byte","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/utf8.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":1,"tests_lines":[25],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":1,"tests_passed":0,"tests_passed_rate":0.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[144,145,146],"codes_lines_covered":[[["{","    // Test with a byte that is a valid start byte (110xxxxx)","    let valid_start_byte_1: u8 = 0b11000000; // Should return true","    assert!(is_start_byte(valid_start_byte_1));","","    // Test with a byte that is a valid start byte (1110xxxx)","    let valid_start_byte_2: u8 = 0b11100000; // Should return true","    assert!(is_start_byte(valid_start_byte_2));","","    // Test with a byte that is not a valid start byte (10xxxxxx)","    let invalid_start_byte_1: u8 = 0b10000000; // Should return false","    assert!(!is_start_byte(invalid_start_byte_1));","","    // Test with a byte that is not a valid start byte (10xxxxxx)","    let invalid_start_byte_2: u8 = 0b10111111; // Should return false","    assert!(!is_start_byte(invalid_start_byte_2));","","    // Test with a byte that is not a valid start byte (0xxxxxxx)","    let invalid_start_byte_3: u8 = 0b00000000; // Should return false","    assert!(!is_start_byte(invalid_start_byte_3));","","    // Test with a byte that is not a valid start byte (1111xxxx)","    let invalid_start_byte_4: u8 = 0b11110000; // Should return true, but is not a valid start byte as per the UTF-8 rules.","    assert!(is_start_byte(invalid_start_byte_4));","}"],[144,145,146]]],"codes_branches":[],"codes_branches_covered":[[["{","    // Test with a byte that is a valid start byte (110xxxxx)","    let valid_start_byte_1: u8 = 0b11000000; // Should return true","    assert!(is_start_byte(valid_start_byte_1));","","    // Test with a byte that is a valid start byte (1110xxxx)","    let valid_start_byte_2: u8 = 0b11100000; // Should return true","    assert!(is_start_byte(valid_start_byte_2));","","    // Test with a byte that is not a valid start byte (10xxxxxx)","    let invalid_start_byte_1: u8 = 0b10000000; // Should return false","    assert!(!is_start_byte(invalid_start_byte_1));","","    // Test with a byte that is not a valid start byte (10xxxxxx)","    let invalid_start_byte_2: u8 = 0b10111111; // Should return false","    assert!(!is_start_byte(invalid_start_byte_2));","","    // Test with a byte that is not a valid start byte (0xxxxxxx)","    let invalid_start_byte_3: u8 = 0b00000000; // Should return false","    assert!(!is_start_byte(invalid_start_byte_3));","","    // Test with a byte that is not a valid start byte (1111xxxx)","    let invalid_start_byte_4: u8 = 0b11110000; // Should return true, but is not a valid start byte as per the UTF-8 rules.","    assert!(is_start_byte(invalid_start_byte_4));","}"],[]]]}