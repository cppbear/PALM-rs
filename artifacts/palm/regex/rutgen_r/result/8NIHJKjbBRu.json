{"function_name":"regex::utf8::next_utf8","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/utf8.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":21,"tests_lines":[6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6],"oracles":21,"oracles_compiled":21,"oracles_compiled_rate":100.0,"tests_compiled":21,"tests_compiled_rate":100.0,"oracles_run":21,"oracles_passed":17,"oracles_passed_rate":80.95238095238095,"tests_run":21,"tests_passed":17,"tests_passed_rate":80.95238095238095,"lines":13,"lines_covered":13,"lines_coveraged_rate":100.0,"branches":6,"branches_covered":6,"branches_coverage_rate":100.0,"codes_lines":[24,25,26,27,29,30,31,32,33,34,36,38,39],"codes_lines_covered":[[["{","    let text: &[u8] = b\"Hello, world!\";","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 1); // Expect moving to next byte","}"],[24,25,27,29,30,38,39]],[["{","    let text: &[u8] = b\"\\xC2\\xA9\"; // Â© character","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 2); // Expect moving past two bytes","}"],[24,25,27,29,31,32,38,39]],[["{","    let text: &[u8] = b\"\\xE2\\x82\\xAC\"; // â‚¬ character","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 3); // Expect moving past three bytes","}"],[24,25,27,29,31,33,34,38,39]],[["{","    let text: &[u8] = b\"\\xF0\\x9F\\x98\\x80\"; // ðŸ˜€ character","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 4); // Expect moving past four bytes","}"],[24,25,27,29,31,33,36,38,39]],[["{","    let text: &[u8] = b\"\";","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 1); // Out of bounds; expect moving to next index","}"],[24,25,26,39]],[["{","    let text: &[u8] = b\"\\x7F\"; // Boundary value for single byte","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 1); // Expect moving to next index","}"],[24,25,27,29,30,38,39]],[["{","    let text: &[u8] = &[0b110_11111, 0b101_00000, 0b101_00001]; // 3-byte UTF-8 sequence starts with 0b110_11111","    let index = 0; // Starting index","    let result = next_utf8(text, index);","    assert_eq!(result, index + 2); // Since 0b110_11111 is 2 bytes; expect index + 2","}"],[24,25,27,29,31,32,38,39]],[["{","    let text: &[u8] = &[0b110_11111, 0b101_00000];","    let index = 2; // Out of bounds index, should trigger the panic condition","    let result = next_utf8(text, index);","    assert_eq!(result, index + 1); // Expect going out of bounds returns index + 1","}"],[24,25,26,39]],[["{","    let text: &[u8] = &[0b1110_1111, 0b101_00000, 0b101_00001, 0b101_00010]; // 4-byte UTF-8 sequence starts with 0b1110_1111","    let index = 0; // Starting index","    let result = next_utf8(text, index);","    assert_eq!(result, index + 3); // Expect index + 3 since it is a 4-byte sequence","}"],[24,25,27,29,31,33,34,38,39]],[["{","    let text: &[u8] = &[0b110_00010, 0b101_00000]; // 2-byte UTF-8 sequence starting with 0b110_00010","    let index = 0; // Starting index","    let result = next_utf8(text, index);","    assert_eq!(result, index + 2); // Expect index + 2 since it's a 2-byte sequence","}"],[24,25,27,29,31,32,38,39]],[["{","    let text = &[0b1110_1111, 0b10_000000]; // Valid UTF-8 sequence starting with 0b1110_1111","    let index = 0; // starting index","    let result = next_utf8(text, index);","    assert_eq!(result, 2); // Expecting index 0 + inc (3), which would point to the next byte","}"],[24,25,27,29,31,33,34,38,39]],[["{","    let text = &[0b110_11111, 0b10_000000]; // Invalid UTF-8 sequence starting with 0b110_11111","    let index = 0; // starting index","    let result = next_utf8(text, index);","    assert_eq!(result, 1); // Expecting index 0 + inc (2), which points to next byte","}"],[24,25,27,29,31,32,38,39]],[["{","    let text = &[0u8]; // Single byte","    let index = 1; // starting index out of bounds","    let result = next_utf8(text, index);","    assert_eq!(result, 2); // Expecting index 1 + 1","}"],[24,25,26,39]],[["{","    let text = &[0b1110_1111]; // Single valid byte that forms a start of a sequence","    let index = 0; // starting index","    let result = next_utf8(text, index);","    assert_eq!(result, 1); // Expecting index 0 + inc (1)","}"],[24,25,27,29,31,33,34,38,39]],[["{","    let text = &[0xF0, 0x90, 0x80, 0x80]; // UTF-8 sequence for U+10000","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 4); // Next valid UTF-8 index after the four-byte sequence","}"],[24,25,27,29,31,33,36,38,39]],[["{","    let text = &[0xE0, 0xA0, 0x80]; // UTF-8 sequence for U+0800","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 3); // Next valid UTF-8 index after the three-byte sequence","}"],[24,25,27,29,31,33,34,38,39]],[["{","    let text = &[0xC2, 0xA9]; // UTF-8 sequence for U+00A9","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 2); // Next valid UTF-8 index after the two-byte sequence","}"],[24,25,27,29,31,32,38,39]],[["{","    let text = &[0x80]; // Invalid single byte","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 1); // Since b <= 0x7F is false, we should skip it and return i + 1","}"],[24,25,27,29,31,32,38,39]],[["{","    let text: &[u8] = &[]; // Empty input","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 1); // Since `text.get(i)` is None, return i + 1","}"],[24,25,26,39]],[["{","    let text: Vec<u8> = Vec::new(); // An empty vector simulates the None case","    let index = 0;","    let result = next_utf8(&text, index);","    assert_eq!(result, index + 1); // Expected to return 1","}"],[24,25,26,39]],[["{","    let text = vec![b'a', b'b', b'c']; // Valid UTF-8 sequence","    let index = text.len(); // Index is equal to the length of the array","    let result = next_utf8(&text, index);","    assert_eq!(result, index + 1); // Expected to return 4, since index is out of bounds","}"],[24,25,26,39]]],"codes_branches":[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":true,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":true,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let text: &[u8] = b\"Hello, world!\";","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 1); // Expect moving to next byte","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":true,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: &[u8] = b\"\\xC2\\xA9\"; // Â© character","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 2); // Expect moving past two bytes","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":true,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: &[u8] = b\"\\xE2\\x82\\xAC\"; // â‚¬ character","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 3); // Expect moving past three bytes","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":true,"negative":false}]],[["{","    let text: &[u8] = b\"\\xF0\\x9F\\x98\\x80\"; // ðŸ˜€ character","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 4); // Expect moving past four bytes","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":true}]],[["{","    let text: &[u8] = b\"\";","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 1); // Out of bounds; expect moving to next index","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: &[u8] = b\"\\x7F\"; // Boundary value for single byte","    let start_index = 0;","    let result = next_utf8(text, start_index);","    assert_eq!(result, start_index + 1); // Expect moving to next index","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":true,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: &[u8] = &[0b110_11111, 0b101_00000, 0b101_00001]; // 3-byte UTF-8 sequence starts with 0b110_11111","    let index = 0; // Starting index","    let result = next_utf8(text, index);","    assert_eq!(result, index + 2); // Since 0b110_11111 is 2 bytes; expect index + 2","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":true,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: &[u8] = &[0b110_11111, 0b101_00000];","    let index = 2; // Out of bounds index, should trigger the panic condition","    let result = next_utf8(text, index);","    assert_eq!(result, index + 1); // Expect going out of bounds returns index + 1","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: &[u8] = &[0b1110_1111, 0b101_00000, 0b101_00001, 0b101_00010]; // 4-byte UTF-8 sequence starts with 0b1110_1111","    let index = 0; // Starting index","    let result = next_utf8(text, index);","    assert_eq!(result, index + 3); // Expect index + 3 since it is a 4-byte sequence","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":true,"negative":false}]],[["{","    let text: &[u8] = &[0b110_00010, 0b101_00000]; // 2-byte UTF-8 sequence starting with 0b110_00010","    let index = 0; // Starting index","    let result = next_utf8(text, index);","    assert_eq!(result, index + 2); // Expect index + 2 since it's a 2-byte sequence","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":true,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text = &[0b1110_1111, 0b10_000000]; // Valid UTF-8 sequence starting with 0b1110_1111","    let index = 0; // starting index","    let result = next_utf8(text, index);","    assert_eq!(result, 2); // Expecting index 0 + inc (3), which would point to the next byte","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":true,"negative":false}]],[["{","    let text = &[0b110_11111, 0b10_000000]; // Invalid UTF-8 sequence starting with 0b110_11111","    let index = 0; // starting index","    let result = next_utf8(text, index);","    assert_eq!(result, 1); // Expecting index 0 + inc (2), which points to next byte","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":true,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text = &[0u8]; // Single byte","    let index = 1; // starting index out of bounds","    let result = next_utf8(text, index);","    assert_eq!(result, 2); // Expecting index 1 + 1","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text = &[0b1110_1111]; // Single valid byte that forms a start of a sequence","    let index = 0; // starting index","    let result = next_utf8(text, index);","    assert_eq!(result, 1); // Expecting index 0 + inc (1)","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":true,"negative":false}]],[["{","    let text = &[0xF0, 0x90, 0x80, 0x80]; // UTF-8 sequence for U+10000","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 4); // Next valid UTF-8 index after the four-byte sequence","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":true}]],[["{","    let text = &[0xE0, 0xA0, 0x80]; // UTF-8 sequence for U+0800","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 3); // Next valid UTF-8 index after the three-byte sequence","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":true},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":true,"negative":false}]],[["{","    let text = &[0xC2, 0xA9]; // UTF-8 sequence for U+00A9","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 2); // Next valid UTF-8 index after the two-byte sequence","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":true,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text = &[0x80]; // Invalid single byte","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 1); // Since b <= 0x7F is false, we should skip it and return i + 1","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":true},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":true,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: &[u8] = &[]; // Empty input","    let i = 0;","    let result = next_utf8(text, i);","    assert_eq!(result, 1); // Since `text.get(i)` is None, return i + 1","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text: Vec<u8> = Vec::new(); // An empty vector simulates the None case","    let index = 0;","    let result = next_utf8(&text, index);","    assert_eq!(result, index + 1); // Expected to return 1","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]],[["{","    let text = vec![b'a', b'b', b'c']; // Valid UTF-8 sequence","    let index = text.len(); // Index is equal to the length of the array","    let result = next_utf8(&text, index);","    assert_eq!(result, index + 1); // Expected to return 4, since index is out of bounds","}"],[{"start_line":29,"start_column":18,"end_line":29,"end_column":27,"positive":false,"negative":false},{"start_line":31,"start_column":15,"end_line":31,"end_column":31,"positive":false,"negative":false},{"start_line":33,"start_column":15,"end_line":33,"end_column":31,"positive":false,"negative":false}]]]}