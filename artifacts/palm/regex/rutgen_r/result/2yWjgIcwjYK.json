{"function_name":"regex::prog::<prog::Program as std::fmt::Debug>::fmt","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/prog.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":18,"tests_lines":[53,11,27,47,40,52,54,71,51,49,41,51,48,61,61,43,31,60],"oracles":18,"oracles_compiled":7,"oracles_compiled_rate":38.88888888888889,"tests_compiled":7,"tests_compiled_rate":38.88888888888889,"oracles_run":7,"oracles_passed":5,"oracles_passed_rate":71.42857142857143,"tests_run":7,"tests_passed":5,"tests_passed_rate":71.42857142857143,"lines":46,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":4,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[170,173,174,175,177,179,181,183,184,185,187,188,189,190,192,193,194,196,197,198,200,201,202,204,205,206,208,209,210,211,212,213,214,215,217,218,219,220,221,222,225,226,227,228,230,231],"codes_lines_covered":[[["{","    struct Inst {","        goto: usize,","        // Dummy struct for panic testing","        ranges: Vec<(u8, u8)>,","    }","","    struct Regex {","        inst: Vec<Inst>,","        start: usize,","    }","","    impl Regex {","        fn iter(&self) -> std::slice::Iter<Inst> {","            self.inst.iter()","        }","    }","","    use std::fmt;","","    impl fmt::Display for Regex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            // A forced panic condition","            Err(fmt::Error)","        }","    }","","    let regex = Regex {","        inst: vec![","            Inst {","                goto: 1,","                ranges: vec![(0x61, 0x7A)],","            },","        ],","        start: 0,","    };","","    // This will panic due to forced error in fmt implementation","    let _ = format!(\"{}\", regex);","}"],[]],[["{","    use std::fmt;","","    #[derive(Debug)]","    struct CharInst {","        c: char,","        goto: usize,","    }","","    #[derive(Debug)]","    struct Inst {","        inst: Vec<InstEnum>,","        start: usize,","    }","","    #[derive(Debug)]","    enum InstEnum {","        Char(CharInst),","    }","","    impl Inst {","        fn iter(&self) -> std::slice::Iter<InstEnum> {","            self.inst.iter()","        }","    }","","    impl fmt::Display for Inst {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    InstEnum::Char(inst) => {","                        let s = format!(\"{:?}\", inst.c);","                        write!(f, \"{:04} {}\", pc, inst.goto)?;","                    }","                }","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    let char_inst = CharInst { c: 'a', goto: 0 };","    let instructions = vec![InstEnum::Char(char_inst)];","    let inst = Inst { inst: instructions, start: 0 };","","    // Capture the output","    let result = format!(\"{}\", inst);","    assert_eq!(result, \"0000 0\\n (start)\\n\");","}"],[]],[["{","    use std::fmt;","","    #[derive(Debug)]","    struct CharInst {","        c: char,","        goto: usize,","    }","","    #[derive(Debug)]","    struct Inst {","        inst: Vec<InstEnum>,","        start: usize,","    }","","    #[derive(Debug)]","    enum InstEnum {","        Char(CharInst),","    }","","    impl Inst {","        fn iter(&self) -> std::slice::Iter<InstEnum> {","            self.inst.iter()","        }","    }","","    impl fmt::Display for Inst {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    InstEnum::Char(inst) => {","                        // Err one condition to trigger a panic","                        if inst.goto == 0 {","                            return Err(fmt::Error);","                        }","                        write!(f, \"{:04} {}\", pc, inst.goto)?;","                    }","                }","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    let char_inst = CharInst { c: 'b', goto: 0 }; // This should cause a panic","    let instructions = vec![InstEnum::Char(char_inst)];","    let inst = Inst { inst: instructions, start: 0 };","","    // This should panic due to the Error condition","    let _ = format!(\"{}\", inst);","}"],[]],[["{","    use std::fmt;","","    struct Inst {","        goto: usize,","        look: String,","    }","","    struct Regex {","        instructions: Vec<Inst>,","        start: usize,","    }","","    impl Regex {","        fn iter(&self) -> std::slice::Iter<Inst> {","            self.instructions.iter()","        }","    }","","    impl fmt::Display for Regex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            use self::Inst::*;","","            fn with_goto(cur: usize, goto: usize, fmtd: String) -> String {","                if goto == cur + 1 {","                    fmtd","                } else {","                    format!(\"{} (goto: {})\", fmtd, goto)","                }","            }","","            for (pc, inst) in self.iter().enumerate() {","                let inst = inst; // Getting the reference","                match inst {","                    Inst { goto, look } => {","                        let s = format!(\"{:?}\", look);","                        let output = write!(f, \"{:04} {}\", pc, with_goto(pc, *goto, s));","                        // Simulate a panic condition","                        if pc == 0 && *goto > 10 {","                            panic!(\"Invalid goto value\");","                        } ","                        output?;","                    }","                }","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    // Setting up test instances","    let invalid_goto_instructions = vec![","        Inst { goto: 12, look: String::from(\"EmptyLook\") }, // Invalid goto","        Inst { goto: 5, look: String::from(\"AnotherLook\") },","    ];","","    let regex = Regex {","        instructions: invalid_goto_instructions,","        start: 0,","    };","","    // This should trigger a panic due to invalid goto value.","    let result = std::panic::catch_unwind(|| {","        let _ = format!(\"{}\", regex);","    });","","    assert!(result.is_err(), \"Expected panic due to invalid goto value.\");","}"],[]],[["{","    struct TestInst {","        goto1: usize,","        goto2: usize,","    }","","    struct TestRegex {","        start: usize,","        inst: Vec<TestInst>,","    }","","    impl TestRegex {","        fn iter(&self) -> std::slice::Iter<TestInst> {","            self.inst.iter()","        }","    }","","    use std::fmt;","","    impl fmt::Display for TestRegex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    inst if pc != self.start => {","                        write!(f, \"{:04} Split({}, {})\", pc, inst.goto1, inst.goto2)?;","                    }","                    _ => {}","                }","","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    let regex = TestRegex {","        start: 0,","        inst: vec![","            TestInst { goto1: 1, goto2: 2 },","            TestInst { goto1: 3, goto2: 4 },","        ],","    };","","    let result = format!(\"{}\", regex);","    assert_eq!(result, \"0000 Split(3, 4)\\n0001 (start)\\n\");","}"],[]],[["{","    struct ErrorInst {","        goto1: usize,","        goto2: usize,","    }","","    struct ErrorRegex {","        start: usize,","        inst: Vec<ErrorInst>,","    }","","    impl ErrorRegex {","        fn iter(&self) -> std::slice::Iter<ErrorInst> {","            self.inst.iter()","        }","    }","","    use std::fmt;","","    impl fmt::Display for ErrorRegex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    _ => {","                        return Err(fmt::Error);","                    }","                }","            }","            Ok(())","        }","    }","","    let err_regex = ErrorRegex {","        start: 0,","        inst: vec![","            ErrorInst { goto1: 1, goto2: 2 },","        ],","    };","","    let _ = format!(\"{}\", err_regex);","}"],[]],[["{","    use std::fmt;","","    #[derive(Debug)]","    struct Inst {","        start: usize,","        instructions: Vec<Instruction>,","    }","","    #[derive(Debug)]","    struct Instruction {","        goto1: usize,","        goto2: usize,","    }","","    impl Inst {","        fn iter(&self) -> std::slice::Iter<Instruction> {","            self.instructions.iter()","        }","    }","","    impl fmt::Display for Inst {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            let pc = 0; // start pc","            for (idx, inst) in self.iter().enumerate() {","                match inst {","                    Instruction { goto1, goto2 } => {","                        // Simulate a panic situation","                        if goto1 % 2 == 0 {","                            panic!(\"Intentional panic for even goto1\");","                        }","                        write!(f, \"{:04} Split({}, {})\", pc, goto1, goto2)?;","                        if pc == self.start {","                            write!(f, \" (start)\")?;","                        }","                        write!(f, \"\\n\")?;","                    }","                }","            }","            Ok(())","        }","    }","","    let instructions = vec![Instruction { goto1: 2, goto2: 3 }];","    let inst = Inst { start: 0, instructions };","","    let _ = format!(\"{}\", inst); //This should cause panic","}"],[]]],"codes_branches":[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct Inst {","        goto: usize,","        // Dummy struct for panic testing","        ranges: Vec<(u8, u8)>,","    }","","    struct Regex {","        inst: Vec<Inst>,","        start: usize,","    }","","    impl Regex {","        fn iter(&self) -> std::slice::Iter<Inst> {","            self.inst.iter()","        }","    }","","    use std::fmt;","","    impl fmt::Display for Regex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            // A forced panic condition","            Err(fmt::Error)","        }","    }","","    let regex = Regex {","        inst: vec![","            Inst {","                goto: 1,","                ranges: vec![(0x61, 0x7A)],","            },","        ],","        start: 0,","    };","","    // This will panic due to forced error in fmt implementation","    let _ = format!(\"{}\", regex);","}"],[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}]],[["{","    use std::fmt;","","    #[derive(Debug)]","    struct CharInst {","        c: char,","        goto: usize,","    }","","    #[derive(Debug)]","    struct Inst {","        inst: Vec<InstEnum>,","        start: usize,","    }","","    #[derive(Debug)]","    enum InstEnum {","        Char(CharInst),","    }","","    impl Inst {","        fn iter(&self) -> std::slice::Iter<InstEnum> {","            self.inst.iter()","        }","    }","","    impl fmt::Display for Inst {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    InstEnum::Char(inst) => {","                        let s = format!(\"{:?}\", inst.c);","                        write!(f, \"{:04} {}\", pc, inst.goto)?;","                    }","                }","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    let char_inst = CharInst { c: 'a', goto: 0 };","    let instructions = vec![InstEnum::Char(char_inst)];","    let inst = Inst { inst: instructions, start: 0 };","","    // Capture the output","    let result = format!(\"{}\", inst);","    assert_eq!(result, \"0000 0\\n (start)\\n\");","}"],[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}]],[["{","    use std::fmt;","","    #[derive(Debug)]","    struct CharInst {","        c: char,","        goto: usize,","    }","","    #[derive(Debug)]","    struct Inst {","        inst: Vec<InstEnum>,","        start: usize,","    }","","    #[derive(Debug)]","    enum InstEnum {","        Char(CharInst),","    }","","    impl Inst {","        fn iter(&self) -> std::slice::Iter<InstEnum> {","            self.inst.iter()","        }","    }","","    impl fmt::Display for Inst {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    InstEnum::Char(inst) => {","                        // Err one condition to trigger a panic","                        if inst.goto == 0 {","                            return Err(fmt::Error);","                        }","                        write!(f, \"{:04} {}\", pc, inst.goto)?;","                    }","                }","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    let char_inst = CharInst { c: 'b', goto: 0 }; // This should cause a panic","    let instructions = vec![InstEnum::Char(char_inst)];","    let inst = Inst { inst: instructions, start: 0 };","","    // This should panic due to the Error condition","    let _ = format!(\"{}\", inst);","}"],[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}]],[["{","    use std::fmt;","","    struct Inst {","        goto: usize,","        look: String,","    }","","    struct Regex {","        instructions: Vec<Inst>,","        start: usize,","    }","","    impl Regex {","        fn iter(&self) -> std::slice::Iter<Inst> {","            self.instructions.iter()","        }","    }","","    impl fmt::Display for Regex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            use self::Inst::*;","","            fn with_goto(cur: usize, goto: usize, fmtd: String) -> String {","                if goto == cur + 1 {","                    fmtd","                } else {","                    format!(\"{} (goto: {})\", fmtd, goto)","                }","            }","","            for (pc, inst) in self.iter().enumerate() {","                let inst = inst; // Getting the reference","                match inst {","                    Inst { goto, look } => {","                        let s = format!(\"{:?}\", look);","                        let output = write!(f, \"{:04} {}\", pc, with_goto(pc, *goto, s));","                        // Simulate a panic condition","                        if pc == 0 && *goto > 10 {","                            panic!(\"Invalid goto value\");","                        } ","                        output?;","                    }","                }","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    // Setting up test instances","    let invalid_goto_instructions = vec![","        Inst { goto: 12, look: String::from(\"EmptyLook\") }, // Invalid goto","        Inst { goto: 5, look: String::from(\"AnotherLook\") },","    ];","","    let regex = Regex {","        instructions: invalid_goto_instructions,","        start: 0,","    };","","    // This should trigger a panic due to invalid goto value.","    let result = std::panic::catch_unwind(|| {","        let _ = format!(\"{}\", regex);","    });","","    assert!(result.is_err(), \"Expected panic due to invalid goto value.\");","}"],[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}]],[["{","    struct TestInst {","        goto1: usize,","        goto2: usize,","    }","","    struct TestRegex {","        start: usize,","        inst: Vec<TestInst>,","    }","","    impl TestRegex {","        fn iter(&self) -> std::slice::Iter<TestInst> {","            self.inst.iter()","        }","    }","","    use std::fmt;","","    impl fmt::Display for TestRegex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    inst if pc != self.start => {","                        write!(f, \"{:04} Split({}, {})\", pc, inst.goto1, inst.goto2)?;","                    }","                    _ => {}","                }","","                if pc == self.start {","                    write!(f, \" (start)\")?;","                }","                write!(f, \"\\n\")?;","            }","            Ok(())","        }","    }","","    let regex = TestRegex {","        start: 0,","        inst: vec![","            TestInst { goto1: 1, goto2: 2 },","            TestInst { goto1: 3, goto2: 4 },","        ],","    };","","    let result = format!(\"{}\", regex);","    assert_eq!(result, \"0000 Split(3, 4)\\n0001 (start)\\n\");","}"],[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}]],[["{","    struct ErrorInst {","        goto1: usize,","        goto2: usize,","    }","","    struct ErrorRegex {","        start: usize,","        inst: Vec<ErrorInst>,","    }","","    impl ErrorRegex {","        fn iter(&self) -> std::slice::Iter<ErrorInst> {","            self.inst.iter()","        }","    }","","    use std::fmt;","","    impl fmt::Display for ErrorRegex {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            for (pc, inst) in self.iter().enumerate() {","                match inst {","                    _ => {","                        return Err(fmt::Error);","                    }","                }","            }","            Ok(())","        }","    }","","    let err_regex = ErrorRegex {","        start: 0,","        inst: vec![","            ErrorInst { goto1: 1, goto2: 2 },","        ],","    };","","    let _ = format!(\"{}\", err_regex);","}"],[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}]],[["{","    use std::fmt;","","    #[derive(Debug)]","    struct Inst {","        start: usize,","        instructions: Vec<Instruction>,","    }","","    #[derive(Debug)]","    struct Instruction {","        goto1: usize,","        goto2: usize,","    }","","    impl Inst {","        fn iter(&self) -> std::slice::Iter<Instruction> {","            self.instructions.iter()","        }","    }","","    impl fmt::Display for Inst {","        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {","            let pc = 0; // start pc","            for (idx, inst) in self.iter().enumerate() {","                match inst {","                    Instruction { goto1, goto2 } => {","                        // Simulate a panic situation","                        if goto1 % 2 == 0 {","                            panic!(\"Intentional panic for even goto1\");","                        }","                        write!(f, \"{:04} Split({}, {})\", pc, goto1, goto2)?;","                        if pc == self.start {","                            write!(f, \" (start)\")?;","                        }","                        write!(f, \"\\n\")?;","                    }","                }","            }","            Ok(())","        }","    }","","    let instructions = vec![Instruction { goto1: 2, goto2: 3 }];","    let inst = Inst { start: 0, instructions };","","    let _ = format!(\"{}\", inst); //This should cause panic","}"],[{"start_line":225,"start_column":16,"end_line":225,"end_column":32,"positive":false,"negative":false},{"start_line":174,"start_column":16,"end_line":174,"end_column":31,"positive":false,"negative":false}]]]}