{"function_name":"regex::exec::exec::ExecBuilder::bounded_backtracking","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/exec.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":3,"tests_lines":[25,25,24],"oracles":3,"oracles_compiled":2,"oracles_compiled_rate":66.66666666666666,"tests_compiled":2,"tests_compiled_rate":66.66666666666666,"oracles_run":2,"oracles_passed":1,"oracles_passed_rate":50.0,"tests_run":2,"tests_passed":1,"tests_passed_rate":50.0,"lines":4,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[175,176,177,178],"codes_lines_covered":[[["{","    struct Regex {","        match_type: Option<MatchType>,","    }","","    impl Regex {","        pub fn bounded_backtracking(mut self) -> Self {","            self.match_type = Some(MatchType::Nfa(MatchNfaType::Backtrack));","            self","        }","    }","","    enum MatchType {","        Nfa(MatchNfaType),","    }","","    enum MatchNfaType {","        Backtrack,","    }","","    let regex = Regex { match_type: None };","    let updated_regex = regex.bounded_backtracking();","    ","    assert!(matches!(updated_regex.match_type, Some(MatchType::Nfa(MatchNfaType::Backtrack))));","}"],[]],[["{","    struct Regex {","        match_type: Option<MatchType>,","    }","","    impl Regex {","        pub fn bounded_backtracking(mut self) -> Self {","            self.match_type = Some(MatchType::Nfa(MatchNfaType::Backtrack));","            self","        }","    }","","    enum MatchType {","        Nfa(MatchNfaType),","    }","","    enum MatchNfaType {","        Backtrack,","    }","","    // Code that triggers the panic condition","    let regex = Regex { match_type: None };","    let _ = regex.bounded_backtracking(); // Insert panic-triggering condition if applicable","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Regex {","        match_type: Option<MatchType>,","    }","","    impl Regex {","        pub fn bounded_backtracking(mut self) -> Self {","            self.match_type = Some(MatchType::Nfa(MatchNfaType::Backtrack));","            self","        }","    }","","    enum MatchType {","        Nfa(MatchNfaType),","    }","","    enum MatchNfaType {","        Backtrack,","    }","","    let regex = Regex { match_type: None };","    let updated_regex = regex.bounded_backtracking();","    ","    assert!(matches!(updated_regex.match_type, Some(MatchType::Nfa(MatchNfaType::Backtrack))));","}"],[]],[["{","    struct Regex {","        match_type: Option<MatchType>,","    }","","    impl Regex {","        pub fn bounded_backtracking(mut self) -> Self {","            self.match_type = Some(MatchType::Nfa(MatchNfaType::Backtrack));","            self","        }","    }","","    enum MatchType {","        Nfa(MatchNfaType),","    }","","    enum MatchNfaType {","        Backtrack,","    }","","    // Code that triggers the panic condition","    let regex = Regex { match_type: None };","    let _ = regex.bounded_backtracking(); // Insert panic-triggering condition if applicable","}"],[]]]}