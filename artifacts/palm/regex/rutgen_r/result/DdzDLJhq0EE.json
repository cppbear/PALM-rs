{"function_name":"regex::literal::literal::FreqyPacked::new","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":20,"tests_lines":[6,11,11,11,62,20,62,10,10,10,4,6,4,6,6,9,9,9,9,5],"oracles":20,"oracles_compiled":14,"oracles_compiled_rate":70.0,"tests_compiled":14,"tests_compiled_rate":70.0,"oracles_run":14,"oracles_passed":10,"oracles_passed_rate":71.42857142857143,"tests_run":14,"tests_passed":10,"tests_passed_rate":71.42857142857143,"lines":32,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":10,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[447,448,449,450,451,452,453,454,455,456,457,458,459,461,462,463,464,465,466,470,471,472,473,474,475,476,477,478,479,480,481,482],"codes_lines_covered":[[["{","    // Test for a non-empty pattern","    let input = vec![5, 3, 1, 2, 3, 5];","    let result = new(input.clone());","    assert_eq!(result.pat, input);","    assert_eq!(result.rare1, 1);","    assert_eq!(result.rare2, 2);","    assert_eq!(result.rare1i, 2);","    assert_eq!(result.rare2i, 3);","    assert_eq!(result.char_len, 6);","}"],[]],[["{","    // Test for a pattern with distinct bytes","    let input = vec![7, 8, 6, 5, 2, 3, 4];","    let result = new(input.clone());","    assert_eq!(result.pat, input);","    assert_eq!(result.rare1, 2);","    assert_eq!(result.rare2, 3);","    assert_eq!(result.rare1i, 4);","    assert_eq!(result.rare2i, 5);","    assert_eq!(result.char_len, 7);","}"],[]],[["{","    // Test for a pattern with the same byte repeated","    let input = vec![9, 9, 9, 9];","    let result = new(input.clone());","    assert_eq!(result.pat, input);","    assert_eq!(result.rare1, 9);","    assert_eq!(result.rare2, 9);","    assert_eq!(result.rare1i, 3);","    assert_eq!(result.rare2i, 3);","    assert_eq!(result.char_len, 4);","}"],[]],[["{","    struct FreqyPacked {","        pat: Vec<u8>,","        char_len: usize,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    fn freq_rank(_byte: u8) -> usize {","        1 // Placeholder implementation for testing","    }","","    fn char_len_lossy(pat: &Vec<u8>) -> usize {","        pat.len() // Simple implementation for testing","    }","","    fn new(pat: Vec<u8>) -> FreqyPacked {","        if pat.is_empty() {","            return FreqyPacked { pat: vec![], char_len: 0, rare1: 0, rare1i: 0, rare2: 0, rare2i: 0 };","        }","","        let mut rare1 = pat[0];","        let mut rare2 = pat[0];","        for b in pat[1..].iter().cloned() {","            if freq_rank(b) < freq_rank(rare1) {","                rare1 = b;","            }","        }","        for &b in &pat {","            if rare1 == rare2 {","                rare2 = b;","            } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {","                rare2 = b;","            }","        }","","        let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();","        let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();","","        let char_len = char_len_lossy(&pat);","        FreqyPacked {","            pat: pat,","            char_len: char_len,","            rare1: rare1,","            rare1i: rare1i,","            rare2: rare2,","            rare2i: rare2i,","        }","    }","","    let pat = vec![10, 20, 10, 30, 20];","    let packed = new(pat.clone());","","    assert_eq!(packed.pat, pat);","    assert_eq!(packed.char_len, pat.len());","    assert_eq!(packed.rare1, 10);","    assert_eq!(packed.rare1i, 2);","    assert_eq!(packed.rare2, 20);","    assert_eq!(packed.rare2i, 4);","}"],[]],[["{","    struct FreqyPacked {","        pat: Vec<u8>,","        char_len: usize,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    fn new(pat: Vec<u8>) -> FreqyPacked {","        if pat.is_empty() {","            panic!(\"Pattern cannot be empty\");","        }","        // Implementation omitted for brevity","        FreqyPacked { pat, char_len: 0, rare1: 0, rare1i: 0, rare2: 0, rare2i: 0 }","    }","","    new(vec![]);","}"],[]],[["{","    struct FreqyPacked {","        pat: Vec<u8>,","        char_len: usize,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    fn freq_rank(_byte: u8) -> usize {","        1 // Placeholder implementation","    }","","    fn char_len_lossy(pat: &Vec<u8>) -> usize {","        pat.len() // Placeholder implementation","    }","","    fn new(pat: Vec<u8>) -> FreqyPacked {","        if pat.is_empty() {","            return FreqyPacked { pat: vec![], char_len: 0, rare1: 0, rare1i: 0, rare2: 0, rare2i: 0 };","        }","","        let mut rare1 = pat[0];","        let mut rare2 = pat[0];","        for b in pat[1..].iter().cloned() {","            if freq_rank(b) < freq_rank(rare1) {","                rare1 = b;","            }","        }","        for &b in &pat {","            if rare1 == rare2 {","                rare2 = b;","            } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {","                rare2 = b;","            }","        }","","        let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();","        let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();","","        let char_len = char_len_lossy(&pat);","        FreqyPacked {","            pat: pat,","            char_len: char_len,","            rare1: rare1,","            rare1i: rare1i,","            rare2: rare2,","            rare2i: rare2i,","        }","    }","","    let pat = vec![50];","    let packed = new(pat.clone());","","    assert_eq!(packed.pat, pat);","    assert_eq!(packed.char_len, 1);","    assert_eq!(packed.rare1, 50);","    assert_eq!(packed.rare1i, 0);","    assert_eq!(packed.rare2, 50);","    assert_eq!(packed.rare2i, 0);","}"],[]],[["{","    let pat = vec![3, 1, 2, 1, 4];","    let result = new(pat);","    assert_eq!(result.pat, vec![3, 1, 2, 1, 4]);","    assert_eq!(result.char_len, 5);","    assert_eq!(result.rare1, 1);","    assert_eq!(result.rare1i, 3);","    assert_eq!(result.rare2, 2);","    assert_eq!(result.rare2i, 2);","}"],[]],[["{","    let pat = vec![5, 5, 1, 2, 1, 2];","    let result = new(pat);","    assert_eq!(result.pat, vec![5, 5, 1, 2, 1, 2]);","    assert_eq!(result.char_len, 6);","    assert_eq!(result.rare1, 1);","    assert_eq!(result.rare1i, 4);","    assert_eq!(result.rare2, 2);","    assert_eq!(result.rare2i, 3);","}"],[]],[["{","    let pat = vec![7, 7, 7, 7, 7];","    let result = new(pat);","    assert_eq!(result.pat, vec![7, 7, 7, 7, 7]);","    assert_eq!(result.char_len, 5);","    assert_eq!(result.rare1, 7);","    assert_eq!(result.rare1i, 4);","    assert_eq!(result.rare2, 7);","    assert_eq!(result.rare2i, 4);","}"],[]],[["{","    let pat: Vec<u8> = vec![];","    let _result = new(pat);","}"],[]],[["{","    let pattern = vec![1, 2, 3, 1, 4, 2]; // Valid non-empty pat","    let freqy = new(pattern);","    assert_eq!(freqy.pat.len(), 6);","    assert!(freqy.rare1 != freqy.rare2);","}"],[]],[["{","    let pattern: Vec<u8> = Vec::new(); // Should panic on empty pat","    new(pattern);","}"],[]],[["{","    let pattern = vec![5, 5, 3, 2, 2, 1]; ","    let freqy = new(pattern);","    assert_eq!(freqy.rare1, 1);","    assert_eq!(freqy.rare2, 2);","}"],[]],[["{","    let pattern = vec![3, 3, 3, 3, 3]; ","    let freqy = new(pattern);","    assert_eq!(freqy.rare1, 3);","    assert_eq!(freqy.rare2, 3); // rare1 and rare2 are the same","}"],[]]],"codes_branches":[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    // Test for a non-empty pattern","    let input = vec![5, 3, 1, 2, 3, 5];","    let result = new(input.clone());","    assert_eq!(result.pat, input);","    assert_eq!(result.rare1, 1);","    assert_eq!(result.rare2, 2);","    assert_eq!(result.rare1i, 2);","    assert_eq!(result.rare2i, 3);","    assert_eq!(result.char_len, 6);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    // Test for a pattern with distinct bytes","    let input = vec![7, 8, 6, 5, 2, 3, 4];","    let result = new(input.clone());","    assert_eq!(result.pat, input);","    assert_eq!(result.rare1, 2);","    assert_eq!(result.rare2, 3);","    assert_eq!(result.rare1i, 4);","    assert_eq!(result.rare2i, 5);","    assert_eq!(result.char_len, 7);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    // Test for a pattern with the same byte repeated","    let input = vec![9, 9, 9, 9];","    let result = new(input.clone());","    assert_eq!(result.pat, input);","    assert_eq!(result.rare1, 9);","    assert_eq!(result.rare2, 9);","    assert_eq!(result.rare1i, 3);","    assert_eq!(result.rare2i, 3);","    assert_eq!(result.char_len, 4);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    struct FreqyPacked {","        pat: Vec<u8>,","        char_len: usize,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    fn freq_rank(_byte: u8) -> usize {","        1 // Placeholder implementation for testing","    }","","    fn char_len_lossy(pat: &Vec<u8>) -> usize {","        pat.len() // Simple implementation for testing","    }","","    fn new(pat: Vec<u8>) -> FreqyPacked {","        if pat.is_empty() {","            return FreqyPacked { pat: vec![], char_len: 0, rare1: 0, rare1i: 0, rare2: 0, rare2i: 0 };","        }","","        let mut rare1 = pat[0];","        let mut rare2 = pat[0];","        for b in pat[1..].iter().cloned() {","            if freq_rank(b) < freq_rank(rare1) {","                rare1 = b;","            }","        }","        for &b in &pat {","            if rare1 == rare2 {","                rare2 = b;","            } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {","                rare2 = b;","            }","        }","","        let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();","        let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();","","        let char_len = char_len_lossy(&pat);","        FreqyPacked {","            pat: pat,","            char_len: char_len,","            rare1: rare1,","            rare1i: rare1i,","            rare2: rare2,","            rare2i: rare2i,","        }","    }","","    let pat = vec![10, 20, 10, 30, 20];","    let packed = new(pat.clone());","","    assert_eq!(packed.pat, pat);","    assert_eq!(packed.char_len, pat.len());","    assert_eq!(packed.rare1, 10);","    assert_eq!(packed.rare1i, 2);","    assert_eq!(packed.rare2, 20);","    assert_eq!(packed.rare2i, 4);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    struct FreqyPacked {","        pat: Vec<u8>,","        char_len: usize,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    fn new(pat: Vec<u8>) -> FreqyPacked {","        if pat.is_empty() {","            panic!(\"Pattern cannot be empty\");","        }","        // Implementation omitted for brevity","        FreqyPacked { pat, char_len: 0, rare1: 0, rare1i: 0, rare2: 0, rare2i: 0 }","    }","","    new(vec![]);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    struct FreqyPacked {","        pat: Vec<u8>,","        char_len: usize,","        rare1: u8,","        rare1i: usize,","        rare2: u8,","        rare2i: usize,","    }","","    fn freq_rank(_byte: u8) -> usize {","        1 // Placeholder implementation","    }","","    fn char_len_lossy(pat: &Vec<u8>) -> usize {","        pat.len() // Placeholder implementation","    }","","    fn new(pat: Vec<u8>) -> FreqyPacked {","        if pat.is_empty() {","            return FreqyPacked { pat: vec![], char_len: 0, rare1: 0, rare1i: 0, rare2: 0, rare2i: 0 };","        }","","        let mut rare1 = pat[0];","        let mut rare2 = pat[0];","        for b in pat[1..].iter().cloned() {","            if freq_rank(b) < freq_rank(rare1) {","                rare1 = b;","            }","        }","        for &b in &pat {","            if rare1 == rare2 {","                rare2 = b;","            } else if b != rare1 && freq_rank(b) < freq_rank(rare2) {","                rare2 = b;","            }","        }","","        let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();","        let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();","","        let char_len = char_len_lossy(&pat);","        FreqyPacked {","            pat: pat,","            char_len: char_len,","            rare1: rare1,","            rare1i: rare1i,","            rare2: rare2,","            rare2i: rare2i,","        }","    }","","    let pat = vec![50];","    let packed = new(pat.clone());","","    assert_eq!(packed.pat, pat);","    assert_eq!(packed.char_len, 1);","    assert_eq!(packed.rare1, 50);","    assert_eq!(packed.rare1i, 0);","    assert_eq!(packed.rare2, 50);","    assert_eq!(packed.rare2i, 0);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pat = vec![3, 1, 2, 1, 4];","    let result = new(pat);","    assert_eq!(result.pat, vec![3, 1, 2, 1, 4]);","    assert_eq!(result.char_len, 5);","    assert_eq!(result.rare1, 1);","    assert_eq!(result.rare1i, 3);","    assert_eq!(result.rare2, 2);","    assert_eq!(result.rare2i, 2);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pat = vec![5, 5, 1, 2, 1, 2];","    let result = new(pat);","    assert_eq!(result.pat, vec![5, 5, 1, 2, 1, 2]);","    assert_eq!(result.char_len, 6);","    assert_eq!(result.rare1, 1);","    assert_eq!(result.rare1i, 4);","    assert_eq!(result.rare2, 2);","    assert_eq!(result.rare2i, 3);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pat = vec![7, 7, 7, 7, 7];","    let result = new(pat);","    assert_eq!(result.pat, vec![7, 7, 7, 7, 7]);","    assert_eq!(result.char_len, 5);","    assert_eq!(result.rare1, 7);","    assert_eq!(result.rare1i, 4);","    assert_eq!(result.rare2, 7);","    assert_eq!(result.rare2i, 4);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pat: Vec<u8> = vec![];","    let _result = new(pat);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pattern = vec![1, 2, 3, 1, 4, 2]; // Valid non-empty pat","    let freqy = new(pattern);","    assert_eq!(freqy.pat.len(), 6);","    assert!(freqy.rare1 != freqy.rare2);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pattern: Vec<u8> = Vec::new(); // Should panic on empty pat","    new(pattern);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pattern = vec![5, 5, 3, 2, 2, 1]; ","    let freqy = new(pattern);","    assert_eq!(freqy.rare1, 1);","    assert_eq!(freqy.rare2, 2);","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]],[["{","    let pattern = vec![3, 3, 3, 3, 3]; ","    let freqy = new(pattern);","    assert_eq!(freqy.rare1, 3);","    assert_eq!(freqy.rare2, 3); // rare1 and rare2 are the same","}"],[{"start_line":448,"start_column":12,"end_line":448,"end_column":26,"positive":false,"negative":false},{"start_line":457,"start_column":16,"end_line":457,"end_column":47,"positive":false,"negative":false},{"start_line":462,"start_column":16,"end_line":462,"end_column":30,"positive":false,"negative":false},{"start_line":464,"start_column":23,"end_line":464,"end_column":33,"positive":false,"negative":false},{"start_line":464,"start_column":37,"end_line":464,"end_column":68,"positive":false,"negative":false}]]]}