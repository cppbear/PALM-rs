{"function_name":"regex::literal::literal::Matcher::new","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":12,"tests_lines":[26,26,14,14,38,37,19,34,18,18,71,76],"oracles":12,"oracles_compiled":4,"oracles_compiled_rate":33.33333333333333,"tests_compiled":4,"tests_compiled_rate":33.33333333333333,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":34,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":28,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[209,210,211,212,213,220,221,222,223,224,225,226,227,228,230,232,233,234,236,237,238,239,240,241,242,253,254,255,256,257,259,260,261,262],"codes_lines_covered":[[["{","    struct TestLiterals {","        literals: Vec<Vec<u8>>,","    }","","    impl TestLiterals {","        fn literals(&self) -> &Vec<Vec<u8>> {","            &self.literals","        }","    }","","    struct SingleByteSet {","        dense: Vec<u8>,","        complete: bool,","    }","","    struct Matcher;","","    impl Matcher {","        const Empty: Matcher = Matcher;","        const Bytes: fn(SingleByteSet) -> Matcher = |s| Matcher;","    }","","    let lits = TestLiterals {","        literals: vec![b\"test\".to_vec()],","    };","","    let sset = SingleByteSet {","        dense: vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j',","                    b'k', b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't',","                    b'u', b'v', b'w', b'x', b'y', b'z'], // 26 bytes","        complete: true,","    };","","    let result = Matcher::Bytes(sset);","    ","    // Additional assertions can be added here to validate the result","}"],[]],[["{","    struct TestLiterals {","        literals: Vec<Vec<u8>>,","    }","","    impl TestLiterals {","        fn literals(&self) -> &Vec<Vec<u8>> {","            &self.literals","        }","    }","","    struct SingleByteSet {","        dense: Vec<u8>,","        complete: bool,","    }","","    struct Matcher;","","    impl Matcher {","        const Empty: Matcher = Matcher;","        const Bytes: fn(SingleByteSet) -> Matcher = |s| Matcher;","    }","","    let lits = TestLiterals {","        literals: vec![b\"example\".to_vec()],","    };","","    let sset = SingleByteSet {","        dense: vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j',","                    b'k', b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't'], // 20 bytes","        complete: true,","    };","","    let result = Matcher::Bytes(sset);","    ","    // Additional assertions can be added here to validate the result","}"],[]],[["{","    let lits = Literals {","        literals: vec![\"test\".to_string()],","    };","    ","    let sset = SingleByteSet {","        dense: vec![1, 2], // less than 26 elements","        complete: false,","        all_ascii: true,","    };","    ","    let matcher = new(&lits, sset);","    ","    match matcher {","        Matcher::AC(_) => {},","        _ => panic!(\"Expected Matcher::AC(_)\"),","    }","}"],[]],[["{","    let lits = Literals {","        literals: vec![\"first\".to_string(), \"second\".to_string()],","    };","","    let sset = SingleByteSet {","        dense: vec![1, 2], // less than 26 elements","        complete: false,","        all_ascii: false,","    };","    ","    let matcher = new(&lits, sset);","    ","    match matcher {","        Matcher::AC(_) => {},","        _ => panic!(\"Expected Matcher::AC(_)\"),","    }","}"],[]]],"codes_branches":[{"start_line":210,"start_column":12,"end_line":210,"end_column":38,"positive":false,"negative":false},{"start_line":213,"start_column":12,"end_line":213,"end_column":34,"positive":false,"negative":false},{"start_line":222,"start_column":12,"end_line":222,"end_column":25,"positive":false,"negative":false},{"start_line":225,"start_column":12,"end_line":225,"end_column":38,"positive":false,"negative":false},{"start_line":227,"start_column":16,"end_line":227,"end_column":60,"positive":false,"negative":false},{"start_line":233,"start_column":36,"end_line":233,"end_column":57,"positive":false,"negative":false},{"start_line":234,"start_column":12,"end_line":234,"end_column":34,"positive":false,"negative":false},{"start_line":234,"start_column":38,"end_line":234,"end_column":59,"positive":false,"negative":false},{"start_line":236,"start_column":16,"end_line":236,"end_column":59,"positive":false,"negative":false},{"start_line":237,"start_column":24,"end_line":237,"end_column":33,"positive":false,"negative":false},{"start_line":242,"start_column":12,"end_line":242,"end_column":35,"positive":false,"negative":false},{"start_line":242,"start_column":39,"end_line":242,"end_column":60,"positive":false,"negative":false},{"start_line":253,"start_column":16,"end_line":253,"end_column":59,"positive":false,"negative":false},{"start_line":254,"start_column":24,"end_line":254,"end_column":33,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestLiterals {","        literals: Vec<Vec<u8>>,","    }","","    impl TestLiterals {","        fn literals(&self) -> &Vec<Vec<u8>> {","            &self.literals","        }","    }","","    struct SingleByteSet {","        dense: Vec<u8>,","        complete: bool,","    }","","    struct Matcher;","","    impl Matcher {","        const Empty: Matcher = Matcher;","        const Bytes: fn(SingleByteSet) -> Matcher = |s| Matcher;","    }","","    let lits = TestLiterals {","        literals: vec![b\"test\".to_vec()],","    };","","    let sset = SingleByteSet {","        dense: vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j',","                    b'k', b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't',","                    b'u', b'v', b'w', b'x', b'y', b'z'], // 26 bytes","        complete: true,","    };","","    let result = Matcher::Bytes(sset);","    ","    // Additional assertions can be added here to validate the result","}"],[{"start_line":210,"start_column":12,"end_line":210,"end_column":38,"positive":false,"negative":false},{"start_line":213,"start_column":12,"end_line":213,"end_column":34,"positive":false,"negative":false},{"start_line":222,"start_column":12,"end_line":222,"end_column":25,"positive":false,"negative":false},{"start_line":225,"start_column":12,"end_line":225,"end_column":38,"positive":false,"negative":false},{"start_line":227,"start_column":16,"end_line":227,"end_column":60,"positive":false,"negative":false},{"start_line":233,"start_column":36,"end_line":233,"end_column":57,"positive":false,"negative":false},{"start_line":234,"start_column":12,"end_line":234,"end_column":34,"positive":false,"negative":false},{"start_line":234,"start_column":38,"end_line":234,"end_column":59,"positive":false,"negative":false},{"start_line":236,"start_column":16,"end_line":236,"end_column":59,"positive":false,"negative":false},{"start_line":237,"start_column":24,"end_line":237,"end_column":33,"positive":false,"negative":false},{"start_line":242,"start_column":12,"end_line":242,"end_column":35,"positive":false,"negative":false},{"start_line":242,"start_column":39,"end_line":242,"end_column":60,"positive":false,"negative":false},{"start_line":253,"start_column":16,"end_line":253,"end_column":59,"positive":false,"negative":false},{"start_line":254,"start_column":24,"end_line":254,"end_column":33,"positive":false,"negative":false}]],[["{","    struct TestLiterals {","        literals: Vec<Vec<u8>>,","    }","","    impl TestLiterals {","        fn literals(&self) -> &Vec<Vec<u8>> {","            &self.literals","        }","    }","","    struct SingleByteSet {","        dense: Vec<u8>,","        complete: bool,","    }","","    struct Matcher;","","    impl Matcher {","        const Empty: Matcher = Matcher;","        const Bytes: fn(SingleByteSet) -> Matcher = |s| Matcher;","    }","","    let lits = TestLiterals {","        literals: vec![b\"example\".to_vec()],","    };","","    let sset = SingleByteSet {","        dense: vec![b'a', b'b', b'c', b'd', b'e', b'f', b'g', b'h', b'i', b'j',","                    b'k', b'l', b'm', b'n', b'o', b'p', b'q', b'r', b's', b't'], // 20 bytes","        complete: true,","    };","","    let result = Matcher::Bytes(sset);","    ","    // Additional assertions can be added here to validate the result","}"],[{"start_line":210,"start_column":12,"end_line":210,"end_column":38,"positive":false,"negative":false},{"start_line":213,"start_column":12,"end_line":213,"end_column":34,"positive":false,"negative":false},{"start_line":222,"start_column":12,"end_line":222,"end_column":25,"positive":false,"negative":false},{"start_line":225,"start_column":12,"end_line":225,"end_column":38,"positive":false,"negative":false},{"start_line":227,"start_column":16,"end_line":227,"end_column":60,"positive":false,"negative":false},{"start_line":233,"start_column":36,"end_line":233,"end_column":57,"positive":false,"negative":false},{"start_line":234,"start_column":12,"end_line":234,"end_column":34,"positive":false,"negative":false},{"start_line":234,"start_column":38,"end_line":234,"end_column":59,"positive":false,"negative":false},{"start_line":236,"start_column":16,"end_line":236,"end_column":59,"positive":false,"negative":false},{"start_line":237,"start_column":24,"end_line":237,"end_column":33,"positive":false,"negative":false},{"start_line":242,"start_column":12,"end_line":242,"end_column":35,"positive":false,"negative":false},{"start_line":242,"start_column":39,"end_line":242,"end_column":60,"positive":false,"negative":false},{"start_line":253,"start_column":16,"end_line":253,"end_column":59,"positive":false,"negative":false},{"start_line":254,"start_column":24,"end_line":254,"end_column":33,"positive":false,"negative":false}]],[["{","    let lits = Literals {","        literals: vec![\"test\".to_string()],","    };","    ","    let sset = SingleByteSet {","        dense: vec![1, 2], // less than 26 elements","        complete: false,","        all_ascii: true,","    };","    ","    let matcher = new(&lits, sset);","    ","    match matcher {","        Matcher::AC(_) => {},","        _ => panic!(\"Expected Matcher::AC(_)\"),","    }","}"],[{"start_line":210,"start_column":12,"end_line":210,"end_column":38,"positive":false,"negative":false},{"start_line":213,"start_column":12,"end_line":213,"end_column":34,"positive":false,"negative":false},{"start_line":222,"start_column":12,"end_line":222,"end_column":25,"positive":false,"negative":false},{"start_line":225,"start_column":12,"end_line":225,"end_column":38,"positive":false,"negative":false},{"start_line":227,"start_column":16,"end_line":227,"end_column":60,"positive":false,"negative":false},{"start_line":233,"start_column":36,"end_line":233,"end_column":57,"positive":false,"negative":false},{"start_line":234,"start_column":12,"end_line":234,"end_column":34,"positive":false,"negative":false},{"start_line":234,"start_column":38,"end_line":234,"end_column":59,"positive":false,"negative":false},{"start_line":236,"start_column":16,"end_line":236,"end_column":59,"positive":false,"negative":false},{"start_line":237,"start_column":24,"end_line":237,"end_column":33,"positive":false,"negative":false},{"start_line":242,"start_column":12,"end_line":242,"end_column":35,"positive":false,"negative":false},{"start_line":242,"start_column":39,"end_line":242,"end_column":60,"positive":false,"negative":false},{"start_line":253,"start_column":16,"end_line":253,"end_column":59,"positive":false,"negative":false},{"start_line":254,"start_column":24,"end_line":254,"end_column":33,"positive":false,"negative":false}]],[["{","    let lits = Literals {","        literals: vec![\"first\".to_string(), \"second\".to_string()],","    };","","    let sset = SingleByteSet {","        dense: vec![1, 2], // less than 26 elements","        complete: false,","        all_ascii: false,","    };","    ","    let matcher = new(&lits, sset);","    ","    match matcher {","        Matcher::AC(_) => {},","        _ => panic!(\"Expected Matcher::AC(_)\"),","    }","}"],[{"start_line":210,"start_column":12,"end_line":210,"end_column":38,"positive":false,"negative":false},{"start_line":213,"start_column":12,"end_line":213,"end_column":34,"positive":false,"negative":false},{"start_line":222,"start_column":12,"end_line":222,"end_column":25,"positive":false,"negative":false},{"start_line":225,"start_column":12,"end_line":225,"end_column":38,"positive":false,"negative":false},{"start_line":227,"start_column":16,"end_line":227,"end_column":60,"positive":false,"negative":false},{"start_line":233,"start_column":36,"end_line":233,"end_column":57,"positive":false,"negative":false},{"start_line":234,"start_column":12,"end_line":234,"end_column":34,"positive":false,"negative":false},{"start_line":234,"start_column":38,"end_line":234,"end_column":59,"positive":false,"negative":false},{"start_line":236,"start_column":16,"end_line":236,"end_column":59,"positive":false,"negative":false},{"start_line":237,"start_column":24,"end_line":237,"end_column":33,"positive":false,"negative":false},{"start_line":242,"start_column":12,"end_line":242,"end_column":35,"positive":false,"negative":false},{"start_line":242,"start_column":39,"end_line":242,"end_column":60,"positive":false,"negative":false},{"start_line":253,"start_column":16,"end_line":253,"end_column":59,"positive":false,"negative":false},{"start_line":254,"start_column":24,"end_line":254,"end_column":33,"positive":false,"negative":false}]]]}