{"function_name":"regex::dfa::dfa::Byte::as_byte","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":5,"tests_lines":[4,4,20,20,20],"oracles":5,"oracles_compiled":3,"oracles_compiled_rate":60.0,"tests_compiled":3,"tests_compiled_rate":60.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1700,1701,1702,1704,1706],"codes_lines_covered":[[["{","    struct TestStruct(u32);","    ","    impl TestStruct {","        fn is_eof(&self) -> bool {","            false","        }","","        fn as_byte(&self) -> Option<u8> {","            if self.is_eof() {","                None","            } else {","                Some(self.0 as u8)","            }","        }","    }","","    let instance = TestStruct(255); // Max value that can fit in u8","    assert_eq!(instance.as_byte(), Some(255));","}"],[]],[["{","    struct TestStruct(u32);","    ","    impl TestStruct {","        fn is_eof(&self) -> bool {","            false","        }","","        fn as_byte(&self) -> Option<u8> {","            if self.is_eof() {","                None","            } else {","                Some(self.0 as u8)","            }","        }","    }","","    let instance = TestStruct(0);","    assert_eq!(instance.as_byte(), Some(0));","}"],[]],[["{","    struct TestStruct(u32);","    ","    impl TestStruct {","        fn is_eof(&self) -> bool {","            false","        }","","        fn as_byte(&self) -> Option<u8> {","            if self.is_eof() {","                None","            } else {","                Some(self.0 as u8)","            }","        }","    }","","    let instance = TestStruct(100);","    assert_eq!(instance.as_byte(), Some(100));","}"],[]]],"codes_branches":[{"start_line":1701,"start_column":12,"end_line":1701,"end_column":25,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestStruct(u32);","    ","    impl TestStruct {","        fn is_eof(&self) -> bool {","            false","        }","","        fn as_byte(&self) -> Option<u8> {","            if self.is_eof() {","                None","            } else {","                Some(self.0 as u8)","            }","        }","    }","","    let instance = TestStruct(255); // Max value that can fit in u8","    assert_eq!(instance.as_byte(), Some(255));","}"],[{"start_line":1701,"start_column":12,"end_line":1701,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestStruct(u32);","    ","    impl TestStruct {","        fn is_eof(&self) -> bool {","            false","        }","","        fn as_byte(&self) -> Option<u8> {","            if self.is_eof() {","                None","            } else {","                Some(self.0 as u8)","            }","        }","    }","","    let instance = TestStruct(0);","    assert_eq!(instance.as_byte(), Some(0));","}"],[{"start_line":1701,"start_column":12,"end_line":1701,"end_column":25,"positive":false,"negative":false}]],[["{","    struct TestStruct(u32);","    ","    impl TestStruct {","        fn is_eof(&self) -> bool {","            false","        }","","        fn as_byte(&self) -> Option<u8> {","            if self.is_eof() {","                None","            } else {","                Some(self.0 as u8)","            }","        }","    }","","    let instance = TestStruct(100);","    assert_eq!(instance.as_byte(), Some(100));","}"],[{"start_line":1701,"start_column":12,"end_line":1701,"end_column":25,"positive":false,"negative":false}]]]}