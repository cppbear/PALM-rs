{"function_name":"regex::input::<input::ByteInput<'t> as std::ops::Deref>::deref","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":3,"tests_lines":[19,19,21],"oracles":3,"oracles_compiled":3,"oracles_compiled_rate":100.0,"tests_compiled":3,"tests_compiled_rate":100.0,"oracles_run":3,"oracles_passed":3,"oracles_passed_rate":100.0,"tests_run":3,"tests_passed":3,"tests_passed_rate":100.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[245,246,247],"codes_lines_covered":[[["{","    struct TextHolder {","        text: Vec<u8>,","    }","","    impl TextHolder {","        fn new(text: Vec<u8>) -> Self {","            TextHolder { text }","        }","","        fn deref(&self) -> &[u8] {","            self.text.as_slice()","        }","    }","","    let holder = TextHolder::new(vec![97, 98, 99]); // ASCII for 'abc'","    let result = holder.deref();","    assert_eq!(result, b\"abc\");","}"],[]],[["{","    struct TextHolder {","        text: Vec<u8>,","    }","","    impl TextHolder {","        fn new(text: Vec<u8>) -> Self {","            TextHolder { text }","        }","","        fn deref(&self) -> &[u8] {","            self.text.as_slice()","        }","    }","","    let holder = TextHolder::new(vec![]);","    let result = holder.deref();","    assert_eq!(result, b\"\");","}"],[]],[["{","    struct TextHolder {","        text: Vec<u8>,","    }","","    impl TextHolder {","        fn new(text: Vec<u8>) -> Self {","            TextHolder { text }","        }","","        fn deref(&self) -> &[u8] {","            self.text.as_slice()","        }","    }","","    let large_text = vec![120; 10_000]; // 10,000 bytes of `x`","    let holder = TextHolder::new(large_text);","    let result = holder.deref();","    assert_eq!(result.len(), 10_000);","    assert!(result.iter().all(|&byte| byte == 120));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TextHolder {","        text: Vec<u8>,","    }","","    impl TextHolder {","        fn new(text: Vec<u8>) -> Self {","            TextHolder { text }","        }","","        fn deref(&self) -> &[u8] {","            self.text.as_slice()","        }","    }","","    let holder = TextHolder::new(vec![97, 98, 99]); // ASCII for 'abc'","    let result = holder.deref();","    assert_eq!(result, b\"abc\");","}"],[]],[["{","    struct TextHolder {","        text: Vec<u8>,","    }","","    impl TextHolder {","        fn new(text: Vec<u8>) -> Self {","            TextHolder { text }","        }","","        fn deref(&self) -> &[u8] {","            self.text.as_slice()","        }","    }","","    let holder = TextHolder::new(vec![]);","    let result = holder.deref();","    assert_eq!(result, b\"\");","}"],[]],[["{","    struct TextHolder {","        text: Vec<u8>,","    }","","    impl TextHolder {","        fn new(text: Vec<u8>) -> Self {","            TextHolder { text }","        }","","        fn deref(&self) -> &[u8] {","            self.text.as_slice()","        }","    }","","    let large_text = vec![120; 10_000]; // 10,000 bytes of `x`","    let holder = TextHolder::new(large_text);","    let result = holder.deref();","    assert_eq!(result.len(), 10_000);","    assert!(result.iter().all(|&byte| byte == 120));","}"],[]]]}