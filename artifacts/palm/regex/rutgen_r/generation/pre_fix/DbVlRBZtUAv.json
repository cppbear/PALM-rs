{
  "name": "regex::input::<input::ByteInput<'t> as input::Input>::is_empty_match",
  "name_with_impl": "regex::input::{impl#7}::is_empty_match",
  "mod_info": {
    "name": "input",
    "loc": "src/lib.rs:655:1:655:11"
  },
  "visible": true,
  "loc": "src/input.rs:268:5:318:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: empty.look matches NotWordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is true\n",
        "// constraint: at.is_start() is true\n",
        "// constraint: c2.is_none() is true\n",
        "// constraint: at.is_end() is false\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestInput {",
                  "        only_utf8: bool,",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    struct TestInputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl TestInputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.position == self.data.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct TestInstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = TestInput { only_utf8: true, data: vec![0xFF] }; // Mock data for utf-8 invalid",
                  "    let at = TestInputAt { position: 0 }; // at is start",
                  "    let empty_look = TestInstEmptyLook { look: prog::EmptyLook::NotWordBoundaryAscii };",
                  "",
                  "    let result = input.is_empty_match(at, &empty_look);",
                  "",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:452:15\n    |\n452 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:457:48\n    |\n457 |     let empty_look = TestInstEmptyLook { look: prog::EmptyLook::NotWordBoundaryAscii };\n    |                                                ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n457 -     let empty_look = TestInstEmptyLook { look: prog::EmptyLook::NotWordBoundaryAscii };\n457 +     let empty_look = TestInstEmptyLook { look: EmptyLook::NotWordBoundaryAscii };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `TestInput` in the current scope\n   --> src/input.rs:459:24\n    |\n428 |     struct TestInput {\n    |     ---------------- method `is_empty_match` not found for this struct\n...\n459 |     let result = input.is_empty_match(at, &empty_look);\n    |                        ^^^^^^^^^^^^^^ method not found in `TestInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0609]: no field `data` on type `&TestInputAt`\n   --> src/input.rs:447:35\n    |\n447 |             self.position == self.data.len()\n    |                                   ^^^^ unknown field\n    |\n    = note: available field is: `position`\n\nwarning: unused import: `super`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^\n\nSome errors have detailed explanations: E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 4 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: empty.look matches NotWordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is true\n",
        "// constraint: at.is_start() is false\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestInput {",
                  "        only_utf8: bool,",
                  "        data: Vec<u8>,",
                  "    }",
                  "",
                  "    impl TestInput {",
                  "        fn previous_char(&self, at: &InputAt) -> Option<char> {",
                  "            if at.pos() > 0 {",
                  "                Some(self.data[at.pos() - 1] as char) // Simplified character retrieval",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: &InputAt) -> Option<char> {",
                  "            if at.pos() < self.data.len() {",
                  "                Some(self.data[at.pos()] as char) // Simplified character retrieval",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, total_length: usize) -> bool {",
                  "            self.position == total_length",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input_data = TestInput {",
                  "        only_utf8: true,",
                  "        data: vec![b'a', b'b', b'c'], // Sample UTF-8 byte data",
                  "    };",
                  "    ",
                  "    let at = InputAt { position: 1 }; // Not at start for the test case",
                  "    let empty_look = InstEmptyLook {",
                  "        look: prog::EmptyLook::NotWordBoundaryAscii,",
                  "    };",
                  "",
                  "    assert_eq!(input_data.is_empty_match(at, &empty_look), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:484:15\n    |\n484 |         look: prog::EmptyLook::NotWordBoundaryAscii,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n484 -         look: prog::EmptyLook::NotWordBoundaryAscii,\n484 +         look: EmptyLook::NotWordBoundaryAscii,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `TestInput` in the current scope\n   --> src/input.rs:487:27\n    |\n428 |     struct TestInput {\n    |     ---------------- method `is_empty_match` not found for this struct\n...\n487 |     assert_eq!(input_data.is_empty_match(at, &empty_look), false);\n    |                           ^^^^^^^^^^^^^^ method not found in `TestInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: empty.look matches NotWordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is false\n",
        "// constraint: c2.is_none() is true\n",
        "// constraint: at.is_end() is true\n",
        "// expected return value/type: c1.is_word_byte() == c2.is_word_byte()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct MockInput {",
                  "        only_utf8: bool,",
                  "        content: Vec<u8>,",
                  "    }",
                  "",
                  "    impl MockInput {",
                  "        fn previous_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() == 0 {",
                  "                None",
                  "            } else {",
                  "                Some(self.content[at.pos() - 1])",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() >= self.content.len() {",
                  "                None",
                  "            } else {",
                  "                Some(self.content[at.pos()])",
                  "            }",
                  "",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn new(position: usize) -> Self {",
                  "            Self { position }",
                  "        }",
                  "",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.position >= self.position",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = MockInput {",
                  "        only_utf8: true,",
                  "        content: b\"ab\".to_vec(),",
                  "    };",
                  "",
                  "    let at = InputAt::new(2);",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::NotWordBoundaryAscii,",
                  "    };",
                  "",
                  "    let result = input.is_empty_match(at, &empty);",
                  "",
                  "    assert_eq!(result, true); // Since 'b' is a word byte and there is no character after it",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:479:15\n    |\n479 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:489:15\n    |\n489 |         look: prog::EmptyLook::NotWordBoundaryAscii,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n489 -         look: prog::EmptyLook::NotWordBoundaryAscii,\n489 +         look: EmptyLook::NotWordBoundaryAscii,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `MockInput` in the current scope\n   --> src/input.rs:492:24\n    |\n428 |     struct MockInput {\n    |     ---------------- method `is_empty_match` not found for this struct\n...\n492 |     let result = input.is_empty_match(at, &empty);\n    |                        ^^^^^^^^^^^^^^ method not found in `MockInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nwarning: unused import: `super`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: empty.look matches NotWordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is false\n",
        "// constraint: c2.is_none() is false\n",
        "// expected return value/type: c1.is_word_byte() == c2.is_word_byte()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct DummyInput {",
                  "        content: Vec<u8>,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl DummyInput {",
                  "        fn previous_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() > 0 {",
                  "                Some(self.content[at.pos() - 1])",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() < self.content.len() {",
                  "                Some(self.content[at.pos()])",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        pos: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.pos",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.pos == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.pos == self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: EmptyLook,",
                  "    }",
                  "",
                  "    #[derive(Debug)]",
                  "    enum EmptyLook {",
                  "        NotWordBoundaryAscii,",
                  "    }",
                  "",
                  "    let input = DummyInput {",
                  "        content: b\"abc123def\".to_vec(),",
                  "        only_utf8: true,",
                  "    };",
                  "    let at = InputAt { pos: 3 }; // position between 'c' and '1'",
                  "    let empty = InstEmptyLook {",
                  "        look: EmptyLook::NotWordBoundaryAscii,",
                  "    };",
                  "",
                  "    // c1 is 'c' (previous char) and c2 is '1' (next char)",
                  "    assert_eq!(input.is_empty_match(at, &empty), false); // 'c' and '1' are different word bytes",
                  "",
                  "    let at = InputAt { pos: 2 }; // position between 'b' and 'c'",
                  "    assert_eq!(input.is_empty_match(at, &empty), true); // 'b' and 'c' are both word bytes",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:492:22\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n492 |     assert_eq!(input.is_empty_match(at, &empty), false); // 'c' and '1' are different word bytes\n    |                      ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:495:22\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n495 |     assert_eq!(input.is_empty_match(at, &empty), true); // 'b' and 'c' are both word bytes\n    |                      ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0609]: no field `content` on type `&llmtests::test_is_empty_match_03::InputAt`\n   --> src/input.rs:469:30\n    |\n469 |             self.pos == self.content.len()\n    |                              ^^^^^^^ unknown field\n    |\n    = note: available field is: `pos`\n\nwarning: unused import: `super`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^\n\nSome errors have detailed explanations: E0599, E0609.\nFor more information about an error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: empty.look matches NotWordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is false\n",
        "// expected return value/type: c1.is_word_byte() == c2.is_word_byte()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use EmptyLook::*;"
          ],
          "has_test_mod": false,
          "common": [
            "#[derive(Debug)]",
            "struct InputAt {",
            "    position: usize,",
            "}",
            "",
            "impl InputAt {",
            "    fn pos(&self) -> usize {",
            "        self.position",
            "    }",
            "",
            "    fn is_start(&self) -> bool {",
            "        self.position == 0",
            "    }",
            "",
            "    fn is_end(&self, length: usize) -> bool {",
            "        self.position == length",
            "    }",
            "}",
            "",
            "#[derive(Debug)]",
            "struct InstEmptyLook {",
            "    look: EmptyLook,",
            "}",
            "",
            "#[derive(Debug)]",
            "enum EmptyLook {",
            "    StartLine,",
            "    EndLine,",
            "    StartText,",
            "    EndText,",
            "    WordBoundary,",
            "    NotWordBoundary,",
            "    WordBoundaryAscii,",
            "    NotWordBoundaryAscii,",
            "}",
            "",
            "#[derive(Debug)]",
            "struct Tester {",
            "    only_utf8: bool,",
            "    data: Vec<u8>,",
            "}",
            "",
            "impl Tester {",
            "    fn new(only_utf8: bool, data: Vec<u8>) -> Self {",
            "        Tester { only_utf8, data }",
            "    }",
            "",
            "    fn len(&self) -> usize {",
            "        self.data.len()",
            "    }",
            "",
            "    fn previous_char(&self, at: InputAt) -> Option<u8> {",
            "        if at.pos() > 0 {",
            "            Some(self.data[at.pos() - 1])",
            "        } else {",
            "            None",
            "        }",
            "    }",
            "",
            "    fn next_char(&self, at: InputAt) -> Option<u8> {",
            "        if at.pos() < self.len() {",
            "            Some(self.data[at.pos()])",
            "        } else {",
            "            None",
            "        }",
            "    }",
            "",
            "    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {",
            "        match empty.look {",
            "            EmptyLook::NotWordBoundaryAscii => {",
            "                let (c1, c2) = (self.previous_char(at), self.next_char(at));",
            "                c1.is_word_byte() == c2.is_word_byte()",
            "            }",
            "            _ => unreachable!(),",
            "        }",
            "    }",
            "}",
            "",
            "impl u8 {",
            "    fn is_word_byte(self) -> bool {",
            "        self.is_ascii_alphanumeric() || self == b'_'",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let tester = Tester::new(false, b\"hello_world\".to_vec());",
                  "    let at = InputAt { position: 5 }; // Position between 'o' and '_'",
                  "    let empty = InstEmptyLook {",
                  "        look: EmptyLook::NotWordBoundaryAscii,",
                  "    };",
                  "    ",
                  "    // Both characters are valid word bytes (ASCII)",
                  "    assert!(tester.is_empty_match(at, &empty));",
                  "",
                  "    let at_end = InputAt { position: 0 }; // Position at start",
                  "    // Previous char does not exist (None), next is 'h' (valid word byte)",
                  "    assert!(!tester.is_empty_match(at_end, &empty));",
                  "",
                  "    let at_middle = InputAt { position: 10 }; // Position after 'd'",
                  "    // Previous is 'd' (valid), next does not exist (None)",
                  "    assert!(!tester.is_empty_match(at_middle, &empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nerror[E0390]: cannot define inherent `impl` for primitive types\n   --> src/input.rs:503:1\n    |\n503 | impl u8 {\n    | ^^^^^^^\n    |\n    = help: consider using an extension trait instead\n\nerror[E0599]: no method named `exec_` found for struct `backtrack::Bounded` in the current scope\n   --> src/backtrack.rs:112:11\n    |\n54  | pub struct Bounded<'a, 'm, 'r, 's, I> {\n    | ------------------------------------- method `exec_` not found for this struct\n...\n112 |         b.exec_(start)\n    |           ^^^^^ method not found in `Bounded<'_, '_, '_, '_, I>`\n\nerror[E0599]: the method `len` exists for reference `&Program`, but its trait bounds were not satisfied\n   --> src/backtrack.rs:132:24\n    |\n132 |             (self.prog.len() * (self.input.len() + 1) + BIT_SIZE - 1)\n    |                        ^^^ method cannot be called on `&Program` due to unsatisfied trait bounds\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ doesn't satisfy `Program: input::Input`\n    |\nnote: trait bound `Program: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:151:14\n    |\n151 |         self.clear();\n    |              ^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n    |\nhelp: some of the expressions' fields have a method of the same name\n    |\n151 |         self.m.jobs.clear();\n    |              +++++++\n151 |         self.prog.insts.clear();\n    |              +++++++++++\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:155:27\n    |\n155 |             return if !at.is_start() {\n    |                           ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n\nerror[E0599]: no method named `backtrack` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:158:22\n    |\n158 |                 self.backtrack(at)\n    |                      ^^^^^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n   --> src/backtrack.rs:163:36\n    |\n163 |             if !self.prog.prefixes.is_empty() {\n    |                                    ^^^^^^^^ method not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `backtrack` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:169:28\n    |\n169 |             matched = self.backtrack(at) || matched;\n    |                            ^^^^^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:173:19\n    |\n173 |             if at.is_end() {\n    |                   ^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:176:35\n    |\n176 |             at = self.input.at(at.next_pos());\n    |                                   ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `step` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:192:29\n    |\n192 |                     if self.step(ip, at) {\n    |                             ^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [Option<usize>]`, but its trait bounds were not satisfied\n   --> src/backtrack.rs:203:42\n    |\n203 |                     if slot < self.slots.len() {\n    |                                          ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[Option<usize>]: ExactSizeIterator`\n            which is required by `&mut [Option<usize>]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `has_visited` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:219:21\n    |\n219 |             if self.has_visited(ip, at) {\n    |                     ^^^^^^^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/backtrack.rs:224:44\n    |\n224 |                     if slot < self.matches.len() {\n    |                                            ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for mutable reference `&'s mut [Option<usize>]` in the current scope\n   --> src/backtrack.rs:230:56\n    |\n230 |                     if let Some(&old_pos) = self.slots.get(inst.slot) {\n    |                                                        ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n230 |                     if let Some(&old_pos) = self.slots.ge(inst.slot) {\n    |                                                        ~~\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:239:57\n    |\n239 |                         self.slots[inst.slot] = Some(at.pos());\n    |                                                         ^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:255:37\n    |\n255 |                     if inst.c == at.char() {\n    |                                     ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:257:47\n    |\n257 |                         at = self.input.at(at.next_pos());\n    |                                               ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `matches` found for reference `&InstRanges` in the current scope\n   --> src/backtrack.rs:263:29\n    |\n263 |                     if inst.matches(at.char()) {\n    |                             ^^^^^^^ method not found in `&InstRanges`\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:263:40\n    |\n263 |                     if inst.matches(at.char()) {\n    |                                        ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:265:47\n    |\n265 |                         at = self.input.at(at.next_pos());\n    |                                               ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `byte` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:271:41\n    |\n271 |                     if let Some(b) = at.byte() {\n    |                                         ^^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `byte` not found for this struct\n\nerror[E0599]: no method named `matches` found for reference `&InstBytes` in the current scope\n   --> src/backtrack.rs:272:33\n    |\n272 |                         if inst.matches(b) {\n    |                                 ^^^^^^^ method not found in `&InstBytes`\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:274:51\n    |\n274 | ...                   at = self.input.at(at.next_pos());\n    |                                             ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:285:50\n    |\n285 |         let k = ip * (self.input.len() + 1) + at.pos();\n    |                                                  ^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n  --> src/utf8.rs:25:24\n   |\n25 |     let b = match text.get(i) {\n   |                        ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n25 |     let b = match text.ge(i) {\n   |                        ~~\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n  --> src/utf8.rs:53:24\n   |\n53 |     let b0 = match src.get(0) {\n   |                        ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n53 |     let b0 = match src.ge(0) {\n   |                        ~~\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:60:20\n     |\n60   |             if src.len() < 2 {\n     |                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:75:20\n     |\n75   |             if src.len() < 3 {\n     |                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:95:20\n     |\n95   |             if src.len() < 4 {\n     |                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n   --> src/utf8.rs:124:12\n    |\n124 |     if src.is_empty() {\n    |            ^^^^^^^^ method not found in `&[u8]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:127:25\n     |\n127  |     let mut start = src.len() - 1;\n     |                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:131:23\n     |\n131  |     while start > src.len().saturating_sub(4) {\n     |                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:139:33\n     |\n139  |         Some((_, n)) if n < src.len() - start => None,\n     |                                 ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n  --> src/compile.rs:55:32\n   |\n55 |             compiled: Program::new(),\n   |                                ^^^ function or associated item not found in `Program`\n   |\n  ::: src/prog.rs:18:1\n   |\n18 | pub struct Program {\n   | ------------------ function or associated item `new` not found for this struct\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `SuffixCache` in the current scope\n   --> src/compile.rs:59:40\n    |\n59  |             suffix_cache: SuffixCache::new(1000),\n    |                                        ^^^ function or associated item not found in `SuffixCache`\n...\n983 | struct SuffixCache {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:61:41\n     |\n61   |             byte_classes: ByteClassSet::new(),\n     |                                         ^^^ function or associated item not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:126:29\n    |\n126 |         debug_assert!(exprs.len() >= 1);\n    |                             ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:127:32\n    |\n127 |         self.num_exprs = exprs.len();\n    |                                ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:128:18\n    |\n128 |         if exprs.len() == 1 {\n    |                  ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `compile_one` found for struct `Compiler` in the current scope\n   --> src/compile.rs:129:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_one` not found for this struct\n...\n129 |             self.compile_one(&exprs[0])\n    |                  ^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `compile_many` found for struct `Compiler` in the current scope\n   --> src/compile.rs:131:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_many` not found for this struct\n...\n131 |             self.compile_many(exprs)\n    |                  ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `needs_dotstar` found for struct `Program` in the current scope\n   --> src/compile.rs:143:26\n    |\n143 |         if self.compiled.needs_dotstar() {\n    |                          ^^^^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `needs_dotstar` not found for this struct\n\nerror[E0599]: no method named `c_dotstar` found for struct `Compiler` in the current scope\n   --> src/compile.rs:144:34\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_dotstar` not found for this struct\n...\n144 |             dotstar_patch = self.c_dotstar()?;\n    |                                  ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n   --> src/compile.rs:147:34\n    |\n147 |         self.compiled.captures = vec![None];\n    |                                  ^^^^^^^^^^ function or associated item not found in `[_]`\n    |\nhelp: there is an associated function `to_vec` with a similar name\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n    |\n116 | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117 | |         where\n118 | |             Self: Sized;\n    | |________________________^\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `c_capture` found for struct `Compiler` in the current scope\n   --> src/compile.rs:148:26\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_capture` not found for this struct\n...\n148 |         let patch = self.c_capture(0, expr)?;\n    |                          ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `needs_dotstar` found for struct `Program` in the current scope\n   --> src/compile.rs:149:26\n    |\n149 |         if self.compiled.needs_dotstar() {\n    |                          ^^^^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `needs_dotstar` not found for this struct\n\nerror[E0599]: no method named `fill` found for struct `Compiler` in the current scope\n   --> src/compile.rs:150:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill` not found for this struct\n...\n150 |             self.fill(dotstar_patch.hole, patch.entry);\n    |                  ^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:154:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n154 |         self.fill_to_next(patch.hole);\n    |              ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n   --> src/compile.rs:155:33\n    |\n155 |         self.compiled.matches = vec![self.insts.len()];\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `[_]`\n    |\nhelp: there is an associated function `to_vec` with a similar name\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n    |\n116 | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117 | |         where\n118 | |             Self: Sized;\n    | |________________________^\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `push_compiled` found for struct `Compiler` in the current scope\n   --> src/compile.rs:156:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_compiled` not found for this struct\n...\n156 |         self.push_compiled(Inst::Match(0));\n    |              ^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `compile_finish` found for struct `Compiler` in the current scope\n   --> src/compile.rs:157:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_finish` not found for this struct\n...\n157 |         self.compile_finish()\n    |              ^^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:164:29\n    |\n164 |         debug_assert!(exprs.len() > 1);\n    |                             ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:167:19\n    |\n167 |             exprs.iter().all(|e| e.is_anchored_start());\n    |                   ^^^^ method not found in `&[Hir]`\n\nerror[E0599]: no method named `iter` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:169:19\n    |\n169 |             exprs.iter().all(|e| e.is_anchored_end());\n    |                   ^^^^ method not found in `&[Hir]`\n\nerror[E0599]: no method named `needs_dotstar` found for struct `Program` in the current scope\n   --> src/compile.rs:171:26\n    |\n171 |         if self.compiled.needs_dotstar() {\n    |                          ^^^^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `needs_dotstar` not found for this struct\n\nerror[E0599]: no method named `c_dotstar` found for struct `Compiler` in the current scope\n   --> src/compile.rs:172:34\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_dotstar` not found for this struct\n...\n172 |             dotstar_patch = self.c_dotstar()?;\n    |                                  ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:177:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n177 |         self.fill_to_next(dotstar_patch.hole);\n    |              ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:180:41\n    |\n180 |         for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n    |                                         ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for slice `[Hir]` in the current scope\n   --> src/compile.rs:180:52\n    |\n180 |         for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n    |                                                    ^^^^ method not found in `[Hir]`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:181:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n181 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for struct `Compiler` in the current scope\n   --> src/compile.rs:182:30\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_split_hole` not found for this struct\n...\n182 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `c_capture` found for struct `Compiler` in the current scope\n   --> src/compile.rs:183:46\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_capture` not found for this struct\n...\n183 |             let Patch { hole, entry } = self.c_capture(0, expr)?;\n    |                                              ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:184:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n184 |             self.fill_to_next(hole);\n    |                  ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `push_compiled` found for struct `Compiler` in the current scope\n   --> src/compile.rs:186:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_compiled` not found for this struct\n...\n186 |             self.push_compiled(Inst::Match(i));\n    |                  ^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_split` found for struct `Compiler` in the current scope\n   --> src/compile.rs:187:30\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_split` not found for this struct\n...\n187 |             prev_hole = self.fill_split(split, Some(entry), None);\n    |                              ^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:189:23\n    |\n189 |         let i = exprs.len() - 1;\n    |                       ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `c_capture` found for struct `Compiler` in the current scope\n   --> src/compile.rs:190:42\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_capture` not found for this struct\n...\n190 |         let Patch { hole, entry } = self.c_capture(0, &exprs[i])?;\n    |                                          ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill` found for struct `Compiler` in the current scope\n   --> src/compile.rs:191:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill` not found for this struct\n...\n191 |         self.fill(prev_hole, entry);\n    |              ^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:192:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n192 |         self.fill_to_next(hole);\n    |              ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `push_compiled` found for struct `Compiler` in the current scope\n   --> src/compile.rs:194:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_compiled` not found for this struct\n...\n194 |         self.push_compiled(Inst::Match(i));\n    |              ^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `compile_finish` found for struct `Compiler` in the current scope\n   --> src/compile.rs:195:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_finish` not found for this struct\n...\n195 |         self.compile_finish()\n    |              ^^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `unwrap` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:200:52\n    |\n200 |             self.insts.into_iter().map(|inst| inst.unwrap()).collect();\n    |                                                    ^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `unwrap` not found for this enum\n\nerror[E0599]: no method named `byte_classes` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:201:56\n     |\n201  |         self.compiled.byte_classes = self.byte_classes.byte_classes();\n     |                                                        ^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `byte_classes` not found for this struct\n\nerror[E0599]: no method named `check_size` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:262:14\n    |\n262 |         self.check_size()?;\n    |              ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_literal` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:266:22\n    |\n266 |                 self.c_literal(&[c])\n    |                      ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/compile.rs:269:39\n    |\n269 |                 assert!(self.compiled.uses_bytes());\n    |                                       ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no method named `c_bytes` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:270:22\n    |\n270 |                 self.c_bytes(&[b])\n    |                      ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:273:22\n    |\n273 |                 self.c_class(cls.ranges())\n    |                      ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/compile.rs:276:34\n    |\n276 |                 if self.compiled.uses_bytes() {\n    |                                  ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no method named `c_class_bytes` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:277:26\n    |\n277 |                     self.c_class_bytes(cls.ranges())\n    |                          ^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:285:26\n    |\n285 |                     self.c_class(&char_ranges)\n    |                          ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:289:35\n     |\n289  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:290:22\n    |\n290 |                 self.c_empty_look(prog::EmptyLook::EndLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:293:35\n     |\n293  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:294:22\n    |\n294 |                 self.c_empty_look(prog::EmptyLook::StartLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:297:35\n     |\n297  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:298:22\n    |\n298 |                 self.c_empty_look(prog::EmptyLook::StartLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:301:35\n     |\n301  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:302:22\n    |\n302 |                 self.c_empty_look(prog::EmptyLook::EndLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:305:22\n    |\n305 |                 self.c_empty_look(prog::EmptyLook::EndText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:308:22\n    |\n308 |                 self.c_empty_look(prog::EmptyLook::StartText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:311:22\n    |\n311 |                 self.c_empty_look(prog::EmptyLook::StartText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:314:22\n    |\n314 |                 self.c_empty_look(prog::EmptyLook::EndText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:318:35\n     |\n318  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:319:22\n    |\n319 |                 self.c_empty_look(prog::EmptyLook::WordBoundary)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:323:35\n     |\n323  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:324:22\n    |\n324 |                 self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:327:35\n     |\n327  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:328:22\n    |\n328 |                 self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:331:35\n     |\n331  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:332:22\n    |\n332 |                 self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:336:58\n    |\n336 |                     hir::GroupKind::NonCapturing => self.c(&g.hir),\n    |                                                          ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_capture` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:341:30\n    |\n341 |                         self.c_capture(2 * index as usize, &g.hir)\n    |                              ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_capture` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:349:30\n    |\n349 |                         self.c_capture(2 * index as usize, &g.hir)\n    |                              ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:355:26\n    |\n355 |                     self.c_concat(es.iter().rev())\n    |                          ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `iter` found for reference `&Vec<Hir>` in the current scope\n   --> src/compile.rs:355:38\n    |\n355 |                     self.c_concat(es.iter().rev())\n    |                                      ^^^^ method not found in `&Vec<Hir>`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:357:26\n    |\n357 |                     self.c_concat(es)\n    |                          ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_alternate` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:360:41\n    |\n360 |             Alternation(ref es) => self.c_alternate(&**es),\n    |                                         ^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:361:41\n    |\n361 |             Repetition(ref rep) => self.c_repeat(rep),\n    |                                         ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:370:18\n    |\n370 |             self.c(expr)\n    |                  ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:373:29\n    |\n373 |             let hole = self.push_hole(InstHole::Save { slot: first_slot });\n    |                             ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:374:30\n    |\n374 |             let patch = self.c(expr)?;\n    |                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:375:18\n    |\n375 |             self.fill(hole, patch.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:376:18\n    |\n376 |             self.fill_to_next(patch.hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:377:29\n    |\n377 |             let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });\n    |                             ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `only_utf8` found for struct `Program` in the current scope\n   --> src/compile.rs:383:30\n    |\n383 |         Ok(if !self.compiled.only_utf8() {\n    |                              ^^^^^^^^^-- help: remove the arguments\n    |                              |\n    |                              field, not a method\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `only_utf8` not found for this struct\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:384:18\n    |\n384 |             self.c(&Hir::repetition(hir::Repetition {\n    |             -----^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:390:18\n    |\n390 |             self.c(&Hir::repetition(hir::Repetition {\n    |             -----^ method not found in `&mut Compiler`\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty` found for reference `&[char]` in the current scope\n   --> src/compile.rs:399:30\n    |\n399 |         debug_assert!(!chars.is_empty());\n    |                              ^^^^^^^^ method not found in `&[char]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&[char]` in the current scope\n   --> src/compile.rs:402:32\n    |\n402 |                 Box::new(chars.iter().rev())\n    |                                ^^^^ method not found in `&[char]`\n\nerror[E0599]: no method named `iter` found for reference `&[char]` in the current scope\n   --> src/compile.rs:404:32\n    |\n404 |                 Box::new(chars.iter())\n    |                                ^^^^ method not found in `&[char]`\n\nerror[E0599]: no method named `c_char` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:407:46\n    |\n407 |         let Patch { mut hole, entry } = self.c_char(first)?;\n    |                                              ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_char` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:409:26\n    |\n409 |             let p = self.c_char(c)?;\n    |                          ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:410:18\n    |\n410 |             self.fill(hole, p.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:417:14\n    |\n417 |         self.c_class(&[hir::ClassUnicodeRange::new(c, c)])\n    |              ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `is_empty` found for reference `&[ClassUnicodeRange]` in the current scope\n   --> src/compile.rs:421:25\n    |\n421 |         assert!(!ranges.is_empty());\n    |                         ^^^^^^^^ method not found in `&[ClassUnicodeRange]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/compile.rs:422:26\n    |\n422 |         if self.compiled.uses_bytes() {\n    |                          ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no method named `compile` found for struct `CompileClass` in the current scope\n   --> src/compile.rs:426:15\n    |\n423 | /             CompileClass {\n424 | |                 c: self,\n425 | |                 ranges: ranges,\n426 | |             }.compile()\n    | |              -^^^^^^^ method not found in `CompileClass<'_, '_>`\n    | |______________|\n    |\n...\n869 |   struct CompileClass<'a, 'b> {\n    |   --------------------------- method `compile` not found for this struct\n\nerror[E0599]: no method named `iter` found for reference `&[ClassUnicodeRange]` in the current scope\n   --> src/compile.rs:429:24\n    |\n429 |                 ranges.iter().map(|r| (r.start(), r.end())).collect();\n    |                        ^^^^ method not found in `&[ClassUnicodeRange]`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:431:22\n    |\n431 |                 self.push_hole(InstHole::Char { c: ranges[0].0 })\n    |                      ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:433:22\n    |\n433 |                 self.push_hole(InstHole::Ranges { ranges: ranges })\n    |                      ^^^^^^^^^ method not found in `&mut Compiler`\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n   --> src/compile.rs:440:30\n    |\n440 |         debug_assert!(!bytes.is_empty());\n    |                              ^^^^^^^^ method not found in `&[u8]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/compile.rs:443:32\n    |\n443 |                 Box::new(bytes.iter().rev())\n    |                                ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/compile.rs:445:32\n    |\n445 |                 Box::new(bytes.iter())\n    |                                ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `c_byte` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:448:46\n    |\n448 |         let Patch { mut hole, entry } = self.c_byte(first)?;\n    |                                              ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_byte` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:450:26\n    |\n450 |             let p = self.c_byte(b)?;\n    |                          ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:451:18\n    |\n451 |             self.fill(hole, p.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class_bytes` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:458:14\n    |\n458 |         self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])\n    |              ^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `is_empty` found for reference `&[ClassBytesRange]` in the current scope\n   --> src/compile.rs:462:31\n    |\n462 |         debug_assert!(!ranges.is_empty());\n    |                               ^^^^^^^^ method not found in `&[ClassBytesRange]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[ClassBytesRange]` in the current scope\n    --> src/compile.rs:467:36\n     |\n467  |         for r in &ranges[0..ranges.len() - 1] {\n     |                                    ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:468:18\n    |\n468 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:469:30\n    |\n469 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:471:31\n     |\n471  |             self.byte_classes.set_range(r.start(), r.end());\n     |                               ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:472:29\n    |\n472 |             holes.push(self.push_hole(InstHole::Bytes {\n    |                        -----^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:475:30\n    |\n475 |             prev_hole = self.fill_split(split, Some(next), None);\n    |                              ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[ClassBytesRange]` in the current scope\n    --> src/compile.rs:478:32\n     |\n478  |         let r = &ranges[ranges.len() - 1];\n     |                                ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:479:27\n     |\n479  |         self.byte_classes.set_range(r.start(), r.end());\n     |                           ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:480:25\n    |\n480 |         holes.push(self.push_hole(InstHole::Bytes {\n    |                    -----^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:483:14\n    |\n483 |         self.fill(prev_hole, next);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:488:25\n    |\n488 |         let hole = self.push_hole(InstHole::EmptyLook { look: look });\n    |                         ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:501:46\n    |\n501 |         let Patch { mut hole, entry } = self.c(first)?;\n    |                                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:503:26\n    |\n503 |             let p = self.c(e)?;\n    |                          ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:504:18\n    |\n504 |             self.fill(hole, p.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:512:19\n    |\n512 |             exprs.len() >= 2, \"alternates must have at least 2 exprs\");\n    |                   ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:522:34\n    |\n522 |         for e in &exprs[0..exprs.len() - 1] {\n    |                                  ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:523:18\n    |\n523 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:524:30\n    |\n524 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:526:46\n    |\n526 |             let Patch { hole, entry } = self.c(e)?;\n    |                                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:538:30\n    |\n538 |             prev_hole = self.fill_split(split, Some(entry), None);\n    |                              ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:541:42\n    |\n541 |         let Patch { hole, entry } = self.c(&exprs[exprs.len() - 1])?;\n    |                                          ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:541:57\n    |\n541 |         let Patch { hole, entry } = self.c(&exprs[exprs.len() - 1])?;\n    |                                                         ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:549:14\n    |\n549 |         self.fill(prev_hole, entry);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_zero_or_one` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:556:31\n    |\n556 |             ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),\n    |                               ^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_zero_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:557:32\n    |\n557 |             ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),\n    |                                ^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_one_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:558:31\n    |\n558 |             OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),\n    |                               ^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_range` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:560:22\n    |\n560 |                 self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)\n    |                      ^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_range_min_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:563:22\n    |\n563 |                 self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_range` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:566:22\n    |\n566 |                 self.c_repeat_range(&rep.hir, rep.greedy, min, max)\n    |                      ^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:573:26\n    |\n573 |         let split = self.push_split_hole();\n    |                          ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:574:63\n    |\n574 |         let Patch { hole: hole_rep, entry: entry_rep } = self.c(expr)?;\n    |                                                               ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:577:18\n    |\n577 |             self.fill_split(split, Some(entry_rep), None)\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:579:18\n    |\n579 |             self.fill_split(split, None, Some(entry_rep))\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n   --> src/compile.rs:581:21\n    |\n581 |         let holes = vec![hole_rep, split_hole];\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `[_]`\n    |\nhelp: there is an associated function `to_vec` with a similar name\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n    |\n116 | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117 | |         where\n118 | |             Self: Sized;\n    | |________________________^\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:587:26\n    |\n587 |         let split = self.push_split_hole();\n    |                          ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:588:63\n    |\n588 |         let Patch { hole: hole_rep, entry: entry_rep } = self.c(expr)?;\n    |                                                               ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:590:14\n    |\n590 |         self.fill(hole_rep, split_entry);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:592:18\n    |\n592 |             self.fill_split(split, Some(entry_rep), None)\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:594:18\n    |\n594 |             self.fill_split(split, None, Some(entry_rep))\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:600:63\n    |\n600 |         let Patch { hole: hole_rep, entry: entry_rep } = self.c(expr)?;\n    |                                                               ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:601:14\n    |\n601 |         self.fill_to_next(hole_rep);\n    |              ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:602:26\n    |\n602 |         let split = self.push_split_hole();\n    |                          ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:605:18\n    |\n605 |             self.fill_split(split, Some(entry_rep), None)\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:607:18\n    |\n607 |             self.fill_split(split, None, Some(entry_rep))\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:619:33\n    |\n619 |         let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n    |                                 ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_zero_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:620:30\n    |\n620 |         let patch_rep = self.c_repeat_zero_or_more(expr, greedy)?;\n    |                              ^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:621:14\n    |\n621 |         self.fill(patch_concat.hole, patch_rep.entry);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:633:33\n    |\n633 |         let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n    |                                 ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:660:18\n    |\n660 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:661:30\n    |\n661 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:662:46\n    |\n662 |             let Patch { hole, entry } = self.c(expr)?;\n    |                                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:665:33\n    |\n665 |                 holes.push(self.fill_split(split, Some(entry), None));\n    |                                 ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:667:33\n    |\n667 |                 holes.push(self.fill_split(split, None, Some(entry)));\n    |                                 ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:678:32\n    |\n678 |                 self.insts[pc].fill(goto);\n    |                                ^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `fill` not found for this enum\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:682:26\n    |\n682 |                     self.fill(hole, goto);\n    |                          ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:690:14\n    |\n690 |         self.fill(hole, next);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:704:40\n    |\n704 |                         self.insts[pc].fill_split(goto1, goto2);\n    |                                        ^^^^^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `fill_split` not found for this enum\n\nerror[E0599]: no method named `half_fill_split_goto1` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:708:40\n    |\n708 |                         self.insts[pc].half_fill_split_goto1(goto1);\n    |                                        ^^^^^^^^^^^^^^^^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `half_fill_split_goto1` not found for this enum\n\nerror[E0599]: no method named `half_fill_split_goto2` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:712:40\n    |\n712 |                         self.insts[pc].half_fill_split_goto2(goto2);\n    |                                        ^^^^^^^^^^^^^^^^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `half_fill_split_goto2` not found for this enum\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:722:41\n    |\n722 |                     new_holes.push(self.fill_split(hole, goto1, goto2));\n    |                                         ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for reference `&InstHole` in the current scope\n   --> src/compile.rs:781:53\n    |\n781 |             MaybeInst::Uncompiled(ref inst) => inst.fill(goto),\n    |                                                     ^^^^ method not found in `&InstHole`\n\nerror[E0599]: no method named `clear` found for struct `SuffixCache` in the current scope\n   --> src/compile.rs:880:29\n    |\n880 |         self.c.suffix_cache.clear();\n    |                             ^^^^^ method not found in `SuffixCache`\n...\n983 | struct SuffixCache {\n    | ------------------ method `clear` not found for this struct\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n880 |         self.c.suffix_cache.table.clear();\n    |                             ++++++\n\nerror[E0599]: no method named `iter` found for reference `&'b [ClassUnicodeRange]` in the current scope\n   --> src/compile.rs:882:39\n    |\n882 |         for (i, range) in self.ranges.iter().enumerate() {\n    |                                       ^^^^ method not found in `&[ClassUnicodeRange]`\n\nerror[E0599]: no method named `len` found for reference `&'b [ClassUnicodeRange]` in the current scope\n    --> src/compile.rs:883:54\n     |\n883  |             let is_last_range = i + 1 == self.ranges.len();\n     |                                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `c_utf8_seq` found for struct `CompileClass` in the current scope\n   --> src/compile.rs:892:54\n    |\n869 | struct CompileClass<'a, 'b> {\n    | --------------------------- method `c_utf8_seq` not found for this struct\n...\n892 |                     let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n    |                                                      ^^^^^^^^^^ method not found in `CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `fill` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:894:28\n    |\n894 |                     self.c.fill(last_split, entry);\n    |                            ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:903:28\n    |\n903 |                     self.c.fill_to_next(last_split);\n    |                            ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:904:41\n    |\n904 |                     last_split = self.c.push_split_hole();\n    |                                         ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_utf8_seq` found for struct `CompileClass` in the current scope\n   --> src/compile.rs:905:54\n    |\n869 | struct CompileClass<'a, 'b> {\n    | --------------------------- method `c_utf8_seq` not found for this struct\n...\n905 |                     let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n    |                                                      ^^^^^^^^^^ method not found in `CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:907:41\n    |\n907 |                     last_split = self.c.fill_split(last_split, Some(entry), None);\n    |                                         ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_utf8_seq_` found for mutable reference `&mut CompileClass<'a, 'b>` in the current scope\n   --> src/compile.rs:920:18\n    |\n920 |             self.c_utf8_seq_(seq)\n    |                  ^^^^^^^^^^^ method not found in `&mut CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `c_utf8_seq_` found for mutable reference `&mut CompileClass<'a, 'b>` in the current scope\n   --> src/compile.rs:922:18\n    |\n922 |             self.c_utf8_seq_(seq.into_iter().rev())\n    |                  ^^^^^^^^^^^ method not found in `&mut CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `get` found for struct `SuffixCache` in the current scope\n   --> src/compile.rs:939:62\n    |\n939 |                 if let Some(cached_pc) = self.c.suffix_cache.get(key, pc) {\n    |                                                              ^^^ method not found in `SuffixCache`\n...\n983 | struct SuffixCache {\n    | ------------------ method `get` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:944:33\n     |\n944  |             self.c.byte_classes.set_range(byte_range.start, byte_range.end);\n     |                                 ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:946:36\n    |\n946 |                 last_hole = self.c.push_hole(InstHole::Bytes {\n    |                             -------^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_compiled` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:951:24\n    |\n951 |                 self.c.push_compiled(Inst::Bytes(InstBytes {\n    |                 -------^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/compile.rs:957:44\n    |\n957 |             from_inst = self.c.insts.len().checked_sub(1).unwrap();\n    |                                            ^^^^^^^^^^^ method not found in `usize`\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: no method named `hash` found for mutable reference `&mut SuffixCache` in the current scope\n    --> src/compile.rs:1015:22\n     |\n1015 |         let h = self.hash(&key);\n     |                      ^^^^ method not found in `&mut SuffixCache`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `hash`, perhaps you need to implement it:\n             candidate #1: `Hash`\n\nerror[E0599]: no method named `wrapping_mul` found for type `u64` in the current scope\n    --> src/compile.rs:1038:45\n     |\n1038 |         h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);\n     |                                             ^^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `wrapping_mul` found for type `u64` in the current scope\n    --> src/compile.rs:1039:41\n     |\n1039 |         h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);\n     |                                         ^^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `wrapping_mul` found for type `u64` in the current scope\n    --> src/compile.rs:1040:39\n     |\n1040 |         h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);\n     |                                       ^^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `set_range` found for mutable reference `&mut ByteClassSet` in the current scope\n    --> src/compile.rs:1071:18\n     |\n1071 |             self.set_range(b1 as u8, (b2 - 1) as u8);\n     |                  ^^^^^^^^^ method not found in `&mut ByteClassSet`\n\nerror[E0599]: no method named `checked_add` found for type `u8` in the current scope\n    --> src/compile.rs:1090:31\n     |\n1090 |                 class = class.checked_add(1).unwrap();\n     |                               ^^^^^^^^^^^ method not found in `u8`\n\nerror[E0599]: no method named `len` found for reference `&Program` in the current scope\n  --> src/dfa.rs:74:43\n   |\n74 |     if insts.dfa_size_limit == 0 || insts.len() > ::std::i32::MAX as usize {\n   |                                           ^^^ method not found in `&Program`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following traits define an item `len`, perhaps you need to implement one of them:\n           candidate #1: `input::Input`\n           candidate #2: `Automaton`\n           candidate #3: `ExactSizeIterator`\nhelp: some of the expressions' fields have a method of the same name\n   |\n74 |     if insts.dfa_size_limit == 0 || insts.byte_classes.len() > ::std::i32::MAX as usize {\n   |                                           +++++++++++++\n74 |     if insts.dfa_size_limit == 0 || insts.capture_name_idx.len() > ::std::i32::MAX as usize {\n   |                                           +++++++++++++++++\n74 |     if insts.dfa_size_limit == 0 || insts.captures.len() > ::std::i32::MAX as usize {\n   |                                           +++++++++\n74 |     if insts.dfa_size_limit == 0 || insts.insts.len() > ::std::i32::MAX as usize {\n   |                                           ++++++\n     and 1 other candidate\n\nerror[E0599]: no method named `is_empty` found for reference `&'a [u8]` in the current scope\n   --> src/dfa.rs:299:22\n    |\n299 |         if self.data.is_empty() {\n    |                      ^^^^^^^^ method not found in `&'a [u8]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `dfa::Transitions` in the current scope\n   --> src/dfa.rs:432:37\n    |\n170 | struct Transitions {\n    | ------------------ function or associated item `new` not found for this struct\n...\n432 |                 trans: Transitions::new(num_byte_classes),\n    |                                     ^^^ function or associated item not found in `Transitions`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/dfa.rs:439:30\n    |\n439 |             qcur: SparseSet::new(prog.insts.len()),\n    |                              ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/dfa.rs:440:31\n    |\n440 |             qnext: SparseSet::new(prog.insts.len()),\n    |                               ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `reset_size` found for struct `CacheInner` in the current scope\n   --> src/dfa.rs:442:21\n    |\n111 | struct CacheInner {\n    | ----------------- method `reset_size` not found for this struct\n...\n442 |         cache.inner.reset_size();\n    |                     ^^^^^^^^^^ method not found in `CacheInner`\n\nerror[E0599]: no method named `start_flags` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:477:46\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_flags` not found for this struct\n...\n477 |         let (empty_flags, state_flags) = dfa.start_flags(text, at);\n    |                                              ^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:478:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_state` not found for this struct\n...\n478 |         dfa.start = match dfa.start_state(\n    |                           ----^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `exec_at` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:488:13\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `exec_at` not found for this struct\n...\n488 |         dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text)\n    |             ^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_flags_reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:510:46\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_flags_reverse` not found for this struct\n...\n510 |         let (empty_flags, state_flags) = dfa.start_flags_reverse(text, at);\n    |                                              ^^^^^^^^^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:511:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_state` not found for this struct\n...\n511 |         dfa.start = match dfa.start_state(\n    |                           ----^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `exec_at_reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:521:13\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `exec_at_reverse` not found for this struct\n...\n521 |         dfa.exec_at_reverse(&mut cache.qcur, &mut cache.qnext, text)\n    |             ^^^^^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/dfa.rs:532:31\n    |\n532 |         debug_assert!(matches.len() == prog.matches.len());\n    |                               ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `start_flags` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:544:46\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_flags` not found for this struct\n...\n544 |         let (empty_flags, state_flags) = dfa.start_flags(text, at);\n    |                                              ^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:545:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_state` not found for this struct\n...\n545 |         dfa.start = match dfa.start_state(\n    |                           ----^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `exec_at` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:555:26\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `exec_at` not found for this struct\n...\n555 |         let result = dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text);\n    |                          ^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/dfa.rs:557:24\n    |\n557 |             if matches.len() == 1 {\n    |                        ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:562:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `state` not found for this struct\n...\n562 |                 for ip in dfa.state(dfa.last_match_si).inst_ptrs() {\n    |                               ^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:623:25\n     |\n623  |         while at < text.len() {\n     |                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:636:53\n     |\n636  |             while next_si <= STATE_MAX && at < text.len() {\n     |                                                     ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:638:41\n    |\n638 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:640:58\n     |\n640  |                 if prev_si > STATE_MAX || at + 2 >= text.len() {\n     |                                                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:644:41\n    |\n644 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:649:41\n    |\n649 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:655:41\n    |\n655 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:676:38\n    |\n676 |                     let state = self.state(next_si);\n    |                                      ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:690:38\n     |\n690  |                     && at + 2 < text.len() {\n     |                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:693:30\n    |\n693 |                         self.next_si(next_si & !STATE_MATCH, text, at)\n    |                              ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `has_prefix` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:705:36\n    |\n705 |                 debug_assert!(self.has_prefix());\n    |                                    ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `prefix_at` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:708:33\n    |\n708 |                 at = match self.prefix_at(text, at) {\n    |                                 ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `prefix_at`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:709:57\n     |\n709  |                     None => return Result::NoMatch(text.len()),\n     |                                                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:720:34\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `byte` not found for this struct\n...\n720 |                 let byte = Byte::byte(text[at - 1]);\n    |                                  ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:728:38\n    |\n728 |                 next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n    |                                      ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:730:55\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n730 |                     Some(STATE_DEAD) => return result.set_non_match(at),\n    |                                                       ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:752:30\n    |\n752 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                              ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no function or associated item named `eof` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:752:69\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `eof` not found for this struct\n...\n752 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                                                                     ^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:754:47\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n754 |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n    |                                               ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:754:66\n     |\n754  |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n     |                                                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:761:41\n     |\n761  |             result = Result::Match(text.len());\n     |                                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:788:41\n    |\n788 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:794:41\n    |\n794 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:799:41\n    |\n799 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:805:41\n    |\n805 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:820:30\n    |\n820 |                         self.next_si(next_si & !STATE_MATCH, text, at)\n    |                              ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:830:34\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `byte` not found for this struct\n...\n830 |                 let byte = Byte::byte(text[at]);\n    |                                  ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:833:38\n    |\n833 |                 next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n    |                                      ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:835:55\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n835 |                     Some(STATE_DEAD) => return result.set_non_match(at),\n    |                                                       ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:854:30\n    |\n854 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                              ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no function or associated item named `eof` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:854:69\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `eof` not found for this struct\n...\n854 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                                                                     ^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:856:47\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n856 |             Some(STATE_DEAD) => return result.set_non_match(0),\n    |                                               ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:895:32\n     |\n895  |         debug_assert!(i < text.len());\n     |                                ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `get_unchecked` found for reference `&[u8]` in the current scope\n   --> src/dfa.rs:896:23\n    |\n896 |         let b = *text.get_unchecked(i);\n    |                       ^^^^^^^^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `get_unchecked` found for struct `Vec<u8>` in the current scope\n   --> src/dfa.rs:898:43\n    |\n898 |         let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n    |                                           ^^^^^^^^^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named `next_unchecked` found for struct `dfa::Transitions` in the current scope\n   --> src/dfa.rs:899:26\n    |\n170 | struct Transitions {\n    | ------------------ method `next_unchecked` not found for this struct\n...\n899 |         self.cache.trans.next_unchecked(si, cls as usize)\n    |                          ^^^^^^^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:920:14\n    |\n920 |         qcur.clear();\n    |              ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:921:24\n    |\n921 |         for ip in self.state(si).inst_ptrs() {\n    |                        ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `insert` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:922:18\n    |\n922 |             qcur.insert(ip);\n    |                  ^^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:931:33\n    |\n931 |         let is_word_last = self.state(si).flags().is_word();\n    |                                 ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_ascii_word` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:932:25\n    |\n405 | struct Byte(u16);\n    | ----------- method `is_ascii_word` not found for this struct\n...\n932 |         let is_word = b.is_ascii_word();\n    |                         ^^^^^^^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:933:17\n    |\n933 |         if self.state(si).flags().has_empty() {\n    |                 ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_eof` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:939:18\n    |\n405 | struct Byte(u16);\n    | ----------- method `is_eof` not found for this struct\n...\n939 |             if b.is_eof() {\n    |                  ^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:942:25\n    |\n405 | struct Byte(u16);\n    | ----------- method `as_byte` not found for this struct\n...\n942 |             } else if b.as_byte().map_or(false, |b| b == b'\\n') {\n    |                         ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:952:19\n    |\n952 |             qnext.clear();\n    |                   ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `follow_epsilons` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:954:22\n    |\n954 |                 self.follow_epsilons(usize_to_u32(ip), qnext, flags);\n    |                      ^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:971:36\n    |\n405 | struct Byte(u16);\n    | ----------- method `as_byte` not found for this struct\n...\n971 |         empty_flags.start_line = b.as_byte().map_or(false, |b| b == b'\\n');\n    |                                    ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `is_ascii_word` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:972:14\n    |\n405 | struct Byte(u16);\n    | ----------- method `is_ascii_word` not found for this struct\n...\n972 |         if b.is_ascii_word() {\n    |              ^^^^^^^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_word` found for struct `StateFlags` in the current scope\n   --> src/dfa.rs:973:25\n    |\n421 | struct StateFlags(u8);\n    | ----------------- method `set_word` not found for this struct\n...\n973 |             state_flags.set_word();\n    |                         ^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:977:15\n    |\n977 |         qnext.clear();\n    |               ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `set_match` found for struct `StateFlags` in the current scope\n   --> src/dfa.rs:985:33\n    |\n421 | struct StateFlags(u8);\n    | ----------------- method `set_match` not found for this struct\n...\n985 |                     state_flags.set_match();\n    |                                 ^^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `continue_past_first_match` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:986:30\n    |\n986 |                     if !self.continue_past_first_match() {\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `contains` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:989:39\n    |\n989 | ...                   && !qnext.contains(ip as usize) {\n    |                                 ^^^^^^^^ method not found in `&mut SparseSet`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `contains`, perhaps you need to implement it:\n            candidate #1: `RangeBounds`\n\nerror[E0599]: no method named `insert` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:992:31\n    |\n992 |                         qnext.insert(ip);\n    |                               ^^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:996:26\n    |\n405 | struct Byte(u16);\n    | ----------- method `as_byte` not found for this struct\n...\n996 |                     if b.as_byte().map_or(false, |b| inst.matches(b)) {\n    |                          ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `matches` found for reference `&InstBytes` in the current scope\n   --> src/dfa.rs:996:59\n    |\n996 |                     if b.as_byte().map_or(false, |b| inst.matches(b)) {\n    |                                                           ^^^^^^^ method not found in `&InstBytes`\n\nerror[E0599]: no method named `follow_epsilons` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:997:30\n    |\n997 |                         self.follow_epsilons(\n    |                         -----^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_eof` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1005:18\n     |\n405  | struct Byte(u16);\n     | ----------- method `is_eof` not found for this struct\n...\n1005 |             if b.is_eof() && self.prog.matches.len() > 1 {\n     |                  ^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `cached_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1024:35\n     |\n1024 |         let mut next = match self.cached_state(\n     |                              -----^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1035:33\n     |\n1035 |             debug_assert!(!self.state(next).flags().is_match());\n     |                                 ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `start_ptr` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1036:25\n     |\n1036 |             next = self.start_ptr(next);\n     |                         ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1038:38\n     |\n1038 |         if next <= STATE_MAX && self.state(next).flags().is_match() {\n     |                                      ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `byte_class` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1044:28\n     |\n1044 |             let cls = self.byte_class(b);\n     |                            ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `set_next` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1045:30\n     |\n170  | struct Transitions {\n     | ------------------ method `set_next` not found for this struct\n...\n1045 |             self.cache.trans.set_next(si, cls, next);\n     |                              ^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `contains` found for mutable reference `&mut SparseSet` in the current scope\n    --> src/dfa.rs:1090:22\n     |\n1090 |                 if q.contains(ip as usize) {\n     |                      ^^^^^^^^ method not found in `&mut SparseSet`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `contains`, perhaps you need to implement it:\n             candidate #1: `RangeBounds`\n\nerror[E0599]: no method named `insert` found for mutable reference `&mut SparseSet` in the current scope\n    --> src/dfa.rs:1093:19\n     |\n1093 |                 q.insert(ip as usize);\n     |                   ^^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `cached_state_key` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1177:30\n     |\n1177 |         let key = match self.cached_state_key(q, &mut state_flags) {\n     |                              ^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `approximate_size` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1186:17\n     |\n1186 |         if self.approximate_size() > self.prog.dfa_size_limit\n     |                 ^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `clear_cache_and_save` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1187:22\n     |\n1187 |             && !self.clear_cache_and_save(current_state)\n     |                      ^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `add_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1193:14\n     |\n1193 |         self.add_state(key)\n     |              ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n    --> src/dfa.rs:1223:25\n     |\n1223 |         let mut insts = vec![0];\n     |                         ^^^^^^^ function or associated item not found in `[_]`\n     |\nhelp: there is an associated function `to_vec` with a similar name\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n     |\n116  | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117  | |         where\n118  | |             Self: Sized;\n     | |________________________^\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `set_empty` found for mutable reference `&mut StateFlags` in the current scope\n    --> src/dfa.rs:1232:33\n     |\n1232 |                     state_flags.set_empty();\n     |                                 ^^^^^^^^^ method not found in `&mut StateFlags`\n\nerror[E0599]: no method named `continue_past_first_match` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1237:30\n     |\n1237 |                     if !self.continue_past_first_match() {\n     |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_match` found for mutable reference `&mut StateFlags` in the current scope\n    --> src/dfa.rs:1247:45\n     |\n1247 |         if insts.len() == 1 && !state_flags.is_match() {\n     |                                             ^^^^^^^^ method not found in `&mut StateFlags`\n\nerror[E0599]: no method named `clear_cache` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1273:26\n     |\n1273 |             None => self.clear_cache(),\n     |                          ^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1275:32\n     |\n1275 |                 let cur = self.state(*si).clone();\n     |                                ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `clear_cache` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1276:26\n     |\n1276 |                 if !self.clear_cache() {\n     |                          ^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `restore_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1282:28\n     |\n1282 |                 *si = self.restore_state(cur).unwrap();\n     |                            ^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1309:26\n     |\n1309 |         let start = self.state(self.start & !STATE_START).clone();\n     |                          ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1311:23\n     |\n1311 |             Some(self.state(self.last_match_si).clone())\n     |                       ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `reset_size` found for mutable reference `&'a mut CacheInner` in the current scope\n    --> src/dfa.rs:1315:20\n     |\n1315 |         self.cache.reset_size();\n     |                    ^^^^^^^^^^ method not found in `&mut CacheInner`\n\nerror[E0599]: no method named `clear` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1316:26\n     |\n170  | struct Transitions {\n     | ------------------ method `clear` not found for this struct\n...\n1316 |         self.cache.trans.clear();\n     |                          ^^^^^ method not found in `Transitions`\n     |\nhelp: one of the expressions' fields has a method of the same name\n     |\n1316 |         self.cache.trans.table.clear();\n     |                          ++++++\n\nerror[E0599]: no method named `restore_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1324:30\n     |\n1324 |         let start_ptr = self.restore_state(start).unwrap();\n     |                              ^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `start_ptr` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1325:27\n     |\n1325 |         self.start = self.start_ptr(start_ptr);\n     |                           ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `restore_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1327:39\n     |\n1327 |             self.last_match_si = self.restore_state(last_match).unwrap();\n     |                                       ^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `add_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1340:14\n     |\n1340 |         self.add_state(state)\n     |              ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1365:32\n     |\n170  | struct Transitions {\n     | ------------------ method `next` not found for this struct\n...\n1365 |         match self.cache.trans.next(si, self.byte_class(b)) {\n     |                                ^^^^ method not found in `Transitions`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `next`, perhaps you need to implement it:\n             candidate #1: `Iterator`\n\nerror[E0599]: no method named `byte_class` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1365:46\n     |\n1365 |         match self.cache.trans.next(si, self.byte_class(b)) {\n     |                                              ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `exec_byte` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1366:35\n     |\n1366 |             STATE_UNKNOWN => self.exec_byte(qcur, qnext, si, b),\n     |                                   ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_word` found for struct `StateFlags` in the current scope\n    --> src/dfa.rs:1398:28\n     |\n421  | struct StateFlags(u8);\n     | ----------------- method `is_word` not found for this struct\n...\n1398 |              ((state_flags.is_word() as u8) << 6))\n     |                            ^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n    --> src/dfa.rs:1406:11\n     |\n1406 |         q.clear();\n     |           ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `follow_epsilons` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1408:14\n     |\n1408 |         self.follow_epsilons(start, q, empty_flags);\n     |              ^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `cached_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1413:29\n     |\n1413 |         let sp = match self.cached_state(q, state_flags, None) {\n     |                             ^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `start_ptr` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1415:30\n     |\n1415 |             Some(sp) => self.start_ptr(sp),\n     |                              ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1429:32\n     |\n1429 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1431:37\n     |\n1431 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1433:44\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1433 |         let is_word_last = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n     |                                            ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1434:33\n     |\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                 ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1434:48\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                                ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_word` found for struct `StateFlags` in the current scope\n    --> src/dfa.rs:1436:25\n     |\n421  | struct StateFlags(u8);\n     | ----------------- method `set_word` not found for this struct\n...\n1436 |             state_flags.set_word();\n     |                         ^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1457:40\n     |\n1457 |         empty_flags.start = at == text.len();\n     |                                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1458:32\n     |\n1458 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1459:45\n     |\n1459 |         empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n     |                                             ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1460:37\n     |\n1460 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1463:23\n     |\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1463:38\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                      ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1464:39\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1464 |         let is_word = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n     |                                       ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_word` found for struct `StateFlags` in the current scope\n    --> src/dfa.rs:1466:25\n     |\n421  | struct StateFlags(u8);\n     | ----------------- method `set_word` not found for this struct\n...\n1466 |             state_flags.set_word();\n     |                         ^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `num_byte_classes` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1478:47\n     |\n1478 |         &self.cache.states[si as usize / self.num_byte_classes()]\n     |                                               ^^^^^^^^^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `add` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1493:41\n     |\n170  | struct Transitions {\n     | ------------------ method `add` not found for this struct\n...\n1493 |         let si = match self.cache.trans.add() {\n     |                                         ^^^ method not found in `Transitions`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `add`, perhaps you need to implement it:\n             candidate #1: `Add`\n\nerror[E0599]: no method named `byte_class` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1503:32\n     |\n1503 |                 let cls = self.byte_class(Byte::byte(b as u8));\n     |                                ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1503:49\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1503 |                 let cls = self.byte_class(Byte::byte(b as u8));\n     |                                                 ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_next` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1504:34\n     |\n170  | struct Transitions {\n     | ------------------ method `set_next` not found for this struct\n...\n1504 |                 self.cache.trans.set_next(si, cls, STATE_QUIT);\n     |                                  ^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `state_heap_size` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1510:30\n     |\n170  | struct Transitions {\n     | ------------------ method `state_heap_size` not found for this struct\n...\n1510 |             self.cache.trans.state_heap_size()\n     |                              ^^^^^^^^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: the method `len` exists for struct `Box<[u8]>`, but its trait bounds were not satisfied\n    --> src/dfa.rs:1511:31\n     |\n1511 |               + (2 * state.data.len())\n     |                                 ^^^\n     |\n    ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:238:1\n     |\n238  | / pub struct Box<\n239  | |     T: ?Sized,\n240  | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n241  | | >(Unique<T>, A);\n     | |_- doesn't satisfy `Box<[u8]>: ExactSizeIterator`\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `Box<[u8]>: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `num_states` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1518:43\n     |\n170  | struct Transitions {\n     | ------------------ method `num_states` not found for this struct\n...\n1518 |                       == self.cache.trans.num_states());\n     |                                           ^^^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `find` found for struct `LiteralSearcher` in the current scope\n    --> src/dfa.rs:1531:28\n     |\n1531 |         self.prog.prefixes.find(&text[at..]).map(|(s, _)| at + s)\n     |                            ^^^^ method not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `find` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `find`, perhaps you need to implement one of them:\n             candidate #1: `Automaton`\n             candidate #2: `Iterator`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1547:17\n     |\n405  | struct Byte(u16);\n     | ----------- method `as_byte` not found for this struct\n...\n1547 |         match b.as_byte() {\n     |                 ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `num_byte_classes` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1548:26\n     |\n1548 |             None => self.num_byte_classes() - 1,\n     |                          ^^^^^^^^^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `u8_class` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1549:29\n     |\n1549 |             Some(b) => self.u8_class(b),\n     |                             ^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n    --> src/dfa.rs:1574:32\n     |\n1574 |         && !self.prog.prefixes.is_empty()\n     |                                ^^^^^^^^ method not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `is_empty` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n             candidate #1: `input::Input`\n             candidate #2: `Automaton`\n             candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `has_prefix` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1584:17\n     |\n1584 |         if self.has_prefix() {\n     |                 ^^^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `approximate_size` found for reference `&'a Program` in the current scope\n    --> src/dfa.rs:1597:37\n     |\n1597 |         self.cache.size + self.prog.approximate_size()\n     |                                     ^^^^^^^^^^^^^^^^ method not found in `&Program`\n\nerror[E0599]: no method named `get_unchecked` found for struct `Vec<u32>` in the current scope\n    --> src/dfa.rs:1654:21\n     |\n1654 |         *self.table.get_unchecked(si as usize + cls)\n     |                     ^^^^^^^^^^^^^ method not found in `Vec<u32>`\n\nerror[E0599]: no method named `as_byte` found for reference `&dfa::Byte` in the current scope\n    --> src/dfa.rs:1690:28\n     |\n1690 |         let b = match self.as_byte() {\n     |                            ^^^^^^^ method not found in `&dfa::Byte`\n\nerror[E0599]: no method named `is_eof` found for reference `&dfa::Byte` in the current scope\n    --> src/dfa.rs:1701:17\n     |\n1701 |         if self.is_eof() {\n     |                 ^^^^^^ method not found in `&dfa::Byte`\n\nerror[E0599]: no method named `inst_ptrs` found for reference `&State` in the current scope\n    --> src/dfa.rs:1711:36\n     |\n1711 |         let ips: Vec<usize> = self.inst_ptrs().collect();\n     |                                    ^^^^^^^^^ method not found in `&State`\n\nerror[E0599]: no method named `flags` found for reference `&State` in the current scope\n    --> src/dfa.rs:1713:32\n     |\n1713 |          .field(\"flags\", &self.flags())\n     |                                ^^^^^ method not found in `&State`\n\nerror[E0599]: no method named `num_states` found for reference `&dfa::Transitions` in the current scope\n    --> src/dfa.rs:1722:27\n     |\n1722 |         for si in 0..self.num_states() {\n     |                           ^^^^^^^^^^ method not found in `&Transitions`\n\nerror[E0599]: no method named `iter` found for reference `&'a [u32]` in the current scope\n    --> src/dfa.rs:1736:31\n     |\n1736 |         for (b, si) in self.0.iter().enumerate() {\n     |                               ^^^^ method not found in `&'a [u32]`\n\nerror[E0599]: no method named `is_match` found for reference `&StateFlags` in the current scope\n    --> src/dfa.rs:1754:35\n     |\n1754 |          .field(\"is_match\", &self.is_match())\n     |                                   ^^^^^^^^ method not found in `&StateFlags`\n\nerror[E0599]: no method named `is_word` found for reference `&StateFlags` in the current scope\n    --> src/dfa.rs:1755:34\n     |\n1755 |          .field(\"is_word\", &self.is_word())\n     |                                  ^^^^^^^ method not found in `&StateFlags`\n\nerror[E0599]: no method named `has_empty` found for reference `&StateFlags` in the current scope\n    --> src/dfa.rs:1756:36\n     |\n1756 |          .field(\"has_empty\", &self.has_empty())\n     |                                    ^^^^^^^^^ method not found in `&StateFlags`\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1833:25\n     |\n1833 |     for (i, &b) in data.iter().enumerate() {\n     |                         ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `new_many` found for struct `ExecBuilder` in the current scope\n   --> src/exec.rs:120:15\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_many` not found for this struct\n...\n120 |         Self::new_many(&[re])\n    |               ^^^^^^^^ function or associated item not found in `ExecBuilder`\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/exec.rs:132:15\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n...\n132 |         Self::new_options(opts)\n    |               ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n   --> src/exec.rs:286:31\n    |\n286 |                 nfa: Program::new(),\n    |                               ^^^ function or associated item not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n   --> src/exec.rs:287:31\n    |\n287 |                 dfa: Program::new(),\n    |                               ^^^ function or associated item not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n   --> src/exec.rs:288:39\n    |\n288 |                 dfa_reverse: Program::new(),\n    |                                       ^^^ function or associated item not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `empty` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:289:44\n    |\n289 |                 suffixes: LiteralSearcher::empty(),\n    |                                            ^^^^^ function or associated item not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- function or associated item `empty` not found for this struct\n\nerror[E0599]: no method named `parse` found for struct `ExecBuilder` in the current scope\n   --> src/exec.rs:294:27\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- method `parse` not found for this struct\n...\n294 |         let parsed = self.parse()?;\n    |                           ^^^^^ method not found in `ExecBuilder`\n\nerror[E0599]: no function or associated item named `new` found for struct `Compiler` in the current scope\n   --> src/exec.rs:296:23\n    |\n296 |             Compiler::new()\n    |                       ^^^ function or associated item not found in `Compiler`\n    |\n   ::: src/compile.rs:37:1\n    |\n37  | pub struct Compiler {\n    | ------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Compiler` in the current scope\n   --> src/exec.rs:302:23\n    |\n302 |             Compiler::new()\n    |                       ^^^ function or associated item not found in `Compiler`\n    |\n   ::: src/compile.rs:37:1\n    |\n37  | pub struct Compiler {\n    | ------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Compiler` in the current scope\n   --> src/exec.rs:308:23\n    |\n308 |             Compiler::new()\n    |                       ^^^ function or associated item not found in `Compiler`\n    |\n   ::: src/compile.rs:37:1\n    |\n37  | pub struct Compiler {\n    | ------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `prefixes` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:317:41\n    |\n317 |         nfa.prefixes = LiteralSearcher::prefixes(prefixes);\n    |                                         ^^^^^^^^ function or associated item not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- function or associated item `prefixes` not found for this struct\n\nerror[E0599]: no function or associated item named `suffixes` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:327:40\n    |\n327 |             suffixes: LiteralSearcher::suffixes(suffixes),\n    |                                        ^^^^^^^^ function or associated item not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- function or associated item `suffixes` not found for this struct\n\nerror[E0599]: no method named `choose_match_type` found for struct `ExecReadOnly` in the current scope\n   --> src/exec.rs:330:28\n    |\n65  | struct ExecReadOnly {\n    | ------------------- method `choose_match_type` not found for this struct\n...\n330 |         ro.match_type = ro.choose_match_type(self.match_type);\n    |                            ^^^^^^^^^^^^^^^^^ method not found in `ExecReadOnly`\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:343:24\n    |\n343 |         next_utf8(text.as_bytes(), i)\n    |                        ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:348:39\n    |\n348 |         self.0.shortest_match_at(text.as_bytes(), start)\n    |                                       ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:353:33\n    |\n353 |         self.0.is_match_at(text.as_bytes(), start)\n    |                                 ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:358:29\n    |\n358 |         self.0.find_at(text.as_bytes(), start)\n    |                             ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:368:44\n    |\n368 |         self.0.read_captures_at(locs, text.as_bytes(), start)\n    |                                            ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:390:18\n    |\n390 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:395:22\n    |\n395 |                 self.find_literals(ty, text, start).map(|(_, e)| e)\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `shortest_dfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:398:28\n    |\n398 |                 match self.shortest_dfa(text, start) {\n    |                            ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:401:47\n    |\n401 |                     dfa::Result::Quit => self.shortest_nfa(text, start),\n    |                                               ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:405:33\n    |\n405 |                 match dfa::Fsm::reverse(\n    |                                 ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:410:26\n     |\n410  |                     text.len(),\n     |                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:412:56\n     |\n412  |                     dfa::Result::Match(_) => Some(text.len()),\n     |                                                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `shortest_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:414:47\n    |\n414 |                     dfa::Result::Quit => self.shortest_nfa(text, start),\n    |                                               ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:418:28\n    |\n418 |                 match self.shortest_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:421:47\n    |\n421 |                     dfa::Result::Quit => self.shortest_nfa(text, start),\n    |                                               ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:424:40\n    |\n424 |             MatchType::Nfa(ty) => self.shortest_nfa_type(ty, text, start),\n    |                                        ^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:435:18\n    |\n435 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:443:22\n    |\n443 |                 self.find_literals(ty, text, start).is_some()\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `shortest_dfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:446:28\n    |\n446 |                 match self.shortest_dfa(text, start) {\n    |                            ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `match_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:449:47\n    |\n449 |                     dfa::Result::Quit => self.match_nfa(text, start),\n    |                                               ^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:453:33\n    |\n453 |                 match dfa::Fsm::reverse(\n    |                                 ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:458:26\n     |\n458  |                     text.len(),\n     |                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `match_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:462:47\n    |\n462 |                     dfa::Result::Quit => self.match_nfa(text, start),\n    |                                               ^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:466:28\n    |\n466 |                 match self.shortest_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `match_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:469:47\n    |\n469 |                     dfa::Result::Quit => self.match_nfa(text, start),\n    |                                               ^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `match_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:472:40\n    |\n472 |             MatchType::Nfa(ty) => self.match_nfa_type(ty, text, start),\n    |                                        ^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:481:18\n    |\n481 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:486:22\n    |\n486 |                 self.find_literals(ty, text, start)\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `find_dfa_forward` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:489:28\n    |\n489 |                 match self.find_dfa_forward(text, start) {\n    |                            ^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:493:30\n    |\n493 |                         self.find_nfa(MatchNfaType::Auto, text, start)\n    |                              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_dfa_anchored_reverse` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:498:28\n    |\n498 |                 match self.find_dfa_anchored_reverse(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:502:30\n    |\n502 |                         self.find_nfa(MatchNfaType::Auto, text, start)\n    |                              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:507:28\n    |\n507 |                 match self.find_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:511:30\n    |\n511 |                         self.find_nfa(MatchNfaType::Auto, text, start)\n    |                              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:515:40\n    |\n515 |             MatchType::Nfa(ty) => self.find_nfa(ty, text, start),\n    |                                        ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `iter_mut` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/exec.rs:538:27\n    |\n538 |         for slot in slots.iter_mut() {\n    |                           ^^^^^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [Option<usize>]`, but its trait bounds were not satisfied\n   --> src/exec.rs:543:21\n    |\n543 |         match slots.len() {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[Option<usize>]: ExactSizeIterator`\n            which is required by `&mut [Option<usize>]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:554:18\n    |\n554 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:559:22\n    |\n559 |                 self.find_literals(ty, text, start).and_then(|(s, e)| {\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:560:26\n    |\n560 |                     self.captures_nfa_with_match(slots, text, s, e)\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:565:26\n    |\n565 |                     self.captures_nfa(slots, text, start)\n    |                          ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find_dfa_forward` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:567:32\n    |\n567 |                     match self.find_dfa_forward(text, start) {\n    |                                ^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:569:34\n    |\n569 | ...                   self.captures_nfa_with_match(slots, text, s, e)\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:572:51\n    |\n572 |                         dfa::Result::Quit => self.captures_nfa(slots, text, start),\n    |                                                   ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find_dfa_anchored_reverse` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:577:28\n    |\n577 |                 match self.find_dfa_anchored_reverse(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:579:30\n    |\n579 |                         self.captures_nfa_with_match(slots, text, s, e)\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:582:47\n    |\n582 |                     dfa::Result::Quit => self.captures_nfa(slots, text, start),\n    |                                               ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:586:28\n    |\n586 |                 match self.find_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:588:30\n    |\n588 |                         self.captures_nfa_with_match(slots, text, s, e)\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:591:47\n    |\n591 |                     dfa::Result::Quit => self.captures_nfa(slots, text, start),\n    |                                               ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:595:22\n    |\n595 |                 self.captures_nfa_type(ty, slots, text, start)\n    |                      ^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find` found for reference `&LiteralSearcher` in the current scope\n   --> src/exec.rs:618:22\n    |\n618 |                 lits.find(&text[start..])\n    |                      ^^^^ method not found in `&LiteralSearcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `find_start` found for reference `&LiteralSearcher` in the current scope\n   --> src/exec.rs:625:26\n    |\n625 |                     lits.find_start(&text[start..])\n    |                          ^^^^^^^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: no method named `find_end` found for reference `&LiteralSearcher` in the current scope\n   --> src/exec.rs:633:22\n    |\n633 |                 lits.find_end(&text[start..])\n    |                      ^^^^^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: no function or associated item named `forward` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:650:35\n    |\n650 |         let end = match dfa::Fsm::forward(\n    |                                   ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `forward` not found for this struct\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:663:25\n    |\n663 |         match dfa::Fsm::reverse(\n    |                         ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:689:25\n    |\n689 |         match dfa::Fsm::reverse(\n    |                         ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:694:18\n     |\n694  |             text.len() - start,\n     |                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:696:48\n     |\n696  |             Match(s) => Match((start + s, text.len())),\n     |                                                ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `forward` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:705:19\n    |\n705 |         dfa::Fsm::forward(&self.ro.dfa, self.cache, true, text, start)\n    |                   ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `forward` not found for this struct\n\nerror[E0599]: no method named `exec_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:717:20\n    |\n717 |         match self.exec_dfa_reverse_suffix(text, start) {\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_dfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:718:26\n    |\n718 |             None => self.shortest_dfa(text, start),\n    |                          ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `lcs` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:744:36\n    |\n744 |         let lcs = self.ro.suffixes.lcs();\n    |                                    ^^^ private field, not a method\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `lcs` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:748:27\n     |\n748  |         while end <= text.len() {\n     |                           ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:751:50\n     |\n751  |                 None => return Some(NoMatch(text.len())),\n     |                                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:754:29\n    |\n754 |             match dfa::Fsm::reverse(\n    |                             ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:767:27\n     |\n767  |         Some(NoMatch(text.len()))\n     |                           ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `exec_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:783:38\n    |\n783 |         let match_start = match self.exec_dfa_reverse_suffix(text, start) {\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_dfa_forward` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:784:33\n    |\n784 |             None => return self.find_dfa_forward(text, start),\n    |                                 ^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `forward` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:795:25\n    |\n795 |         match dfa::Fsm::forward(\n    |                         ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `forward` not found for this struct\n\nerror[E0599]: no method named `match_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:818:14\n    |\n818 |         self.match_nfa_type(MatchNfaType::Auto, text, start)\n    |              ^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:828:14\n    |\n828 |         self.exec_nfa(ty, &mut [false], &mut [], true, text, start)\n    |              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:833:14\n    |\n833 |         self.shortest_nfa_type(MatchNfaType::Auto, text, start)\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:844:17\n    |\n844 |         if self.exec_nfa(ty, &mut [false], &mut slots, true, text, start) {\n    |                 ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:859:17\n    |\n859 |         if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {\n    |                 ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:885:63\n     |\n885  |             next_utf8(text, next_utf8(text, match_end)), text.len());\n     |                                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:886:14\n    |\n886 |         self.captures_nfa(slots, &text[..e], match_start)\n    |              ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:898:14\n    |\n898 |         self.captures_nfa_type(MatchNfaType::Auto, slots, text, start)\n    |              ^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:909:17\n    |\n909 |         if self.exec_nfa(ty, &mut [false], slots, false, text, start) {\n    |                 ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `len` found for struct `Program` in the current scope\n   --> src/exec.rs:930:51\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n    |                                                   ^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `len` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\nhelp: some of the expressions' fields have a method of the same name\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.byte_classes.len(), text.len()) {\n    |                                                   +++++++++++++\n930 |             if backtrack::should_exec(self.ro.nfa.capture_name_idx.len(), text.len()) {\n    |                                                   +++++++++++++++++\n930 |             if backtrack::should_exec(self.ro.nfa.captures.len(), text.len()) {\n    |                                                   +++++++++\n930 |             if backtrack::should_exec(self.ro.nfa.insts.len(), text.len()) {\n    |                                                   ++++++\n      and 1 other candidate\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:930:63\n     |\n930  |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n     |                                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `exec_backtrack` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:938:31\n    |\n938 |             Backtrack => self.exec_backtrack(matches, slots, text, start),\n    |                               ^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_pikevm` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:940:22\n    |\n940 |                 self.exec_pikevm(\n    |                 -----^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/exec.rs:955:24\n    |\n955 |         if self.ro.nfa.uses_bytes() {\n    |                        ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no function or associated item named `exec` found for struct `pikevm::Fsm` in the current scope\n   --> src/exec.rs:956:26\n    |\n956 |             pikevm::Fsm::exec(\n    |                          ^^^^ function or associated item not found in `Fsm<'_, _>`\n    |\n   ::: src/pikevm.rs:38:1\n    |\n38  | pub struct Fsm<'r, I> {\n    | --------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `ByteInput<'_>` in the current scope\n   --> src/exec.rs:962:28\n    |\n962 |                 ByteInput::new(text, self.ro.nfa.only_utf8),\n    |                            ^^^ function or associated item not found in `ByteInput<'_>`\n    |\n   ::: src/input.rs:227:1\n    |\n227 | pub struct ByteInput<'t> {\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `exec` found for struct `pikevm::Fsm` in the current scope\n   --> src/exec.rs:965:26\n    |\n965 |             pikevm::Fsm::exec(\n    |                          ^^^^ function or associated item not found in `Fsm<'_, _>`\n    |\n   ::: src/pikevm.rs:38:1\n    |\n38  | pub struct Fsm<'r, I> {\n    | --------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `CharInput<'_>` in the current scope\n   --> src/exec.rs:971:28\n    |\n971 |                 CharInput::new(text),\n    |                            ^^^ function or associated item not found in `CharInput<'_>`\n    |\n   ::: src/input.rs:140:1\n    |\n140 | pub struct CharInput<'t>(&'t [u8]);\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/exec.rs:984:24\n    |\n984 |         if self.ro.nfa.uses_bytes() {\n    |                        ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no function or associated item named `exec` found for struct `backtrack::Bounded` in the current scope\n   --> src/exec.rs:985:33\n    |\n985 |             backtrack::Bounded::exec(\n    |                                 ^^^^ function or associated item not found in `Bounded<'_, '_, '_, '_, _>`\n    |\n   ::: src/backtrack.rs:54:1\n    |\n54  | pub struct Bounded<'a, 'm, 'r, 's, I> {\n    | ------------------------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `ByteInput<'_>` in the current scope\n   --> src/exec.rs:990:28\n    |\n990 |                 ByteInput::new(text, self.ro.nfa.only_utf8),\n    |                            ^^^ function or associated item not found in `ByteInput<'_>`\n    |\n   ::: src/input.rs:227:1\n    |\n227 | pub struct ByteInput<'t> {\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `exec` found for struct `backtrack::Bounded` in the current scope\n   --> src/exec.rs:993:33\n    |\n993 |             backtrack::Bounded::exec(\n    |                                 ^^^^ function or associated item not found in `Bounded<'_, '_, '_, '_, _>`\n    |\n   ::: src/backtrack.rs:54:1\n    |\n54  | pub struct Bounded<'a, 'm, 'r, 's, I> {\n    | ------------------------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `CharInput<'_>` in the current scope\n   --> src/exec.rs:998:28\n    |\n998 |                 CharInput::new(text),\n    |                            ^^^ function or associated item not found in `CharInput<'_>`\n    |\n   ::: src/input.rs:140:1\n    |\n140 | pub struct CharInput<'t>(&'t [u8]);\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1017:18\n     |\n1017 |         if !self.is_anchor_end_match(text) {\n     |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n    --> src/exec.rs:1022:42\n     |\n1022 |                 debug_assert_eq!(matches.len(), 1);\n     |                                          ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[bool]: ExactSizeIterator`\n             which is required by `&mut [bool]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1023:35\n     |\n1023 |                 matches[0] = self.find_literals(ty, text, start).is_some();\n     |                                   ^^^^^^^^^^^^^\n     |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n    --> src/re_trait.rs:151:5\n     |\n151  | /     fn find_iter (\n152  | |         self,\n153  | |         text: &Self::Text,\n154  | |     ) -> Matches<Self> {\n     | |______________________^\n\nerror[E0599]: no function or associated item named `forward_many` found for struct `dfa::Fsm` in the current scope\n    --> src/exec.rs:1027:33\n     |\n1027 |                 match dfa::Fsm::forward_many(\n     |                                 ^^^^^^^^^^^^ function or associated item not found in `Fsm<'_>`\n     |\n    ::: src/dfa.rs:179:1\n     |\n179  | pub struct Fsm<'a> {\n     | ------------------ function or associated item `forward_many` not found for this struct\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1037:30\n     |\n1037 |                         self.exec_nfa(\n     |                         -----^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1047:29\n     |\n1047 |             Nfa(ty) => self.exec_nfa(ty, matches, &mut [], false, text, start),\n     |                             ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:1055:17\n     |\n1055 |         if text.len() > (1<<20) && self.ro.nfa.is_anchored_end {\n     |                 ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `lcs` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1056:40\n     |\n1056 |             let lcs = self.ro.suffixes.lcs();\n     |                                        ^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `lcs` not found for this struct\n\nerror[E0599]: no method named `capture_name_idx` found for struct `ExecNoSync` in the current scope\n    --> src/exec.rs:1071:16\n     |\n52   | pub struct ExecNoSync<'c> {\n     | ------------------------- method `capture_name_idx` not found for this struct\n...\n1071 |         self.0.capture_name_idx()\n     |                ^^^^^^^^^^^^^^^^ method not found in `ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `new` found for struct `ProgramCacheInner` in the current scope\n    --> src/exec.rs:1079:66\n     |\n1079 |         let create = || Box::new(RefCell::new(ProgramCacheInner::new(&self.ro)));\n     |                                                                  ^^^ function or associated item not found in `ProgramCacheInner`\n...\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `searcher` found for reference `&Exec` in the current scope\n    --> src/exec.rs:1089:28\n     |\n1089 |         ExecNoSyncStr(self.searcher())\n     |                            ^^^^^^^^ method not found in `&Exec`\n\nerror[E0599]: no method named `complete` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1161:34\n     |\n1161 |             if self.nfa.prefixes.complete() {\n     |                                  ^^^^^^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `complete` not found for this struct\n\nerror[E0599]: no method named `complete` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1168:30\n     |\n1168 |             if self.suffixes.complete() {\n     |                              ^^^^^^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `complete` not found for this struct\n\nerror[E0599]: no method named `should_suffix_scan` found for reference `&ExecReadOnly` in the current scope\n    --> src/exec.rs:1192:21\n     |\n1192 |             if self.should_suffix_scan() {\n     |                     ^^^^^^^^^^^^^^^^^^ method not found in `&ExecReadOnly`\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1217:26\n     |\n1217 |         if self.suffixes.is_empty() {\n     |                          ^^^^^^^^ method not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `is_empty` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n             candidate #1: `input::Input`\n             candidate #2: `Automaton`\n             candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `lcs` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1220:37\n     |\n1220 |         let lcs_len = self.suffixes.lcs().char_len();\n     |                                     ^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `lcs` not found for this struct\n\nerror[E0599]: no method named `lcp` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1221:53\n     |\n1221 |         lcs_len >= 3 && lcs_len > self.dfa.prefixes.lcp().char_len()\n     |                                                     ^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `lcp` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1285:36\n     |\n1285 |             pikevm: pikevm::Cache::new(&ro.nfa),\n     |                                    ^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1286:42\n     |\n1286 |             backtrack: backtrack::Cache::new(&ro.nfa),\n     |                                          ^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1287:30\n     |\n1287 |             dfa: dfa::Cache::new(&ro.dfa),\n     |                              ^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1288:38\n     |\n1288 |             dfa_reverse: dfa::Cache::new(&ro.dfa_reverse),\n     |                                      ^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_empty` found for reference `&str` in the current scope\n  --> src/expand.rs:13:24\n   |\n13 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n  --> src/expand.rs:14:40\n   |\n14 |         match memchr(b'$', replacement.as_bytes()) {\n   |                                        ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n  --> src/expand.rs:21:24\n   |\n21 |         if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty` found for reference `&str` in the current scope\n  --> src/expand.rs:26:36\n   |\n26 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_unicode::Captures<'_>` in the current scope\n  --> src/expand.rs:39:26\n   |\n39 |                     caps.get(i).map(|m| m.as_str()).unwrap_or(\"\"));\n   |                          ^^^ method not found in `&Captures<'_>`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `get`, perhaps you need to implement it:\n           candidate #1: `SliceIndex`\n\nerror[E0599]: no method named `name` found for reference `&re_unicode::Captures<'_>` in the current scope\n  --> src/expand.rs:43:26\n   |\n43 |                     caps.name(name).map(|m| m.as_str()).unwrap_or(\"\"));\n   |                          ^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n  --> src/expand.rs:55:24\n   |\n55 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ method not found in `&[u8]`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n  --> src/expand.rs:63:24\n   |\n63 |         if replacement.get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n63 |         if replacement.ge(1).map_or(false, |&b| b == b'$') {\n   |                        ~~\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n  --> src/expand.rs:68:36\n   |\n68 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ method not found in `&[u8]`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_bytes::Captures<'_>` in the current scope\n  --> src/expand.rs:81:26\n   |\n81 |                     caps.get(i).map(|m| m.as_bytes()).unwrap_or(b\"\"));\n   |                          ^^^ method not found in `&Captures<'_>`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `get`, perhaps you need to implement it:\n           candidate #1: `SliceIndex`\n\nerror[E0599]: no method named `name` found for reference `&re_bytes::Captures<'_>` in the current scope\n  --> src/expand.rs:85:26\n   |\n85 |                     caps.name(name).map(|m| m.as_bytes()).unwrap_or(b\"\"));\n   |                          ^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/expand.rs:133:12\n     |\n133  |     if rep.len() <= 1 || rep[0] != b'$' {\n     |            ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/expand.rs:143:15\n    |\n143 |     while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n143 |     while rep.ge(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ~~\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/expand.rs:155:17\n    |\n155 |         if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n155 |         if !rep.ge(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ~~\n\nerror[E0599]: no method named `parse` found for reference `&str` in the current scope\n   --> src/expand.rs:161:24\n    |\n161 |         cap: match cap.parse::<u32>() {\n    |                        ^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:40:16\n    |\n40  |         self.c.is_none() && self.byte.is_none()\n    |                ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `len_utf8` found for struct `input::Char` in the current scope\n   --> src/input.rs:164:20\n    |\n164 |             len: c.len_utf8(),\n    |                    ^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `len_utf8` not found for this struct\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:169:12\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n...\n169 |         at.char()\n    |            ^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:173:37\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n173 |         decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    |                                     ^^^-- help: remove the arguments\n    |                                     |\n    |                                     field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:181:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n181 |                 at.pos() == 0 || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:185:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n185 |                 at.pos() == self.len() || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:187:29\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n187 |             StartText => at.pos() == 0,\n    |                             ^^^-- help: remove the arguments\n    |                             |\n    |                             field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:188:27\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n188 |             EndText => at.pos() == self.len(),\n    |                           ^^^-- help: remove the arguments\n    |                           |\n    |                           field, not a method\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:191:20\n    |\n191 |                 c1.is_word_char() != c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:191:41\n    |\n191 |                 c1.is_word_char() != c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:195:20\n    |\n195 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:195:41\n    |\n195 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:199:20\n    |\n199 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:199:41\n    |\n199 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:203:20\n    |\n203 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:203:41\n    |\n203 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `find` found for reference `&LiteralSearcher` in the current scope\n   --> src/input.rs:213:18\n    |\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                  ^^^^ method not found in `&LiteralSearcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:213:32\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                ^^^-- help: remove the arguments\n    |                                |\n    |                                field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:213:66\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                                  ^^^-- help: remove the arguments\n    |                                                                  |\n    |                                                                  field, not a method\n\nerror[E0599]: the method `len` exists for reference `&'t [u8]`, but its trait bounds were not satisfied\n   --> src/input.rs:217:16\n    |\n217 |         self.0.len()\n    |                ^^^\n    |\nnote: the following trait bounds were not satisfied:\n      `[u8]: Sized`\n      `[u8]: input::Input`\n   --> src/input.rs:114:10\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |          ^  ^^^^^  -----     -----\n    |          |  |\n    |          |  unsatisfied trait bound introduced here\n    |          unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is in scope\nhelp: consider relaxing the type parameter's implicit `Sized` bound\n    |\n114 | impl<'a, T: ?Sized + Input> Input for &'a T {\n    |             ++++++++\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `get` found for reference `&ByteInput<'t>` in the current scope\n   --> src/input.rs:255:24\n    |\n255 |             byte: self.get(i).cloned(),\n    |                        ^^^\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: there is a method `ge` with a similar name\n    |\n255 |             byte: self.ge(i).cloned(),\n    |                        ~~\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:261:30\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n261 |         decode_utf8(&self[at.pos()..]).map(|(c, _)| c).into()\n    |                              ^^^-- help: remove the arguments\n    |                              |\n    |                              field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:265:37\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n265 |         decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    |                                     ^^^-- help: remove the arguments\n    |                                     |\n    |                                     field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:273:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n273 |                 at.pos() == 0 || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:277:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n277 |                 at.pos() == self.len() || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:279:29\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n279 |             StartText => at.pos() == 0,\n    |                             ^^^-- help: remove the arguments\n    |                             |\n    |                             field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:280:27\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n280 |             EndText => at.pos() == self.len(),\n    |                           ^^^-- help: remove the arguments\n    |                           |\n    |                           field, not a method\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:283:20\n    |\n283 |                 c1.is_word_char() != c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:283:41\n    |\n283 |                 c1.is_word_char() != c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:287:20\n    |\n287 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:287:41\n    |\n287 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:294:27\n    |\n294 |                     if c1.is_none() && !at.is_start() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:294:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n...\n294 |                     if c1.is_none() && !at.is_start() {\n    |                                            ^^^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:297:27\n    |\n297 |                     if c2.is_none() && !at.is_end() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:297:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n...\n297 |                     if c2.is_none() && !at.is_end() {\n    |                                            ^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:301:20\n    |\n301 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:301:41\n    |\n301 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:308:27\n    |\n308 |                     if c1.is_none() && !at.is_start() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:308:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n...\n308 |                     if c1.is_none() && !at.is_start() {\n    |                                            ^^^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:311:27\n    |\n311 |                     if c2.is_none() && !at.is_end() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:311:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n...\n311 |                     if c2.is_none() && !at.is_end() {\n    |                                            ^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:315:20\n    |\n315 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:315:41\n    |\n315 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `find` found for reference `&LiteralSearcher` in the current scope\n   --> src/input.rs:325:18\n    |\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                  ^^^^ method not found in `&LiteralSearcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:325:32\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                ^^^-- help: remove the arguments\n    |                                |\n    |                                field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:325:66\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                                  ^^^-- help: remove the arguments\n    |                                                                  |\n    |                                                                  field, not a method\n\nerror[E0599]: the method `len` exists for reference `&'t [u8]`, but its trait bounds were not satisfied\n   --> src/input.rs:329:19\n    |\n329 |         self.text.len()\n    |                   ^^^\n    |\nnote: the following trait bounds were not satisfied:\n      `[u8]: Sized`\n      `[u8]: input::Input`\n   --> src/input.rs:114:10\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |          ^  ^^^^^  -----     -----\n    |          |  |\n    |          |  unsatisfied trait bound introduced here\n    |          unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is in scope\nhelp: consider relaxing the type parameter's implicit `Sized` bound\n    |\n114 | impl<'a, T: ?Sized + Input> Input for &'a T {\n    |             ++++++++\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `len_utf8` found for type `char` in the current scope\n   --> src/input.rs:367:48\n    |\n367 |         char::from_u32(self.0).map_or(0, |c| c.len_utf8())\n    |                                                ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:477:15\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n477 |         if at.pos() > 0 {\n    |               ^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:478:31\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n478 |             Some(self.data[at.pos() - 1])\n    |                               ^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:485:15\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n485 |         if at.pos() < self.len() {\n    |               ^^^ method not found in `InputAt`\n\nerror[E0599]: the method `len` exists for reference `&Tester`, but its trait bounds were not satisfied\n   --> src/input.rs:485:28\n    |\n462 | struct Tester {\n    | ------------- doesn't satisfy `Tester: input::Input`\n...\n485 |         if at.pos() < self.len() {\n    |                            ^^^ method cannot be called on `&Tester` due to unsatisfied trait bounds\n    |\nnote: trait bound `Tester: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:486:31\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n486 |             Some(self.data[at.pos()])\n    |                               ^^^ method not found in `InputAt`\n\nerror[E0599]: the method `previous_char` exists for reference `&Tester`, but its trait bounds were not satisfied\n   --> src/input.rs:495:38\n    |\n462 | struct Tester {\n    | ------------- doesn't satisfy `Tester: input::Input`\n...\n495 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ method cannot be called on `&Tester` due to unsatisfied trait bounds\n    |\nnote: trait bound `Tester: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `previous_char`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `next_char` exists for reference `&Tester`, but its trait bounds were not satisfied\n   --> src/input.rs:495:62\n    |\n462 | struct Tester {\n    | ------------- doesn't satisfy `Tester: input::Input`\n...\n495 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ method cannot be called on `&Tester` due to unsatisfied trait bounds\n    |\nnote: trait bound `Tester: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `next_char`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_ascii_alphanumeric` found for type `u8` in the current scope\n   --> src/input.rs:505:14\n    |\n505 |         self.is_ascii_alphanumeric() || self == b'_'\n    |              ^^^^^^^^^^^^^^^^^^^^^ method not found in `u8`\n\nerror[E0599]: no function or associated item named `new` found for struct `Tester` in the current scope\n   --> src/input.rs:512:26\n    |\n462 | struct Tester {\n    | ------------- function or associated item `new` not found for this struct\n...\n512 |     let tester = Tester::new(false, b\"hello_world\".to_vec());\n    |                          ^^^ function or associated item not found in `Tester`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `to_vec` found for reference `&'static [u8; 11]` in the current scope\n   --> src/input.rs:512:52\n    |\n512 |     let tester = Tester::new(false, b\"hello_world\".to_vec());\n    |                                                    ^^^^^^ method not found in `&[u8; 11]`\n\nerror[E0599]: no function or associated item named `new` found for struct `LiteralSearcher` in the current scope\n  --> src/literal/mod.rs:61:15\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `new` not found for this struct\n...\n61 |         Self::new(Literals::empty(), Matcher::Empty)\n   |               ^^^ function or associated item not found in `LiteralSearcher`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no variant or associated item named `prefixes` found for enum `Matcher` in the current scope\n  --> src/literal/mod.rs:66:32\n   |\n39 | enum Matcher {\n   | ------------ variant or associated item `prefixes` not found for this enum\n...\n66 |         let matcher = Matcher::prefixes(&lits);\n   |                                ^^^^^^^^ variant or associated item not found in `Matcher`\n\nerror[E0599]: no function or associated item named `new` found for struct `LiteralSearcher` in the current scope\n  --> src/literal/mod.rs:67:15\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `new` not found for this struct\n...\n67 |         Self::new(lits, matcher)\n   |               ^^^ function or associated item not found in `LiteralSearcher`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no variant or associated item named `suffixes` found for enum `Matcher` in the current scope\n  --> src/literal/mod.rs:72:32\n   |\n39 | enum Matcher {\n   | ------------ variant or associated item `suffixes` not found for this enum\n...\n72 |         let matcher = Matcher::suffixes(&lits);\n   |                                ^^^^^^^^ variant or associated item not found in `Matcher`\n\nerror[E0599]: no function or associated item named `new` found for struct `LiteralSearcher` in the current scope\n  --> src/literal/mod.rs:73:15\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `new` not found for this struct\n...\n73 |         Self::new(lits, matcher)\n   |               ^^^ function or associated item not found in `LiteralSearcher`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:80:31\n    |\n80  |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n    |                               ^^^ function or associated item not found in `FreqyPacked`\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n  --> src/literal/mod.rs:80:64\n   |\n80 |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n   |                                                                ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `new` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:81:31\n    |\n81  |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n    |                               ^^^ function or associated item not found in `FreqyPacked`\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n  --> src/literal/mod.rs:81:64\n   |\n81 |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n   |                                                                ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `is_empty` exists for reference `&LiteralSearcher`, but its trait bounds were not satisfied\n  --> src/literal/mod.rs:93:32\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- doesn't satisfy `LiteralSearcher: Automaton<_>`\n...\n93 |         self.complete && !self.is_empty()\n   |                                ^^^^^^^^ method cannot be called on `&LiteralSearcher` due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n           `LiteralSearcher: Automaton<_>`\n           which is required by `&LiteralSearcher: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n  --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n   |\n11 | pub trait Automaton<P> {\n   | ^^^^^^^^^^^^^^^^^^^^^^\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n           candidate #1: `input::Input`\n           candidate #2: `Automaton`\n           candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `find` exists for reference `&SingleByteSet`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:102:37\n    |\n102 |             Bytes(ref sset) => sset.find(haystack).map(|i| (i, i + 1)),\n    |                                     ^^^^ method cannot be called on `&SingleByteSet` due to unsatisfied trait bounds\n...\n330 | struct SingleByteSet {\n    | -------------------- doesn't satisfy `SingleByteSet: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `SingleByteSet: Automaton<_>`\n            which is required by `&SingleByteSet: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `find` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:103:37\n    |\n103 |             FreqyPacked(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                     ^^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `len` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:103:70\n    |\n103 |             FreqyPacked(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                                                      ^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `find` exists for reference `&BoyerMooreSearch`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:104:36\n    |\n104 |             BoyerMoore(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                    ^^^^ method cannot be called on `&BoyerMooreSearch` due to unsatisfied trait bounds\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- doesn't satisfy `BoyerMooreSearch: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `BoyerMooreSearch: Automaton<_>`\n            which is required by `&BoyerMooreSearch: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `len` exists for reference `&BoyerMooreSearch`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:104:69\n    |\n104 |             BoyerMoore(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                                                     ^^^ method cannot be called on `&BoyerMooreSearch` due to unsatisfied trait bounds\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- doesn't satisfy `BoyerMooreSearch: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `BoyerMooreSearch: Automaton<_>`\n            which is required by `&BoyerMooreSearch: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `find` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:106:36\n    |\n106 |             TeddySSSE3(ref t) => t.find(haystack).map(|m| (m.start, m.end)),\n    |                                    ^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_ssse3::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_ssse3::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_ssse3::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `find` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:107:35\n    |\n107 |             TeddyAVX2(ref t) => t.find(haystack).map(|m| (m.start, m.end)),\n    |                                   ^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_avx2::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_avx2::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_avx2::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `iter` found for reference `&LiteralSearcher` in the current scope\n   --> src/literal/mod.rs:113:25\n    |\n113 |         for lit in self.iter() {\n    |                         ^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:114:37\n    |\n114 |             if lit.len() > haystack.len() {\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&LiteralSearcher` in the current scope\n   --> src/literal/mod.rs:126:25\n    |\n126 |         for lit in self.iter() {\n    |                         ^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:127:37\n    |\n127 |             if lit.len() > haystack.len() {\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:130:42\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                          ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:131:39\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                       ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:131:67\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `patterns` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:146:45\n    |\n146 |                 LiteralIter::TeddySSSE3(ted.patterns())\n    |                                             ^^^^^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_ssse3::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_ssse3::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_ssse3::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `patterns`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: the method `patterns` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:149:44\n    |\n149 |                 LiteralIter::TeddyAVX2(ted.patterns())\n    |                                            ^^^^^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_avx2::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_avx2::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_avx2::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `patterns`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: the method `len` exists for reference `&LiteralSearcher`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:166:14\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- doesn't satisfy `LiteralSearcher: Automaton<_>`\n...\n166 |         self.len() == 0\n    |              ^^^ method cannot be called on `&LiteralSearcher` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `LiteralSearcher: Automaton<_>`\n            which is required by `&LiteralSearcher: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:178:40\n    |\n178 |             TeddySSSE3(ref ted) => ted.len(),\n    |                                        ^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_ssse3::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_ssse3::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_ssse3::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:179:39\n    |\n179 |             TeddyAVX2(ref ted) => ted.len(),\n    |                                       ^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_avx2::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_avx2::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_avx2::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `approximate_size` found for reference `&SingleByteSet` in the current scope\n   --> src/literal/mod.rs:188:37\n    |\n188 |             Bytes(ref sset) => sset.approximate_size(),\n    |                                     ^^^^^^^^^^^^^^^^ method not found in `&SingleByteSet`\n\nerror[E0599]: no method named `approximate_size` found for reference `&literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:189:47\n    |\n189 |             FreqyPacked(ref single) => single.approximate_size(),\n    |                                               ^^^^^^^^^^^^^^^^ method not found in `&FreqyPacked`\n\nerror[E0599]: no method named `approximate_size` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:190:46\n    |\n190 |             BoyerMoore(ref single) => single.approximate_size(),\n    |                                              ^^^^^^^^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: no method named `approximate_size` found for reference `&teddy_ssse3::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:192:40\n    |\n192 |             TeddySSSE3(ref ted) => ted.approximate_size(),\n    |                                        ^^^^^^^^^^^^^^^^ method not found in `&Teddy`\n\nerror[E0599]: no method named `approximate_size` found for reference `&teddy_avx2::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:193:39\n    |\n193 |             TeddyAVX2(ref ted) => ted.approximate_size(),\n    |                                       ^^^^^^^^^^^^^^^^ method not found in `&Teddy`\n\nerror[E0599]: no function or associated item named `prefixes` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:200:35\n    |\n200 |         let sset = SingleByteSet::prefixes(lits);\n    |                                   ^^^^^^^^ function or associated item not found in `SingleByteSet`\n...\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `prefixes` not found for this struct\n\nerror[E0599]: no variant or associated item named `new` found for enum `Matcher` in the current scope\n   --> src/literal/mod.rs:201:18\n    |\n39  | enum Matcher {\n    | ------------ variant or associated item `new` not found for this enum\n...\n201 |         Matcher::new(lits, sset)\n    |                  ^^^ variant or associated item not found in `Matcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `suffixes` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:205:35\n    |\n205 |         let sset = SingleByteSet::suffixes(lits);\n    |                                   ^^^^^^^^ function or associated item not found in `SingleByteSet`\n...\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `suffixes` not found for this struct\n\nerror[E0599]: no variant or associated item named `new` found for enum `Matcher` in the current scope\n   --> src/literal/mod.rs:206:18\n    |\n39  | enum Matcher {\n    | ------------ variant or associated item `new` not found for this enum\n...\n206 |         Matcher::new(lits, sset)\n    |                  ^^^ variant or associated item not found in `Matcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: the method `is_empty` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:210:28\n    |\n210 |         if lits.literals().is_empty() {\n    |                            ^^^^^^^^ method cannot be called on `&[Literal]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:225:28\n    |\n225 |         if lits.literals().len() == 1 {\n    |                            ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `to_vec` found for struct `syntax::hir::literal::Literal` in the current scope\n   --> src/literal/mod.rs:226:42\n    |\n226 |             let lit = lits.literals()[0].to_vec();\n    |                                          ^^^^^^ method not found in `Literal`\n\nerror[E0599]: no function or associated item named `should_use` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:227:34\n    |\n227 |             if BoyerMooreSearch::should_use(lit.as_slice()) {\n    |                                  ^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `should_use` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:228:62\n    |\n228 |                 return Matcher::BoyerMoore(BoyerMooreSearch::new(lit));\n    |                                                              ^^^ function or associated item not found in `BoyerMooreSearch`\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:230:58\n    |\n230 |                 return Matcher::FreqyPacked(FreqyPacked::new(lit));\n    |                                                          ^^^ function or associated item not found in `FreqyPacked`\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `available` found for struct `teddy_avx2::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:234:23\n    |\n234 |         if TeddyAVX2::available() && !is_aho_corasick_fast {\n    |                       ^^^^^^^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `available` not found for this struct\n\nerror[E0599]: the method `len` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:236:32\n    |\n236 |             if lits.literals().len() <= MAX_TEDDY_LITERALS {\n    |                                ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `teddy_avx2::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:237:47\n    |\n237 |                 if let Some(ted) = TeddyAVX2::new(lits) {\n    |                                               ^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `available` found for struct `teddy_ssse3::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:242:24\n    |\n242 |         if TeddySSSE3::available() && !is_aho_corasick_fast {\n    |                        ^^^^^^^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `available` not found for this struct\n\nerror[E0599]: the method `len` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:253:32\n    |\n253 |             if lits.literals().len() <= MAX_TEDDY_LITERALS {\n    |                                ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `teddy_ssse3::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:254:48\n    |\n254 |                 if let Some(ted) = TeddySSSE3::new(lits) {\n    |                                                ^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:281:25\n    |\n281 |                 if many.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[u8]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[u8]: ExactSizeIterator`\n            which is required by `&mut &[u8]: ExactSizeIterator`\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:290:24\n    |\n290 |                 if one.is_empty() {\n    |                        ^^^^^^^^ method cannot be called on `&mut &[u8]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[u8]: ExactSizeIterator`\n            which is required by `&mut &[u8]: ExactSizeIterator`\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:299:25\n    |\n299 |                 if lits.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[Literal]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[syntax::hir::literal::Literal]: ExactSizeIterator`\n            which is required by `&mut &[syntax::hir::literal::Literal]: ExactSizeIterator`\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[Vec<u8>]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:308:25\n    |\n308 |                 if lits.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[Vec<u8>]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[Vec<u8>]: ExactSizeIterator`\n            which is required by `&mut &[Vec<u8>]: ExactSizeIterator`\n            `[Vec<u8>]: Automaton<_>`\n            which is required by `&[Vec<u8>]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[Vec<u8>]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:317:25\n    |\n317 |                 if lits.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[Vec<u8>]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[Vec<u8>]: ExactSizeIterator`\n            which is required by `&mut &[Vec<u8>]: ExactSizeIterator`\n            `[Vec<u8>]: Automaton<_>`\n            which is required by `&[Vec<u8>]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:348:39\n    |\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `new` not found for this struct\n...\n348 |         let mut sset = SingleByteSet::new();\n    |                                       ^^^ function or associated item not found in `SingleByteSet`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `get` found for reference `&syntax::hir::literal::Literal` in the current scope\n   --> src/literal/mod.rs:351:35\n    |\n351 |             if let Some(&b) = lit.get(0) {\n    |                                   ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n351 |             if let Some(&b) = lit.ge(0) {\n    |                                   ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:365:39\n    |\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `new` not found for this struct\n...\n365 |         let mut sset = SingleByteSet::new();\n    |                                       ^^^ function or associated item not found in `SingleByteSet`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `get` found for reference `&syntax::hir::literal::Literal` in the current scope\n   --> src/literal/mod.rs:368:35\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                   ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n368 |             if let Some(&b) = lit.ge(lit.len().checked_sub(1).unwrap()) {\n    |                                   ~~\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/literal/mod.rs:368:49\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                                 ^^^^^^^^^^^ method not found in `usize`\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: no method named `_find` found for reference `&SingleByteSet` in the current scope\n   --> src/literal/mod.rs:389:23\n    |\n389 |             _ => self._find(text),\n    |                       ^^^^^ method not found in `&SingleByteSet`\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:395:33\n    |\n395 |         for (i, &b) in haystack.iter().enumerate() {\n    |                                 ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `empty` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:449:33\n    |\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `empty` not found for this struct\n...\n449 |             return FreqyPacked::empty();\n    |                                 ^^^^^ function or associated item not found in `FreqyPacked`\n\nerror[E0599]: no method named `iter` found for slice `[u8]` in the current scope\n   --> src/literal/mod.rs:456:27\n    |\n456 |         for b in pat[1..].iter().cloned() {\n    |                           ^^^^ method not found in `[u8]`\n\nerror[E0599]: no method named `iter` found for struct `Vec<u8>` in the current scope\n   --> src/literal/mod.rs:470:26\n    |\n470 |         let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    |                          ^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named `iter` found for struct `Vec<u8>` in the current scope\n   --> src/literal/mod.rs:471:26\n    |\n471 |         let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n    |                          ^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:498:21\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:498:33\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `is_empty` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:498:46\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                              ^^^^^^^^ method cannot be called on `&[u8]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:502:28\n    |\n502 |         while i < haystack.len() {\n    |                            ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:508:35\n    |\n508 |             let end = start + pat.len();\n    |                                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:509:31\n    |\n509 |             if end > haystack.len() {\n    |                               ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:523:17\n    |\n523 |         if text.len() < self.len() {\n    |                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:523:30\n    |\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n...\n523 |         if text.len() < self.len() {\n    |                              ^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:526:19\n    |\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:526:32\n    |\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n...\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                                ^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `chars` found for enum `Cow<'_, str>` in the current scope\n   --> src/literal/mod.rs:543:36\n    |\n543 |     String::from_utf8_lossy(bytes).chars().count()\n    |                                    ^^^^^ method not found in `Cow<'_, str>`\n\nerror[E0599]: no function or associated item named `select_guard` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:615:29\n    |\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `select_guard` not found for this struct\n...\n615 |         let (g, gi) = Self::select_guard(pattern.as_slice());\n    |                             ^^^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n\nerror[E0599]: no function or associated item named `compile_skip_table` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:616:32\n    |\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `compile_skip_table` not found for this struct\n...\n616 |         let skip_table = Self::compile_skip_table(pattern.as_slice());\n    |                                ^^^^^^^^^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n\nerror[E0599]: no function or associated item named `compile_md2_shift` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:617:31\n    |\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `compile_md2_shift` not found for this struct\n...\n617 |         let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n    |                               ^^^^^^^^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:632:21\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:646:21\n    |\n646 |         if haystack.len() > short_circut {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:648:37\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `skip_loop` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:650:41\n    |\n650 |                 window_end = match self.skip_loop(haystack, window_end, backstop) {\n    |                                         ^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: no method named `check_match` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:658:25\n    |\n658 |                 if self.check_match(haystack, window_end) {\n    |                         ^^^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:670:37\n    |\n670 |         while window_end < haystack.len() {\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `check_match` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:673:25\n    |\n673 |                 if self.check_match(haystack, window_end) {\n    |                         ^^^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:732:35\n    |\n732 |         let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n    |                                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:739:17\n    |\n739 |         pattern.len() > MIN_LEN\n    |                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:741:24\n    |\n741 |             && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    |                        ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/literal/mod.rs:815:34\n    |\n814 |   ...                   window_end = window_end\n    |  ____________________________________-\n815 | | ...                       .checked_sub(1 + self.guard_reverse_idx)\n    | |                           -^^^^^^^^^^^ method not found in `usize`\n    | |___________________________|\n    |\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:835:36\n    |\n835 |         let mut tab = vec![pattern.len(); 256];\n    |                                    ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:842:31\n    |\n842 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:843:41\n    |\n843 |             tab[*c as usize] = (pattern.len() - 1) - i;\n    |                                         ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:853:42\n    |\n853 |         let mut rarest_rev_idx = pattern.len() - 1;\n    |                                          ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:854:31\n    |\n854 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:857:43\n    |\n857 |                 rarest_rev_idx = (pattern.len() - 1) - i;\n    |                                           ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `last` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:868:31\n    |\n868 |         let shiftc = *pattern.last().unwrap();\n    |                               ^^^^ `&[u8]` is not an iterator\n    |\nhelp: call `.into_iter()` first\n    |\n868 |         let shiftc = *pattern.into_iter().last().unwrap();\n    |                               ++++++++++++\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:873:20\n    |\n873 |         if pattern.len() == 1 {\n    |                    ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:877:29\n    |\n877 |         let mut i = pattern.len() - 2;\n    |                             ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:880:33\n    |\n880 |                 return (pattern.len() - 1) - i;\n    |                                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:887:17\n    |\n887 |         pattern.len() - 1\n    |                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1007:24\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1007:42\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1009:31\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1009:47\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1011:43\n     |\n1011 |                 && &haystack[i..(i+needle.len())] == needle {\n     |                                           ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `new` found for struct `Threads` in the current scope\n  --> src/pikevm.rs:90:29\n   |\n62 | struct Threads {\n   | -------------- function or associated item `new` not found for this struct\n...\n90 |             clist: Threads::new(),\n   |                             ^^^ function or associated item not found in `Threads`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Threads` in the current scope\n  --> src/pikevm.rs:91:29\n   |\n62 | struct Threads {\n   | -------------- function or associated item `new` not found for this struct\n...\n91 |             nlist: Threads::new(),\n   |                             ^^^ function or associated item not found in `Threads`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `resize` found for struct `Threads` in the current scope\n   --> src/pikevm.rs:113:21\n    |\n62  | struct Threads {\n    | -------------- method `resize` not found for this struct\n...\n113 |         cache.clist.resize(prog.len(), prog.captures.len());\n    |                     ^^^^^^ method not found in `Threads`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n113 |         cache.clist.caps.resize(prog.len(), prog.captures.len());\n    |                     +++++\n\nerror[E0599]: the method `len` exists for reference `&Program`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:113:33\n    |\n113 |         cache.clist.resize(prog.len(), prog.captures.len());\n    |                                 ^^^ method cannot be called on `&Program` due to unsatisfied trait bounds\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ doesn't satisfy `Program: input::Input`\n    |\nnote: trait bound `Program: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `resize` found for struct `Threads` in the current scope\n   --> src/pikevm.rs:114:21\n    |\n62  | struct Threads {\n    | -------------- method `resize` not found for this struct\n...\n114 |         cache.nlist.resize(prog.len(), prog.captures.len());\n    |                     ^^^^^^ method not found in `Threads`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n114 |         cache.nlist.caps.resize(prog.len(), prog.captures.len());\n    |                     +++++\n\nerror[E0599]: the method `len` exists for reference `&Program`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:114:33\n    |\n114 |         cache.nlist.resize(prog.len(), prog.captures.len());\n    |                                 ^^^ method cannot be called on `&Program` due to unsatisfied trait bounds\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ doesn't satisfy `Program: input::Input`\n    |\nnote: trait bound `Program: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `exec_` found for struct `pikevm::Fsm` in the current scope\n   --> src/pikevm.rs:120:11\n    |\n38  |   pub struct Fsm<'r, I> {\n    |   --------------------- method `exec_` not found for this struct\n...\n116 | /         Fsm {\n117 | |             prog: prog,\n118 | |             stack: &mut cache.stack,\n119 | |             input: input,\n120 | |         }.exec_(\n    | |          -^^^^^ method not found in `Fsm<'_, I>`\n    | |__________|\n    |\n\nerror[E0599]: no method named `clear` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:141:19\n    |\n141 |         clist.set.clear();\n    |                   ^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `clear` not found for this struct\n\nerror[E0599]: no method named `clear` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:142:19\n    |\n142 |         nlist.set.clear();\n    |                   ^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `clear` not found for this struct\n\nerror[E0599]: no method named `is_empty` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:144:26\n    |\n144 |             if clist.set.is_empty() {\n    |                          ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:155:40\n    |\n155 |                 if (matched && matches.len() <= 1)\n    |                                        ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:157:29\n    |\n157 |                     || (!at.is_start() && self.prog.is_anchored_start) {\n    |                             ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n   --> src/pikevm.rs:164:40\n    |\n164 |                 if !self.prog.prefixes.is_empty() {\n    |                                        ^^^^^^^^ method not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `is_empty` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:175:26\n    |\n175 |             if clist.set.is_empty()\n    |                          ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:177:22\n    |\n177 |                 self.add(&mut clist, slots, 0, at);\n    |                      ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:183:44\n    |\n183 |             let at_next = self.input.at(at.next_pos());\n    |                                            ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `len` found for struct `SparseSet` in the current scope\n    --> src/pikevm.rs:184:35\n     |\n184  |             for i in 0..clist.set.len() {\n     |                                   ^^^\n     |\n    ::: src/sparse.rs:15:1\n     |\n15   | pub struct SparseSet {\n     | -------------------- method `len` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `len`, perhaps you need to implement one of them:\n             candidate #1: `input::Input`\n             candidate #2: `Automaton`\n             candidate #3: `ExactSizeIterator`\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `step` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:186:25\n    |\n186 |                 if self.step(\n    |                    -----^^^^ method not found in `&mut Fsm<'r, I>`\n\nerror[E0599]: no method named `caps` found for mutable reference `&mut Threads` in the current scope\n   --> src/pikevm.rs:190:27\n    |\n190 |                     clist.caps(ip),\n    |                           ^^^^---- help: remove the arguments\n    |                           |\n    |                           field, not a method\n\nerror[E0599]: no method named `iter` found for mutable reference `&mut [bool]` in the current scope\n   --> src/pikevm.rs:196:58\n    |\n196 |                     all_matched = all_matched || matches.iter().all(|&b| b);\n    |                                                          ^^^^ method not found in `&mut [bool]`\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:215:19\n    |\n215 |             if at.is_end() {\n    |                   ^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n\nerror[E0599]: no method named `clear` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:220:23\n    |\n220 |             nlist.set.clear();\n    |                       ^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `clear` not found for this struct\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:250:41\n    |\n250 |                 if match_slot < matches.len() {\n    |                                         ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter_mut` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/pikevm.rs:253:42\n    |\n253 |                 for (slot, val) in slots.iter_mut().zip(thread_caps.iter()) {\n    |                                          ^^^^^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: no method named `iter` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/pikevm.rs:253:69\n    |\n253 |                 for (slot, val) in slots.iter_mut().zip(thread_caps.iter()) {\n    |                                                                     ^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:259:33\n    |\n259 |                 if inst.c == at.char() {\n    |                                 ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:260:26\n    |\n260 |                     self.add(nlist, thread_caps, inst.goto, at_next);\n    |                          ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `matches` found for reference `&InstRanges` in the current scope\n   --> src/pikevm.rs:265:25\n    |\n265 |                 if inst.matches(at.char()) {\n    |                         ^^^^^^^ method not found in `&InstRanges`\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:265:36\n    |\n265 |                 if inst.matches(at.char()) {\n    |                                    ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:266:26\n    |\n266 |                     self.add(nlist, thread_caps, inst.goto, at_next);\n    |                          ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `byte` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:271:37\n    |\n271 |                 if let Some(b) = at.byte() {\n    |                                     ^^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `byte` not found for this struct\n\nerror[E0599]: no method named `matches` found for reference `&InstBytes` in the current scope\n   --> src/pikevm.rs:272:29\n    |\n272 |                     if inst.matches(b) {\n    |                             ^^^^^^^ method not found in `&InstBytes`\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:273:30\n    |\n273 |                         self.add(nlist, thread_caps, inst.goto, at_next);\n    |                              ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `add_step` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:295:26\n    |\n295 |                     self.add_step(nlist, thread_caps, ip, at);\n    |                          ^^^^^^^^ method not found in `&mut Fsm<'r, I>`\n\nerror[E0599]: no method named `contains` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:319:26\n    |\n319 |             if nlist.set.contains(ip) {\n    |                          ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `contains` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `contains`, perhaps you need to implement it:\n            candidate #1: `RangeBounds`\n\nerror[E0599]: no method named `insert` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:322:23\n    |\n322 |             nlist.set.insert(ip);\n    |                       ^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `insert` not found for this struct\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [Option<usize>]`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:330:48\n    |\n330 |                     if inst.slot < thread_caps.len() {\n    |                                                ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[Option<usize>]: ExactSizeIterator`\n            which is required by `&mut [Option<usize>]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:335:58\n    |\n335 |                         thread_caps[inst.slot] = Some(at.pos());\n    |                                                          ^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n\nerror[E0599]: no method named `caps` found for mutable reference `&mut Threads` in the current scope\n   --> src/pikevm.rs:344:40\n    |\n344 |                     let t = &mut nlist.caps(ip);\n    |                                        ^^^^---- help: remove the arguments\n    |                                        |\n    |                                        field, not a method\n\nerror[E0599]: no method named `iter` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/pikevm.rs:345:69\n    |\n345 |                     for (slot, val) in t.iter_mut().zip(thread_caps.iter()) {\n    |                                                                     ^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:358:29\n    |\n358 |             set: SparseSet::new(0),\n    |                             ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `capacity` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:365:34\n    |\n365 |         if num_insts == self.set.capacity() {\n    |                                  ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `capacity` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:369:31\n    |\n369 |         self.set = SparseSet::new(num_insts);\n    |                               ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `empty` found for struct `LiteralSearcher` in the current scope\n  --> src/prog.rs:95:40\n   |\n95 |             prefixes: LiteralSearcher::empty(),\n   |                                        ^^^^^ function or associated item not found in `LiteralSearcher`\n   |\n  ::: src/literal/mod.rs:31:1\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `empty` not found for this struct\n\nerror[E0599]: no method named `skip` found for reference `&Program` in the current scope\n   --> src/prog.rs:120:25\n    |\n120 |         match self[self.skip(pc)] {\n    |                         ^^^^ `&Program` is not an iterator\n    |\nhelp: call `.into_iter()` first\n    |\n120 |         match self[self.into_iter().skip(pc)] {\n    |                         ++++++++++++\n\nerror[E0599]: no method named `len` found for reference `&Program` in the current scope\n   --> src/prog.rs:151:15\n    |\n151 |         (self.len() * mem::size_of::<Inst>())\n    |               ^^^ method not found in `&Program`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\nhelp: some of the expressions' fields have a method of the same name\n    |\n151 |         (self.byte_classes.len() * mem::size_of::<Inst>())\n    |               +++++++++++++\n151 |         (self.capture_name_idx.len() * mem::size_of::<Inst>())\n    |               +++++++++++++++++\n151 |         (self.captures.len() * mem::size_of::<Inst>())\n    |               +++++++++\n151 |         (self.insts.len() * mem::size_of::<Inst>())\n    |               ++++++\n      and 1 other candidate\n\nerror[E0599]: no method named `approximate_size` found for struct `LiteralSearcher` in the current scope\n   --> src/prog.rs:157:25\n    |\n157 |         + self.prefixes.approximate_size()\n    |                         ^^^^^^^^^^^^^^^^ method not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `approximate_size` not found for this struct\n\nerror[E0599]: no method named `iter` found for reference `&Program` in the current scope\n   --> src/prog.rs:187:32\n    |\n187 |         for (pc, inst) in self.iter().enumerate() {\n    |                                ^^^^ method not found in `&Program`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n187 |         for (pc, inst) in self.capture_name_idx.iter().enumerate() {\n    |                                +++++++++++++++++\n\nerror[E0599]: no method named `iter` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:210:26\n    |\n209 |                       let ranges = inst.ranges\n    |  __________________________________-\n210 | |                         .iter()\n    | |                         -^^^^ method not found in `Vec<(char, char)>`\n    | |_________________________|\n    |\n\nerror[E0599]: no method named `iter` found for reference `&'a Program` in the current scope\n   --> src/prog.rs:237:49\n    |\n237 |     fn into_iter(self) -> Self::IntoIter { self.iter() }\n    |                                                 ^^^^ method not found in `&Program`\n\nerror[E0599]: no method named `iter` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:376:30\n    |\n376 |         for r in self.ranges.iter().take(4) {\n    |                              ^^^^ method not found in `Vec<(char, char)>`\n\nerror[E0599]: no method named `binary_search_by` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:384:21\n    |\n384 |         self.ranges.binary_search_by(|r| {\n    |         ------------^^^^^^^^^^^^^^^^ method not found in `Vec<(char, char)>`\n\nerror[E0599]: no method named `iter` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:398:21\n    |\n398 |         self.ranges.iter()\n    |                     ^^^^ method not found in `Vec<(char, char)>`\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:79:22\n    |\n79  |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n225 | define_builder!(bytes, re_bytes, false);\n    | --------------------------------------- in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:79:22\n    |\n79  |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n226 | define_builder!(unicode, re_unicode, true);\n    | ------------------------------------------ in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:260:22\n    |\n260 |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n387 | define_set_builder!(set_bytes, bytes, false);\n    | -------------------------------------------- in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_set_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:260:22\n    |\n260 |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n388 | define_set_builder!(set_unicode, unicode, true);\n    | ----------------------------------------------- in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_set_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_str` found for reference `&re_bytes::Regex` in the current scope\n  --> src/re_bytes.rs:83:30\n   |\n83 |         write!(f, \"{}\", self.as_str())\n   |                              ^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:109:16\n    |\n78  | pub struct Regex(Exec);\n    | ---------------- function or associated item `new` not found for this struct\n...\n109 |         Regex::new(s)\n    |                ^^^ function or associated item not found in `Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_builder::bytes::RegexBuilder` in the current scope\n   --> src/re_bytes.rs:120:23\n    |\n120 |         RegexBuilder::new(re).build()\n    |                       ^^^ function or associated item not found in `RegexBuilder`\n    |\n   ::: src/re_builder.rs:60:1\n    |\n60  | pub struct RegexBuilder(RegexOptions);\n    | ----------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:142:14\n    |\n142 |         self.is_match_at(text, 0)\n    |              ^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `find_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:166:14\n    |\n166 |         self.find_at(text, 0)\n    |              ^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:188:24\n    |\n188 |         Matches(self.0.searcher().find_iter(text))\n    |                        ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `locations` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:255:29\n    |\n255 |         let mut locs = self.locations();\n    |                             ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `locations`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `read_captures_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:256:14\n    |\n256 |         self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n    |              ^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `read_captures_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `capture_name_idx` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:259:34\n    |\n259 |             named_groups: self.0.capture_name_idx().clone(),\n    |                                  ^^^^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_name_idx` not found for this struct\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:293:31\n    |\n293 |         CaptureMatches(self.0.searcher().captures_iter(text))\n    |                               ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `find_iter` found for reference `&'r re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:318:26\n    |\n318 |             finder: self.find_iter(text),\n    |                          ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `split` found for reference `&'r re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:349:26\n    |\n349 |             splits: self.split(text),\n    |                          ^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `split`, perhaps you need to implement it:\n            candidate #1: `BufRead`\n\nerror[E0599]: no method named `replacen` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:467:14\n    |\n467 |         self.replacen(text, 1, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `replacen` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:481:14\n    |\n481 |         self.replacen(text, 0, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `find_iter` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:497:31\n    |\n497 |             let mut it = self.find_iter(text).enumerate().peekable();\n    |                               ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t [u8]` in the current scope\n    --> src/re_bytes.rs:501:51\n     |\n501  |             let mut new = Vec::with_capacity(text.len());\n     |                                                   ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `captures_iter` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:517:27\n    |\n517 |         let mut it = self.captures_iter(text).enumerate().peekable();\n    |                           ^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `captures_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t [u8]` in the current scope\n    --> src/re_bytes.rs:521:47\n     |\n521  |         let mut new = Vec::with_capacity(text.len());\n     |                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:562:14\n    |\n562 |         self.shortest_match_at(text, 0)\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:577:16\n    |\n577 |         self.0.searcher().shortest_match_at(text, start)\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:588:14\n    |\n588 |         self.shortest_match_at(text, start).is_some()\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:603:16\n    |\n603 |         self.0.searcher().find_at(text, start)\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:604:34\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n604 |             .map(|(s, e)| Match::new(text, s, e))\n    |                                  ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:620:16\n    |\n620 |         self.0.searcher().read_captures_at(locs, text, start)\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:621:34\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n621 |             .map(|(s, e)| Match::new(text, s, e))\n    |                                  ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:629:17\n    |\n629 |         &self.0.regex_strings()[0]\n    |                 ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `regex_strings` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:634:29\n    |\n634 |         CaptureNames(self.0.capture_names().iter())\n    |                             ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:639:16\n    |\n639 |         self.0.capture_names().len()\n    |                ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:646:16\n    |\n646 |         self.0.searcher().locations()\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_bytes.rs:664:27\n    |\n664 |         let text = self.0.text();\n    |                           ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n664 |         let text = self.0.next();\n    |                           ~~~~\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:665:43\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n665 |         self.0.next().map(|(s, e)| Match::new(text, s, e))\n    |                                           ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `text` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_bytes.rs:683:26\n    |\n683 |             text: self.0.text(),\n    |                          ^^^^\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n683 |             text: self.0.next(),\n    |                          ~~~~\n\nerror[E0599]: no method named `regex` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_bytes.rs:685:34\n    |\n685 |             named_groups: self.0.regex().capture_name_idx().clone(),\n    |                                  ^^^^^ method not found in `CaptureMatches<'t, ExecNoSync<'r>>`\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `regex` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_bytes.rs:703:34\n    |\n703 |         let text = self.finder.0.text();\n    |                                  ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n703 |         let text = self.finder.0.next();\n    |                                  ~~~~\n\nerror[E0599]: no method named `start` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:715:50\n    |\n30  | pub struct Match<'t> {\n    | -------------------- method `start` not found for this struct\n...\n715 |                 let matched = &text[self.last..m.start()];\n    |                                                  ^^^^^-- help: remove the arguments\n    |                                                  |\n    |                                                  field, not a method\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `start`, perhaps you need to implement one of them:\n            candidate #1: `syntax::ast::Visitor`\n            candidate #2: `syntax::hir::Visitor`\n\nerror[E0599]: no method named `end` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:716:31\n    |\n30  | pub struct Match<'t> {\n    | -------------------- method `end` not found for this struct\n...\n716 |                 self.last = m.end();\n    |                               ^^^-- help: remove the arguments\n    |                               |\n    |                               field, not a method\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_bytes.rs:743:45\n    |\n743 |             let text = self.splits.finder.0.text();\n    |                                             ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n743 |             let text = self.splits.finder.0.next();\n    |                                             ~~~~\n\nerror[E0599]: no method named `pos` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:810:19\n    |\n810 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `pos` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:810:46\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n810 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                                              ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_bytes::Captures<'t>` in the current scope\n   --> src/re_bytes.rs:816:56\n    |\n816 |         self.named_groups.get(name).and_then(|&i| self.get(i))\n    |                                                        ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n816 |         self.named_groups.get(name).and_then(|&i| self.named_groups.get(i))\n    |                                                        +++++++++++++\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:827:27\n    |\n827 |             it: self.locs.iter(),\n    |                           ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `len` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:857:19\n    |\n857 |         self.locs.len()\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `len` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:891:38\n    |\n891 |         for (slot, m) in self.0.locs.iter().enumerate() {\n    |                                      ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `get` found for reference `&re_bytes::Captures<'t>` in the current scope\n   --> src/re_bytes.rs:918:14\n    |\n918 |         self.get(i).map(|m| m.as_bytes())\n    |              ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n918 |         self.named_groups.get(i).map(|m| m.as_bytes())\n    |              +++++++++++++\n\nerror[E0599]: no method named `name` found for reference `&'a re_bytes::Captures<'t>` in the current scope\n   --> src/re_bytes.rs:939:14\n    |\n939 |         self.name(name).map(|m| m.as_bytes())\n    |              ^^^^ method not found in `&Captures<'t>`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:963:48\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n963 |             .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    |                                                ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `expand` found for reference `&re_bytes::Captures<'_>` in the current scope\n    --> src/re_bytes.rs:1037:14\n     |\n1037 |         caps.expand(*self, dst);\n     |              ^^^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no function or associated item named `new` found for struct `set_unicode::RegexSetBuilder` in the current scope\n   --> src/re_set.rs:106:26\n    |\n106 |           RegexSetBuilder::new(exprs).build()\n    |                            ^^^ function or associated item not found in `RegexSetBuilder`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/re_builder.rs:242:1\n    |\n242 |   pub struct RegexSetBuilder(RegexOptions);\n    |   -------------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_set::unicode::RegexSet` in the current scope\n   --> src/re_set.rs:134:14\n    |\n134 |           self.is_match_at(text, 0)\n    |                ^^^^^^^^^^^ method not found in `&RegexSet`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:145:16\n    |\n145 |           self.0.searcher().is_match_at($as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:185:46\n    |\n185 |           let mut matches = vec![false; self.0.regex_strings().len()];\n    |                                                ^^^^^^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `read_matches_at` found for reference `&re_set::unicode::RegexSet` in the current scope\n   --> src/re_set.rs:186:24\n    |\n186 |           let any = self.read_matches_at(&mut matches, text, 0);\n    |                          ^^^^^^^^^^^^^^^ method not found in `&RegexSet`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:212:16\n    |\n212 |           self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:217:16\n    |\n217 |           self.0.regex_strings().len()\n    |                  ^^^^^^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `iter` found for reference `&'a re_set::unicode::SetMatches` in the current scope\n   --> src/re_set.rs:275:14\n    |\n275 |           self.iter()\n    |                ^^^^ method not found in `&SetMatches`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:357:44\n    |\n357 |           write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    |                                              ^^^^^^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/re_set.rs:361:65\n    |\n361 |   #[allow(dead_code)] fn as_bytes_str(text: &str) -> &[u8] { text.as_bytes() }\n    |                                                                   ^^^^^^^^ method not found in `&str`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new` found for struct `set_bytes::RegexSetBuilder` in the current scope\n   --> src/re_set.rs:106:26\n    |\n106 |           RegexSetBuilder::new(exprs).build()\n    |                            ^^^ function or associated item not found in `RegexSetBuilder`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/re_builder.rs:242:1\n    |\n242 |   pub struct RegexSetBuilder(RegexOptions);\n    |   -------------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_set::bytes::RegexSet` in the current scope\n   --> src/re_set.rs:134:14\n    |\n134 |           self.is_match_at(text, 0)\n    |                ^^^^^^^^^^^ method not found in `&RegexSet`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:145:16\n    |\n145 |           self.0.searcher().is_match_at($as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:185:46\n    |\n185 |           let mut matches = vec![false; self.0.regex_strings().len()];\n    |                                                ^^^^^^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `read_matches_at` found for reference `&re_set::bytes::RegexSet` in the current scope\n   --> src/re_set.rs:186:24\n    |\n186 |           let any = self.read_matches_at(&mut matches, text, 0);\n    |                          ^^^^^^^^^^^^^^^ method not found in `&RegexSet`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:212:16\n    |\n212 |           self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:217:16\n    |\n217 |           self.0.regex_strings().len()\n    |                  ^^^^^^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `iter` found for reference `&'a re_set::bytes::SetMatches` in the current scope\n   --> src/re_set.rs:275:14\n    |\n275 |           self.iter()\n    |                ^^^^ method not found in `&SetMatches`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:357:44\n    |\n357 |           write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    |                                              ^^^^^^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/re_set.rs:361:65\n    |\n361 |   #[allow(dead_code)] fn as_bytes_str(text: &str) -> &[u8] { text.as_bytes() }\n    |                                                                   ^^^^^^^^ method not found in `&str`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `get` found for struct `Vec<Option<usize>>` in the current scope\n  --> src/re_trait.rs:30:23\n   |\n30 |         match (self.0.get(s), self.0.get(e)) {\n   |                       ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n30 |         match (self.0.ge(s), self.0.get(e)) {\n   |                       ~~\n\nerror[E0599]: no method named `get` found for struct `Vec<Option<usize>>` in the current scope\n  --> src/re_trait.rs:30:38\n   |\n30 |         match (self.0.get(s), self.0.get(e)) {\n   |                                      ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n30 |         match (self.0.get(s), self.0.ge(e)) {\n   |                                      ~~\n\nerror[E0599]: no method named `len` found for reference `&'c Locations` in the current scope\n  --> src/re_trait.rs:73:34\n   |\n73 |         if self.idx >= self.locs.len() {\n   |                                  ^^^ method not found in `&Locations`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following traits define an item `len`, perhaps you need to implement one of them:\n           candidate #1: `input::Input`\n           candidate #2: `Automaton`\n           candidate #3: `ExactSizeIterator`\nhelp: one of the expressions' fields has a method of the same name\n   |\n73 |         if self.idx >= self.locs.0.len() {\n   |                                  ++\n\nerror[E0599]: no method named `pos` found for reference `&'c Locations` in the current scope\n  --> src/re_trait.rs:76:33\n   |\n76 |         let x = match self.locs.pos(self.idx) {\n   |                                 ^^^ method not found in `&Locations`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/re_trait.rs:198:47\n     |\n198  |         if self.last_end > self.text.as_ref().len() {\n     |                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_trait.rs:231:16\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n...\n231 |         self.0.text()\n    |                ^^^^-- help: remove the arguments\n    |                |\n    |                field, not a method\n\nerror[E0599]: no method named `regex` found for struct `re_trait::Matches` in the current scope\n   --> src/re_trait.rs:236:16\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `regex` not found for this struct\n...\n236 |         self.0.regex()\n    |                ^^^^^ method not found in `Matches<'t, R>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/re_trait.rs:245:51\n     |\n245  |         if self.0.last_end > self.0.text.as_ref().len() {\n     |                                                   ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_str` found for struct `re_unicode::Match` in the current scope\n  --> src/re_unicode.rs:77:11\n   |\n39 | pub struct Match<'t> {\n   | -------------------- method `as_str` not found for this struct\n...\n77 |         m.as_str()\n   |           ^^^^^^ method not found in `Match<'t>`\n\nerror[E0599]: no method named `as_str` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:142:30\n    |\n142 |         write!(f, \"{}\", self.as_str())\n    |                              ^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:165:16\n    |\n137 | pub struct Regex(Exec);\n    | ---------------- function or associated item `new` not found for this struct\n...\n165 |         Regex::new(s)\n    |                ^^^ function or associated item not found in `Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_builder::unicode::RegexBuilder` in the current scope\n   --> src/re_unicode.rs:176:23\n    |\n176 |         RegexBuilder::new(re).build()\n    |                       ^^^ function or associated item not found in `RegexBuilder`\n    |\n   ::: src/re_builder.rs:60:1\n    |\n60  | pub struct RegexBuilder(RegexOptions);\n    | ----------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:198:14\n    |\n198 |         self.is_match_at(text, 0)\n    |              ^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `find_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:223:14\n    |\n223 |         self.find_at(text, 0)\n    |              ^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:245:24\n    |\n245 |         Matches(self.0.searcher_str().find_iter(text))\n    |                        ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `locations` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:312:29\n    |\n312 |         let mut locs = self.locations();\n    |                             ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `locations`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `read_captures_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:313:14\n    |\n313 |         self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n    |              ^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `read_captures_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `capture_name_idx` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:316:34\n    |\n316 |             named_groups: self.0.capture_name_idx().clone(),\n    |                                  ^^^^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_name_idx` not found for this struct\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:349:31\n    |\n349 |         CaptureMatches(self.0.searcher_str().captures_iter(text))\n    |                               ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `find_iter` found for reference `&'r re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:372:26\n    |\n372 |             finder: self.find_iter(text),\n    |                          ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `split` found for reference `&'r re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:400:26\n    |\n400 |             splits: self.split(text),\n    |                          ^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `split`, perhaps you need to implement it:\n            candidate #1: `BufRead`\n\nerror[E0599]: no method named `replacen` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:514:14\n    |\n514 |         self.replacen(text, 1, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `replacen` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:528:14\n    |\n528 |         self.replacen(text, 0, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `find_iter` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:553:31\n    |\n553 |             let mut it = self.find_iter(text).enumerate().peekable();\n    |                               ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t str` in the current scope\n    --> src/re_unicode.rs:557:54\n     |\n557  |             let mut new = String::with_capacity(text.len());\n     |                                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `captures_iter` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:573:27\n    |\n573 |         let mut it = self.captures_iter(text).enumerate().peekable();\n    |                           ^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `captures_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t str` in the current scope\n    --> src/re_unicode.rs:577:50\n     |\n577  |         let mut new = String::with_capacity(text.len());\n     |                                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:618:14\n    |\n618 |         self.shortest_match_at(text, 0)\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:633:16\n    |\n633 |         self.0.searcher_str().shortest_match_at(text, start)\n    |                ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:644:14\n    |\n644 |         self.shortest_match_at(text, start).is_some()\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:659:16\n    |\n659 |         self.0.searcher_str().find_at(text, start).map(|(s, e)| {\n    |                ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:660:20\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n660 |             Match::new(text, s, e)\n    |                    ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:678:14\n    |\n677 | /         self.0\n678 | |             .searcher_str()\n    | |             -^^^^^^^^^^^^ method not found in `Exec`\n    | |_____________|\n    |\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:680:34\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n680 |             .map(|(s, e)| Match::new(text, s, e))\n    |                                  ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:688:17\n    |\n688 |         &self.0.regex_strings()[0]\n    |                 ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `regex_strings` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:693:29\n    |\n693 |         CaptureNames(self.0.capture_names().iter())\n    |                             ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:698:16\n    |\n698 |         self.0.capture_names().len()\n    |                ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:705:16\n    |\n705 |         self.0.searcher_str().locations()\n    |                ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_unicode.rs:745:34\n    |\n745 |         let text = self.finder.0.text();\n    |                                  ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n745 |         let text = self.finder.0.next();\n    |                                  ~~~~\n\nerror[E0599]: no method named `start` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:757:50\n    |\n39  | pub struct Match<'t> {\n    | -------------------- method `start` not found for this struct\n...\n757 |                 let matched = &text[self.last..m.start()];\n    |                                                  ^^^^^-- help: remove the arguments\n    |                                                  |\n    |                                                  field, not a method\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `start`, perhaps you need to implement one of them:\n            candidate #1: `syntax::ast::Visitor`\n            candidate #2: `syntax::hir::Visitor`\n\nerror[E0599]: no method named `end` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:758:31\n    |\n39  | pub struct Match<'t> {\n    | -------------------- method `end` not found for this struct\n...\n758 |                 self.last = m.end();\n    |                               ^^^-- help: remove the arguments\n    |                               |\n    |                               field, not a method\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_unicode.rs:785:45\n    |\n785 |             let text = self.splits.finder.0.text();\n    |                                             ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n785 |             let text = self.splits.finder.0.next();\n    |                                             ~~~~\n\nerror[E0599]: no method named `pos` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:831:19\n    |\n831 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `pos` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:831:46\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n831 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                                              ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_unicode::Captures<'t>` in the current scope\n   --> src/re_unicode.rs:837:56\n    |\n837 |         self.named_groups.get(name).and_then(|&i| self.get(i))\n    |                                                        ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n837 |         self.named_groups.get(name).and_then(|&i| self.named_groups.get(i))\n    |                                                        +++++++++++++\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:848:27\n    |\n848 |             it: self.locs.iter(),\n    |                           ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `len` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:878:19\n    |\n878 |         self.locs.len()\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `len` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:897:38\n    |\n897 |         for (slot, m) in self.0.locs.iter().enumerate() {\n    |                                      ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `get` found for reference `&re_unicode::Captures<'t>` in the current scope\n   --> src/re_unicode.rs:924:14\n    |\n924 |         self.get(i).map(|m| m.as_str())\n    |              ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n924 |         self.named_groups.get(i).map(|m| m.as_str())\n    |              +++++++++++++\n\nerror[E0599]: no method named `name` found for reference `&'a re_unicode::Captures<'t>` in the current scope\n   --> src/re_unicode.rs:945:14\n    |\n945 |         self.name(name).map(|m| m.as_str())\n    |              ^^^^ method not found in `&Captures<'t>`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:969:48\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n969 |             .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    |                                                ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `text` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_unicode.rs:987:26\n    |\n987 |             text: self.0.text(),\n    |                          ^^^^\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n987 |             text: self.0.next(),\n    |                          ~~~~\n\nerror[E0599]: no method named `regex` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_unicode.rs:989:34\n    |\n989 |             named_groups: self.0.regex().capture_name_idx().clone(),\n    |                                  ^^^^^ method not found in `CaptureMatches<'t, ExecNoSyncStr<'r>>`\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `regex` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n    --> src/re_unicode.rs:1007:27\n     |\n1007 |         let text = self.0.text();\n     |                           ^^^^ private field, not a method\n     |\n    ::: src/re_trait.rs:174:1\n     |\n174  | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n     | ------------------------- method `text` not found for this struct\n     |\nhelp: there is a method `next` with a similar name\n     |\n1007 |         let text = self.0.next();\n     |                           ~~~~\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n    --> src/re_unicode.rs:1008:43\n     |\n39   | pub struct Match<'t> {\n     | -------------------- function or associated item `new` not found for this struct\n...\n1008 |         self.0.next().map(|(s, e)| Match::new(text, s, e))\n     |                                           ^^^ function or associated item not found in `Match<'_>`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `expand` found for reference `&re_unicode::Captures<'_>` in the current scope\n    --> src/re_unicode.rs:1081:14\n     |\n1081 |         caps.expand(*self, dst);\n     |              ^^^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no method named `as_bytes` found for mutable reference `&mut &'a str` in the current scope\n    --> src/re_unicode.rs:1085:33\n     |\n1085 |         match memchr(b'$', self.as_bytes()) {\n     |                                 ^^^^^^^^ method not found in `&mut &str`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&'a SparseSet` in the current scope\n  --> src/sparse.rs:77:49\n   |\n77 |     fn into_iter(self) -> Self::IntoIter { self.iter() }\n   |                                                 ^^^^ method not found in `&SparseSet`\n\nwarning: unused import: `RegularExpression`\n  --> src/re_unicode.rs:25:22\n   |\n25 | use re_trait::{self, RegularExpression, Locations, SubCapturesPosIter};\n   |                      ^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `re_trait::RegularExpression`\n   --> src/re_set.rs:23:17\n    |\n23  |               use re_trait::RegularExpression;\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = note: this warning originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unused import: `super`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^\n\nwarning: unused import: `re_trait::RegularExpression`\n   --> src/re_set.rs:23:17\n    |\n23  |               use re_trait::RegularExpression;\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = note: this warning originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unused import: `RegularExpression`\n  --> src/re_bytes.rs:24:22\n   |\n24 | use re_trait::{self, RegularExpression, Locations, SubCapturesPosIter};\n   |                      ^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0390, E0599.\nFor more information about an error, try `rustc --explain E0390`.\nwarning: `regex` (lib test) generated 36 warnings\nerror: could not compile `regex` (lib test) due to 864 previous errors; 36 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let tester = Tester::new(false, b\"hello123\".to_vec());",
                  "    let at = InputAt { position: 5 }; // Position between 'o' and '1'",
                  "    let empty = InstEmptyLook {",
                  "        look: EmptyLook::NotWordBoundaryAscii,",
                  "    };",
                  "    ",
                  "    // Previous byte is valid (o), next byte is numeric (1)",
                  "    assert!(tester.is_empty_match(at, &empty));",
                  "",
                  "    let at_end = InputAt { position: 6 }; // Position at '1'",
                  "    // Previous is 'l' (valid), next is '2' (valid)",
                  "    assert!(!tester.is_empty_match(at_end, &empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nerror[E0390]: cannot define inherent `impl` for primitive types\n   --> src/input.rs:503:1\n    |\n503 | impl u8 {\n    | ^^^^^^^\n    |\n    = help: consider using an extension trait instead\n\nerror[E0599]: no method named `exec_` found for struct `backtrack::Bounded` in the current scope\n   --> src/backtrack.rs:112:11\n    |\n54  | pub struct Bounded<'a, 'm, 'r, 's, I> {\n    | ------------------------------------- method `exec_` not found for this struct\n...\n112 |         b.exec_(start)\n    |           ^^^^^ method not found in `Bounded<'_, '_, '_, '_, I>`\n\nerror[E0599]: the method `len` exists for reference `&Program`, but its trait bounds were not satisfied\n   --> src/backtrack.rs:132:24\n    |\n132 |             (self.prog.len() * (self.input.len() + 1) + BIT_SIZE - 1)\n    |                        ^^^ method cannot be called on `&Program` due to unsatisfied trait bounds\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ doesn't satisfy `Program: input::Input`\n    |\nnote: trait bound `Program: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:151:14\n    |\n151 |         self.clear();\n    |              ^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n    |\nhelp: some of the expressions' fields have a method of the same name\n    |\n151 |         self.m.jobs.clear();\n    |              +++++++\n151 |         self.prog.insts.clear();\n    |              +++++++++++\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:155:27\n    |\n155 |             return if !at.is_start() {\n    |                           ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n\nerror[E0599]: no method named `backtrack` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:158:22\n    |\n158 |                 self.backtrack(at)\n    |                      ^^^^^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n   --> src/backtrack.rs:163:36\n    |\n163 |             if !self.prog.prefixes.is_empty() {\n    |                                    ^^^^^^^^ method not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `backtrack` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:169:28\n    |\n169 |             matched = self.backtrack(at) || matched;\n    |                            ^^^^^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:173:19\n    |\n173 |             if at.is_end() {\n    |                   ^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:176:35\n    |\n176 |             at = self.input.at(at.next_pos());\n    |                                   ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `step` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:192:29\n    |\n192 |                     if self.step(ip, at) {\n    |                             ^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [Option<usize>]`, but its trait bounds were not satisfied\n   --> src/backtrack.rs:203:42\n    |\n203 |                     if slot < self.slots.len() {\n    |                                          ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[Option<usize>]: ExactSizeIterator`\n            which is required by `&mut [Option<usize>]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `has_visited` found for mutable reference `&mut backtrack::Bounded<'a, 'm, 'r, 's, I>` in the current scope\n   --> src/backtrack.rs:219:21\n    |\n219 |             if self.has_visited(ip, at) {\n    |                     ^^^^^^^^^^^ method not found in `&mut Bounded<'a, 'm, 'r, 's, I>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/backtrack.rs:224:44\n    |\n224 |                     if slot < self.matches.len() {\n    |                                            ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for mutable reference `&'s mut [Option<usize>]` in the current scope\n   --> src/backtrack.rs:230:56\n    |\n230 |                     if let Some(&old_pos) = self.slots.get(inst.slot) {\n    |                                                        ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n230 |                     if let Some(&old_pos) = self.slots.ge(inst.slot) {\n    |                                                        ~~\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:239:57\n    |\n239 |                         self.slots[inst.slot] = Some(at.pos());\n    |                                                         ^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:255:37\n    |\n255 |                     if inst.c == at.char() {\n    |                                     ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:257:47\n    |\n257 |                         at = self.input.at(at.next_pos());\n    |                                               ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `matches` found for reference `&InstRanges` in the current scope\n   --> src/backtrack.rs:263:29\n    |\n263 |                     if inst.matches(at.char()) {\n    |                             ^^^^^^^ method not found in `&InstRanges`\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:263:40\n    |\n263 |                     if inst.matches(at.char()) {\n    |                                        ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:265:47\n    |\n265 |                         at = self.input.at(at.next_pos());\n    |                                               ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `byte` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:271:41\n    |\n271 |                     if let Some(b) = at.byte() {\n    |                                         ^^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `byte` not found for this struct\n\nerror[E0599]: no method named `matches` found for reference `&InstBytes` in the current scope\n   --> src/backtrack.rs:272:33\n    |\n272 |                         if inst.matches(b) {\n    |                                 ^^^^^^^ method not found in `&InstBytes`\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:274:51\n    |\n274 | ...                   at = self.input.at(at.next_pos());\n    |                                             ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/backtrack.rs:285:50\n    |\n285 |         let k = ip * (self.input.len() + 1) + at.pos();\n    |                                                  ^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n  --> src/utf8.rs:25:24\n   |\n25 |     let b = match text.get(i) {\n   |                        ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n25 |     let b = match text.ge(i) {\n   |                        ~~\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n  --> src/utf8.rs:53:24\n   |\n53 |     let b0 = match src.get(0) {\n   |                        ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n53 |     let b0 = match src.ge(0) {\n   |                        ~~\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:60:20\n     |\n60   |             if src.len() < 2 {\n     |                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:75:20\n     |\n75   |             if src.len() < 3 {\n     |                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:95:20\n     |\n95   |             if src.len() < 4 {\n     |                    ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n   --> src/utf8.rs:124:12\n    |\n124 |     if src.is_empty() {\n    |            ^^^^^^^^ method not found in `&[u8]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:127:25\n     |\n127  |     let mut start = src.len() - 1;\n     |                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:131:23\n     |\n131  |     while start > src.len().saturating_sub(4) {\n     |                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/utf8.rs:139:33\n     |\n139  |         Some((_, n)) if n < src.len() - start => None,\n     |                                 ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n  --> src/compile.rs:55:32\n   |\n55 |             compiled: Program::new(),\n   |                                ^^^ function or associated item not found in `Program`\n   |\n  ::: src/prog.rs:18:1\n   |\n18 | pub struct Program {\n   | ------------------ function or associated item `new` not found for this struct\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `SuffixCache` in the current scope\n   --> src/compile.rs:59:40\n    |\n59  |             suffix_cache: SuffixCache::new(1000),\n    |                                        ^^^ function or associated item not found in `SuffixCache`\n...\n983 | struct SuffixCache {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:61:41\n     |\n61   |             byte_classes: ByteClassSet::new(),\n     |                                         ^^^ function or associated item not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:126:29\n    |\n126 |         debug_assert!(exprs.len() >= 1);\n    |                             ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:127:32\n    |\n127 |         self.num_exprs = exprs.len();\n    |                                ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:128:18\n    |\n128 |         if exprs.len() == 1 {\n    |                  ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `compile_one` found for struct `Compiler` in the current scope\n   --> src/compile.rs:129:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_one` not found for this struct\n...\n129 |             self.compile_one(&exprs[0])\n    |                  ^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `compile_many` found for struct `Compiler` in the current scope\n   --> src/compile.rs:131:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_many` not found for this struct\n...\n131 |             self.compile_many(exprs)\n    |                  ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `needs_dotstar` found for struct `Program` in the current scope\n   --> src/compile.rs:143:26\n    |\n143 |         if self.compiled.needs_dotstar() {\n    |                          ^^^^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `needs_dotstar` not found for this struct\n\nerror[E0599]: no method named `c_dotstar` found for struct `Compiler` in the current scope\n   --> src/compile.rs:144:34\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_dotstar` not found for this struct\n...\n144 |             dotstar_patch = self.c_dotstar()?;\n    |                                  ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n   --> src/compile.rs:147:34\n    |\n147 |         self.compiled.captures = vec![None];\n    |                                  ^^^^^^^^^^ function or associated item not found in `[_]`\n    |\nhelp: there is an associated function `to_vec` with a similar name\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n    |\n116 | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117 | |         where\n118 | |             Self: Sized;\n    | |________________________^\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `c_capture` found for struct `Compiler` in the current scope\n   --> src/compile.rs:148:26\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_capture` not found for this struct\n...\n148 |         let patch = self.c_capture(0, expr)?;\n    |                          ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `needs_dotstar` found for struct `Program` in the current scope\n   --> src/compile.rs:149:26\n    |\n149 |         if self.compiled.needs_dotstar() {\n    |                          ^^^^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `needs_dotstar` not found for this struct\n\nerror[E0599]: no method named `fill` found for struct `Compiler` in the current scope\n   --> src/compile.rs:150:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill` not found for this struct\n...\n150 |             self.fill(dotstar_patch.hole, patch.entry);\n    |                  ^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:154:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n154 |         self.fill_to_next(patch.hole);\n    |              ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n   --> src/compile.rs:155:33\n    |\n155 |         self.compiled.matches = vec![self.insts.len()];\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `[_]`\n    |\nhelp: there is an associated function `to_vec` with a similar name\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n    |\n116 | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117 | |         where\n118 | |             Self: Sized;\n    | |________________________^\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `push_compiled` found for struct `Compiler` in the current scope\n   --> src/compile.rs:156:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_compiled` not found for this struct\n...\n156 |         self.push_compiled(Inst::Match(0));\n    |              ^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `compile_finish` found for struct `Compiler` in the current scope\n   --> src/compile.rs:157:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_finish` not found for this struct\n...\n157 |         self.compile_finish()\n    |              ^^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:164:29\n    |\n164 |         debug_assert!(exprs.len() > 1);\n    |                             ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:167:19\n    |\n167 |             exprs.iter().all(|e| e.is_anchored_start());\n    |                   ^^^^ method not found in `&[Hir]`\n\nerror[E0599]: no method named `iter` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:169:19\n    |\n169 |             exprs.iter().all(|e| e.is_anchored_end());\n    |                   ^^^^ method not found in `&[Hir]`\n\nerror[E0599]: no method named `needs_dotstar` found for struct `Program` in the current scope\n   --> src/compile.rs:171:26\n    |\n171 |         if self.compiled.needs_dotstar() {\n    |                          ^^^^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `needs_dotstar` not found for this struct\n\nerror[E0599]: no method named `c_dotstar` found for struct `Compiler` in the current scope\n   --> src/compile.rs:172:34\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_dotstar` not found for this struct\n...\n172 |             dotstar_patch = self.c_dotstar()?;\n    |                                  ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:177:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n177 |         self.fill_to_next(dotstar_patch.hole);\n    |              ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:180:41\n    |\n180 |         for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n    |                                         ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for slice `[Hir]` in the current scope\n   --> src/compile.rs:180:52\n    |\n180 |         for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n    |                                                    ^^^^ method not found in `[Hir]`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:181:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n181 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for struct `Compiler` in the current scope\n   --> src/compile.rs:182:30\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_split_hole` not found for this struct\n...\n182 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `c_capture` found for struct `Compiler` in the current scope\n   --> src/compile.rs:183:46\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_capture` not found for this struct\n...\n183 |             let Patch { hole, entry } = self.c_capture(0, expr)?;\n    |                                              ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:184:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n184 |             self.fill_to_next(hole);\n    |                  ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `push_compiled` found for struct `Compiler` in the current scope\n   --> src/compile.rs:186:18\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_compiled` not found for this struct\n...\n186 |             self.push_compiled(Inst::Match(i));\n    |                  ^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_split` found for struct `Compiler` in the current scope\n   --> src/compile.rs:187:30\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_split` not found for this struct\n...\n187 |             prev_hole = self.fill_split(split, Some(entry), None);\n    |                              ^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:189:23\n    |\n189 |         let i = exprs.len() - 1;\n    |                       ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `c_capture` found for struct `Compiler` in the current scope\n   --> src/compile.rs:190:42\n    |\n37  | pub struct Compiler {\n    | ------------------- method `c_capture` not found for this struct\n...\n190 |         let Patch { hole, entry } = self.c_capture(0, &exprs[i])?;\n    |                                          ^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill` found for struct `Compiler` in the current scope\n   --> src/compile.rs:191:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill` not found for this struct\n...\n191 |         self.fill(prev_hole, entry);\n    |              ^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for struct `Compiler` in the current scope\n   --> src/compile.rs:192:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `fill_to_next` not found for this struct\n...\n192 |         self.fill_to_next(hole);\n    |              ^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `push_compiled` found for struct `Compiler` in the current scope\n   --> src/compile.rs:194:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `push_compiled` not found for this struct\n...\n194 |         self.push_compiled(Inst::Match(i));\n    |              ^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `compile_finish` found for struct `Compiler` in the current scope\n   --> src/compile.rs:195:14\n    |\n37  | pub struct Compiler {\n    | ------------------- method `compile_finish` not found for this struct\n...\n195 |         self.compile_finish()\n    |              ^^^^^^^^^^^^^^ method not found in `Compiler`\n\nerror[E0599]: no method named `unwrap` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:200:52\n    |\n200 |             self.insts.into_iter().map(|inst| inst.unwrap()).collect();\n    |                                                    ^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `unwrap` not found for this enum\n\nerror[E0599]: no method named `byte_classes` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:201:56\n     |\n201  |         self.compiled.byte_classes = self.byte_classes.byte_classes();\n     |                                                        ^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `byte_classes` not found for this struct\n\nerror[E0599]: no method named `check_size` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:262:14\n    |\n262 |         self.check_size()?;\n    |              ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_literal` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:266:22\n    |\n266 |                 self.c_literal(&[c])\n    |                      ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/compile.rs:269:39\n    |\n269 |                 assert!(self.compiled.uses_bytes());\n    |                                       ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no method named `c_bytes` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:270:22\n    |\n270 |                 self.c_bytes(&[b])\n    |                      ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:273:22\n    |\n273 |                 self.c_class(cls.ranges())\n    |                      ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/compile.rs:276:34\n    |\n276 |                 if self.compiled.uses_bytes() {\n    |                                  ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no method named `c_class_bytes` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:277:26\n    |\n277 |                     self.c_class_bytes(cls.ranges())\n    |                          ^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:285:26\n    |\n285 |                     self.c_class(&char_ranges)\n    |                          ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:289:35\n     |\n289  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:290:22\n    |\n290 |                 self.c_empty_look(prog::EmptyLook::EndLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:293:35\n     |\n293  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:294:22\n    |\n294 |                 self.c_empty_look(prog::EmptyLook::StartLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:297:35\n     |\n297  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:298:22\n    |\n298 |                 self.c_empty_look(prog::EmptyLook::StartLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:301:35\n     |\n301  |                 self.byte_classes.set_range(b'\\n', b'\\n');\n     |                                   ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:302:22\n    |\n302 |                 self.c_empty_look(prog::EmptyLook::EndLine)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:305:22\n    |\n305 |                 self.c_empty_look(prog::EmptyLook::EndText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:308:22\n    |\n308 |                 self.c_empty_look(prog::EmptyLook::StartText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:311:22\n    |\n311 |                 self.c_empty_look(prog::EmptyLook::StartText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:314:22\n    |\n314 |                 self.c_empty_look(prog::EmptyLook::EndText)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:318:35\n     |\n318  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:319:22\n    |\n319 |                 self.c_empty_look(prog::EmptyLook::WordBoundary)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:323:35\n     |\n323  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:324:22\n    |\n324 |                 self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:327:35\n     |\n327  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:328:22\n    |\n328 |                 self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_word_boundary` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:331:35\n     |\n331  |                 self.byte_classes.set_word_boundary();\n     |                                   ^^^^^^^^^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_word_boundary` not found for this struct\n\nerror[E0599]: no method named `c_empty_look` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:332:22\n    |\n332 |                 self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n    |                      ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:336:58\n    |\n336 |                     hir::GroupKind::NonCapturing => self.c(&g.hir),\n    |                                                          ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_capture` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:341:30\n    |\n341 |                         self.c_capture(2 * index as usize, &g.hir)\n    |                              ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_capture` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:349:30\n    |\n349 |                         self.c_capture(2 * index as usize, &g.hir)\n    |                              ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:355:26\n    |\n355 |                     self.c_concat(es.iter().rev())\n    |                          ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `iter` found for reference `&Vec<Hir>` in the current scope\n   --> src/compile.rs:355:38\n    |\n355 |                     self.c_concat(es.iter().rev())\n    |                                      ^^^^ method not found in `&Vec<Hir>`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:357:26\n    |\n357 |                     self.c_concat(es)\n    |                          ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_alternate` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:360:41\n    |\n360 |             Alternation(ref es) => self.c_alternate(&**es),\n    |                                         ^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:361:41\n    |\n361 |             Repetition(ref rep) => self.c_repeat(rep),\n    |                                         ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:370:18\n    |\n370 |             self.c(expr)\n    |                  ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:373:29\n    |\n373 |             let hole = self.push_hole(InstHole::Save { slot: first_slot });\n    |                             ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:374:30\n    |\n374 |             let patch = self.c(expr)?;\n    |                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:375:18\n    |\n375 |             self.fill(hole, patch.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:376:18\n    |\n376 |             self.fill_to_next(patch.hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:377:29\n    |\n377 |             let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });\n    |                             ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `only_utf8` found for struct `Program` in the current scope\n   --> src/compile.rs:383:30\n    |\n383 |         Ok(if !self.compiled.only_utf8() {\n    |                              ^^^^^^^^^-- help: remove the arguments\n    |                              |\n    |                              field, not a method\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `only_utf8` not found for this struct\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:384:18\n    |\n384 |             self.c(&Hir::repetition(hir::Repetition {\n    |             -----^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:390:18\n    |\n390 |             self.c(&Hir::repetition(hir::Repetition {\n    |             -----^ method not found in `&mut Compiler`\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty` found for reference `&[char]` in the current scope\n   --> src/compile.rs:399:30\n    |\n399 |         debug_assert!(!chars.is_empty());\n    |                              ^^^^^^^^ method not found in `&[char]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&[char]` in the current scope\n   --> src/compile.rs:402:32\n    |\n402 |                 Box::new(chars.iter().rev())\n    |                                ^^^^ method not found in `&[char]`\n\nerror[E0599]: no method named `iter` found for reference `&[char]` in the current scope\n   --> src/compile.rs:404:32\n    |\n404 |                 Box::new(chars.iter())\n    |                                ^^^^ method not found in `&[char]`\n\nerror[E0599]: no method named `c_char` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:407:46\n    |\n407 |         let Patch { mut hole, entry } = self.c_char(first)?;\n    |                                              ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_char` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:409:26\n    |\n409 |             let p = self.c_char(c)?;\n    |                          ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:410:18\n    |\n410 |             self.fill(hole, p.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:417:14\n    |\n417 |         self.c_class(&[hir::ClassUnicodeRange::new(c, c)])\n    |              ^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `is_empty` found for reference `&[ClassUnicodeRange]` in the current scope\n   --> src/compile.rs:421:25\n    |\n421 |         assert!(!ranges.is_empty());\n    |                         ^^^^^^^^ method not found in `&[ClassUnicodeRange]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/compile.rs:422:26\n    |\n422 |         if self.compiled.uses_bytes() {\n    |                          ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no method named `compile` found for struct `CompileClass` in the current scope\n   --> src/compile.rs:426:15\n    |\n423 | /             CompileClass {\n424 | |                 c: self,\n425 | |                 ranges: ranges,\n426 | |             }.compile()\n    | |              -^^^^^^^ method not found in `CompileClass<'_, '_>`\n    | |______________|\n    |\n...\n869 |   struct CompileClass<'a, 'b> {\n    |   --------------------------- method `compile` not found for this struct\n\nerror[E0599]: no method named `iter` found for reference `&[ClassUnicodeRange]` in the current scope\n   --> src/compile.rs:429:24\n    |\n429 |                 ranges.iter().map(|r| (r.start(), r.end())).collect();\n    |                        ^^^^ method not found in `&[ClassUnicodeRange]`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:431:22\n    |\n431 |                 self.push_hole(InstHole::Char { c: ranges[0].0 })\n    |                      ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:433:22\n    |\n433 |                 self.push_hole(InstHole::Ranges { ranges: ranges })\n    |                      ^^^^^^^^^ method not found in `&mut Compiler`\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n   --> src/compile.rs:440:30\n    |\n440 |         debug_assert!(!bytes.is_empty());\n    |                              ^^^^^^^^ method not found in `&[u8]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/compile.rs:443:32\n    |\n443 |                 Box::new(bytes.iter().rev())\n    |                                ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/compile.rs:445:32\n    |\n445 |                 Box::new(bytes.iter())\n    |                                ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `c_byte` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:448:46\n    |\n448 |         let Patch { mut hole, entry } = self.c_byte(first)?;\n    |                                              ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_byte` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:450:26\n    |\n450 |             let p = self.c_byte(b)?;\n    |                          ^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:451:18\n    |\n451 |             self.fill(hole, p.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_class_bytes` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:458:14\n    |\n458 |         self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])\n    |              ^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `is_empty` found for reference `&[ClassBytesRange]` in the current scope\n   --> src/compile.rs:462:31\n    |\n462 |         debug_assert!(!ranges.is_empty());\n    |                               ^^^^^^^^ method not found in `&[ClassBytesRange]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[ClassBytesRange]` in the current scope\n    --> src/compile.rs:467:36\n     |\n467  |         for r in &ranges[0..ranges.len() - 1] {\n     |                                    ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:468:18\n    |\n468 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:469:30\n    |\n469 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:471:31\n     |\n471  |             self.byte_classes.set_range(r.start(), r.end());\n     |                               ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:472:29\n    |\n472 |             holes.push(self.push_hole(InstHole::Bytes {\n    |                        -----^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:475:30\n    |\n475 |             prev_hole = self.fill_split(split, Some(next), None);\n    |                              ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[ClassBytesRange]` in the current scope\n    --> src/compile.rs:478:32\n     |\n478  |         let r = &ranges[ranges.len() - 1];\n     |                                ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:479:27\n     |\n479  |         self.byte_classes.set_range(r.start(), r.end());\n     |                           ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:480:25\n    |\n480 |         holes.push(self.push_hole(InstHole::Bytes {\n    |                    -----^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:483:14\n    |\n483 |         self.fill(prev_hole, next);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:488:25\n    |\n488 |         let hole = self.push_hole(InstHole::EmptyLook { look: look });\n    |                         ^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:501:46\n    |\n501 |         let Patch { mut hole, entry } = self.c(first)?;\n    |                                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:503:26\n    |\n503 |             let p = self.c(e)?;\n    |                          ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:504:18\n    |\n504 |             self.fill(hole, p.entry);\n    |                  ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:512:19\n    |\n512 |             exprs.len() >= 2, \"alternates must have at least 2 exprs\");\n    |                   ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:522:34\n    |\n522 |         for e in &exprs[0..exprs.len() - 1] {\n    |                                  ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:523:18\n    |\n523 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:524:30\n    |\n524 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:526:46\n    |\n526 |             let Patch { hole, entry } = self.c(e)?;\n    |                                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:538:30\n    |\n538 |             prev_hole = self.fill_split(split, Some(entry), None);\n    |                              ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:541:42\n    |\n541 |         let Patch { hole, entry } = self.c(&exprs[exprs.len() - 1])?;\n    |                                          ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `len` found for reference `&[Hir]` in the current scope\n   --> src/compile.rs:541:57\n    |\n541 |         let Patch { hole, entry } = self.c(&exprs[exprs.len() - 1])?;\n    |                                                         ^^^ method not found in `&[Hir]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:549:14\n    |\n549 |         self.fill(prev_hole, entry);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_zero_or_one` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:556:31\n    |\n556 |             ZeroOrOne => self.c_repeat_zero_or_one(&rep.hir, rep.greedy),\n    |                               ^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_zero_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:557:32\n    |\n557 |             ZeroOrMore => self.c_repeat_zero_or_more(&rep.hir, rep.greedy),\n    |                                ^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_one_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:558:31\n    |\n558 |             OneOrMore => self.c_repeat_one_or_more(&rep.hir, rep.greedy),\n    |                               ^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_range` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:560:22\n    |\n560 |                 self.c_repeat_range(&rep.hir, rep.greedy, min_max, min_max)\n    |                      ^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_range_min_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:563:22\n    |\n563 |                 self.c_repeat_range_min_or_more(&rep.hir, rep.greedy, min)\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_range` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:566:22\n    |\n566 |                 self.c_repeat_range(&rep.hir, rep.greedy, min, max)\n    |                      ^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:573:26\n    |\n573 |         let split = self.push_split_hole();\n    |                          ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:574:63\n    |\n574 |         let Patch { hole: hole_rep, entry: entry_rep } = self.c(expr)?;\n    |                                                               ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:577:18\n    |\n577 |             self.fill_split(split, Some(entry_rep), None)\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:579:18\n    |\n579 |             self.fill_split(split, None, Some(entry_rep))\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n   --> src/compile.rs:581:21\n    |\n581 |         let holes = vec![hole_rep, split_hole];\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ function or associated item not found in `[_]`\n    |\nhelp: there is an associated function `to_vec` with a similar name\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n    |\n116 | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117 | |         where\n118 | |             Self: Sized;\n    | |________________________^\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:587:26\n    |\n587 |         let split = self.push_split_hole();\n    |                          ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:588:63\n    |\n588 |         let Patch { hole: hole_rep, entry: entry_rep } = self.c(expr)?;\n    |                                                               ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:590:14\n    |\n590 |         self.fill(hole_rep, split_entry);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:592:18\n    |\n592 |             self.fill_split(split, Some(entry_rep), None)\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:594:18\n    |\n594 |             self.fill_split(split, None, Some(entry_rep))\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:600:63\n    |\n600 |         let Patch { hole: hole_rep, entry: entry_rep } = self.c(expr)?;\n    |                                                               ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:601:14\n    |\n601 |         self.fill_to_next(hole_rep);\n    |              ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:602:26\n    |\n602 |         let split = self.push_split_hole();\n    |                          ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:605:18\n    |\n605 |             self.fill_split(split, Some(entry_rep), None)\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:607:18\n    |\n607 |             self.fill_split(split, None, Some(entry_rep))\n    |                  ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:619:33\n    |\n619 |         let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n    |                                 ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_repeat_zero_or_more` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:620:30\n    |\n620 |         let patch_rep = self.c_repeat_zero_or_more(expr, greedy)?;\n    |                              ^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:621:14\n    |\n621 |         self.fill(patch_concat.hole, patch_rep.entry);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_concat` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:633:33\n    |\n633 |         let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n    |                                 ^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:660:18\n    |\n660 |             self.fill_to_next(prev_hole);\n    |                  ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:661:30\n    |\n661 |             let split = self.push_split_hole();\n    |                              ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:662:46\n    |\n662 |             let Patch { hole, entry } = self.c(expr)?;\n    |                                              ^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:665:33\n    |\n665 |                 holes.push(self.fill_split(split, Some(entry), None));\n    |                                 ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:667:33\n    |\n667 |                 holes.push(self.fill_split(split, None, Some(entry)));\n    |                                 ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:678:32\n    |\n678 |                 self.insts[pc].fill(goto);\n    |                                ^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `fill` not found for this enum\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:682:26\n    |\n682 |                     self.fill(hole, goto);\n    |                          ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:690:14\n    |\n690 |         self.fill(hole, next);\n    |              ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_split` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:704:40\n    |\n704 |                         self.insts[pc].fill_split(goto1, goto2);\n    |                                        ^^^^^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `fill_split` not found for this enum\n\nerror[E0599]: no method named `half_fill_split_goto1` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:708:40\n    |\n708 |                         self.insts[pc].half_fill_split_goto1(goto1);\n    |                                        ^^^^^^^^^^^^^^^^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `half_fill_split_goto1` not found for this enum\n\nerror[E0599]: no method named `half_fill_split_goto2` found for enum `MaybeInst` in the current scope\n   --> src/compile.rs:712:40\n    |\n712 |                         self.insts[pc].half_fill_split_goto2(goto2);\n    |                                        ^^^^^^^^^^^^^^^^^^^^^ method not found in `MaybeInst`\n...\n770 | enum MaybeInst {\n    | -------------- method `half_fill_split_goto2` not found for this enum\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&mut Compiler` in the current scope\n   --> src/compile.rs:722:41\n    |\n722 |                     new_holes.push(self.fill_split(hole, goto1, goto2));\n    |                                         ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill` found for reference `&InstHole` in the current scope\n   --> src/compile.rs:781:53\n    |\n781 |             MaybeInst::Uncompiled(ref inst) => inst.fill(goto),\n    |                                                     ^^^^ method not found in `&InstHole`\n\nerror[E0599]: no method named `clear` found for struct `SuffixCache` in the current scope\n   --> src/compile.rs:880:29\n    |\n880 |         self.c.suffix_cache.clear();\n    |                             ^^^^^ method not found in `SuffixCache`\n...\n983 | struct SuffixCache {\n    | ------------------ method `clear` not found for this struct\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n880 |         self.c.suffix_cache.table.clear();\n    |                             ++++++\n\nerror[E0599]: no method named `iter` found for reference `&'b [ClassUnicodeRange]` in the current scope\n   --> src/compile.rs:882:39\n    |\n882 |         for (i, range) in self.ranges.iter().enumerate() {\n    |                                       ^^^^ method not found in `&[ClassUnicodeRange]`\n\nerror[E0599]: no method named `len` found for reference `&'b [ClassUnicodeRange]` in the current scope\n    --> src/compile.rs:883:54\n     |\n883  |             let is_last_range = i + 1 == self.ranges.len();\n     |                                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `c_utf8_seq` found for struct `CompileClass` in the current scope\n   --> src/compile.rs:892:54\n    |\n869 | struct CompileClass<'a, 'b> {\n    | --------------------------- method `c_utf8_seq` not found for this struct\n...\n892 |                     let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n    |                                                      ^^^^^^^^^^ method not found in `CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `fill` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:894:28\n    |\n894 |                     self.c.fill(last_split, entry);\n    |                            ^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `fill_to_next` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:903:28\n    |\n903 |                     self.c.fill_to_next(last_split);\n    |                            ^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_split_hole` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:904:41\n    |\n904 |                     last_split = self.c.push_split_hole();\n    |                                         ^^^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_utf8_seq` found for struct `CompileClass` in the current scope\n   --> src/compile.rs:905:54\n    |\n869 | struct CompileClass<'a, 'b> {\n    | --------------------------- method `c_utf8_seq` not found for this struct\n...\n905 |                     let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n    |                                                      ^^^^^^^^^^ method not found in `CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `fill_split` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:907:41\n    |\n907 |                     last_split = self.c.fill_split(last_split, Some(entry), None);\n    |                                         ^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `c_utf8_seq_` found for mutable reference `&mut CompileClass<'a, 'b>` in the current scope\n   --> src/compile.rs:920:18\n    |\n920 |             self.c_utf8_seq_(seq)\n    |                  ^^^^^^^^^^^ method not found in `&mut CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `c_utf8_seq_` found for mutable reference `&mut CompileClass<'a, 'b>` in the current scope\n   --> src/compile.rs:922:18\n    |\n922 |             self.c_utf8_seq_(seq.into_iter().rev())\n    |                  ^^^^^^^^^^^ method not found in `&mut CompileClass<'a, 'b>`\n\nerror[E0599]: no method named `get` found for struct `SuffixCache` in the current scope\n   --> src/compile.rs:939:62\n    |\n939 |                 if let Some(cached_pc) = self.c.suffix_cache.get(key, pc) {\n    |                                                              ^^^ method not found in `SuffixCache`\n...\n983 | struct SuffixCache {\n    | ------------------ method `get` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\n\nerror[E0599]: no method named `set_range` found for struct `ByteClassSet` in the current scope\n    --> src/compile.rs:944:33\n     |\n944  |             self.c.byte_classes.set_range(byte_range.start, byte_range.end);\n     |                                 ^^^^^^^^^ method not found in `ByteClassSet`\n...\n1045 | struct ByteClassSet([bool; 256]);\n     | ------------------- method `set_range` not found for this struct\n\nerror[E0599]: no method named `push_hole` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:946:36\n    |\n946 |                 last_hole = self.c.push_hole(InstHole::Bytes {\n    |                             -------^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `push_compiled` found for mutable reference `&'a mut Compiler` in the current scope\n   --> src/compile.rs:951:24\n    |\n951 |                 self.c.push_compiled(Inst::Bytes(InstBytes {\n    |                 -------^^^^^^^^^^^^^ method not found in `&mut Compiler`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/compile.rs:957:44\n    |\n957 |             from_inst = self.c.insts.len().checked_sub(1).unwrap();\n    |                                            ^^^^^^^^^^^ method not found in `usize`\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: no method named `hash` found for mutable reference `&mut SuffixCache` in the current scope\n    --> src/compile.rs:1015:22\n     |\n1015 |         let h = self.hash(&key);\n     |                      ^^^^ method not found in `&mut SuffixCache`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `hash`, perhaps you need to implement it:\n             candidate #1: `Hash`\n\nerror[E0599]: no method named `wrapping_mul` found for type `u64` in the current scope\n    --> src/compile.rs:1038:45\n     |\n1038 |         h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);\n     |                                             ^^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `wrapping_mul` found for type `u64` in the current scope\n    --> src/compile.rs:1039:41\n     |\n1039 |         h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);\n     |                                         ^^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `wrapping_mul` found for type `u64` in the current scope\n    --> src/compile.rs:1040:39\n     |\n1040 |         h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);\n     |                                       ^^^^^^^^^^^^ method not found in `u64`\n\nerror[E0599]: no method named `set_range` found for mutable reference `&mut ByteClassSet` in the current scope\n    --> src/compile.rs:1071:18\n     |\n1071 |             self.set_range(b1 as u8, (b2 - 1) as u8);\n     |                  ^^^^^^^^^ method not found in `&mut ByteClassSet`\n\nerror[E0599]: no method named `checked_add` found for type `u8` in the current scope\n    --> src/compile.rs:1090:31\n     |\n1090 |                 class = class.checked_add(1).unwrap();\n     |                               ^^^^^^^^^^^ method not found in `u8`\n\nerror[E0599]: no method named `len` found for reference `&Program` in the current scope\n  --> src/dfa.rs:74:43\n   |\n74 |     if insts.dfa_size_limit == 0 || insts.len() > ::std::i32::MAX as usize {\n   |                                           ^^^ method not found in `&Program`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following traits define an item `len`, perhaps you need to implement one of them:\n           candidate #1: `input::Input`\n           candidate #2: `Automaton`\n           candidate #3: `ExactSizeIterator`\nhelp: some of the expressions' fields have a method of the same name\n   |\n74 |     if insts.dfa_size_limit == 0 || insts.byte_classes.len() > ::std::i32::MAX as usize {\n   |                                           +++++++++++++\n74 |     if insts.dfa_size_limit == 0 || insts.capture_name_idx.len() > ::std::i32::MAX as usize {\n   |                                           +++++++++++++++++\n74 |     if insts.dfa_size_limit == 0 || insts.captures.len() > ::std::i32::MAX as usize {\n   |                                           +++++++++\n74 |     if insts.dfa_size_limit == 0 || insts.insts.len() > ::std::i32::MAX as usize {\n   |                                           ++++++\n     and 1 other candidate\n\nerror[E0599]: no method named `is_empty` found for reference `&'a [u8]` in the current scope\n   --> src/dfa.rs:299:22\n    |\n299 |         if self.data.is_empty() {\n    |                      ^^^^^^^^ method not found in `&'a [u8]`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `dfa::Transitions` in the current scope\n   --> src/dfa.rs:432:37\n    |\n170 | struct Transitions {\n    | ------------------ function or associated item `new` not found for this struct\n...\n432 |                 trans: Transitions::new(num_byte_classes),\n    |                                     ^^^ function or associated item not found in `Transitions`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/dfa.rs:439:30\n    |\n439 |             qcur: SparseSet::new(prog.insts.len()),\n    |                              ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/dfa.rs:440:31\n    |\n440 |             qnext: SparseSet::new(prog.insts.len()),\n    |                               ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `reset_size` found for struct `CacheInner` in the current scope\n   --> src/dfa.rs:442:21\n    |\n111 | struct CacheInner {\n    | ----------------- method `reset_size` not found for this struct\n...\n442 |         cache.inner.reset_size();\n    |                     ^^^^^^^^^^ method not found in `CacheInner`\n\nerror[E0599]: no method named `start_flags` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:477:46\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_flags` not found for this struct\n...\n477 |         let (empty_flags, state_flags) = dfa.start_flags(text, at);\n    |                                              ^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:478:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_state` not found for this struct\n...\n478 |         dfa.start = match dfa.start_state(\n    |                           ----^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `exec_at` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:488:13\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `exec_at` not found for this struct\n...\n488 |         dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text)\n    |             ^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_flags_reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:510:46\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_flags_reverse` not found for this struct\n...\n510 |         let (empty_flags, state_flags) = dfa.start_flags_reverse(text, at);\n    |                                              ^^^^^^^^^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:511:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_state` not found for this struct\n...\n511 |         dfa.start = match dfa.start_state(\n    |                           ----^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `exec_at_reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:521:13\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `exec_at_reverse` not found for this struct\n...\n521 |         dfa.exec_at_reverse(&mut cache.qcur, &mut cache.qnext, text)\n    |             ^^^^^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/dfa.rs:532:31\n    |\n532 |         debug_assert!(matches.len() == prog.matches.len());\n    |                               ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `start_flags` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:544:46\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_flags` not found for this struct\n...\n544 |         let (empty_flags, state_flags) = dfa.start_flags(text, at);\n    |                                              ^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `start_state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:545:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `start_state` not found for this struct\n...\n545 |         dfa.start = match dfa.start_state(\n    |                           ----^^^^^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `exec_at` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:555:26\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `exec_at` not found for this struct\n...\n555 |         let result = dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text);\n    |                          ^^^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/dfa.rs:557:24\n    |\n557 |             if matches.len() == 1 {\n    |                        ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `state` found for struct `dfa::Fsm` in the current scope\n   --> src/dfa.rs:562:31\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ method `state` not found for this struct\n...\n562 |                 for ip in dfa.state(dfa.last_match_si).inst_ptrs() {\n    |                               ^^^^^ method not found in `Fsm<'_>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:623:25\n     |\n623  |         while at < text.len() {\n     |                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:636:53\n     |\n636  |             while next_si <= STATE_MAX && at < text.len() {\n     |                                                     ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:638:41\n    |\n638 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:640:58\n     |\n640  |                 if prev_si > STATE_MAX || at + 2 >= text.len() {\n     |                                                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:644:41\n    |\n644 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:649:41\n    |\n649 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:655:41\n    |\n655 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:676:38\n    |\n676 |                     let state = self.state(next_si);\n    |                                      ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:690:38\n     |\n690  |                     && at + 2 < text.len() {\n     |                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:693:30\n    |\n693 |                         self.next_si(next_si & !STATE_MATCH, text, at)\n    |                              ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `has_prefix` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:705:36\n    |\n705 |                 debug_assert!(self.has_prefix());\n    |                                    ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `prefix_at` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:708:33\n    |\n708 |                 at = match self.prefix_at(text, at) {\n    |                                 ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `prefix_at`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:709:57\n     |\n709  |                     None => return Result::NoMatch(text.len()),\n     |                                                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:720:34\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `byte` not found for this struct\n...\n720 |                 let byte = Byte::byte(text[at - 1]);\n    |                                  ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:728:38\n    |\n728 |                 next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n    |                                      ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:730:55\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n730 |                     Some(STATE_DEAD) => return result.set_non_match(at),\n    |                                                       ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:752:30\n    |\n752 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                              ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no function or associated item named `eof` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:752:69\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `eof` not found for this struct\n...\n752 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                                                                     ^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:754:47\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n754 |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n    |                                               ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:754:66\n     |\n754  |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n     |                                                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:761:41\n     |\n761  |             result = Result::Match(text.len());\n     |                                         ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:788:41\n    |\n788 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:794:41\n    |\n794 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:799:41\n    |\n799 |                 prev_si = unsafe { self.next_si(next_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:805:41\n    |\n805 |                 next_si = unsafe { self.next_si(prev_si, text, at) };\n    |                                         ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next_si` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:820:30\n    |\n820 |                         self.next_si(next_si & !STATE_MATCH, text, at)\n    |                              ^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:830:34\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `byte` not found for this struct\n...\n830 |                 let byte = Byte::byte(text[at]);\n    |                                  ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:833:38\n    |\n833 |                 next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n    |                                      ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:835:55\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n835 |                     Some(STATE_DEAD) => return result.set_non_match(at),\n    |                                                       ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `next_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:854:30\n    |\n854 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                              ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `next_state`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: no function or associated item named `eof` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:854:69\n    |\n405 | struct Byte(u16);\n    | ----------- function or associated item `eof` not found for this struct\n...\n854 |         prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n    |                                                                     ^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_non_match` found for enum `dfa::Result` in the current scope\n   --> src/dfa.rs:856:47\n    |\n218 | pub enum Result<T> {\n    | ------------------ method `set_non_match` not found for this enum\n...\n856 |             Some(STATE_DEAD) => return result.set_non_match(0),\n    |                                               ^^^^^^^^^^^^^ method not found in `Result<usize>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:895:32\n     |\n895  |         debug_assert!(i < text.len());\n     |                                ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `get_unchecked` found for reference `&[u8]` in the current scope\n   --> src/dfa.rs:896:23\n    |\n896 |         let b = *text.get_unchecked(i);\n    |                       ^^^^^^^^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `get_unchecked` found for struct `Vec<u8>` in the current scope\n   --> src/dfa.rs:898:43\n    |\n898 |         let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n    |                                           ^^^^^^^^^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named `next_unchecked` found for struct `dfa::Transitions` in the current scope\n   --> src/dfa.rs:899:26\n    |\n170 | struct Transitions {\n    | ------------------ method `next_unchecked` not found for this struct\n...\n899 |         self.cache.trans.next_unchecked(si, cls as usize)\n    |                          ^^^^^^^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:920:14\n    |\n920 |         qcur.clear();\n    |              ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:921:24\n    |\n921 |         for ip in self.state(si).inst_ptrs() {\n    |                        ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `insert` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:922:18\n    |\n922 |             qcur.insert(ip);\n    |                  ^^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:931:33\n    |\n931 |         let is_word_last = self.state(si).flags().is_word();\n    |                                 ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_ascii_word` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:932:25\n    |\n405 | struct Byte(u16);\n    | ----------- method `is_ascii_word` not found for this struct\n...\n932 |         let is_word = b.is_ascii_word();\n    |                         ^^^^^^^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:933:17\n    |\n933 |         if self.state(si).flags().has_empty() {\n    |                 ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_eof` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:939:18\n    |\n405 | struct Byte(u16);\n    | ----------- method `is_eof` not found for this struct\n...\n939 |             if b.is_eof() {\n    |                  ^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:942:25\n    |\n405 | struct Byte(u16);\n    | ----------- method `as_byte` not found for this struct\n...\n942 |             } else if b.as_byte().map_or(false, |b| b == b'\\n') {\n    |                         ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:952:19\n    |\n952 |             qnext.clear();\n    |                   ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `follow_epsilons` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:954:22\n    |\n954 |                 self.follow_epsilons(usize_to_u32(ip), qnext, flags);\n    |                      ^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:971:36\n    |\n405 | struct Byte(u16);\n    | ----------- method `as_byte` not found for this struct\n...\n971 |         empty_flags.start_line = b.as_byte().map_or(false, |b| b == b'\\n');\n    |                                    ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `is_ascii_word` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:972:14\n    |\n405 | struct Byte(u16);\n    | ----------- method `is_ascii_word` not found for this struct\n...\n972 |         if b.is_ascii_word() {\n    |              ^^^^^^^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_word` found for struct `StateFlags` in the current scope\n   --> src/dfa.rs:973:25\n    |\n421 | struct StateFlags(u8);\n    | ----------------- method `set_word` not found for this struct\n...\n973 |             state_flags.set_word();\n    |                         ^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:977:15\n    |\n977 |         qnext.clear();\n    |               ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `set_match` found for struct `StateFlags` in the current scope\n   --> src/dfa.rs:985:33\n    |\n421 | struct StateFlags(u8);\n    | ----------------- method `set_match` not found for this struct\n...\n985 |                     state_flags.set_match();\n    |                                 ^^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `continue_past_first_match` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:986:30\n    |\n986 |                     if !self.continue_past_first_match() {\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `contains` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:989:39\n    |\n989 | ...                   && !qnext.contains(ip as usize) {\n    |                                 ^^^^^^^^ method not found in `&mut SparseSet`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `contains`, perhaps you need to implement it:\n            candidate #1: `RangeBounds`\n\nerror[E0599]: no method named `insert` found for mutable reference `&mut SparseSet` in the current scope\n   --> src/dfa.rs:992:31\n    |\n992 |                         qnext.insert(ip);\n    |                               ^^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n   --> src/dfa.rs:996:26\n    |\n405 | struct Byte(u16);\n    | ----------- method `as_byte` not found for this struct\n...\n996 |                     if b.as_byte().map_or(false, |b| inst.matches(b)) {\n    |                          ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `matches` found for reference `&InstBytes` in the current scope\n   --> src/dfa.rs:996:59\n    |\n996 |                     if b.as_byte().map_or(false, |b| inst.matches(b)) {\n    |                                                           ^^^^^^^ method not found in `&InstBytes`\n\nerror[E0599]: no method named `follow_epsilons` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n   --> src/dfa.rs:997:30\n    |\n997 |                         self.follow_epsilons(\n    |                         -----^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_eof` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1005:18\n     |\n405  | struct Byte(u16);\n     | ----------- method `is_eof` not found for this struct\n...\n1005 |             if b.is_eof() && self.prog.matches.len() > 1 {\n     |                  ^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `cached_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1024:35\n     |\n1024 |         let mut next = match self.cached_state(\n     |                              -----^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1035:33\n     |\n1035 |             debug_assert!(!self.state(next).flags().is_match());\n     |                                 ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `start_ptr` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1036:25\n     |\n1036 |             next = self.start_ptr(next);\n     |                         ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1038:38\n     |\n1038 |         if next <= STATE_MAX && self.state(next).flags().is_match() {\n     |                                      ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `byte_class` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1044:28\n     |\n1044 |             let cls = self.byte_class(b);\n     |                            ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `set_next` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1045:30\n     |\n170  | struct Transitions {\n     | ------------------ method `set_next` not found for this struct\n...\n1045 |             self.cache.trans.set_next(si, cls, next);\n     |                              ^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `contains` found for mutable reference `&mut SparseSet` in the current scope\n    --> src/dfa.rs:1090:22\n     |\n1090 |                 if q.contains(ip as usize) {\n     |                      ^^^^^^^^ method not found in `&mut SparseSet`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `contains`, perhaps you need to implement it:\n             candidate #1: `RangeBounds`\n\nerror[E0599]: no method named `insert` found for mutable reference `&mut SparseSet` in the current scope\n    --> src/dfa.rs:1093:19\n     |\n1093 |                 q.insert(ip as usize);\n     |                   ^^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `cached_state_key` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1177:30\n     |\n1177 |         let key = match self.cached_state_key(q, &mut state_flags) {\n     |                              ^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `approximate_size` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1186:17\n     |\n1186 |         if self.approximate_size() > self.prog.dfa_size_limit\n     |                 ^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `clear_cache_and_save` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1187:22\n     |\n1187 |             && !self.clear_cache_and_save(current_state)\n     |                      ^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `add_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1193:14\n     |\n1193 |         self.add_state(key)\n     |              ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no function or associated item named `into_vec` found for slice `[_]` in the current scope\n    --> src/dfa.rs:1223:25\n     |\n1223 |         let mut insts = vec![0];\n     |                         ^^^^^^^ function or associated item not found in `[_]`\n     |\nhelp: there is an associated function `to_vec` with a similar name\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:116:9\n     |\n116  | /         fn to_vec<A: Allocator>(s: &[Self], alloc: A) -> Vec<Self, A>\n117  | |         where\n118  | |             Self: Sized;\n     | |________________________^\n     = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `set_empty` found for mutable reference `&mut StateFlags` in the current scope\n    --> src/dfa.rs:1232:33\n     |\n1232 |                     state_flags.set_empty();\n     |                                 ^^^^^^^^^ method not found in `&mut StateFlags`\n\nerror[E0599]: no method named `continue_past_first_match` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1237:30\n     |\n1237 |                     if !self.continue_past_first_match() {\n     |                              ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_match` found for mutable reference `&mut StateFlags` in the current scope\n    --> src/dfa.rs:1247:45\n     |\n1247 |         if insts.len() == 1 && !state_flags.is_match() {\n     |                                             ^^^^^^^^ method not found in `&mut StateFlags`\n\nerror[E0599]: no method named `clear_cache` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1273:26\n     |\n1273 |             None => self.clear_cache(),\n     |                          ^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1275:32\n     |\n1275 |                 let cur = self.state(*si).clone();\n     |                                ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `clear_cache` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1276:26\n     |\n1276 |                 if !self.clear_cache() {\n     |                          ^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `restore_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1282:28\n     |\n1282 |                 *si = self.restore_state(cur).unwrap();\n     |                            ^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1309:26\n     |\n1309 |         let start = self.state(self.start & !STATE_START).clone();\n     |                          ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1311:23\n     |\n1311 |             Some(self.state(self.last_match_si).clone())\n     |                       ^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `reset_size` found for mutable reference `&'a mut CacheInner` in the current scope\n    --> src/dfa.rs:1315:20\n     |\n1315 |         self.cache.reset_size();\n     |                    ^^^^^^^^^^ method not found in `&mut CacheInner`\n\nerror[E0599]: no method named `clear` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1316:26\n     |\n170  | struct Transitions {\n     | ------------------ method `clear` not found for this struct\n...\n1316 |         self.cache.trans.clear();\n     |                          ^^^^^ method not found in `Transitions`\n     |\nhelp: one of the expressions' fields has a method of the same name\n     |\n1316 |         self.cache.trans.table.clear();\n     |                          ++++++\n\nerror[E0599]: no method named `restore_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1324:30\n     |\n1324 |         let start_ptr = self.restore_state(start).unwrap();\n     |                              ^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `start_ptr` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1325:27\n     |\n1325 |         self.start = self.start_ptr(start_ptr);\n     |                           ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `restore_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1327:39\n     |\n1327 |             self.last_match_si = self.restore_state(last_match).unwrap();\n     |                                       ^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `add_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1340:14\n     |\n1340 |         self.add_state(state)\n     |              ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `next` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1365:32\n     |\n170  | struct Transitions {\n     | ------------------ method `next` not found for this struct\n...\n1365 |         match self.cache.trans.next(si, self.byte_class(b)) {\n     |                                ^^^^ method not found in `Transitions`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `next`, perhaps you need to implement it:\n             candidate #1: `Iterator`\n\nerror[E0599]: no method named `byte_class` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1365:46\n     |\n1365 |         match self.cache.trans.next(si, self.byte_class(b)) {\n     |                                              ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `exec_byte` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1366:35\n     |\n1366 |             STATE_UNKNOWN => self.exec_byte(qcur, qnext, si, b),\n     |                                   ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_word` found for struct `StateFlags` in the current scope\n    --> src/dfa.rs:1398:28\n     |\n421  | struct StateFlags(u8);\n     | ----------------- method `is_word` not found for this struct\n...\n1398 |              ((state_flags.is_word() as u8) << 6))\n     |                            ^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `clear` found for mutable reference `&mut SparseSet` in the current scope\n    --> src/dfa.rs:1406:11\n     |\n1406 |         q.clear();\n     |           ^^^^^ method not found in `&mut SparseSet`\n\nerror[E0599]: no method named `follow_epsilons` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1408:14\n     |\n1408 |         self.follow_epsilons(start, q, empty_flags);\n     |              ^^^^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `cached_state` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1413:29\n     |\n1413 |         let sp = match self.cached_state(q, state_flags, None) {\n     |                             ^^^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `start_ptr` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1415:30\n     |\n1415 |             Some(sp) => self.start_ptr(sp),\n     |                              ^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1429:32\n     |\n1429 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1431:37\n     |\n1431 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1433:44\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1433 |         let is_word_last = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n     |                                            ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1434:33\n     |\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                 ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1434:48\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                                ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_word` found for struct `StateFlags` in the current scope\n    --> src/dfa.rs:1436:25\n     |\n421  | struct StateFlags(u8);\n     | ----------------- method `set_word` not found for this struct\n...\n1436 |             state_flags.set_word();\n     |                         ^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1457:40\n     |\n1457 |         empty_flags.start = at == text.len();\n     |                                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1458:32\n     |\n1458 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1459:45\n     |\n1459 |         empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n     |                                             ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1460:37\n     |\n1460 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ method not found in `&[u8]`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1463:23\n     |\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                       ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1463:38\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                      ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1464:39\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1464 |         let is_word = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n     |                                       ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_word` found for struct `StateFlags` in the current scope\n    --> src/dfa.rs:1466:25\n     |\n421  | struct StateFlags(u8);\n     | ----------------- method `set_word` not found for this struct\n...\n1466 |             state_flags.set_word();\n     |                         ^^^^^^^^ method not found in `StateFlags`\n\nerror[E0599]: no method named `num_byte_classes` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1478:47\n     |\n1478 |         &self.cache.states[si as usize / self.num_byte_classes()]\n     |                                               ^^^^^^^^^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `add` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1493:41\n     |\n170  | struct Transitions {\n     | ------------------ method `add` not found for this struct\n...\n1493 |         let si = match self.cache.trans.add() {\n     |                                         ^^^ method not found in `Transitions`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `add`, perhaps you need to implement it:\n             candidate #1: `Add`\n\nerror[E0599]: no method named `byte_class` found for mutable reference `&mut dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1503:32\n     |\n1503 |                 let cls = self.byte_class(Byte::byte(b as u8));\n     |                                ^^^^^^^^^^ method not found in `&mut Fsm<'a>`\n\nerror[E0599]: no function or associated item named `byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1503:49\n     |\n405  | struct Byte(u16);\n     | ----------- function or associated item `byte` not found for this struct\n...\n1503 |                 let cls = self.byte_class(Byte::byte(b as u8));\n     |                                                 ^^^^ function or associated item not found in `dfa::Byte`\n\nerror[E0599]: no method named `set_next` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1504:34\n     |\n170  | struct Transitions {\n     | ------------------ method `set_next` not found for this struct\n...\n1504 |                 self.cache.trans.set_next(si, cls, STATE_QUIT);\n     |                                  ^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `state_heap_size` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1510:30\n     |\n170  | struct Transitions {\n     | ------------------ method `state_heap_size` not found for this struct\n...\n1510 |             self.cache.trans.state_heap_size()\n     |                              ^^^^^^^^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: the method `len` exists for struct `Box<[u8]>`, but its trait bounds were not satisfied\n    --> src/dfa.rs:1511:31\n     |\n1511 |               + (2 * state.data.len())\n     |                                 ^^^\n     |\n    ::: /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:238:1\n     |\n238  | / pub struct Box<\n239  | |     T: ?Sized,\n240  | |     #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n241  | | >(Unique<T>, A);\n     | |_- doesn't satisfy `Box<[u8]>: ExactSizeIterator`\n     |\n     = note: the following trait bounds were not satisfied:\n             `[u8]: ExactSizeIterator`\n             which is required by `Box<[u8]>: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n49   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `num_states` found for struct `dfa::Transitions` in the current scope\n    --> src/dfa.rs:1518:43\n     |\n170  | struct Transitions {\n     | ------------------ method `num_states` not found for this struct\n...\n1518 |                       == self.cache.trans.num_states());\n     |                                           ^^^^^^^^^^ method not found in `Transitions`\n\nerror[E0599]: no method named `find` found for struct `LiteralSearcher` in the current scope\n    --> src/dfa.rs:1531:28\n     |\n1531 |         self.prog.prefixes.find(&text[at..]).map(|(s, _)| at + s)\n     |                            ^^^^ method not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `find` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `find`, perhaps you need to implement one of them:\n             candidate #1: `Automaton`\n             candidate #2: `Iterator`\n\nerror[E0599]: no method named `as_byte` found for struct `dfa::Byte` in the current scope\n    --> src/dfa.rs:1547:17\n     |\n405  | struct Byte(u16);\n     | ----------- method `as_byte` not found for this struct\n...\n1547 |         match b.as_byte() {\n     |                 ^^^^^^^ method not found in `dfa::Byte`\n\nerror[E0599]: no method named `num_byte_classes` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1548:26\n     |\n1548 |             None => self.num_byte_classes() - 1,\n     |                          ^^^^^^^^^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `u8_class` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1549:29\n     |\n1549 |             Some(b) => self.u8_class(b),\n     |                             ^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n    --> src/dfa.rs:1574:32\n     |\n1574 |         && !self.prog.prefixes.is_empty()\n     |                                ^^^^^^^^ method not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `is_empty` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n             candidate #1: `input::Input`\n             candidate #2: `Automaton`\n             candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `has_prefix` found for reference `&dfa::Fsm<'a>` in the current scope\n    --> src/dfa.rs:1584:17\n     |\n1584 |         if self.has_prefix() {\n     |                 ^^^^^^^^^^ method not found in `&Fsm<'a>`\n\nerror[E0599]: no method named `approximate_size` found for reference `&'a Program` in the current scope\n    --> src/dfa.rs:1597:37\n     |\n1597 |         self.cache.size + self.prog.approximate_size()\n     |                                     ^^^^^^^^^^^^^^^^ method not found in `&Program`\n\nerror[E0599]: no method named `get_unchecked` found for struct `Vec<u32>` in the current scope\n    --> src/dfa.rs:1654:21\n     |\n1654 |         *self.table.get_unchecked(si as usize + cls)\n     |                     ^^^^^^^^^^^^^ method not found in `Vec<u32>`\n\nerror[E0599]: no method named `as_byte` found for reference `&dfa::Byte` in the current scope\n    --> src/dfa.rs:1690:28\n     |\n1690 |         let b = match self.as_byte() {\n     |                            ^^^^^^^ method not found in `&dfa::Byte`\n\nerror[E0599]: no method named `is_eof` found for reference `&dfa::Byte` in the current scope\n    --> src/dfa.rs:1701:17\n     |\n1701 |         if self.is_eof() {\n     |                 ^^^^^^ method not found in `&dfa::Byte`\n\nerror[E0599]: no method named `inst_ptrs` found for reference `&State` in the current scope\n    --> src/dfa.rs:1711:36\n     |\n1711 |         let ips: Vec<usize> = self.inst_ptrs().collect();\n     |                                    ^^^^^^^^^ method not found in `&State`\n\nerror[E0599]: no method named `flags` found for reference `&State` in the current scope\n    --> src/dfa.rs:1713:32\n     |\n1713 |          .field(\"flags\", &self.flags())\n     |                                ^^^^^ method not found in `&State`\n\nerror[E0599]: no method named `num_states` found for reference `&dfa::Transitions` in the current scope\n    --> src/dfa.rs:1722:27\n     |\n1722 |         for si in 0..self.num_states() {\n     |                           ^^^^^^^^^^ method not found in `&Transitions`\n\nerror[E0599]: no method named `iter` found for reference `&'a [u32]` in the current scope\n    --> src/dfa.rs:1736:31\n     |\n1736 |         for (b, si) in self.0.iter().enumerate() {\n     |                               ^^^^ method not found in `&'a [u32]`\n\nerror[E0599]: no method named `is_match` found for reference `&StateFlags` in the current scope\n    --> src/dfa.rs:1754:35\n     |\n1754 |          .field(\"is_match\", &self.is_match())\n     |                                   ^^^^^^^^ method not found in `&StateFlags`\n\nerror[E0599]: no method named `is_word` found for reference `&StateFlags` in the current scope\n    --> src/dfa.rs:1755:34\n     |\n1755 |          .field(\"is_word\", &self.is_word())\n     |                                  ^^^^^^^ method not found in `&StateFlags`\n\nerror[E0599]: no method named `has_empty` found for reference `&StateFlags` in the current scope\n    --> src/dfa.rs:1756:36\n     |\n1756 |          .field(\"has_empty\", &self.has_empty())\n     |                                    ^^^^^^^^^ method not found in `&StateFlags`\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n    --> src/dfa.rs:1833:25\n     |\n1833 |     for (i, &b) in data.iter().enumerate() {\n     |                         ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `new_many` found for struct `ExecBuilder` in the current scope\n   --> src/exec.rs:120:15\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_many` not found for this struct\n...\n120 |         Self::new_many(&[re])\n    |               ^^^^^^^^ function or associated item not found in `ExecBuilder`\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/exec.rs:132:15\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n...\n132 |         Self::new_options(opts)\n    |               ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n   --> src/exec.rs:286:31\n    |\n286 |                 nfa: Program::new(),\n    |                               ^^^ function or associated item not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n   --> src/exec.rs:287:31\n    |\n287 |                 dfa: Program::new(),\n    |                               ^^^ function or associated item not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Program` in the current scope\n   --> src/exec.rs:288:39\n    |\n288 |                 dfa_reverse: Program::new(),\n    |                                       ^^^ function or associated item not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `empty` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:289:44\n    |\n289 |                 suffixes: LiteralSearcher::empty(),\n    |                                            ^^^^^ function or associated item not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- function or associated item `empty` not found for this struct\n\nerror[E0599]: no method named `parse` found for struct `ExecBuilder` in the current scope\n   --> src/exec.rs:294:27\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- method `parse` not found for this struct\n...\n294 |         let parsed = self.parse()?;\n    |                           ^^^^^ method not found in `ExecBuilder`\n\nerror[E0599]: no function or associated item named `new` found for struct `Compiler` in the current scope\n   --> src/exec.rs:296:23\n    |\n296 |             Compiler::new()\n    |                       ^^^ function or associated item not found in `Compiler`\n    |\n   ::: src/compile.rs:37:1\n    |\n37  | pub struct Compiler {\n    | ------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Compiler` in the current scope\n   --> src/exec.rs:302:23\n    |\n302 |             Compiler::new()\n    |                       ^^^ function or associated item not found in `Compiler`\n    |\n   ::: src/compile.rs:37:1\n    |\n37  | pub struct Compiler {\n    | ------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Compiler` in the current scope\n   --> src/exec.rs:308:23\n    |\n308 |             Compiler::new()\n    |                       ^^^ function or associated item not found in `Compiler`\n    |\n   ::: src/compile.rs:37:1\n    |\n37  | pub struct Compiler {\n    | ------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `prefixes` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:317:41\n    |\n317 |         nfa.prefixes = LiteralSearcher::prefixes(prefixes);\n    |                                         ^^^^^^^^ function or associated item not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- function or associated item `prefixes` not found for this struct\n\nerror[E0599]: no function or associated item named `suffixes` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:327:40\n    |\n327 |             suffixes: LiteralSearcher::suffixes(suffixes),\n    |                                        ^^^^^^^^ function or associated item not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- function or associated item `suffixes` not found for this struct\n\nerror[E0599]: no method named `choose_match_type` found for struct `ExecReadOnly` in the current scope\n   --> src/exec.rs:330:28\n    |\n65  | struct ExecReadOnly {\n    | ------------------- method `choose_match_type` not found for this struct\n...\n330 |         ro.match_type = ro.choose_match_type(self.match_type);\n    |                            ^^^^^^^^^^^^^^^^^ method not found in `ExecReadOnly`\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:343:24\n    |\n343 |         next_utf8(text.as_bytes(), i)\n    |                        ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:348:39\n    |\n348 |         self.0.shortest_match_at(text.as_bytes(), start)\n    |                                       ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:353:33\n    |\n353 |         self.0.is_match_at(text.as_bytes(), start)\n    |                                 ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:358:29\n    |\n358 |         self.0.find_at(text.as_bytes(), start)\n    |                             ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/exec.rs:368:44\n    |\n368 |         self.0.read_captures_at(locs, text.as_bytes(), start)\n    |                                            ^^^^^^^^ method not found in `&str`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:390:18\n    |\n390 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:395:22\n    |\n395 |                 self.find_literals(ty, text, start).map(|(_, e)| e)\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `shortest_dfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:398:28\n    |\n398 |                 match self.shortest_dfa(text, start) {\n    |                            ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:401:47\n    |\n401 |                     dfa::Result::Quit => self.shortest_nfa(text, start),\n    |                                               ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:405:33\n    |\n405 |                 match dfa::Fsm::reverse(\n    |                                 ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:410:26\n     |\n410  |                     text.len(),\n     |                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:412:56\n     |\n412  |                     dfa::Result::Match(_) => Some(text.len()),\n     |                                                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `shortest_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:414:47\n    |\n414 |                     dfa::Result::Quit => self.shortest_nfa(text, start),\n    |                                               ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:418:28\n    |\n418 |                 match self.shortest_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:421:47\n    |\n421 |                     dfa::Result::Quit => self.shortest_nfa(text, start),\n    |                                               ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:424:40\n    |\n424 |             MatchType::Nfa(ty) => self.shortest_nfa_type(ty, text, start),\n    |                                        ^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:435:18\n    |\n435 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:443:22\n    |\n443 |                 self.find_literals(ty, text, start).is_some()\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `shortest_dfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:446:28\n    |\n446 |                 match self.shortest_dfa(text, start) {\n    |                            ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `match_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:449:47\n    |\n449 |                     dfa::Result::Quit => self.match_nfa(text, start),\n    |                                               ^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:453:33\n    |\n453 |                 match dfa::Fsm::reverse(\n    |                                 ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:458:26\n     |\n458  |                     text.len(),\n     |                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `match_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:462:47\n    |\n462 |                     dfa::Result::Quit => self.match_nfa(text, start),\n    |                                               ^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:466:28\n    |\n466 |                 match self.shortest_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `match_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:469:47\n    |\n469 |                     dfa::Result::Quit => self.match_nfa(text, start),\n    |                                               ^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `match_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:472:40\n    |\n472 |             MatchType::Nfa(ty) => self.match_nfa_type(ty, text, start),\n    |                                        ^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:481:18\n    |\n481 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:486:22\n    |\n486 |                 self.find_literals(ty, text, start)\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `find_dfa_forward` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:489:28\n    |\n489 |                 match self.find_dfa_forward(text, start) {\n    |                            ^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:493:30\n    |\n493 |                         self.find_nfa(MatchNfaType::Auto, text, start)\n    |                              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_dfa_anchored_reverse` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:498:28\n    |\n498 |                 match self.find_dfa_anchored_reverse(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:502:30\n    |\n502 |                         self.find_nfa(MatchNfaType::Auto, text, start)\n    |                              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:507:28\n    |\n507 |                 match self.find_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:511:30\n    |\n511 |                         self.find_nfa(MatchNfaType::Auto, text, start)\n    |                              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:515:40\n    |\n515 |             MatchType::Nfa(ty) => self.find_nfa(ty, text, start),\n    |                                        ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `iter_mut` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/exec.rs:538:27\n    |\n538 |         for slot in slots.iter_mut() {\n    |                           ^^^^^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [Option<usize>]`, but its trait bounds were not satisfied\n   --> src/exec.rs:543:21\n    |\n543 |         match slots.len() {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[Option<usize>]: ExactSizeIterator`\n            which is required by `&mut [Option<usize>]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:554:18\n    |\n554 |         if !self.is_anchor_end_match(text) {\n    |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:559:22\n    |\n559 |                 self.find_literals(ty, text, start).and_then(|(s, e)| {\n    |                      ^^^^^^^^^^^^^\n    |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:151:5\n    |\n151 | /     fn find_iter (\n152 | |         self,\n153 | |         text: &Self::Text,\n154 | |     ) -> Matches<Self> {\n    | |______________________^\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:560:26\n    |\n560 |                     self.captures_nfa_with_match(slots, text, s, e)\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:565:26\n    |\n565 |                     self.captures_nfa(slots, text, start)\n    |                          ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find_dfa_forward` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:567:32\n    |\n567 |                     match self.find_dfa_forward(text, start) {\n    |                                ^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:569:34\n    |\n569 | ...                   self.captures_nfa_with_match(slots, text, s, e)\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:572:51\n    |\n572 |                         dfa::Result::Quit => self.captures_nfa(slots, text, start),\n    |                                                   ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find_dfa_anchored_reverse` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:577:28\n    |\n577 |                 match self.find_dfa_anchored_reverse(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:579:30\n    |\n579 |                         self.captures_nfa_with_match(slots, text, s, e)\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:582:47\n    |\n582 |                     dfa::Result::Quit => self.captures_nfa(slots, text, start),\n    |                                               ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:586:28\n    |\n586 |                 match self.find_dfa_reverse_suffix(text, start) {\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `captures_nfa_with_match` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:588:30\n    |\n588 |                         self.captures_nfa_with_match(slots, text, s, e)\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:591:47\n    |\n591 |                     dfa::Result::Quit => self.captures_nfa(slots, text, start),\n    |                                               ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:595:22\n    |\n595 |                 self.captures_nfa_type(ty, slots, text, start)\n    |                      ^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `find` found for reference `&LiteralSearcher` in the current scope\n   --> src/exec.rs:618:22\n    |\n618 |                 lits.find(&text[start..])\n    |                      ^^^^ method not found in `&LiteralSearcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `find_start` found for reference `&LiteralSearcher` in the current scope\n   --> src/exec.rs:625:26\n    |\n625 |                     lits.find_start(&text[start..])\n    |                          ^^^^^^^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: no method named `find_end` found for reference `&LiteralSearcher` in the current scope\n   --> src/exec.rs:633:22\n    |\n633 |                 lits.find_end(&text[start..])\n    |                      ^^^^^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: no function or associated item named `forward` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:650:35\n    |\n650 |         let end = match dfa::Fsm::forward(\n    |                                   ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `forward` not found for this struct\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:663:25\n    |\n663 |         match dfa::Fsm::reverse(\n    |                         ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:689:25\n    |\n689 |         match dfa::Fsm::reverse(\n    |                         ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:694:18\n     |\n694  |             text.len() - start,\n     |                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:696:48\n     |\n696  |             Match(s) => Match((start + s, text.len())),\n     |                                                ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `forward` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:705:19\n    |\n705 |         dfa::Fsm::forward(&self.ro.dfa, self.cache, true, text, start)\n    |                   ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `forward` not found for this struct\n\nerror[E0599]: no method named `exec_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:717:20\n    |\n717 |         match self.exec_dfa_reverse_suffix(text, start) {\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_dfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:718:26\n    |\n718 |             None => self.shortest_dfa(text, start),\n    |                          ^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `lcs` found for struct `LiteralSearcher` in the current scope\n   --> src/exec.rs:744:36\n    |\n744 |         let lcs = self.ro.suffixes.lcs();\n    |                                    ^^^ private field, not a method\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `lcs` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:748:27\n     |\n748  |         while end <= text.len() {\n     |                           ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:751:50\n     |\n751  |                 None => return Some(NoMatch(text.len())),\n     |                                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `reverse` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:754:29\n    |\n754 |             match dfa::Fsm::reverse(\n    |                             ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `reverse` not found for this struct\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:767:27\n     |\n767  |         Some(NoMatch(text.len()))\n     |                           ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `exec_dfa_reverse_suffix` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:783:38\n    |\n783 |         let match_start = match self.exec_dfa_reverse_suffix(text, start) {\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `find_dfa_forward` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:784:33\n    |\n784 |             None => return self.find_dfa_forward(text, start),\n    |                                 ^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `forward` found for struct `dfa::Fsm` in the current scope\n   --> src/exec.rs:795:25\n    |\n795 |         match dfa::Fsm::forward(\n    |                         ^^^^^^^ function or associated item not found in `Fsm<'_>`\n    |\n   ::: src/dfa.rs:179:1\n    |\n179 | pub struct Fsm<'a> {\n    | ------------------ function or associated item `forward` not found for this struct\n\nerror[E0599]: no method named `match_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:818:14\n    |\n818 |         self.match_nfa_type(MatchNfaType::Auto, text, start)\n    |              ^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:828:14\n    |\n828 |         self.exec_nfa(ty, &mut [false], &mut [], true, text, start)\n    |              ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `shortest_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:833:14\n    |\n833 |         self.shortest_nfa_type(MatchNfaType::Auto, text, start)\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:844:17\n    |\n844 |         if self.exec_nfa(ty, &mut [false], &mut slots, true, text, start) {\n    |                 ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:859:17\n    |\n859 |         if self.exec_nfa(ty, &mut [false], &mut slots, false, text, start) {\n    |                 ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:885:63\n     |\n885  |             next_utf8(text, next_utf8(text, match_end)), text.len());\n     |                                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `captures_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:886:14\n    |\n886 |         self.captures_nfa(slots, &text[..e], match_start)\n    |              ^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `captures_nfa_type` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:898:14\n    |\n898 |         self.captures_nfa_type(MatchNfaType::Auto, slots, text, start)\n    |              ^^^^^^^^^^^^^^^^^\n    |\nhelp: there is a method `captures_iter` with a similar name, but with different arguments\n   --> src/re_trait.rs:165:5\n    |\n165 | /     fn captures_iter(\n166 | |         self,\n167 | |         text: &Self::Text,\n168 | |     ) -> CaptureMatches<Self> {\n    | |_____________________________^\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:909:17\n    |\n909 |         if self.exec_nfa(ty, &mut [false], slots, false, text, start) {\n    |                 ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `len` found for struct `Program` in the current scope\n   --> src/exec.rs:930:51\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n    |                                                   ^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `len` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\nhelp: some of the expressions' fields have a method of the same name\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.byte_classes.len(), text.len()) {\n    |                                                   +++++++++++++\n930 |             if backtrack::should_exec(self.ro.nfa.capture_name_idx.len(), text.len()) {\n    |                                                   +++++++++++++++++\n930 |             if backtrack::should_exec(self.ro.nfa.captures.len(), text.len()) {\n    |                                                   +++++++++\n930 |             if backtrack::should_exec(self.ro.nfa.insts.len(), text.len()) {\n    |                                                   ++++++\n      and 1 other candidate\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:930:63\n     |\n930  |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n     |                                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `exec_backtrack` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:938:31\n    |\n938 |             Backtrack => self.exec_backtrack(matches, slots, text, start),\n    |                               ^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_pikevm` found for reference `&ExecNoSync<'c>` in the current scope\n   --> src/exec.rs:940:22\n    |\n940 |                 self.exec_pikevm(\n    |                 -----^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/exec.rs:955:24\n    |\n955 |         if self.ro.nfa.uses_bytes() {\n    |                        ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no function or associated item named `exec` found for struct `pikevm::Fsm` in the current scope\n   --> src/exec.rs:956:26\n    |\n956 |             pikevm::Fsm::exec(\n    |                          ^^^^ function or associated item not found in `Fsm<'_, _>`\n    |\n   ::: src/pikevm.rs:38:1\n    |\n38  | pub struct Fsm<'r, I> {\n    | --------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `ByteInput<'_>` in the current scope\n   --> src/exec.rs:962:28\n    |\n962 |                 ByteInput::new(text, self.ro.nfa.only_utf8),\n    |                            ^^^ function or associated item not found in `ByteInput<'_>`\n    |\n   ::: src/input.rs:227:1\n    |\n227 | pub struct ByteInput<'t> {\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `exec` found for struct `pikevm::Fsm` in the current scope\n   --> src/exec.rs:965:26\n    |\n965 |             pikevm::Fsm::exec(\n    |                          ^^^^ function or associated item not found in `Fsm<'_, _>`\n    |\n   ::: src/pikevm.rs:38:1\n    |\n38  | pub struct Fsm<'r, I> {\n    | --------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `CharInput<'_>` in the current scope\n   --> src/exec.rs:971:28\n    |\n971 |                 CharInput::new(text),\n    |                            ^^^ function or associated item not found in `CharInput<'_>`\n    |\n   ::: src/input.rs:140:1\n    |\n140 | pub struct CharInput<'t>(&'t [u8]);\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `uses_bytes` found for struct `Program` in the current scope\n   --> src/exec.rs:984:24\n    |\n984 |         if self.ro.nfa.uses_bytes() {\n    |                        ^^^^^^^^^^ method not found in `Program`\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ method `uses_bytes` not found for this struct\n\nerror[E0599]: no function or associated item named `exec` found for struct `backtrack::Bounded` in the current scope\n   --> src/exec.rs:985:33\n    |\n985 |             backtrack::Bounded::exec(\n    |                                 ^^^^ function or associated item not found in `Bounded<'_, '_, '_, '_, _>`\n    |\n   ::: src/backtrack.rs:54:1\n    |\n54  | pub struct Bounded<'a, 'm, 'r, 's, I> {\n    | ------------------------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `ByteInput<'_>` in the current scope\n   --> src/exec.rs:990:28\n    |\n990 |                 ByteInput::new(text, self.ro.nfa.only_utf8),\n    |                            ^^^ function or associated item not found in `ByteInput<'_>`\n    |\n   ::: src/input.rs:227:1\n    |\n227 | pub struct ByteInput<'t> {\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `exec` found for struct `backtrack::Bounded` in the current scope\n   --> src/exec.rs:993:33\n    |\n993 |             backtrack::Bounded::exec(\n    |                                 ^^^^ function or associated item not found in `Bounded<'_, '_, '_, '_, _>`\n    |\n   ::: src/backtrack.rs:54:1\n    |\n54  | pub struct Bounded<'a, 'm, 'r, 's, I> {\n    | ------------------------------------- function or associated item `exec` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `exec`, perhaps you need to implement it:\n            candidate #1: `std::os::unix::process::CommandExt`\n\nerror[E0599]: no function or associated item named `new` found for struct `CharInput<'_>` in the current scope\n   --> src/exec.rs:998:28\n    |\n998 |                 CharInput::new(text),\n    |                            ^^^ function or associated item not found in `CharInput<'_>`\n    |\n   ::: src/input.rs:140:1\n    |\n140 | pub struct CharInput<'t>(&'t [u8]);\n    | ------------------------ function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_anchor_end_match` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1017:18\n     |\n1017 |         if !self.is_anchor_end_match(text) {\n     |                  ^^^^^^^^^^^^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n    --> src/exec.rs:1022:42\n     |\n1022 |                 debug_assert_eq!(matches.len(), 1);\n     |                                          ^^^\n     |\n     = note: the following trait bounds were not satisfied:\n             `[bool]: ExactSizeIterator`\n             which is required by `&mut [bool]: ExactSizeIterator`\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `find_literals` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1023:35\n     |\n1023 |                 matches[0] = self.find_literals(ty, text, start).is_some();\n     |                                   ^^^^^^^^^^^^^\n     |\nhelp: there is a method `find_iter` with a similar name, but with different arguments\n    --> src/re_trait.rs:151:5\n     |\n151  | /     fn find_iter (\n152  | |         self,\n153  | |         text: &Self::Text,\n154  | |     ) -> Matches<Self> {\n     | |______________________^\n\nerror[E0599]: no function or associated item named `forward_many` found for struct `dfa::Fsm` in the current scope\n    --> src/exec.rs:1027:33\n     |\n1027 |                 match dfa::Fsm::forward_many(\n     |                                 ^^^^^^^^^^^^ function or associated item not found in `Fsm<'_>`\n     |\n    ::: src/dfa.rs:179:1\n     |\n179  | pub struct Fsm<'a> {\n     | ------------------ function or associated item `forward_many` not found for this struct\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1037:30\n     |\n1037 |                         self.exec_nfa(\n     |                         -----^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `exec_nfa` found for reference `&ExecNoSync<'c>` in the current scope\n    --> src/exec.rs:1047:29\n     |\n1047 |             Nfa(ty) => self.exec_nfa(ty, matches, &mut [], false, text, start),\n     |                             ^^^^^^^^ method not found in `&ExecNoSync<'c>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/exec.rs:1055:17\n     |\n1055 |         if text.len() > (1<<20) && self.ro.nfa.is_anchored_end {\n     |                 ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `lcs` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1056:40\n     |\n1056 |             let lcs = self.ro.suffixes.lcs();\n     |                                        ^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `lcs` not found for this struct\n\nerror[E0599]: no method named `capture_name_idx` found for struct `ExecNoSync` in the current scope\n    --> src/exec.rs:1071:16\n     |\n52   | pub struct ExecNoSync<'c> {\n     | ------------------------- method `capture_name_idx` not found for this struct\n...\n1071 |         self.0.capture_name_idx()\n     |                ^^^^^^^^^^^^^^^^ method not found in `ExecNoSync<'c>`\n\nerror[E0599]: no function or associated item named `new` found for struct `ProgramCacheInner` in the current scope\n    --> src/exec.rs:1079:66\n     |\n1079 |         let create = || Box::new(RefCell::new(ProgramCacheInner::new(&self.ro)));\n     |                                                                  ^^^ function or associated item not found in `ProgramCacheInner`\n...\n1275 | pub struct ProgramCacheInner {\n     | ---------------------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `searcher` found for reference `&Exec` in the current scope\n    --> src/exec.rs:1089:28\n     |\n1089 |         ExecNoSyncStr(self.searcher())\n     |                            ^^^^^^^^ method not found in `&Exec`\n\nerror[E0599]: no method named `complete` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1161:34\n     |\n1161 |             if self.nfa.prefixes.complete() {\n     |                                  ^^^^^^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `complete` not found for this struct\n\nerror[E0599]: no method named `complete` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1168:30\n     |\n1168 |             if self.suffixes.complete() {\n     |                              ^^^^^^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `complete` not found for this struct\n\nerror[E0599]: no method named `should_suffix_scan` found for reference `&ExecReadOnly` in the current scope\n    --> src/exec.rs:1192:21\n     |\n1192 |             if self.should_suffix_scan() {\n     |                     ^^^^^^^^^^^^^^^^^^ method not found in `&ExecReadOnly`\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1217:26\n     |\n1217 |         if self.suffixes.is_empty() {\n     |                          ^^^^^^^^ method not found in `LiteralSearcher`\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `is_empty` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n             candidate #1: `input::Input`\n             candidate #2: `Automaton`\n             candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `lcs` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1220:37\n     |\n1220 |         let lcs_len = self.suffixes.lcs().char_len();\n     |                                     ^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `lcs` not found for this struct\n\nerror[E0599]: no method named `lcp` found for struct `LiteralSearcher` in the current scope\n    --> src/exec.rs:1221:53\n     |\n1221 |         lcs_len >= 3 && lcs_len > self.dfa.prefixes.lcp().char_len()\n     |                                                     ^^^ private field, not a method\n     |\n    ::: src/literal/mod.rs:31:1\n     |\n31   | pub struct LiteralSearcher {\n     | -------------------------- method `lcp` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `pikevm::Cache` in the current scope\n    --> src/exec.rs:1285:36\n     |\n1285 |             pikevm: pikevm::Cache::new(&ro.nfa),\n     |                                    ^^^ function or associated item not found in `Cache`\n     |\n    ::: src/pikevm.rs:52:1\n     |\n52   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `backtrack::Cache` in the current scope\n    --> src/exec.rs:1286:42\n     |\n1286 |             backtrack: backtrack::Cache::new(&ro.nfa),\n     |                                          ^^^ function or associated item not found in `Cache`\n     |\n    ::: src/backtrack.rs:65:1\n     |\n65   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1287:30\n     |\n1287 |             dfa: dfa::Cache::new(&ro.dfa),\n     |                              ^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `dfa::Cache` in the current scope\n    --> src/exec.rs:1288:38\n     |\n1288 |             dfa_reverse: dfa::Cache::new(&ro.dfa_reverse),\n     |                                      ^^^ function or associated item not found in `dfa::Cache`\n     |\n    ::: src/dfa.rs:92:1\n     |\n92   | pub struct Cache {\n     | ---------------- function or associated item `new` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_empty` found for reference `&str` in the current scope\n  --> src/expand.rs:13:24\n   |\n13 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n  --> src/expand.rs:14:40\n   |\n14 |         match memchr(b'$', replacement.as_bytes()) {\n   |                                        ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n  --> src/expand.rs:21:24\n   |\n21 |         if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty` found for reference `&str` in the current scope\n  --> src/expand.rs:26:36\n   |\n26 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ method not found in `&str`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_unicode::Captures<'_>` in the current scope\n  --> src/expand.rs:39:26\n   |\n39 |                     caps.get(i).map(|m| m.as_str()).unwrap_or(\"\"));\n   |                          ^^^ method not found in `&Captures<'_>`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `get`, perhaps you need to implement it:\n           candidate #1: `SliceIndex`\n\nerror[E0599]: no method named `name` found for reference `&re_unicode::Captures<'_>` in the current scope\n  --> src/expand.rs:43:26\n   |\n43 |                     caps.name(name).map(|m| m.as_str()).unwrap_or(\"\"));\n   |                          ^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n  --> src/expand.rs:55:24\n   |\n55 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ method not found in `&[u8]`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n  --> src/expand.rs:63:24\n   |\n63 |         if replacement.get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n63 |         if replacement.ge(1).map_or(false, |&b| b == b'$') {\n   |                        ~~\n\nerror[E0599]: no method named `is_empty` found for reference `&[u8]` in the current scope\n  --> src/expand.rs:68:36\n   |\n68 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ method not found in `&[u8]`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n  --> src/input.rs:79:1\n   |\n79 | pub trait Input {\n   | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_bytes::Captures<'_>` in the current scope\n  --> src/expand.rs:81:26\n   |\n81 |                     caps.get(i).map(|m| m.as_bytes()).unwrap_or(b\"\"));\n   |                          ^^^ method not found in `&Captures<'_>`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `get`, perhaps you need to implement it:\n           candidate #1: `SliceIndex`\n\nerror[E0599]: no method named `name` found for reference `&re_bytes::Captures<'_>` in the current scope\n  --> src/expand.rs:85:26\n   |\n85 |                     caps.name(name).map(|m| m.as_bytes()).unwrap_or(b\"\"));\n   |                          ^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/expand.rs:133:12\n     |\n133  |     if rep.len() <= 1 || rep[0] != b'$' {\n     |            ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n1    + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/expand.rs:143:15\n    |\n143 |     while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n143 |     while rep.ge(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ~~\n\nerror[E0599]: no method named `get` found for reference `&[u8]` in the current scope\n   --> src/expand.rs:155:17\n    |\n155 |         if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n155 |         if !rep.ge(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ~~\n\nerror[E0599]: no method named `parse` found for reference `&str` in the current scope\n   --> src/expand.rs:161:24\n    |\n161 |         cap: match cap.parse::<u32>() {\n    |                        ^^^^^ method not found in `&str`\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:40:16\n    |\n40  |         self.c.is_none() && self.byte.is_none()\n    |                ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `len_utf8` found for struct `input::Char` in the current scope\n   --> src/input.rs:164:20\n    |\n164 |             len: c.len_utf8(),\n    |                    ^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `len_utf8` not found for this struct\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:169:12\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n...\n169 |         at.char()\n    |            ^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:173:37\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n173 |         decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    |                                     ^^^-- help: remove the arguments\n    |                                     |\n    |                                     field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:181:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n181 |                 at.pos() == 0 || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:185:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n185 |                 at.pos() == self.len() || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:187:29\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n187 |             StartText => at.pos() == 0,\n    |                             ^^^-- help: remove the arguments\n    |                             |\n    |                             field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:188:27\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n188 |             EndText => at.pos() == self.len(),\n    |                           ^^^-- help: remove the arguments\n    |                           |\n    |                           field, not a method\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:191:20\n    |\n191 |                 c1.is_word_char() != c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:191:41\n    |\n191 |                 c1.is_word_char() != c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:195:20\n    |\n195 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:195:41\n    |\n195 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:199:20\n    |\n199 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:199:41\n    |\n199 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:203:20\n    |\n203 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:203:41\n    |\n203 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `find` found for reference `&LiteralSearcher` in the current scope\n   --> src/input.rs:213:18\n    |\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                  ^^^^ method not found in `&LiteralSearcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:213:32\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                ^^^-- help: remove the arguments\n    |                                |\n    |                                field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:213:66\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                                  ^^^-- help: remove the arguments\n    |                                                                  |\n    |                                                                  field, not a method\n\nerror[E0599]: the method `len` exists for reference `&'t [u8]`, but its trait bounds were not satisfied\n   --> src/input.rs:217:16\n    |\n217 |         self.0.len()\n    |                ^^^\n    |\nnote: the following trait bounds were not satisfied:\n      `[u8]: Sized`\n      `[u8]: input::Input`\n   --> src/input.rs:114:10\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |          ^  ^^^^^  -----     -----\n    |          |  |\n    |          |  unsatisfied trait bound introduced here\n    |          unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is in scope\nhelp: consider relaxing the type parameter's implicit `Sized` bound\n    |\n114 | impl<'a, T: ?Sized + Input> Input for &'a T {\n    |             ++++++++\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `get` found for reference `&ByteInput<'t>` in the current scope\n   --> src/input.rs:255:24\n    |\n255 |             byte: self.get(i).cloned(),\n    |                        ^^^\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: there is a method `ge` with a similar name\n    |\n255 |             byte: self.ge(i).cloned(),\n    |                        ~~\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:261:30\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n261 |         decode_utf8(&self[at.pos()..]).map(|(c, _)| c).into()\n    |                              ^^^-- help: remove the arguments\n    |                              |\n    |                              field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:265:37\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n265 |         decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    |                                     ^^^-- help: remove the arguments\n    |                                     |\n    |                                     field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:273:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n273 |                 at.pos() == 0 || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:277:20\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n277 |                 at.pos() == self.len() || c == '\\n'\n    |                    ^^^-- help: remove the arguments\n    |                    |\n    |                    field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:279:29\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n279 |             StartText => at.pos() == 0,\n    |                             ^^^-- help: remove the arguments\n    |                             |\n    |                             field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:280:27\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n280 |             EndText => at.pos() == self.len(),\n    |                           ^^^-- help: remove the arguments\n    |                           |\n    |                           field, not a method\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:283:20\n    |\n283 |                 c1.is_word_char() != c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:283:41\n    |\n283 |                 c1.is_word_char() != c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:287:20\n    |\n287 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_word_char` found for struct `input::Char` in the current scope\n   --> src/input.rs:287:41\n    |\n287 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_char` not found for this struct\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:294:27\n    |\n294 |                     if c1.is_none() && !at.is_start() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:294:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n...\n294 |                     if c1.is_none() && !at.is_start() {\n    |                                            ^^^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:297:27\n    |\n297 |                     if c2.is_none() && !at.is_end() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:297:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n...\n297 |                     if c2.is_none() && !at.is_end() {\n    |                                            ^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:301:20\n    |\n301 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:301:41\n    |\n301 |                 c1.is_word_byte() != c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:308:27\n    |\n308 |                     if c1.is_none() && !at.is_start() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:308:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n...\n308 |                     if c1.is_none() && !at.is_start() {\n    |                                            ^^^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_none` found for struct `input::Char` in the current scope\n   --> src/input.rs:311:27\n    |\n311 |                     if c2.is_none() && !at.is_end() {\n    |                           ^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_none` not found for this struct\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:311:44\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n...\n311 |                     if c2.is_none() && !at.is_end() {\n    |                                            ^^^^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:315:20\n    |\n315 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                    ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `is_word_byte` found for struct `input::Char` in the current scope\n   --> src/input.rs:315:41\n    |\n315 |                 c1.is_word_byte() == c2.is_word_byte()\n    |                                         ^^^^^^^^^^^^ method not found in `Char`\n...\n346 | pub struct Char(u32);\n    | --------------- method `is_word_byte` not found for this struct\n\nerror[E0599]: no method named `find` found for reference `&LiteralSearcher` in the current scope\n   --> src/input.rs:325:18\n    |\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                  ^^^^ method not found in `&LiteralSearcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:325:32\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                ^^^-- help: remove the arguments\n    |                                |\n    |                                field, not a method\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/input.rs:325:66\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n...\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                                  ^^^-- help: remove the arguments\n    |                                                                  |\n    |                                                                  field, not a method\n\nerror[E0599]: the method `len` exists for reference `&'t [u8]`, but its trait bounds were not satisfied\n   --> src/input.rs:329:19\n    |\n329 |         self.text.len()\n    |                   ^^^\n    |\nnote: the following trait bounds were not satisfied:\n      `[u8]: Sized`\n      `[u8]: input::Input`\n   --> src/input.rs:114:10\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |          ^  ^^^^^  -----     -----\n    |          |  |\n    |          |  unsatisfied trait bound introduced here\n    |          unsatisfied trait bound introduced here\n    = help: items from traits can only be used if the trait is in scope\nhelp: consider relaxing the type parameter's implicit `Sized` bound\n    |\n114 | impl<'a, T: ?Sized + Input> Input for &'a T {\n    |             ++++++++\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `len_utf8` found for type `char` in the current scope\n   --> src/input.rs:367:48\n    |\n367 |         char::from_u32(self.0).map_or(0, |c| c.len_utf8())\n    |                                                ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:477:15\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n477 |         if at.pos() > 0 {\n    |               ^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:478:31\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n478 |             Some(self.data[at.pos() - 1])\n    |                               ^^^ method not found in `InputAt`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:485:15\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n485 |         if at.pos() < self.len() {\n    |               ^^^ method not found in `InputAt`\n\nerror[E0599]: the method `len` exists for reference `&Tester`, but its trait bounds were not satisfied\n   --> src/input.rs:485:28\n    |\n462 | struct Tester {\n    | ------------- doesn't satisfy `Tester: input::Input`\n...\n485 |         if at.pos() < self.len() {\n    |                            ^^^ method cannot be called on `&Tester` due to unsatisfied trait bounds\n    |\nnote: trait bound `Tester: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `pos` found for struct `llmtests::InputAt` in the current scope\n   --> src/input.rs:486:31\n    |\n426 | struct InputAt {\n    | -------------- method `pos` not found for this struct\n...\n486 |             Some(self.data[at.pos()])\n    |                               ^^^ method not found in `InputAt`\n\nerror[E0599]: the method `previous_char` exists for reference `&Tester`, but its trait bounds were not satisfied\n   --> src/input.rs:495:38\n    |\n462 | struct Tester {\n    | ------------- doesn't satisfy `Tester: input::Input`\n...\n495 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ method cannot be called on `&Tester` due to unsatisfied trait bounds\n    |\nnote: trait bound `Tester: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `previous_char`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `next_char` exists for reference `&Tester`, but its trait bounds were not satisfied\n   --> src/input.rs:495:62\n    |\n462 | struct Tester {\n    | ------------- doesn't satisfy `Tester: input::Input`\n...\n495 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ method cannot be called on `&Tester` due to unsatisfied trait bounds\n    |\nnote: trait bound `Tester: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `next_char`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_ascii_alphanumeric` found for type `u8` in the current scope\n   --> src/input.rs:505:14\n    |\n505 |         self.is_ascii_alphanumeric() || self == b'_'\n    |              ^^^^^^^^^^^^^^^^^^^^^ method not found in `u8`\n\nerror[E0599]: no function or associated item named `new` found for struct `Tester` in the current scope\n   --> src/input.rs:512:26\n    |\n462 | struct Tester {\n    | ------------- function or associated item `new` not found for this struct\n...\n512 |     let tester = Tester::new(false, b\"hello123\".to_vec());\n    |                          ^^^ function or associated item not found in `Tester`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `to_vec` found for reference `&'static [u8; 8]` in the current scope\n   --> src/input.rs:512:49\n    |\n512 |     let tester = Tester::new(false, b\"hello123\".to_vec());\n    |                                                 ^^^^^^ method not found in `&[u8; 8]`\n\nerror[E0599]: no function or associated item named `new` found for struct `LiteralSearcher` in the current scope\n  --> src/literal/mod.rs:61:15\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `new` not found for this struct\n...\n61 |         Self::new(Literals::empty(), Matcher::Empty)\n   |               ^^^ function or associated item not found in `LiteralSearcher`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no variant or associated item named `prefixes` found for enum `Matcher` in the current scope\n  --> src/literal/mod.rs:66:32\n   |\n39 | enum Matcher {\n   | ------------ variant or associated item `prefixes` not found for this enum\n...\n66 |         let matcher = Matcher::prefixes(&lits);\n   |                                ^^^^^^^^ variant or associated item not found in `Matcher`\n\nerror[E0599]: no function or associated item named `new` found for struct `LiteralSearcher` in the current scope\n  --> src/literal/mod.rs:67:15\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `new` not found for this struct\n...\n67 |         Self::new(lits, matcher)\n   |               ^^^ function or associated item not found in `LiteralSearcher`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no variant or associated item named `suffixes` found for enum `Matcher` in the current scope\n  --> src/literal/mod.rs:72:32\n   |\n39 | enum Matcher {\n   | ------------ variant or associated item `suffixes` not found for this enum\n...\n72 |         let matcher = Matcher::suffixes(&lits);\n   |                                ^^^^^^^^ variant or associated item not found in `Matcher`\n\nerror[E0599]: no function or associated item named `new` found for struct `LiteralSearcher` in the current scope\n  --> src/literal/mod.rs:73:15\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `new` not found for this struct\n...\n73 |         Self::new(lits, matcher)\n   |               ^^^ function or associated item not found in `LiteralSearcher`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:80:31\n    |\n80  |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n    |                               ^^^ function or associated item not found in `FreqyPacked`\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n  --> src/literal/mod.rs:80:64\n   |\n80 |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n   |                                                                ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `new` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:81:31\n    |\n81  |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n    |                               ^^^ function or associated item not found in `FreqyPacked`\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `to_vec` found for reference `&[u8]` in the current scope\n  --> src/literal/mod.rs:81:64\n   |\n81 |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n   |                                                                ^^^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `is_empty` exists for reference `&LiteralSearcher`, but its trait bounds were not satisfied\n  --> src/literal/mod.rs:93:32\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- doesn't satisfy `LiteralSearcher: Automaton<_>`\n...\n93 |         self.complete && !self.is_empty()\n   |                                ^^^^^^^^ method cannot be called on `&LiteralSearcher` due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n           `LiteralSearcher: Automaton<_>`\n           which is required by `&LiteralSearcher: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n  --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n   |\n11 | pub trait Automaton<P> {\n   | ^^^^^^^^^^^^^^^^^^^^^^\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n           candidate #1: `input::Input`\n           candidate #2: `Automaton`\n           candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `find` exists for reference `&SingleByteSet`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:102:37\n    |\n102 |             Bytes(ref sset) => sset.find(haystack).map(|i| (i, i + 1)),\n    |                                     ^^^^ method cannot be called on `&SingleByteSet` due to unsatisfied trait bounds\n...\n330 | struct SingleByteSet {\n    | -------------------- doesn't satisfy `SingleByteSet: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `SingleByteSet: Automaton<_>`\n            which is required by `&SingleByteSet: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `find` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:103:37\n    |\n103 |             FreqyPacked(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                     ^^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `len` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:103:70\n    |\n103 |             FreqyPacked(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                                                      ^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `find` exists for reference `&BoyerMooreSearch`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:104:36\n    |\n104 |             BoyerMoore(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                    ^^^^ method cannot be called on `&BoyerMooreSearch` due to unsatisfied trait bounds\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- doesn't satisfy `BoyerMooreSearch: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `BoyerMooreSearch: Automaton<_>`\n            which is required by `&BoyerMooreSearch: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `len` exists for reference `&BoyerMooreSearch`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:104:69\n    |\n104 |             BoyerMoore(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n    |                                                                     ^^^ method cannot be called on `&BoyerMooreSearch` due to unsatisfied trait bounds\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- doesn't satisfy `BoyerMooreSearch: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `BoyerMooreSearch: Automaton<_>`\n            which is required by `&BoyerMooreSearch: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `find` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:106:36\n    |\n106 |             TeddySSSE3(ref t) => t.find(haystack).map(|m| (m.start, m.end)),\n    |                                    ^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_ssse3::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_ssse3::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_ssse3::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: the method `find` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:107:35\n    |\n107 |             TeddyAVX2(ref t) => t.find(haystack).map(|m| (m.start, m.end)),\n    |                                   ^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_avx2::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_avx2::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_avx2::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `find`, perhaps you need to implement one of them:\n            candidate #1: `Automaton`\n    = note: the trait `Iterator` defines an item `find`, but is explicitly unimplemented\n\nerror[E0599]: no method named `iter` found for reference `&LiteralSearcher` in the current scope\n   --> src/literal/mod.rs:113:25\n    |\n113 |         for lit in self.iter() {\n    |                         ^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:114:37\n    |\n114 |             if lit.len() > haystack.len() {\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&LiteralSearcher` in the current scope\n   --> src/literal/mod.rs:126:25\n    |\n126 |         for lit in self.iter() {\n    |                         ^^^^ method not found in `&LiteralSearcher`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:127:37\n    |\n127 |             if lit.len() > haystack.len() {\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:130:42\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                          ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:131:39\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                       ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:131:67\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `patterns` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:146:45\n    |\n146 |                 LiteralIter::TeddySSSE3(ted.patterns())\n    |                                             ^^^^^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_ssse3::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_ssse3::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_ssse3::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `patterns`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: the method `patterns` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:149:44\n    |\n149 |                 LiteralIter::TeddyAVX2(ted.patterns())\n    |                                            ^^^^^^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_avx2::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_avx2::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_avx2::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `patterns`, perhaps you need to implement it:\n            candidate #1: `Automaton`\n\nerror[E0599]: the method `len` exists for reference `&LiteralSearcher`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:166:14\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- doesn't satisfy `LiteralSearcher: Automaton<_>`\n...\n166 |         self.len() == 0\n    |              ^^^ method cannot be called on `&LiteralSearcher` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `LiteralSearcher: Automaton<_>`\n            which is required by `&LiteralSearcher: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:178:40\n    |\n178 |             TeddySSSE3(ref ted) => ted.len(),\n    |                                        ^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_ssse3::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_ssse3::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_ssse3::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for reference `&Teddy`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:179:39\n    |\n179 |             TeddyAVX2(ref ted) => ted.len(),\n    |                                       ^^^ method cannot be called on `&Teddy` due to unsatisfied trait bounds\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- doesn't satisfy `teddy_avx2::imp::Teddy: Automaton<_>`\n    |\n    = note: the following trait bounds were not satisfied:\n            `teddy_avx2::imp::Teddy: Automaton<_>`\n            which is required by `&teddy_avx2::imp::Teddy: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `approximate_size` found for reference `&SingleByteSet` in the current scope\n   --> src/literal/mod.rs:188:37\n    |\n188 |             Bytes(ref sset) => sset.approximate_size(),\n    |                                     ^^^^^^^^^^^^^^^^ method not found in `&SingleByteSet`\n\nerror[E0599]: no method named `approximate_size` found for reference `&literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:189:47\n    |\n189 |             FreqyPacked(ref single) => single.approximate_size(),\n    |                                               ^^^^^^^^^^^^^^^^ method not found in `&FreqyPacked`\n\nerror[E0599]: no method named `approximate_size` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:190:46\n    |\n190 |             BoyerMoore(ref single) => single.approximate_size(),\n    |                                              ^^^^^^^^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: no method named `approximate_size` found for reference `&teddy_ssse3::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:192:40\n    |\n192 |             TeddySSSE3(ref ted) => ted.approximate_size(),\n    |                                        ^^^^^^^^^^^^^^^^ method not found in `&Teddy`\n\nerror[E0599]: no method named `approximate_size` found for reference `&teddy_avx2::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:193:39\n    |\n193 |             TeddyAVX2(ref ted) => ted.approximate_size(),\n    |                                       ^^^^^^^^^^^^^^^^ method not found in `&Teddy`\n\nerror[E0599]: no function or associated item named `prefixes` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:200:35\n    |\n200 |         let sset = SingleByteSet::prefixes(lits);\n    |                                   ^^^^^^^^ function or associated item not found in `SingleByteSet`\n...\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `prefixes` not found for this struct\n\nerror[E0599]: no variant or associated item named `new` found for enum `Matcher` in the current scope\n   --> src/literal/mod.rs:201:18\n    |\n39  | enum Matcher {\n    | ------------ variant or associated item `new` not found for this enum\n...\n201 |         Matcher::new(lits, sset)\n    |                  ^^^ variant or associated item not found in `Matcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `suffixes` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:205:35\n    |\n205 |         let sset = SingleByteSet::suffixes(lits);\n    |                                   ^^^^^^^^ function or associated item not found in `SingleByteSet`\n...\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `suffixes` not found for this struct\n\nerror[E0599]: no variant or associated item named `new` found for enum `Matcher` in the current scope\n   --> src/literal/mod.rs:206:18\n    |\n39  | enum Matcher {\n    | ------------ variant or associated item `new` not found for this enum\n...\n206 |         Matcher::new(lits, sset)\n    |                  ^^^ variant or associated item not found in `Matcher`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: the method `is_empty` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:210:28\n    |\n210 |         if lits.literals().is_empty() {\n    |                            ^^^^^^^^ method cannot be called on `&[Literal]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:225:28\n    |\n225 |         if lits.literals().len() == 1 {\n    |                            ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `to_vec` found for struct `syntax::hir::literal::Literal` in the current scope\n   --> src/literal/mod.rs:226:42\n    |\n226 |             let lit = lits.literals()[0].to_vec();\n    |                                          ^^^^^^ method not found in `Literal`\n\nerror[E0599]: no function or associated item named `should_use` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:227:34\n    |\n227 |             if BoyerMooreSearch::should_use(lit.as_slice()) {\n    |                                  ^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `should_use` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:228:62\n    |\n228 |                 return Matcher::BoyerMoore(BoyerMooreSearch::new(lit));\n    |                                                              ^^^ function or associated item not found in `BoyerMooreSearch`\n...\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:230:58\n    |\n230 |                 return Matcher::FreqyPacked(FreqyPacked::new(lit));\n    |                                                          ^^^ function or associated item not found in `FreqyPacked`\n...\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `available` found for struct `teddy_avx2::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:234:23\n    |\n234 |         if TeddyAVX2::available() && !is_aho_corasick_fast {\n    |                       ^^^^^^^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `available` not found for this struct\n\nerror[E0599]: the method `len` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:236:32\n    |\n236 |             if lits.literals().len() <= MAX_TEDDY_LITERALS {\n    |                                ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `teddy_avx2::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:237:47\n    |\n237 |                 if let Some(ted) = TeddyAVX2::new(lits) {\n    |                                               ^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_avx2/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `available` found for struct `teddy_ssse3::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:242:24\n    |\n242 |         if TeddySSSE3::available() && !is_aho_corasick_fast {\n    |                        ^^^^^^^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `available` not found for this struct\n\nerror[E0599]: the method `len` exists for reference `&[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:253:32\n    |\n253 |             if lits.literals().len() <= MAX_TEDDY_LITERALS {\n    |                                ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `teddy_ssse3::imp::Teddy` in the current scope\n   --> src/literal/mod.rs:254:48\n    |\n254 |                 if let Some(ted) = TeddySSSE3::new(lits) {\n    |                                                ^^^ function or associated item not found in `Teddy`\n    |\n   ::: src/literal/teddy_ssse3/fallback.rs:4:1\n    |\n4   | pub struct Teddy(());\n    | ---------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:281:25\n    |\n281 |                 if many.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[u8]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[u8]: ExactSizeIterator`\n            which is required by `&mut &[u8]: ExactSizeIterator`\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:290:24\n    |\n290 |                 if one.is_empty() {\n    |                        ^^^^^^^^ method cannot be called on `&mut &[u8]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[u8]: ExactSizeIterator`\n            which is required by `&mut &[u8]: ExactSizeIterator`\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[Literal]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:299:25\n    |\n299 |                 if lits.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[Literal]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[syntax::hir::literal::Literal]: ExactSizeIterator`\n            which is required by `&mut &[syntax::hir::literal::Literal]: ExactSizeIterator`\n            `[syntax::hir::literal::Literal]: Automaton<_>`\n            which is required by `&[syntax::hir::literal::Literal]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[Vec<u8>]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:308:25\n    |\n308 |                 if lits.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[Vec<u8>]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[Vec<u8>]: ExactSizeIterator`\n            which is required by `&mut &[Vec<u8>]: ExactSizeIterator`\n            `[Vec<u8>]: Automaton<_>`\n            which is required by `&[Vec<u8>]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `is_empty` exists for mutable reference `&mut &[Vec<u8>]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:317:25\n    |\n317 |                 if lits.is_empty() {\n    |                         ^^^^^^^^ method cannot be called on `&mut &[Vec<u8>]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `&[Vec<u8>]: ExactSizeIterator`\n            which is required by `&mut &[Vec<u8>]: ExactSizeIterator`\n            `[Vec<u8>]: Automaton<_>`\n            which is required by `&[Vec<u8>]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `new` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:348:39\n    |\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `new` not found for this struct\n...\n348 |         let mut sset = SingleByteSet::new();\n    |                                       ^^^ function or associated item not found in `SingleByteSet`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `get` found for reference `&syntax::hir::literal::Literal` in the current scope\n   --> src/literal/mod.rs:351:35\n    |\n351 |             if let Some(&b) = lit.get(0) {\n    |                                   ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n351 |             if let Some(&b) = lit.ge(0) {\n    |                                   ~~\n\nerror[E0599]: no function or associated item named `new` found for struct `SingleByteSet` in the current scope\n   --> src/literal/mod.rs:365:39\n    |\n330 | struct SingleByteSet {\n    | -------------------- function or associated item `new` not found for this struct\n...\n365 |         let mut sset = SingleByteSet::new();\n    |                                       ^^^ function or associated item not found in `SingleByteSet`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `get` found for reference `&syntax::hir::literal::Literal` in the current scope\n   --> src/literal/mod.rs:368:35\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                   ^^^\n    |\nhelp: there is a method `ge` with a similar name\n    |\n368 |             if let Some(&b) = lit.ge(lit.len().checked_sub(1).unwrap()) {\n    |                                   ~~\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/literal/mod.rs:368:49\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                                 ^^^^^^^^^^^ method not found in `usize`\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: no method named `_find` found for reference `&SingleByteSet` in the current scope\n   --> src/literal/mod.rs:389:23\n    |\n389 |             _ => self._find(text),\n    |                       ^^^^^ method not found in `&SingleByteSet`\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:395:33\n    |\n395 |         for (i, &b) in haystack.iter().enumerate() {\n    |                                 ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no function or associated item named `empty` found for struct `literal::FreqyPacked` in the current scope\n   --> src/literal/mod.rs:449:33\n    |\n420 | pub struct FreqyPacked {\n    | ---------------------- function or associated item `empty` not found for this struct\n...\n449 |             return FreqyPacked::empty();\n    |                                 ^^^^^ function or associated item not found in `FreqyPacked`\n\nerror[E0599]: no method named `iter` found for slice `[u8]` in the current scope\n   --> src/literal/mod.rs:456:27\n    |\n456 |         for b in pat[1..].iter().cloned() {\n    |                           ^^^^ method not found in `[u8]`\n\nerror[E0599]: no method named `iter` found for struct `Vec<u8>` in the current scope\n   --> src/literal/mod.rs:470:26\n    |\n470 |         let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    |                          ^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: no method named `iter` found for struct `Vec<u8>` in the current scope\n   --> src/literal/mod.rs:471:26\n    |\n471 |         let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n    |                          ^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:498:21\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:498:33\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `is_empty` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:498:46\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                              ^^^^^^^^ method cannot be called on `&[u8]` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:502:28\n    |\n502 |         while i < haystack.len() {\n    |                            ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:508:35\n    |\n508 |             let end = start + pat.len();\n    |                                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:509:31\n    |\n509 |             if end > haystack.len() {\n    |                               ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:523:17\n    |\n523 |         if text.len() < self.len() {\n    |                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:523:30\n    |\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n...\n523 |         if text.len() < self.len() {\n    |                              ^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:526:19\n    |\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&FreqyPacked`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:526:32\n    |\n420 | pub struct FreqyPacked {\n    | ---------------------- doesn't satisfy `literal::FreqyPacked: Automaton<_>`\n...\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                                ^^^ method cannot be called on `&FreqyPacked` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `literal::FreqyPacked: Automaton<_>`\n            which is required by `&literal::FreqyPacked: Automaton<_>`\nnote: the trait `Automaton` must be implemented\n   --> /home/abezbm/.cargo/registry/src/index.crates.io-6f17d22bba15001f/aho-corasick-0.6.10/src/autiter.rs:11:1\n    |\n11  | pub trait Automaton<P> {\n    | ^^^^^^^^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `chars` found for enum `Cow<'_, str>` in the current scope\n   --> src/literal/mod.rs:543:36\n    |\n543 |     String::from_utf8_lossy(bytes).chars().count()\n    |                                    ^^^^^ method not found in `Cow<'_, str>`\n\nerror[E0599]: no function or associated item named `select_guard` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:615:29\n    |\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `select_guard` not found for this struct\n...\n615 |         let (g, gi) = Self::select_guard(pattern.as_slice());\n    |                             ^^^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n\nerror[E0599]: no function or associated item named `compile_skip_table` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:616:32\n    |\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `compile_skip_table` not found for this struct\n...\n616 |         let skip_table = Self::compile_skip_table(pattern.as_slice());\n    |                                ^^^^^^^^^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n\nerror[E0599]: no function or associated item named `compile_md2_shift` found for struct `BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:617:31\n    |\n586 | pub struct BoyerMooreSearch {\n    | --------------------------- function or associated item `compile_md2_shift` not found for this struct\n...\n617 |         let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n    |                               ^^^^^^^^^^^^^^^^^ function or associated item not found in `BoyerMooreSearch`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:632:21\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:646:21\n    |\n646 |         if haystack.len() > short_circut {\n    |                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:648:37\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `skip_loop` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:650:41\n    |\n650 |                 window_end = match self.skip_loop(haystack, window_end, backstop) {\n    |                                         ^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: no method named `check_match` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:658:25\n    |\n658 |                 if self.check_match(haystack, window_end) {\n    |                         ^^^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:670:37\n    |\n670 |         while window_end < haystack.len() {\n    |                                     ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `check_match` found for reference `&BoyerMooreSearch` in the current scope\n   --> src/literal/mod.rs:673:25\n    |\n673 |                 if self.check_match(haystack, window_end) {\n    |                         ^^^^^^^^^^^ method not found in `&BoyerMooreSearch`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:732:35\n    |\n732 |         let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n    |                                   ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:739:17\n    |\n739 |         pattern.len() > MIN_LEN\n    |                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:741:24\n    |\n741 |             && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    |                        ^^^^ method not found in `&[u8]`\n\nerror[E0599]: no method named `checked_sub` found for type `usize` in the current scope\n   --> src/literal/mod.rs:815:34\n    |\n814 |   ...                   window_end = window_end\n    |  ____________________________________-\n815 | | ...                       .checked_sub(1 + self.guard_reverse_idx)\n    | |                           -^^^^^^^^^^^ method not found in `usize`\n    | |___________________________|\n    |\n   --> /rust/deps/gimli-0.29.0/src/read/reader.rs:51:8\n    |\n    = note: the method is available for `usize` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReaderOffset` which provides `checked_sub` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use gimli::read::reader::ReaderOffset;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:835:36\n    |\n835 |         let mut tab = vec![pattern.len(); 256];\n    |                                    ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:842:31\n    |\n842 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:843:41\n    |\n843 |             tab[*c as usize] = (pattern.len() - 1) - i;\n    |                                         ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:853:42\n    |\n853 |         let mut rarest_rev_idx = pattern.len() - 1;\n    |                                          ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `iter` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:854:31\n    |\n854 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ method not found in `&[u8]`\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:857:43\n    |\n857 |                 rarest_rev_idx = (pattern.len() - 1) - i;\n    |                                           ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `last` found for reference `&[u8]` in the current scope\n   --> src/literal/mod.rs:868:31\n    |\n868 |         let shiftc = *pattern.last().unwrap();\n    |                               ^^^^ `&[u8]` is not an iterator\n    |\nhelp: call `.into_iter()` first\n    |\n868 |         let shiftc = *pattern.into_iter().last().unwrap();\n    |                               ++++++++++++\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:873:20\n    |\n873 |         if pattern.len() == 1 {\n    |                    ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:877:29\n    |\n877 |         let mut i = pattern.len() - 2;\n    |                             ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:880:33\n    |\n880 |                 return (pattern.len() - 1) - i;\n    |                                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: the method `len` exists for reference `&[u8]`, but its trait bounds were not satisfied\n   --> src/literal/mod.rs:887:17\n    |\n887 |         pattern.len() - 1\n    |                 ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8]: Automaton<_>`\n            which is required by `&[u8]: Automaton<_>`\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n    |\n11  + use object::read::read_ref::ReadRef;\n    |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1007:24\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                        ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1007:42\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                                          ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1009:31\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1009:47\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/literal/mod.rs:1011:43\n     |\n1011 |                 && &haystack[i..(i+needle.len())] == needle {\n     |                                           ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n902  +     use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no function or associated item named `new` found for struct `Threads` in the current scope\n  --> src/pikevm.rs:90:29\n   |\n62 | struct Threads {\n   | -------------- function or associated item `new` not found for this struct\n...\n90 |             clist: Threads::new(),\n   |                             ^^^ function or associated item not found in `Threads`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `Threads` in the current scope\n  --> src/pikevm.rs:91:29\n   |\n62 | struct Threads {\n   | -------------- function or associated item `new` not found for this struct\n...\n91 |             nlist: Threads::new(),\n   |                             ^^^ function or associated item not found in `Threads`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following trait defines an item `new`, perhaps you need to implement it:\n           candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `resize` found for struct `Threads` in the current scope\n   --> src/pikevm.rs:113:21\n    |\n62  | struct Threads {\n    | -------------- method `resize` not found for this struct\n...\n113 |         cache.clist.resize(prog.len(), prog.captures.len());\n    |                     ^^^^^^ method not found in `Threads`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n113 |         cache.clist.caps.resize(prog.len(), prog.captures.len());\n    |                     +++++\n\nerror[E0599]: the method `len` exists for reference `&Program`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:113:33\n    |\n113 |         cache.clist.resize(prog.len(), prog.captures.len());\n    |                                 ^^^ method cannot be called on `&Program` due to unsatisfied trait bounds\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ doesn't satisfy `Program: input::Input`\n    |\nnote: trait bound `Program: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `resize` found for struct `Threads` in the current scope\n   --> src/pikevm.rs:114:21\n    |\n62  | struct Threads {\n    | -------------- method `resize` not found for this struct\n...\n114 |         cache.nlist.resize(prog.len(), prog.captures.len());\n    |                     ^^^^^^ method not found in `Threads`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n114 |         cache.nlist.caps.resize(prog.len(), prog.captures.len());\n    |                     +++++\n\nerror[E0599]: the method `len` exists for reference `&Program`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:114:33\n    |\n114 |         cache.nlist.resize(prog.len(), prog.captures.len());\n    |                                 ^^^ method cannot be called on `&Program` due to unsatisfied trait bounds\n    |\n   ::: src/prog.rs:18:1\n    |\n18  | pub struct Program {\n    | ------------------ doesn't satisfy `Program: input::Input`\n    |\nnote: trait bound `Program: input::Input` was not satisfied\n   --> src/input.rs:114:13\n    |\n114 | impl<'a, T: Input> Input for &'a T {\n    |             ^^^^^  -----     -----\n    |             |\n    |             unsatisfied trait bound introduced here\nnote: the trait `input::Input` must be implemented\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `exec_` found for struct `pikevm::Fsm` in the current scope\n   --> src/pikevm.rs:120:11\n    |\n38  |   pub struct Fsm<'r, I> {\n    |   --------------------- method `exec_` not found for this struct\n...\n116 | /         Fsm {\n117 | |             prog: prog,\n118 | |             stack: &mut cache.stack,\n119 | |             input: input,\n120 | |         }.exec_(\n    | |          -^^^^^ method not found in `Fsm<'_, I>`\n    | |__________|\n    |\n\nerror[E0599]: no method named `clear` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:141:19\n    |\n141 |         clist.set.clear();\n    |                   ^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `clear` not found for this struct\n\nerror[E0599]: no method named `clear` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:142:19\n    |\n142 |         nlist.set.clear();\n    |                   ^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `clear` not found for this struct\n\nerror[E0599]: no method named `is_empty` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:144:26\n    |\n144 |             if clist.set.is_empty() {\n    |                          ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:155:40\n    |\n155 |                 if (matched && matches.len() <= 1)\n    |                                        ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_start` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:157:29\n    |\n157 |                     || (!at.is_start() && self.prog.is_anchored_start) {\n    |                             ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_start` not found for this struct\n\nerror[E0599]: no method named `is_empty` found for struct `LiteralSearcher` in the current scope\n   --> src/pikevm.rs:164:40\n    |\n164 |                 if !self.prog.prefixes.is_empty() {\n    |                                        ^^^^^^^^ method not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `is_empty` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:175:26\n    |\n175 |             if clist.set.is_empty()\n    |                          ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `is_empty` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `is_empty`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:177:22\n    |\n177 |                 self.add(&mut clist, slots, 0, at);\n    |                      ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `next_pos` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:183:44\n    |\n183 |             let at_next = self.input.at(at.next_pos());\n    |                                            ^^^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `next_pos` not found for this struct\n\nerror[E0599]: no method named `len` found for struct `SparseSet` in the current scope\n    --> src/pikevm.rs:184:35\n     |\n184  |             for i in 0..clist.set.len() {\n     |                                   ^^^\n     |\n    ::: src/sparse.rs:15:1\n     |\n15   | pub struct SparseSet {\n     | -------------------- method `len` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following traits define an item `len`, perhaps you need to implement one of them:\n             candidate #1: `input::Input`\n             candidate #2: `Automaton`\n             candidate #3: `ExactSizeIterator`\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `step` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:186:25\n    |\n186 |                 if self.step(\n    |                    -----^^^^ method not found in `&mut Fsm<'r, I>`\n\nerror[E0599]: no method named `caps` found for mutable reference `&mut Threads` in the current scope\n   --> src/pikevm.rs:190:27\n    |\n190 |                     clist.caps(ip),\n    |                           ^^^^---- help: remove the arguments\n    |                           |\n    |                           field, not a method\n\nerror[E0599]: no method named `iter` found for mutable reference `&mut [bool]` in the current scope\n   --> src/pikevm.rs:196:58\n    |\n196 |                     all_matched = all_matched || matches.iter().all(|&b| b);\n    |                                                          ^^^^ method not found in `&mut [bool]`\n\nerror[E0599]: no method named `is_end` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:215:19\n    |\n215 |             if at.is_end() {\n    |                   ^^^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `is_end` not found for this struct\n\nerror[E0599]: no method named `clear` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:220:23\n    |\n220 |             nlist.set.clear();\n    |                       ^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `clear` not found for this struct\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [bool]`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:250:41\n    |\n250 |                 if match_slot < matches.len() {\n    |                                         ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[bool]: ExactSizeIterator`\n            which is required by `&mut [bool]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter_mut` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/pikevm.rs:253:42\n    |\n253 |                 for (slot, val) in slots.iter_mut().zip(thread_caps.iter()) {\n    |                                          ^^^^^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: no method named `iter` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/pikevm.rs:253:69\n    |\n253 |                 for (slot, val) in slots.iter_mut().zip(thread_caps.iter()) {\n    |                                                                     ^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:259:33\n    |\n259 |                 if inst.c == at.char() {\n    |                                 ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:260:26\n    |\n260 |                     self.add(nlist, thread_caps, inst.goto, at_next);\n    |                          ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `matches` found for reference `&InstRanges` in the current scope\n   --> src/pikevm.rs:265:25\n    |\n265 |                 if inst.matches(at.char()) {\n    |                         ^^^^^^^ method not found in `&InstRanges`\n\nerror[E0599]: no method named `char` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:265:36\n    |\n265 |                 if inst.matches(at.char()) {\n    |                                    ^^^^ method not found in `InputAt`\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `char` not found for this struct\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:266:26\n    |\n266 |                     self.add(nlist, thread_caps, inst.goto, at_next);\n    |                          ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `byte` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:271:37\n    |\n271 |                 if let Some(b) = at.byte() {\n    |                                     ^^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `byte` not found for this struct\n\nerror[E0599]: no method named `matches` found for reference `&InstBytes` in the current scope\n   --> src/pikevm.rs:272:29\n    |\n272 |                     if inst.matches(b) {\n    |                             ^^^^^^^ method not found in `&InstBytes`\n\nerror[E0599]: no method named `add` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:273:30\n    |\n273 |                         self.add(nlist, thread_caps, inst.goto, at_next);\n    |                              ^^^ method not found in `&mut Fsm<'r, I>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `add`, perhaps you need to implement it:\n            candidate #1: `Add`\n\nerror[E0599]: no method named `add_step` found for mutable reference `&mut pikevm::Fsm<'r, I>` in the current scope\n   --> src/pikevm.rs:295:26\n    |\n295 |                     self.add_step(nlist, thread_caps, ip, at);\n    |                          ^^^^^^^^ method not found in `&mut Fsm<'r, I>`\n\nerror[E0599]: no method named `contains` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:319:26\n    |\n319 |             if nlist.set.contains(ip) {\n    |                          ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `contains` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `contains`, perhaps you need to implement it:\n            candidate #1: `RangeBounds`\n\nerror[E0599]: no method named `insert` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:322:23\n    |\n322 |             nlist.set.insert(ip);\n    |                       ^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `insert` not found for this struct\n\nerror[E0599]: the method `len` exists for mutable reference `&mut [Option<usize>]`, but its trait bounds were not satisfied\n   --> src/pikevm.rs:330:48\n    |\n330 |                     if inst.slot < thread_caps.len() {\n    |                                                ^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `[Option<usize>]: ExactSizeIterator`\n            which is required by `&mut [Option<usize>]: ExactSizeIterator`\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pos` found for struct `input::InputAt` in the current scope\n   --> src/pikevm.rs:335:58\n    |\n335 |                         thread_caps[inst.slot] = Some(at.pos());\n    |                                                          ^^^ private field, not a method\n    |\n   ::: src/input.rs:25:1\n    |\n25  | pub struct InputAt {\n    | ------------------ method `pos` not found for this struct\n\nerror[E0599]: no method named `caps` found for mutable reference `&mut Threads` in the current scope\n   --> src/pikevm.rs:344:40\n    |\n344 |                     let t = &mut nlist.caps(ip);\n    |                                        ^^^^---- help: remove the arguments\n    |                                        |\n    |                                        field, not a method\n\nerror[E0599]: no method named `iter` found for mutable reference `&mut [Option<usize>]` in the current scope\n   --> src/pikevm.rs:345:69\n    |\n345 |                     for (slot, val) in t.iter_mut().zip(thread_caps.iter()) {\n    |                                                                     ^^^^ method not found in `&mut [Option<usize>]`\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:358:29\n    |\n358 |             set: SparseSet::new(0),\n    |                             ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `capacity` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:365:34\n    |\n365 |         if num_insts == self.set.capacity() {\n    |                                  ^^^^^^^^ method not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- method `capacity` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `SparseSet` in the current scope\n   --> src/pikevm.rs:369:31\n    |\n369 |         self.set = SparseSet::new(num_insts);\n    |                               ^^^ function or associated item not found in `SparseSet`\n    |\n   ::: src/sparse.rs:15:1\n    |\n15  | pub struct SparseSet {\n    | -------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `empty` found for struct `LiteralSearcher` in the current scope\n  --> src/prog.rs:95:40\n   |\n95 |             prefixes: LiteralSearcher::empty(),\n   |                                        ^^^^^ function or associated item not found in `LiteralSearcher`\n   |\n  ::: src/literal/mod.rs:31:1\n   |\n31 | pub struct LiteralSearcher {\n   | -------------------------- function or associated item `empty` not found for this struct\n\nerror[E0599]: no method named `skip` found for reference `&Program` in the current scope\n   --> src/prog.rs:120:25\n    |\n120 |         match self[self.skip(pc)] {\n    |                         ^^^^ `&Program` is not an iterator\n    |\nhelp: call `.into_iter()` first\n    |\n120 |         match self[self.into_iter().skip(pc)] {\n    |                         ++++++++++++\n\nerror[E0599]: no method named `len` found for reference `&Program` in the current scope\n   --> src/prog.rs:151:15\n    |\n151 |         (self.len() * mem::size_of::<Inst>())\n    |               ^^^ method not found in `&Program`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\nhelp: some of the expressions' fields have a method of the same name\n    |\n151 |         (self.byte_classes.len() * mem::size_of::<Inst>())\n    |               +++++++++++++\n151 |         (self.capture_name_idx.len() * mem::size_of::<Inst>())\n    |               +++++++++++++++++\n151 |         (self.captures.len() * mem::size_of::<Inst>())\n    |               +++++++++\n151 |         (self.insts.len() * mem::size_of::<Inst>())\n    |               ++++++\n      and 1 other candidate\n\nerror[E0599]: no method named `approximate_size` found for struct `LiteralSearcher` in the current scope\n   --> src/prog.rs:157:25\n    |\n157 |         + self.prefixes.approximate_size()\n    |                         ^^^^^^^^^^^^^^^^ method not found in `LiteralSearcher`\n    |\n   ::: src/literal/mod.rs:31:1\n    |\n31  | pub struct LiteralSearcher {\n    | -------------------------- method `approximate_size` not found for this struct\n\nerror[E0599]: no method named `iter` found for reference `&Program` in the current scope\n   --> src/prog.rs:187:32\n    |\n187 |         for (pc, inst) in self.iter().enumerate() {\n    |                                ^^^^ method not found in `&Program`\n    |\nhelp: one of the expressions' fields has a method of the same name\n    |\n187 |         for (pc, inst) in self.capture_name_idx.iter().enumerate() {\n    |                                +++++++++++++++++\n\nerror[E0599]: no method named `iter` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:210:26\n    |\n209 |                       let ranges = inst.ranges\n    |  __________________________________-\n210 | |                         .iter()\n    | |                         -^^^^ method not found in `Vec<(char, char)>`\n    | |_________________________|\n    |\n\nerror[E0599]: no method named `iter` found for reference `&'a Program` in the current scope\n   --> src/prog.rs:237:49\n    |\n237 |     fn into_iter(self) -> Self::IntoIter { self.iter() }\n    |                                                 ^^^^ method not found in `&Program`\n\nerror[E0599]: no method named `iter` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:376:30\n    |\n376 |         for r in self.ranges.iter().take(4) {\n    |                              ^^^^ method not found in `Vec<(char, char)>`\n\nerror[E0599]: no method named `binary_search_by` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:384:21\n    |\n384 |         self.ranges.binary_search_by(|r| {\n    |         ------------^^^^^^^^^^^^^^^^ method not found in `Vec<(char, char)>`\n\nerror[E0599]: no method named `iter` found for struct `Vec<(char, char)>` in the current scope\n   --> src/prog.rs:398:21\n    |\n398 |         self.ranges.iter()\n    |                     ^^^^ method not found in `Vec<(char, char)>`\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:79:22\n    |\n79  |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n225 | define_builder!(bytes, re_bytes, false);\n    | --------------------------------------- in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:79:22\n    |\n79  |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n226 | define_builder!(unicode, re_unicode, true);\n    | ------------------------------------------ in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:260:22\n    |\n260 |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n387 | define_set_builder!(set_bytes, bytes, false);\n    | -------------------------------------------- in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_set_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new_options` found for struct `ExecBuilder` in the current scope\n   --> src/re_builder.rs:260:22\n    |\n260 |         ExecBuilder::new_options(self.0.clone())\n    |                      ^^^^^^^^^^^ function or associated item not found in `ExecBuilder`\n...\n388 | define_set_builder!(set_unicode, unicode, true);\n    | ----------------------------------------------- in this macro invocation\n    |\n   ::: src/exec.rs:97:1\n    |\n97  | pub struct ExecBuilder {\n    | ---------------------- function or associated item `new_options` not found for this struct\n    |\n    = note: this error originates in the macro `define_set_builder` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_str` found for reference `&re_bytes::Regex` in the current scope\n  --> src/re_bytes.rs:83:30\n   |\n83 |         write!(f, \"{}\", self.as_str())\n   |                              ^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:109:16\n    |\n78  | pub struct Regex(Exec);\n    | ---------------- function or associated item `new` not found for this struct\n...\n109 |         Regex::new(s)\n    |                ^^^ function or associated item not found in `Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_builder::bytes::RegexBuilder` in the current scope\n   --> src/re_bytes.rs:120:23\n    |\n120 |         RegexBuilder::new(re).build()\n    |                       ^^^ function or associated item not found in `RegexBuilder`\n    |\n   ::: src/re_builder.rs:60:1\n    |\n60  | pub struct RegexBuilder(RegexOptions);\n    | ----------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:142:14\n    |\n142 |         self.is_match_at(text, 0)\n    |              ^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `find_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:166:14\n    |\n166 |         self.find_at(text, 0)\n    |              ^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:188:24\n    |\n188 |         Matches(self.0.searcher().find_iter(text))\n    |                        ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `locations` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:255:29\n    |\n255 |         let mut locs = self.locations();\n    |                             ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `locations`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `read_captures_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:256:14\n    |\n256 |         self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n    |              ^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `read_captures_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `capture_name_idx` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:259:34\n    |\n259 |             named_groups: self.0.capture_name_idx().clone(),\n    |                                  ^^^^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_name_idx` not found for this struct\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:293:31\n    |\n293 |         CaptureMatches(self.0.searcher().captures_iter(text))\n    |                               ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `find_iter` found for reference `&'r re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:318:26\n    |\n318 |             finder: self.find_iter(text),\n    |                          ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `split` found for reference `&'r re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:349:26\n    |\n349 |             splits: self.split(text),\n    |                          ^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `split`, perhaps you need to implement it:\n            candidate #1: `BufRead`\n\nerror[E0599]: no method named `replacen` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:467:14\n    |\n467 |         self.replacen(text, 1, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `replacen` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:481:14\n    |\n481 |         self.replacen(text, 0, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `find_iter` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:497:31\n    |\n497 |             let mut it = self.find_iter(text).enumerate().peekable();\n    |                               ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t [u8]` in the current scope\n    --> src/re_bytes.rs:501:51\n     |\n501  |             let mut new = Vec::with_capacity(text.len());\n     |                                                   ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `captures_iter` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:517:27\n    |\n517 |         let mut it = self.captures_iter(text).enumerate().peekable();\n    |                           ^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `captures_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t [u8]` in the current scope\n    --> src/re_bytes.rs:521:47\n     |\n521  |         let mut new = Vec::with_capacity(text.len());\n     |                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:562:14\n    |\n562 |         self.shortest_match_at(text, 0)\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:577:16\n    |\n577 |         self.0.searcher().shortest_match_at(text, start)\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_bytes::Regex` in the current scope\n   --> src/re_bytes.rs:588:14\n    |\n588 |         self.shortest_match_at(text, start).is_some()\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:603:16\n    |\n603 |         self.0.searcher().find_at(text, start)\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:604:34\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n604 |             .map(|(s, e)| Match::new(text, s, e))\n    |                                  ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:620:16\n    |\n620 |         self.0.searcher().read_captures_at(locs, text, start)\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:621:34\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n621 |             .map(|(s, e)| Match::new(text, s, e))\n    |                                  ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:629:17\n    |\n629 |         &self.0.regex_strings()[0]\n    |                 ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `regex_strings` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:634:29\n    |\n634 |         CaptureNames(self.0.capture_names().iter())\n    |                             ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:639:16\n    |\n639 |         self.0.capture_names().len()\n    |                ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_bytes.rs:646:16\n    |\n646 |         self.0.searcher().locations()\n    |                ^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_bytes.rs:664:27\n    |\n664 |         let text = self.0.text();\n    |                           ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n664 |         let text = self.0.next();\n    |                           ~~~~\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:665:43\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n665 |         self.0.next().map(|(s, e)| Match::new(text, s, e))\n    |                                           ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `text` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_bytes.rs:683:26\n    |\n683 |             text: self.0.text(),\n    |                          ^^^^\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n683 |             text: self.0.next(),\n    |                          ~~~~\n\nerror[E0599]: no method named `regex` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_bytes.rs:685:34\n    |\n685 |             named_groups: self.0.regex().capture_name_idx().clone(),\n    |                                  ^^^^^ method not found in `CaptureMatches<'t, ExecNoSync<'r>>`\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `regex` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_bytes.rs:703:34\n    |\n703 |         let text = self.finder.0.text();\n    |                                  ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n703 |         let text = self.finder.0.next();\n    |                                  ~~~~\n\nerror[E0599]: no method named `start` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:715:50\n    |\n30  | pub struct Match<'t> {\n    | -------------------- method `start` not found for this struct\n...\n715 |                 let matched = &text[self.last..m.start()];\n    |                                                  ^^^^^-- help: remove the arguments\n    |                                                  |\n    |                                                  field, not a method\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `start`, perhaps you need to implement one of them:\n            candidate #1: `syntax::ast::Visitor`\n            candidate #2: `syntax::hir::Visitor`\n\nerror[E0599]: no method named `end` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:716:31\n    |\n30  | pub struct Match<'t> {\n    | -------------------- method `end` not found for this struct\n...\n716 |                 self.last = m.end();\n    |                               ^^^-- help: remove the arguments\n    |                               |\n    |                               field, not a method\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_bytes.rs:743:45\n    |\n743 |             let text = self.splits.finder.0.text();\n    |                                             ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n743 |             let text = self.splits.finder.0.next();\n    |                                             ~~~~\n\nerror[E0599]: no method named `pos` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:810:19\n    |\n810 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `pos` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:810:46\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n810 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                                              ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_bytes::Captures<'t>` in the current scope\n   --> src/re_bytes.rs:816:56\n    |\n816 |         self.named_groups.get(name).and_then(|&i| self.get(i))\n    |                                                        ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n816 |         self.named_groups.get(name).and_then(|&i| self.named_groups.get(i))\n    |                                                        +++++++++++++\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:827:27\n    |\n827 |             it: self.locs.iter(),\n    |                           ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `len` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:857:19\n    |\n857 |         self.locs.len()\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `len` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_bytes.rs:891:38\n    |\n891 |         for (slot, m) in self.0.locs.iter().enumerate() {\n    |                                      ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `get` found for reference `&re_bytes::Captures<'t>` in the current scope\n   --> src/re_bytes.rs:918:14\n    |\n918 |         self.get(i).map(|m| m.as_bytes())\n    |              ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n918 |         self.named_groups.get(i).map(|m| m.as_bytes())\n    |              +++++++++++++\n\nerror[E0599]: no method named `name` found for reference `&'a re_bytes::Captures<'t>` in the current scope\n   --> src/re_bytes.rs:939:14\n    |\n939 |         self.name(name).map(|m| m.as_bytes())\n    |              ^^^^ method not found in `&Captures<'t>`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_bytes::Match` in the current scope\n   --> src/re_bytes.rs:963:48\n    |\n30  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n963 |             .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    |                                                ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `expand` found for reference `&re_bytes::Captures<'_>` in the current scope\n    --> src/re_bytes.rs:1037:14\n     |\n1037 |         caps.expand(*self, dst);\n     |              ^^^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no function or associated item named `new` found for struct `set_unicode::RegexSetBuilder` in the current scope\n   --> src/re_set.rs:106:26\n    |\n106 |           RegexSetBuilder::new(exprs).build()\n    |                            ^^^ function or associated item not found in `RegexSetBuilder`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/re_builder.rs:242:1\n    |\n242 |   pub struct RegexSetBuilder(RegexOptions);\n    |   -------------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_set::unicode::RegexSet` in the current scope\n   --> src/re_set.rs:134:14\n    |\n134 |           self.is_match_at(text, 0)\n    |                ^^^^^^^^^^^ method not found in `&RegexSet`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:145:16\n    |\n145 |           self.0.searcher().is_match_at($as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:185:46\n    |\n185 |           let mut matches = vec![false; self.0.regex_strings().len()];\n    |                                                ^^^^^^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `read_matches_at` found for reference `&re_set::unicode::RegexSet` in the current scope\n   --> src/re_set.rs:186:24\n    |\n186 |           let any = self.read_matches_at(&mut matches, text, 0);\n    |                          ^^^^^^^^^^^^^^^ method not found in `&RegexSet`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:212:16\n    |\n212 |           self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:217:16\n    |\n217 |           self.0.regex_strings().len()\n    |                  ^^^^^^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `iter` found for reference `&'a re_set::unicode::SetMatches` in the current scope\n   --> src/re_set.rs:275:14\n    |\n275 |           self.iter()\n    |                ^^^^ method not found in `&SetMatches`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:357:44\n    |\n357 |           write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    |                                              ^^^^^^^^^^^^^ method not found in `Exec`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/re_set.rs:361:65\n    |\n361 |   #[allow(dead_code)] fn as_bytes_str(text: &str) -> &[u8] { text.as_bytes() }\n    |                                                                   ^^^^^^^^ method not found in `&str`\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no function or associated item named `new` found for struct `set_bytes::RegexSetBuilder` in the current scope\n   --> src/re_set.rs:106:26\n    |\n106 |           RegexSetBuilder::new(exprs).build()\n    |                            ^^^ function or associated item not found in `RegexSetBuilder`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/re_builder.rs:242:1\n    |\n242 |   pub struct RegexSetBuilder(RegexOptions);\n    |   -------------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_set::bytes::RegexSet` in the current scope\n   --> src/re_set.rs:134:14\n    |\n134 |           self.is_match_at(text, 0)\n    |                ^^^^^^^^^^^ method not found in `&RegexSet`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:145:16\n    |\n145 |           self.0.searcher().is_match_at($as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:185:46\n    |\n185 |           let mut matches = vec![false; self.0.regex_strings().len()];\n    |                                                ^^^^^^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `read_matches_at` found for reference `&re_set::bytes::RegexSet` in the current scope\n   --> src/re_set.rs:186:24\n    |\n186 |           let any = self.read_matches_at(&mut matches, text, 0);\n    |                          ^^^^^^^^^^^^^^^ method not found in `&RegexSet`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `searcher` found for struct `Exec` in the current scope\n   --> src/re_set.rs:212:16\n    |\n212 |           self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    |                  ^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:217:16\n    |\n217 |           self.0.regex_strings().len()\n    |                  ^^^^^^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `iter` found for reference `&'a re_set::bytes::SetMatches` in the current scope\n   --> src/re_set.rs:275:14\n    |\n275 |           self.iter()\n    |                ^^^^ method not found in `&SetMatches`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_set.rs:357:44\n    |\n357 |           write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    |                                              ^^^^^^^^^^^^^ method not found in `Exec`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `regex_strings` not found for this struct\n    |\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `as_bytes` found for reference `&str` in the current scope\n   --> src/re_set.rs:361:65\n    |\n361 |   #[allow(dead_code)] fn as_bytes_str(text: &str) -> &[u8] { text.as_bytes() }\n    |                                                                   ^^^^^^^^ method not found in `&str`\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named `get` found for struct `Vec<Option<usize>>` in the current scope\n  --> src/re_trait.rs:30:23\n   |\n30 |         match (self.0.get(s), self.0.get(e)) {\n   |                       ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n30 |         match (self.0.ge(s), self.0.get(e)) {\n   |                       ~~\n\nerror[E0599]: no method named `get` found for struct `Vec<Option<usize>>` in the current scope\n  --> src/re_trait.rs:30:38\n   |\n30 |         match (self.0.get(s), self.0.get(e)) {\n   |                                      ^^^\n   |\nhelp: there is a method `ge` with a similar name\n   |\n30 |         match (self.0.get(s), self.0.ge(e)) {\n   |                                      ~~\n\nerror[E0599]: no method named `len` found for reference `&'c Locations` in the current scope\n  --> src/re_trait.rs:73:34\n   |\n73 |         if self.idx >= self.locs.len() {\n   |                                  ^^^ method not found in `&Locations`\n   |\n   = help: items from traits can only be used if the trait is implemented and in scope\n   = note: the following traits define an item `len`, perhaps you need to implement one of them:\n           candidate #1: `input::Input`\n           candidate #2: `Automaton`\n           candidate #3: `ExactSizeIterator`\nhelp: one of the expressions' fields has a method of the same name\n   |\n73 |         if self.idx >= self.locs.0.len() {\n   |                                  ++\n\nerror[E0599]: no method named `pos` found for reference `&'c Locations` in the current scope\n  --> src/re_trait.rs:76:33\n   |\n76 |         let x = match self.locs.pos(self.idx) {\n   |                                 ^^^ method not found in `&Locations`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/re_trait.rs:198:47\n     |\n198  |         if self.last_end > self.text.as_ref().len() {\n     |                                               ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_trait.rs:231:16\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n...\n231 |         self.0.text()\n    |                ^^^^-- help: remove the arguments\n    |                |\n    |                field, not a method\n\nerror[E0599]: no method named `regex` found for struct `re_trait::Matches` in the current scope\n   --> src/re_trait.rs:236:16\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `regex` not found for this struct\n...\n236 |         self.0.regex()\n    |                ^^^^^ method not found in `Matches<'t, R>`\n\nerror[E0599]: no method named `len` found for reference `&[u8]` in the current scope\n    --> src/re_trait.rs:245:51\n     |\n245  |         if self.0.last_end > self.0.text.as_ref().len() {\n     |                                                   ^^^\n     |\n     = help: items from traits can only be used if the trait is in scope\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: trait `ReadRef` which provides `len` is implemented but not in scope; perhaps you want to import it\n     |\n11   + use object::read::read_ref::ReadRef;\n     |\n\nerror[E0599]: no method named `as_str` found for struct `re_unicode::Match` in the current scope\n  --> src/re_unicode.rs:77:11\n   |\n39 | pub struct Match<'t> {\n   | -------------------- method `as_str` not found for this struct\n...\n77 |         m.as_str()\n   |           ^^^^^^ method not found in `Match<'t>`\n\nerror[E0599]: no method named `as_str` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:142:30\n    |\n142 |         write!(f, \"{}\", self.as_str())\n    |                              ^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:165:16\n    |\n137 | pub struct Regex(Exec);\n    | ---------------- function or associated item `new` not found for this struct\n...\n165 |         Regex::new(s)\n    |                ^^^ function or associated item not found in `Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_builder::unicode::RegexBuilder` in the current scope\n   --> src/re_unicode.rs:176:23\n    |\n176 |         RegexBuilder::new(re).build()\n    |                       ^^^ function or associated item not found in `RegexBuilder`\n    |\n   ::: src/re_builder.rs:60:1\n    |\n60  | pub struct RegexBuilder(RegexOptions);\n    | ----------------------- function or associated item `new` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\n\nerror[E0599]: no method named `is_match_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:198:14\n    |\n198 |         self.is_match_at(text, 0)\n    |              ^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `is_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `find_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:223:14\n    |\n223 |         self.find_at(text, 0)\n    |              ^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:245:24\n    |\n245 |         Matches(self.0.searcher_str().find_iter(text))\n    |                        ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `locations` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:312:29\n    |\n312 |         let mut locs = self.locations();\n    |                             ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `locations`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `read_captures_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:313:14\n    |\n313 |         self.read_captures_at(&mut locs, text, 0).map(|_| Captures {\n    |              ^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `read_captures_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `capture_name_idx` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:316:34\n    |\n316 |             named_groups: self.0.capture_name_idx().clone(),\n    |                                  ^^^^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_name_idx` not found for this struct\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:349:31\n    |\n349 |         CaptureMatches(self.0.searcher_str().captures_iter(text))\n    |                               ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `find_iter` found for reference `&'r re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:372:26\n    |\n372 |             finder: self.find_iter(text),\n    |                          ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `split` found for reference `&'r re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:400:26\n    |\n400 |             splits: self.split(text),\n    |                          ^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `split`, perhaps you need to implement it:\n            candidate #1: `BufRead`\n\nerror[E0599]: no method named `replacen` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:514:14\n    |\n514 |         self.replacen(text, 1, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `replacen` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:528:14\n    |\n528 |         self.replacen(text, 0, rep)\n    |              ^^^^^^^^ method not found in `&Regex`\n\nerror[E0599]: no method named `find_iter` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:553:31\n    |\n553 |             let mut it = self.find_iter(text).enumerate().peekable();\n    |                               ^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `find_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t str` in the current scope\n    --> src/re_unicode.rs:557:54\n     |\n557  |             let mut new = String::with_capacity(text.len());\n     |                                                      ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `captures_iter` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:573:27\n    |\n573 |         let mut it = self.captures_iter(text).enumerate().peekable();\n    |                           ^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `captures_iter`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `len` found for reference `&'t str` in the current scope\n    --> src/re_unicode.rs:577:50\n     |\n577  |         let mut new = String::with_capacity(text.len());\n     |                                                  ^^^\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `len`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\nhelp: there is a method `le` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1197:5\n     |\n1197 |     fn le(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:618:14\n    |\n618 |         self.shortest_match_at(text, 0)\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:633:16\n    |\n633 |         self.0.searcher_str().shortest_match_at(text, start)\n    |                ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `shortest_match_at` found for reference `&re_unicode::Regex` in the current scope\n   --> src/re_unicode.rs:644:14\n    |\n644 |         self.shortest_match_at(text, start).is_some()\n    |              ^^^^^^^^^^^^^^^^^ method not found in `&Regex`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `RegularExpression` defines an item `shortest_match_at`, perhaps you need to implement it\n   --> src/re_trait.rs:99:1\n    |\n99  | pub trait RegularExpression: Sized {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:659:16\n    |\n659 |         self.0.searcher_str().find_at(text, start).map(|(s, e)| {\n    |                ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:660:20\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n660 |             Match::new(text, s, e)\n    |                    ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:678:14\n    |\n677 | /         self.0\n678 | |             .searcher_str()\n    | |             -^^^^^^^^^^^^ method not found in `Exec`\n    | |_____________|\n    |\n    |\n   ::: src/exec.rs:41:1\n    |\n41  |   pub struct Exec {\n    |   --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:680:34\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n680 |             .map(|(s, e)| Match::new(text, s, e))\n    |                                  ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `regex_strings` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:688:17\n    |\n688 |         &self.0.regex_strings()[0]\n    |                 ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `regex_strings` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:693:29\n    |\n693 |         CaptureNames(self.0.capture_names().iter())\n    |                             ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `capture_names` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:698:16\n    |\n698 |         self.0.capture_names().len()\n    |                ^^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `capture_names` not found for this struct\n\nerror[E0599]: no method named `searcher_str` found for struct `Exec` in the current scope\n   --> src/re_unicode.rs:705:16\n    |\n705 |         self.0.searcher_str().locations()\n    |                ^^^^^^^^^^^^ method not found in `Exec`\n    |\n   ::: src/exec.rs:41:1\n    |\n41  | pub struct Exec {\n    | --------------- method `searcher_str` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_unicode.rs:745:34\n    |\n745 |         let text = self.finder.0.text();\n    |                                  ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n745 |         let text = self.finder.0.next();\n    |                                  ~~~~\n\nerror[E0599]: no method named `start` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:757:50\n    |\n39  | pub struct Match<'t> {\n    | -------------------- method `start` not found for this struct\n...\n757 |                 let matched = &text[self.last..m.start()];\n    |                                                  ^^^^^-- help: remove the arguments\n    |                                                  |\n    |                                                  field, not a method\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `start`, perhaps you need to implement one of them:\n            candidate #1: `syntax::ast::Visitor`\n            candidate #2: `syntax::hir::Visitor`\n\nerror[E0599]: no method named `end` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:758:31\n    |\n39  | pub struct Match<'t> {\n    | -------------------- method `end` not found for this struct\n...\n758 |                 self.last = m.end();\n    |                               ^^^-- help: remove the arguments\n    |                               |\n    |                               field, not a method\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n   --> src/re_unicode.rs:785:45\n    |\n785 |             let text = self.splits.finder.0.text();\n    |                                             ^^^^ private field, not a method\n    |\n   ::: src/re_trait.rs:174:1\n    |\n174 | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n    | ------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n785 |             let text = self.splits.finder.0.next();\n    |                                             ~~~~\n\nerror[E0599]: no method named `pos` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:831:19\n    |\n831 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `pos` not found for this struct\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:831:46\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n831 |         self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    |                                              ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `get` found for reference `&re_unicode::Captures<'t>` in the current scope\n   --> src/re_unicode.rs:837:56\n    |\n837 |         self.named_groups.get(name).and_then(|&i| self.get(i))\n    |                                                        ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n837 |         self.named_groups.get(name).and_then(|&i| self.named_groups.get(i))\n    |                                                        +++++++++++++\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:848:27\n    |\n848 |             it: self.locs.iter(),\n    |                           ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `len` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:878:19\n    |\n878 |         self.locs.len()\n    |                   ^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `len` not found for this struct\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `len`, perhaps you need to implement one of them:\n            candidate #1: `input::Input`\n            candidate #2: `Automaton`\n            candidate #3: `ExactSizeIterator`\n\nerror[E0599]: no method named `iter` found for struct `Locations` in the current scope\n   --> src/re_unicode.rs:897:38\n    |\n897 |         for (slot, m) in self.0.locs.iter().enumerate() {\n    |                                      ^^^^ method not found in `Locations`\n    |\n   ::: src/re_trait.rs:21:1\n    |\n21  | pub struct Locations(Vec<Slot>);\n    | -------------------- method `iter` not found for this struct\n\nerror[E0599]: no method named `get` found for reference `&re_unicode::Captures<'t>` in the current scope\n   --> src/re_unicode.rs:924:14\n    |\n924 |         self.get(i).map(|m| m.as_str())\n    |              ^^^ method not found in `&Captures<'t>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `get`, perhaps you need to implement it:\n            candidate #1: `SliceIndex`\nhelp: one of the expressions' fields has a method of the same name\n    |\n924 |         self.named_groups.get(i).map(|m| m.as_str())\n    |              +++++++++++++\n\nerror[E0599]: no method named `name` found for reference `&'a re_unicode::Captures<'t>` in the current scope\n   --> src/re_unicode.rs:945:14\n    |\n945 |         self.name(name).map(|m| m.as_str())\n    |              ^^^^ method not found in `&Captures<'t>`\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n   --> src/re_unicode.rs:969:48\n    |\n39  | pub struct Match<'t> {\n    | -------------------- function or associated item `new` not found for this struct\n...\n969 |             .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    |                                                ^^^ function or associated item not found in `Match<'_>`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `new`, perhaps you need to implement it:\n            candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n    |\n262 |     fn ne(&self, other: &Rhs) -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `text` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_unicode.rs:987:26\n    |\n987 |             text: self.0.text(),\n    |                          ^^^^\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `text` not found for this struct\n    |\nhelp: there is a method `next` with a similar name\n    |\n987 |             text: self.0.next(),\n    |                          ~~~~\n\nerror[E0599]: no method named `regex` found for struct `re_trait::CaptureMatches` in the current scope\n   --> src/re_unicode.rs:989:34\n    |\n989 |             named_groups: self.0.regex().capture_name_idx().clone(),\n    |                                  ^^^^^ method not found in `CaptureMatches<'t, ExecNoSyncStr<'r>>`\n    |\n   ::: src/re_trait.rs:225:1\n    |\n225 | pub struct CaptureMatches<'t, R>(Matches<'t, R>)\n    | -------------------------------- method `regex` not found for this struct\n\nerror[E0599]: no method named `text` found for struct `re_trait::Matches` in the current scope\n    --> src/re_unicode.rs:1007:27\n     |\n1007 |         let text = self.0.text();\n     |                           ^^^^ private field, not a method\n     |\n    ::: src/re_trait.rs:174:1\n     |\n174  | pub struct Matches<'t, R> where R: RegularExpression, R::Text: 't {\n     | ------------------------- method `text` not found for this struct\n     |\nhelp: there is a method `next` with a similar name\n     |\n1007 |         let text = self.0.next();\n     |                           ~~~~\n\nerror[E0599]: no function or associated item named `new` found for struct `re_unicode::Match` in the current scope\n    --> src/re_unicode.rs:1008:43\n     |\n39   | pub struct Match<'t> {\n     | -------------------- function or associated item `new` not found for this struct\n...\n1008 |         self.0.next().map(|(s, e)| Match::new(text, s, e))\n     |                                           ^^^ function or associated item not found in `Match<'_>`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `new`, perhaps you need to implement it:\n             candidate #1: `aho_corasick::Transitions`\nhelp: there is a method `ne` with a similar name, but with different arguments\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:262:5\n     |\n262  |     fn ne(&self, other: &Rhs) -> bool {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `expand` found for reference `&re_unicode::Captures<'_>` in the current scope\n    --> src/re_unicode.rs:1081:14\n     |\n1081 |         caps.expand(*self, dst);\n     |              ^^^^^^ method not found in `&Captures<'_>`\n\nerror[E0599]: no method named `as_bytes` found for mutable reference `&mut &'a str` in the current scope\n    --> src/re_unicode.rs:1085:33\n     |\n1085 |         match memchr(b'$', self.as_bytes()) {\n     |                                 ^^^^^^^^ method not found in `&mut &str`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `as_bytes`, perhaps you need to implement it\n    --> src/input.rs:79:1\n     |\n79   | pub trait Input {\n     | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `iter` found for reference `&'a SparseSet` in the current scope\n  --> src/sparse.rs:77:49\n   |\n77 |     fn into_iter(self) -> Self::IntoIter { self.iter() }\n   |                                                 ^^^^ method not found in `&SparseSet`\n\nwarning: unused import: `RegularExpression`\n  --> src/re_unicode.rs:25:22\n   |\n25 | use re_trait::{self, RegularExpression, Locations, SubCapturesPosIter};\n   |                      ^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `re_trait::RegularExpression`\n   --> src/re_set.rs:23:17\n    |\n23  |               use re_trait::RegularExpression;\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n396 | / define_set! {\n397 | |     bytes,\n398 | |     set_bytes,\n399 | |     &[u8],\n...   |\n422 | | /// ```\n423 | | }\n    | |_- in this macro invocation\n    |\n    = note: this warning originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unused import: `super`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^\n\nwarning: unused import: `re_trait::RegularExpression`\n   --> src/re_set.rs:23:17\n    |\n23  |               use re_trait::RegularExpression;\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n367 | / define_set! {\n368 | |     unicode,\n369 | |     set_unicode,\n370 | |     &str,\n...   |\n393 | | /// ```\n394 | | }\n    | |_- in this macro invocation\n    |\n    = note: this warning originates in the macro `define_set` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unused import: `RegularExpression`\n  --> src/re_bytes.rs:24:22\n   |\n24 | use re_trait::{self, RegularExpression, Locations, SubCapturesPosIter};\n   |                      ^^^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0390, E0599.\nFor more information about an error, try `rustc --explain E0390`.\nwarning: `regex` (lib test) generated 36 warnings\nerror: could not compile `regex` (lib test) due to 864 previous errors; 36 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is true\n",
        "// constraint: at.is_start() is true\n",
        "// constraint: c2.is_none() is true\n",
        "// constraint: at.is_end() is false\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        only_utf8: bool,",
                  "        length: usize,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn len(&self) -> usize {",
                  "            self.length",
                  "        }",
                  "",
                  "        fn previous_char(&self, _at: InputAt) -> Option<char> {",
                  "            None // c1 is None",
                  "        }",
                  "",
                  "        fn next_char(&self, _at: InputAt) -> Option<char> {",
                  "            None // c2 is None",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.position == self.length",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        only_utf8: true,",
                  "        length: 5,",
                  "    };",
                  "",
                  "    let at = InputAt {",
                  "        position: 0, // at.is_start() == true",
                  "    };",
                  "",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::WordBoundaryAscii, // matches constraint",
                  "    };",
                  "",
                  "    assert_eq!(input.is_empty_match(at, &empty), false); // expected return value is false",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:466:15\n    |\n466 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:479:15\n    |\n479 |         look: prog::EmptyLook::WordBoundaryAscii, // matches constraint\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n479 -         look: prog::EmptyLook::WordBoundaryAscii, // matches constraint\n479 +         look: EmptyLook::WordBoundaryAscii, // matches constraint\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_06::Input` in the current scope\n   --> src/input.rs:482:22\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n482 |     assert_eq!(input.is_empty_match(at, &empty), false); // expected return value is false\n    |                      ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0609]: no field `length` on type `&llmtests::test_is_empty_match_06::InputAt`\n   --> src/input.rs:461:35\n    |\n461 |             self.position == self.length\n    |                                   ^^^^^^ unknown field\n    |\n    = note: available field is: `position`\n\nSome errors have detailed explanations: E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 4 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is true\n",
        "// constraint: at.is_start() is false\n",
        "// expected return value/type: false\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct TestInput {",
                  "        only_utf8: bool,",
                  "        text: &'static str,",
                  "    }",
                  "",
                  "    impl TestInput {",
                  "        fn previous_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() == 0 {",
                  "                None",
                  "            } else {",
                  "                self.text.chars().nth(at.pos() - 1)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() == self.text.len() {",
                  "                None",
                  "            } else {",
                  "                self.text.chars().nth(at.pos())",
                  "            }",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.text.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.position >= self.text.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = TestInput {",
                  "        only_utf8: true,",
                  "        text: \"abc\",",
                  "    };",
                  "",
                  "    let at = InputAt { position: 1 }; // Not at start",
                  "    let empty_look = InstEmptyLook {",
                  "        look: prog::EmptyLook::WordBoundaryAscii,",
                  "    };",
                  "",
                  "    let result = input.is_empty_match(at, &empty_look);",
                  "    assert_eq!(result, false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:484:15\n    |\n484 |         look: prog::EmptyLook::WordBoundaryAscii,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n484 -         look: prog::EmptyLook::WordBoundaryAscii,\n484 +         look: EmptyLook::WordBoundaryAscii,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `TestInput` in the current scope\n   --> src/input.rs:487:24\n    |\n428 |     struct TestInput {\n    |     ---------------- method `is_empty_match` not found for this struct\n...\n487 |     let result = input.is_empty_match(at, &empty_look);\n    |                        ^^^^^^^^^^^^^^ method not found in `TestInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0609]: no field `text` on type `&llmtests::test_is_empty_match_07::InputAt`\n   --> src/input.rs:469:35\n    |\n469 |             self.position >= self.text.len()\n    |                                   ^^^^ unknown field\n    |\n    = note: available field is: `position`\n\nSome errors have detailed explanations: E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 4 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 13,
      "prompt_conds": [
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is false\n",
        "// constraint: c2.is_none() is true\n",
        "// constraint: at.is_end() is true\n",
        "// expected return value/type: c1.is_word_byte() != c2.is_word_byte()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        only_utf8: bool,",
                  "        text: String,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn previous_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() == 0 {",
                  "                None",
                  "            } else {",
                  "                self.text.chars().nth(at.pos() - 1)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() == self.text.len() {",
                  "                None",
                  "            } else {",
                  "                self.text.chars().nth(at.pos())",
                  "            }",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.text.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        pos: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.pos",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.pos == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.pos == self.text.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        only_utf8: true,",
                  "        text: String::from(\"a\"), // A single word boundary",
                  "    };",
                  "",
                  "    let at = InputAt { pos: 1 }; // Cursor at the end of the text",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::WordBoundaryAscii,",
                  "    };",
                  "",
                  "    let result = input.is_empty_match(at, &empty);",
                  "    assert_eq!(result, true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:484:15\n    |\n484 |         look: prog::EmptyLook::WordBoundaryAscii,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n484 -         look: prog::EmptyLook::WordBoundaryAscii,\n484 +         look: EmptyLook::WordBoundaryAscii,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_08::Input` in the current scope\n   --> src/input.rs:487:24\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n487 |     let result = input.is_empty_match(at, &empty);\n    |                        ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0609]: no field `text` on type `&llmtests::test_is_empty_match_08::InputAt`\n   --> src/input.rs:469:30\n    |\n469 |             self.pos == self.text.len()\n    |                              ^^^^ unknown field\n    |\n    = note: available field is: `pos`\n\nSome errors have detailed explanations: E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 4 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        only_utf8: bool,",
                  "        text: String,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn previous_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() == 0 {",
                  "                None",
                  "            } else {",
                  "                self.text.chars().nth(at.pos() - 1)",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() == self.text.len() {",
                  "                None // This should trigger panic",
                  "            } else {",
                  "                self.text.chars().nth(at.pos())",
                  "            }",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.text.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        pos: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.pos",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.pos == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.pos == self.text.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        only_utf8: true,",
                  "        text: String::from(\"a\"),",
                  "    };",
                  "",
                  "    let at = InputAt { pos: 1 }; // Cursor at the end of the text",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::WordBoundaryAscii,",
                  "    };",
                  "",
                  "    let _ = input.is_empty_match(at, &empty); // This should panic",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:475:15\n    |\n475 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:485:15\n    |\n485 |         look: prog::EmptyLook::WordBoundaryAscii,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n485 -         look: prog::EmptyLook::WordBoundaryAscii,\n485 +         look: EmptyLook::WordBoundaryAscii,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_09::Input` in the current scope\n   --> src/input.rs:488:19\n    |\n429 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n488 |     let _ = input.is_empty_match(at, &empty); // This should panic\n    |                   ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0609]: no field `text` on type `&llmtests::test_is_empty_match_09::InputAt`\n   --> src/input.rs:470:30\n    |\n470 |             self.pos == self.text.len()\n    |                              ^^^^ unknown field\n    |\n    = note: available field is: `pos`\n\nSome errors have detailed explanations: E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 4 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is true\n",
        "// constraint: c1.is_none() is false\n",
        "// constraint: c2.is_none() is false\n",
        "// expected return value/type: c1.is_word_byte() != c2.is_word_byte()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct DummyInput {",
                  "        data: Vec<u8>,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl DummyInput {",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() < self.len() {",
                  "                Some(self.data[at.pos()] as char)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn previous_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() > 0 {",
                  "                Some(self.data[at.pos() - 1] as char)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.pos() == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, input_length: usize) -> bool {",
                  "            self.pos() == input_length",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input_data = DummyInput { ",
                  "        data: vec![b'a', b' '], // Word boundary between 'a' and space",
                  "        only_utf8: true,",
                  "    };",
                  "    ",
                  "    let at = InputAt { position: 1 }; // Position between 'a' and ' '",
                  "    let empty_look = InstEmptyLook { look: prog::EmptyLook::WordBoundaryAscii };",
                  "",
                  "    let result = input_data.is_empty_match(at, &empty_look);",
                  "",
                  "    assert!(result); // c1.is_word_byte() (for 'a') != c2.is_word_byte() (for ' ')",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:483:44\n    |\n483 |     let empty_look = InstEmptyLook { look: prog::EmptyLook::WordBoundaryAscii };\n    |                                            ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n483 -     let empty_look = InstEmptyLook { look: prog::EmptyLook::WordBoundaryAscii };\n483 +     let empty_look = InstEmptyLook { look: EmptyLook::WordBoundaryAscii };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:485:29\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n485 |     let result = input_data.is_empty_match(at, &empty_look);\n    |                             ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct DummyInput {",
                  "        data: Vec<u8>,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl DummyInput {",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() < self.len() {",
                  "                Some(self.data[at.pos()] as char)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn previous_char(&self, at: InputAt) -> Option<char> {",
                  "            if at.pos() > 0 {",
                  "                Some(self.data[at.pos() - 1] as char)",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.pos() == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, input_length: usize) -> bool {",
                  "            self.pos() == input_length",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input_data = DummyInput { ",
                  "        data: vec![b'a', b'a'], // No word boundary between two 'a's",
                  "        only_utf8: true,",
                  "    };",
                  "    ",
                  "    let at = InputAt { position: 1 }; // Position between 'a' and 'a'",
                  "    let empty_look = InstEmptyLook { look: prog::EmptyLook::WordBoundaryAscii };",
                  "",
                  "    let result = input_data.is_empty_match(at, &empty_look);",
                  "",
                  "    assert!(!result); // c1.is_word_byte() (for 'a') == c2.is_word_byte() (for 'a')",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:483:44\n    |\n483 |     let empty_look = InstEmptyLook { look: prog::EmptyLook::WordBoundaryAscii };\n    |                                            ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n483 -     let empty_look = InstEmptyLook { look: prog::EmptyLook::WordBoundaryAscii };\n483 +     let empty_look = InstEmptyLook { look: EmptyLook::WordBoundaryAscii };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:485:29\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n485 |     let result = input_data.is_empty_match(at, &empty_look);\n    |                             ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 16,
      "prompt_conds": [
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: empty.look matches WordBoundaryAscii is true\n",
        "// constraint: self.only_utf8 is false\n",
        "// expected return value/type: c1.is_word_byte() != c2.is_word_byte()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        only_utf8: bool,",
                  "        content: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "",
                  "        fn previous_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() > 0 {",
                  "                Some(self.content[at.pos() - 1])",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() < self.len() {",
                  "                Some(self.content[at.pos()])",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.index",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.index == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, len: usize) -> bool {",
                  "            self.index == len",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        only_utf8: false,",
                  "        content: b\"hello world\".to_vec(),",
                  "    };",
                  "",
                  "    let at_start = InputAt { index: 5 }; // positioned between \"hello\" and \"world\"",
                  "    let at_end = InputAt { index: 10 }; // positioned at 'w'",
                  "",
                  "    let empty_not_word_boundary_ascii = InstEmptyLook {",
                  "        look: prog::EmptyLook::WordBoundaryAscii,",
                  "    };",
                  "",
                  "    assert_eq!(input.is_empty_match(at_start, &empty_not_word_boundary_ascii), true);",
                  "    assert_eq!(input.is_empty_match(at_end, &empty_not_word_boundary_ascii), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:486:15\n    |\n486 |         look: prog::EmptyLook::WordBoundaryAscii,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n486 -         look: prog::EmptyLook::WordBoundaryAscii,\n486 +         look: EmptyLook::WordBoundaryAscii,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_12::Input` in the current scope\n   --> src/input.rs:489:22\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n489 |     assert_eq!(input.is_empty_match(at_start, &empty_not_word_boundary_ascii), true);\n    |                      ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_12::Input` in the current scope\n   --> src/input.rs:490:22\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n490 |     assert_eq!(input.is_empty_match(at_end, &empty_not_word_boundary_ascii), false);\n    |                      ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nwarning: unused import: `super`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 4 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        only_utf8: bool,",
                  "        content: Vec<u8>,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "",
                  "        fn previous_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() > 0 {",
                  "                Some(self.content[at.pos() - 1])",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> Option<u8> {",
                  "            if at.pos() < self.len() {",
                  "                Some(self.content[at.pos()])",
                  "            } else {",
                  "                None",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        index: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.index",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.index == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, len: usize) -> bool {",
                  "            self.index == len",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        only_utf8: false,",
                  "        content: b\"hello123\".to_vec(),",
                  "    };",
                  "",
                  "    let at_between = InputAt { index: 5 }; // positioned between \"hello\" and \"1\"",
                  "",
                  "    let empty_word_boundary_ascii = InstEmptyLook {",
                  "        look: prog::EmptyLook::WordBoundaryAscii,",
                  "    };",
                  "",
                  "    assert_eq!(input.is_empty_match(at_between, &empty_word_boundary_ascii), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:485:15\n    |\n485 |         look: prog::EmptyLook::WordBoundaryAscii,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n485 -         look: prog::EmptyLook::WordBoundaryAscii,\n485 +         look: EmptyLook::WordBoundaryAscii,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_13::Input` in the current scope\n   --> src/input.rs:488:22\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n488 |     assert_eq!(input.is_empty_match(at_between, &empty_word_boundary_ascii), true);\n    |                      ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nwarning: unused import: `super`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 17,
      "prompt_conds": [
        "// constraint: empty.look matches NotWordBoundary is true\n",
        "// constraint: empty.look matches NotWordBoundary is true\n",
        "// expected return value/type: c1.is_word_char() == c2.is_word_char()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use prog::EmptyLook::*;"
          ],
          "has_test_mod": false,
          "common": [
            "#[derive(Debug)]",
            "struct InputAt {",
            "    pos: usize,",
            "}",
            "",
            "impl InputAt {",
            "    fn pos(&self) -> usize {",
            "        self.pos",
            "    }",
            "",
            "    fn is_start(&self) -> bool {",
            "        self.pos == 0",
            "    }",
            "",
            "    fn is_end(&self, len: usize) -> bool {",
            "        self.pos == len",
            "    }",
            "}",
            "",
            "#[derive(Debug)]",
            "struct InstEmptyLook {",
            "    look: EmptyLook,",
            "}",
            "",
            "#[derive(Debug)]",
            "enum EmptyLook {",
            "    NotWordBoundary,",
            "}",
            "",
            "#[derive(Debug)]",
            "struct TestStruct {",
            "    only_utf8: bool,",
            "    data: Vec<u8>,",
            "}",
            "",
            "impl TestStruct {",
            "    fn previous_char(&self, at: &InputAt) -> Option<u8> {",
            "        if at.pos() == 0 {",
            "            None",
            "        } else {",
            "            Some(self.data[at.pos() - 1])",
            "        }",
            "    }",
            "",
            "    fn next_char(&self, at: &InputAt) -> Option<u8> {",
            "        if at.pos() >= self.data.len() {",
            "            None",
            "        } else {",
            "            Some(self.data[at.pos()])",
            "        }",
            "    }",
            "",
            "    fn len(&self) -> usize {",
            "        self.data.len()",
            "    }",
            "}",
            "",
            "trait Input {",
            "    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool;",
            "}",
            "",
            "impl Input for TestStruct {",
            "    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {",
            "        match empty.look {",
            "            NotWordBoundary => {",
            "                let (c1, c2) = (self.previous_char(&at), self.next_char(&at));",
            "                c1.is_word_char() == c2.is_word_char()",
            "            }",
            "            _ => false,",
            "        }",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let test_struct = TestStruct { only_utf8: true, data: b\"hello\".to_vec() };",
                  "    let at = InputAt { pos: 2 }; // 'l'",
                  "    let empty = InstEmptyLook { look: EmptyLook::NotWordBoundary };",
                  "",
                  "    assert!(test_struct.is_empty_match(at, &empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `super::*`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:20\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:41\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let test_struct = TestStruct { only_utf8: true, data: b\"hello1\".to_vec() };",
                  "    let at = InputAt { pos: 5 }; // '1'",
                  "    let empty = InstEmptyLook { look: EmptyLook::NotWordBoundary };",
                  "",
                  "    assert!(!test_struct.is_empty_match(at, &empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `super::*`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:20\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:41\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let test_struct = TestStruct { only_utf8: true, data: b\"\".to_vec() };",
                  "    let at = InputAt { pos: 0 };",
                  "    let empty = InstEmptyLook { look: EmptyLook::NotWordBoundary };",
                  "",
                  "    assert!(test_struct.is_empty_match(at, &empty)); // Edge case, no character on both sides",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `super::*`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:20\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:41\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let test_struct = TestStruct { only_utf8: true, data: b\"abc\".to_vec() };",
                  "    let at = InputAt { pos: 3 }; // End of the string",
                  "    let empty = InstEmptyLook { look: EmptyLook::NotWordBoundary };",
                  "",
                  "    assert!(test_struct.is_empty_match(at, &empty)); // Edge case, no character on right side",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `super::*`\n   --> src/input.rs:423:8\n    |\n423 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:20\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                    ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nerror[E0599]: no method named `is_word_char` found for enum `Option` in the current scope\n   --> src/input.rs:491:41\n    |\n491 |                 c1.is_word_char() == c2.is_word_char()\n    |                                         ^^^^^^^^^^^^ method not found in `Option<u8>`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex` (lib test) generated 32 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 32 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 18,
      "prompt_conds": [
        "// constraint: empty.look matches WordBoundary is true\n",
        "// constraint: empty.look matches WordBoundary is true\n",
        "// expected return value/type: c1.is_word_char() != c2.is_word_char()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct DummyInput {",
                  "        data: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl DummyInput {",
                  "        fn previous_char(&self, at: InputAt) -> char {",
                  "            let pos = at.pos();",
                  "            if pos > 0 {",
                  "                self.data.chars().nth(pos - 1).unwrap_or(' ')",
                  "            } else {",
                  "                ' '",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> char {",
                  "            let pos = at.pos();",
                  "            self.data.chars().nth(pos).unwrap_or(' ')",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.data.len()",
                  "        }",
                  "    }",
                  "",
                  "    impl DummyInput {",
                  "        fn is_word_char(c: char) -> bool {",
                  "            c.is_alphanumeric() || c == '_'",
                  "        }",
                  "",
                  "        fn is_word_byte(c: char) -> bool {",
                  "            c.is_ascii_alphanumeric() || c == '_'",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, input_len: usize) -> bool {",
                  "            self.position >= input_len",
                  "        }",
                  "    }",
                  "    ",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "    ",
                  "    let input_data = \"hello world\";",
                  "    let input = DummyInput {",
                  "        data: input_data.to_string(),",
                  "        only_utf8: true,",
                  "    };",
                  "    ",
                  "    let at_boundary = InputAt { position: 5 }; // position between \"hello\" and \"world\"",
                  "",
                  "    // Test for WordBoundary",
                  "    let empty_look_boundary = InstEmptyLook {",
                  "        look: prog::EmptyLook::WordBoundary,",
                  "    };",
                  "",
                  "    assert_eq!(input.is_empty_match(at_boundary, &empty_look_boundary), true);",
                  "",
                  "    let at_inside_word = InputAt { position: 4 }; // position inside \"hello\"",
                  "    ",
                  "    // Test for NotWordBoundary",
                  "    let empty_look_not_boundary = InstEmptyLook {",
                  "        look: prog::EmptyLook::NotWordBoundary,",
                  "    };",
                  "",
                  "    assert_eq!(input.is_empty_match(at_inside_word, &empty_look_not_boundary), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:482:15\n    |\n482 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:495:15\n    |\n495 |         look: prog::EmptyLook::WordBoundary,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n495 -         look: prog::EmptyLook::WordBoundary,\n495 +         look: EmptyLook::WordBoundary,\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:504:15\n    |\n504 |         look: prog::EmptyLook::NotWordBoundary,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n504 -         look: prog::EmptyLook::NotWordBoundary,\n504 +         look: EmptyLook::NotWordBoundary,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:498:22\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n498 |     assert_eq!(input.is_empty_match(at_boundary, &empty_look_boundary), true);\n    |                      ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:507:22\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n507 |     assert_eq!(input.is_empty_match(at_inside_word, &empty_look_not_boundary), false);\n    |                      ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 5 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 19,
      "prompt_conds": [
        "// constraint: empty.look matches EndText is true\n",
        "// constraint: empty.look matches EndText is true\n",
        "// expected return value/type: at.pos() == self.len()\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use prog::EmptyLook::*;"
          ],
          "has_test_mod": false,
          "common": [
            "#[derive(Debug)]",
            "struct InputAt {",
            "    position: usize,",
            "}",
            "",
            "impl InputAt {",
            "    fn pos(&self) -> usize {",
            "        self.position",
            "    }",
            "    ",
            "    // Simulated methods to represent boundary conditions",
            "    fn is_start(&self) -> bool {",
            "        self.position == 0",
            "    }",
            "",
            "    fn is_end(&self) -> bool {",
            "        self.position >= 10 // assuming a fixed length for this test",
            "    }",
            "}",
            "",
            "#[derive(Debug)]",
            "struct InstEmptyLook {",
            "    look: prog::EmptyLook,",
            "}",
            "",
            "mod prog {",
            "    #[derive(Debug)]",
            "    pub enum EmptyLook {",
            "        EndLine,",
            "        // Other variants can be defined as necessary for testing",
            "    }",
            "}",
            "",
            "// Assuming we have a trait that includes the method under test",
            "struct Regex {",
            "    len: usize,",
            "}",
            "",
            "impl Regex {",
            "    fn len(&self) -> usize {",
            "        self.len",
            "    }",
            "",
            "    fn previous_char(&self, at: &InputAt) -> Option<char> {",
            "        if at.pos() == 0 {",
            "            None",
            "        } else {",
            "            Some(' ') // Example character representation",
            "        }",
            "    }",
            "",
            "    fn next_char(&self, at: &InputAt) -> Option<char> {",
            "        if at.pos() >= self.len() {",
            "            None",
            "        } else {",
            "            Some(' ') // Example character representation",
            "        }",
            "    }",
            "    ",
            "    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {",
            "        match empty.look {",
            "            EndLine => {",
            "                let c = self.next_char(&at);",
            "                at.pos() == self.len() || c == Some('\\n')",
            "            }",
            "            _ => false // Simplified for this test case",
            "        }",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let regex = Regex { len: 10 };",
                  "    let at = InputAt { position: 10 };",
                  "    let empty = InstEmptyLook { look: prog::EmptyLook::EndLine };",
                  "    assert!(regex.is_empty_match(at, &empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0170]: pattern binding `EndLine` is named the same as one of the variants of the type `input::llmtests::prog::EmptyLook`\n   --> src/input.rs:486:13\n    |\n486 |             EndLine => {\n    |             ^^^^^^^ help: to match on the variant, qualify the path: `input::llmtests::prog::EmptyLook::EndLine`\n    |\n    = note: `#[deny(bindings_with_variant_name)]` on by default\n\nwarning: unreachable pattern\n   --> src/input.rs:490:13\n    |\n486 |             EndLine => {\n    |             ------- matches any value\n...\n490 |             _ => false // Simplified for this test case\n    |             ^ unreachable pattern\n    |\n    = note: `#[warn(unreachable_patterns)]` on by default\n\nwarning: unused variable: `EndLine`\n   --> src/input.rs:486:13\n    |\n486 |             EndLine => {\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_EndLine`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of `empty.look` which is behind a shared reference\n   --> src/input.rs:485:15\n    |\n485 |         match empty.look {\n    |               ^^^^^^^^^^\n486 |             EndLine => {\n    |             -------\n    |             |\n    |             data moved here\n    |             move occurs because `EndLine` has type `llmtests::prog::EmptyLook`, which does not implement the `Copy` trait\n    |\nhelp: consider borrowing here\n    |\n485 |         match &empty.look {\n    |               +\n\nSome errors have detailed explanations: E0170, E0507.\nFor more information about an error, try `rustc --explain E0170`.\nwarning: `regex` (lib test) generated 33 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 33 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let regex = Regex { len: 10 };",
                  "    let at = InputAt { position: 9 }; // Just before end",
                  "    let empty = InstEmptyLook { look: prog::EmptyLook::EndLine };",
                  "    assert!(!regex.is_empty_match(at, &empty)); // Expect false, not at the end line",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0170]: pattern binding `EndLine` is named the same as one of the variants of the type `input::llmtests::prog::EmptyLook`\n   --> src/input.rs:486:13\n    |\n486 |             EndLine => {\n    |             ^^^^^^^ help: to match on the variant, qualify the path: `input::llmtests::prog::EmptyLook::EndLine`\n    |\n    = note: `#[deny(bindings_with_variant_name)]` on by default\n\nwarning: unreachable pattern\n   --> src/input.rs:490:13\n    |\n486 |             EndLine => {\n    |             ------- matches any value\n...\n490 |             _ => false // Simplified for this test case\n    |             ^ unreachable pattern\n    |\n    = note: `#[warn(unreachable_patterns)]` on by default\n\nwarning: unused variable: `EndLine`\n   --> src/input.rs:486:13\n    |\n486 |             EndLine => {\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_EndLine`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of `empty.look` which is behind a shared reference\n   --> src/input.rs:485:15\n    |\n485 |         match empty.look {\n    |               ^^^^^^^^^^\n486 |             EndLine => {\n    |             -------\n    |             |\n    |             data moved here\n    |             move occurs because `EndLine` has type `llmtests::prog::EmptyLook`, which does not implement the `Copy` trait\n    |\nhelp: consider borrowing here\n    |\n485 |         match &empty.look {\n    |               +\n\nSome errors have detailed explanations: E0170, E0507.\nFor more information about an error, try `rustc --explain E0170`.\nwarning: `regex` (lib test) generated 33 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 33 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let regex = Regex { len: 10 };",
                  "    let at = InputAt { position: 0 }; // Start position",
                  "    let empty = InstEmptyLook { look: prog::EmptyLook::EndLine };",
                  "    assert!(!regex.is_empty_match(at, &empty)); // Expect false, not the end",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0170]: pattern binding `EndLine` is named the same as one of the variants of the type `input::llmtests::prog::EmptyLook`\n   --> src/input.rs:486:13\n    |\n486 |             EndLine => {\n    |             ^^^^^^^ help: to match on the variant, qualify the path: `input::llmtests::prog::EmptyLook::EndLine`\n    |\n    = note: `#[deny(bindings_with_variant_name)]` on by default\n\nwarning: unreachable pattern\n   --> src/input.rs:490:13\n    |\n486 |             EndLine => {\n    |             ------- matches any value\n...\n490 |             _ => false // Simplified for this test case\n    |             ^ unreachable pattern\n    |\n    = note: `#[warn(unreachable_patterns)]` on by default\n\nwarning: unused variable: `EndLine`\n   --> src/input.rs:486:13\n    |\n486 |             EndLine => {\n    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_EndLine`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of `empty.look` which is behind a shared reference\n   --> src/input.rs:485:15\n    |\n485 |         match empty.look {\n    |               ^^^^^^^^^^\n486 |             EndLine => {\n    |             -------\n    |             |\n    |             data moved here\n    |             move occurs because `EndLine` has type `llmtests::prog::EmptyLook`, which does not implement the `Copy` trait\n    |\nhelp: consider borrowing here\n    |\n485 |         match &empty.look {\n    |               +\n\nSome errors have detailed explanations: E0170, E0507.\nFor more information about an error, try `rustc --explain E0170`.\nwarning: `regex` (lib test) generated 33 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 33 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 20,
      "prompt_conds": [
        "// constraint: empty.look matches StartText is true\n",
        "// constraint: empty.look matches StartText is true\n",
        "// expected return value/type: at.pos() == 0\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        content: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "",
                  "        fn previous_char(&self, at: InputAt) -> char {",
                  "            if at.pos() == 0 {",
                  "                '\\0' // No character before the start",
                  "            } else {",
                  "                self.content.chars().nth(at.pos() - 1).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> char {",
                  "            self.content.chars().nth(at.pos()).unwrap_or('\\0') // Default to null char if out of bounds",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, len: usize) -> bool {",
                  "            self.position == len",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        content: String::from(\"\"),",
                  "        only_utf8: false,",
                  "    };",
                  "    let at = InputAt { position: 0 };",
                  "    let empty = InstEmptyLook { look: prog::EmptyLook::StartText };",
                  "",
                  "    assert_eq!(input.is_empty_match(at, &empty), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:470:15\n    |\n470 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:478:39\n    |\n478 |     let empty = InstEmptyLook { look: prog::EmptyLook::StartText };\n    |                                       ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n478 -     let empty = InstEmptyLook { look: prog::EmptyLook::StartText };\n478 +     let empty = InstEmptyLook { look: EmptyLook::StartText };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_22::Input` in the current scope\n   --> src/input.rs:480:22\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n480 |     assert_eq!(input.is_empty_match(at, &empty), true);\n    |                      ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        content: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "",
                  "        fn previous_char(&self, at: InputAt) -> char {",
                  "            if at.pos() == 0 {",
                  "                '\\0' ",
                  "            } else {",
                  "                self.content.chars().nth(at.pos() - 1).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> char {",
                  "            self.content.chars().nth(at.pos()).unwrap_or('\\0')",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, len: usize) -> bool {",
                  "            self.position == len",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        content: String::from(\"abc\"),",
                  "        only_utf8: false,",
                  "    };",
                  "    let at = InputAt { position: 1 };",
                  "    let empty = InstEmptyLook { look: prog::EmptyLook::StartText };",
                  "",
                  "    assert_eq!(input.is_empty_match(at, &empty), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:470:15\n    |\n470 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:478:39\n    |\n478 |     let empty = InstEmptyLook { look: prog::EmptyLook::StartText };\n    |                                       ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n478 -     let empty = InstEmptyLook { look: prog::EmptyLook::StartText };\n478 +     let empty = InstEmptyLook { look: EmptyLook::StartText };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_23::Input` in the current scope\n   --> src/input.rs:480:22\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n480 |     assert_eq!(input.is_empty_match(at, &empty), false);\n    |                      ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 21,
      "prompt_conds": [
        "// constraint: empty.look matches EndLine is true\n",
        "// constraint: empty.look matches EndLine is true\n",
        "// constraint: at.pos() == self.len() is true\n",
        "// expected return value/type: at.pos() == self.len() || c == '\\n'\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [
            "use prog::EmptyLook::*;"
          ],
          "has_test_mod": false,
          "common": [
            "#[derive(Clone, Copy)]",
            "struct InputAt {",
            "    position: usize,",
            "}",
            "",
            "impl InputAt {",
            "    fn pos(&self) -> usize {",
            "        self.position",
            "    }",
            "    ",
            "    fn is_start(&self) -> bool {",
            "        self.position == 0",
            "    }",
            "    ",
            "    fn is_end(&self, length: usize) -> bool {",
            "        self.position == length",
            "    }",
            "}",
            "",
            "struct InstEmptyLook {",
            "    look: prog::EmptyLook,",
            "}",
            "",
            "struct TestInput {",
            "    only_utf8: bool,",
            "    data: String,",
            "}",
            "",
            "impl TestInput {",
            "    fn len(&self) -> usize {",
            "        self.data.len()",
            "    }",
            "    ",
            "    fn previous_char(&self, at: InputAt) -> Option<char> {",
            "        if at.pos() == 0 {",
            "            None",
            "        } else {",
            "            self.data.chars().nth(at.pos() - 1)",
            "        }",
            "    }",
            "    ",
            "    fn next_char(&self, at: InputAt) -> Option<char> {",
            "        if at.pos() >= self.len() {",
            "            None",
            "        } else {",
            "            self.data.chars().nth(at.pos())",
            "        }",
            "    }",
            "    ",
            "    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {",
            "        match empty.look {",
            "            EndLine => {",
            "                let c = self.next_char(at);",
            "                at.pos() == self.len() || c == Some('\\n')",
            "            }",
            "            _ => panic!(\"Test only for EndLine case\"),",
            "        }",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input_data = TestInput {",
                  "        only_utf8: true,",
                  "        data: String::from(\"Hello\\nWorld\\n\"),",
                  "    };",
                  "    let at = InputAt { position: input_data.len() };",
                  "    let empty_look = InstEmptyLook { look: prog::EmptyLook::EndLine };",
                  "",
                  "    let result = input_data.is_empty_match(at, &empty_look);",
                  "    assert!(result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:445:11\n    |\n445 |     look: prog::EmptyLook,\n    |           ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:493:44\n    |\n493 |     let empty_look = InstEmptyLook { look: prog::EmptyLook::EndLine };\n    |                                            ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n493 -     let empty_look = InstEmptyLook { look: prog::EmptyLook::EndLine };\n493 +     let empty_look = InstEmptyLook { look: EmptyLook::EndLine };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input_data = TestInput {",
                  "        only_utf8: true,",
                  "        data: String::from(\"Hello World\"),",
                  "    };",
                  "    let at = InputAt { position: input_data.len() };",
                  "    let empty_look = InstEmptyLook { look: prog::EmptyLook::EndLine };",
                  "",
                  "    let result = input_data.is_empty_match(at, &empty_look);",
                  "    assert!(result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:445:11\n    |\n445 |     look: prog::EmptyLook,\n    |           ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:493:44\n    |\n493 |     let empty_look = InstEmptyLook { look: prog::EmptyLook::EndLine };\n    |                                            ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n493 -     let empty_look = InstEmptyLook { look: prog::EmptyLook::EndLine };\n493 +     let empty_look = InstEmptyLook { look: EmptyLook::EndLine };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input_data = TestInput {",
                  "        only_utf8: true,",
                  "        data: String::from(\"Panic Test\"),",
                  "    };",
                  "    let at = InputAt { position: input_data.len() };",
                  "    let empty_look = InstEmptyLook { look: prog::EmptyLook::StartLine };",
                  "",
                  "    // This should panic since we are testing an invalid case meant for EndLine only",
                  "    let _ = input_data.is_empty_match(at, &empty_look);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:445:11\n    |\n445 |     look: prog::EmptyLook,\n    |           ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:494:44\n    |\n494 |     let empty_look = InstEmptyLook { look: prog::EmptyLook::StartLine };\n    |                                            ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n494 -     let empty_look = InstEmptyLook { look: prog::EmptyLook::StartLine };\n494 +     let empty_look = InstEmptyLook { look: EmptyLook::StartLine };\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 2 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 22,
      "prompt_conds": [
        "// constraint: empty.look matches EndLine is true\n",
        "// constraint: empty.look matches EndLine is true\n",
        "// constraint: at.pos() == self.len() is false\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        content: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn previous_char(&self, at: InputAt) -> char {",
                  "            if at.pos() == 0 {",
                  "                '\\0'",
                  "            } else {",
                  "                self.content.chars().nth(at.pos() - 1).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> char {",
                  "            if at.pos() >= self.content.len() {",
                  "                '\\0'",
                  "            } else {",
                  "                self.content.chars().nth(at.pos()).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, content_length: usize) -> bool {",
                  "            self.position >= content_length",
                  "        } ",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        content: String::from(\"hello\\nworld\"),",
                  "        only_utf8: false,",
                  "    };",
                  "",
                  "    let at = InputAt { position: 10 }; // at.pos() == 10, which is not equal to length (12)",
                  "    ",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::EndLine,",
                  "    };",
                  "",
                  "    let result = input.is_empty_match(at, &empty);",
                  "    assert_eq!(result, false); // This test expects false since at.pos() is not equal to the length",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:485:15\n    |\n485 |         look: prog::EmptyLook::EndLine,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n485 -         look: prog::EmptyLook::EndLine,\n485 +         look: EmptyLook::EndLine,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_27::Input` in the current scope\n   --> src/input.rs:488:24\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n488 |     let result = input.is_empty_match(at, &empty);\n    |                        ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct Input {",
                  "        content: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl Input {",
                  "        fn previous_char(&self, at: InputAt) -> char {",
                  "            if at.pos() == 0 {",
                  "                '\\0'",
                  "            } else {",
                  "                self.content.chars().nth(at.pos() - 1).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> char {",
                  "            if at.pos() >= self.content.len() {",
                  "                '\\0'",
                  "            } else {",
                  "                self.content.chars().nth(at.pos()).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, content_length: usize) -> bool {",
                  "            self.position >= content_length",
                  "        } ",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    let input = Input {",
                  "        content: String::from(\"hello\\nworld\"),",
                  "        only_utf8: false,",
                  "    };",
                  "",
                  "    let at = InputAt { position: 0 }; // Test at the start of the string",
                  "    ",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::EndLine,",
                  "    };",
                  "",
                  "    let result = input.is_empty_match(at, &empty);",
                  "    assert_eq!(result, false); // This test expects false since at.pos() is not equal to the length (12)",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:474:15\n    |\n474 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:485:15\n    |\n485 |         look: prog::EmptyLook::EndLine,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n485 -         look: prog::EmptyLook::EndLine,\n485 +         look: EmptyLook::EndLine,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `llmtests::test_is_empty_match_28::Input` in the current scope\n   --> src/input.rs:488:24\n    |\n428 |     struct Input {\n    |     ------------ method `is_empty_match` not found for this struct\n...\n488 |     let result = input.is_empty_match(at, &empty);\n    |                        ^^^^^^^^^^^^^^ method not found in `Input`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 23,
      "prompt_conds": [
        "// constraint: empty.look matches StartLine is true\n",
        "// constraint: empty.look matches StartLine is true\n",
        "// constraint: at.pos() == 0 is false\n",
        "// expected return value/type: at.pos() == 0 || c == '\\n'\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    // Define the InputAt struct and its methods",
                  "    struct MockInputAt {",
                  "        position: usize,",
                  "    }",
                  "    ",
                  "    impl MockInputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self, len: usize) -> bool {",
                  "            self.position == len",
                  "        }",
                  "    }",
                  "",
                  "    // Define the InstEmptyLook struct and necessary parts for the test",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    // Create a mock character source for input",
                  "    struct MockInput {",
                  "        content: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockInput {",
                  "        fn previous_char(&self, at: &MockInputAt) -> char {",
                  "            if at.pos() == 0 {",
                  "                '\\0' // No char before the start.",
                  "            } else {",
                  "                self.content.chars().nth(at.pos() - 1).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: &MockInputAt) -> char {",
                  "            self.content.chars().nth(at.pos()).unwrap_or('\\0')",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    // Instantiate the required objects",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::StartLine,",
                  "    };",
                  "    ",
                  "    let input_content = \"Hello\\nWorld\".to_string();",
                  "    let input = MockInput {",
                  "        content: input_content.clone(),",
                  "        only_utf8: true,",
                  "    };",
                  "",
                  "    let at = MockInputAt {",
                  "        position: 1, // at.pos() == 1, which is false for our test",
                  "    };",
                  "",
                  "    // Execute the function under test",
                  "    let result = input.is_empty_match(at, &empty);",
                  "",
                  "    // Assert the expected outcome",
                  "    assert_eq!(result, false); // expected result is false since at.pos() == 1 and c != '\\n'",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:449:15\n    |\n449 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:478:15\n    |\n478 |         look: prog::EmptyLook::StartLine,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n478 -         look: prog::EmptyLook::StartLine,\n478 +         look: EmptyLook::StartLine,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `MockInput` in the current scope\n   --> src/input.rs:492:24\n    |\n453 |     struct MockInput {\n    |     ---------------- method `is_empty_match` not found for this struct\n...\n492 |     let result = input.is_empty_match(at, &empty);\n    |                        ^^^^^^^^^^^^^^ method not found in `MockInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 24,
      "prompt_conds": [
        "// constraint: empty.look matches StartLine is true\n",
        "// constraint: empty.look matches StartLine is true\n",
        "// constraint: at.pos() == 0 is true\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct DummyInput {",
                  "        content: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl DummyInput {",
                  "        fn previous_char(&self, at: InputAt) -> char {",
                  "            if at.pos() == 0 {",
                  "                '\\0' // Simulate the start of text",
                  "            } else {",
                  "                self.content.chars().nth(at.pos() - 1).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> char {",
                  "            self.content.chars().nth(at.pos()).unwrap_or('\\0')",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.position == 0 // Given content is empty in this test",
                  "        }",
                  "    }",
                  "",
                  "    let input = DummyInput {",
                  "        content: String::from(\"\"),",
                  "        only_utf8: false,",
                  "    };",
                  "    let at = InputAt { position: 0 };",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::StartLine,",
                  "    };",
                  "",
                  "    assert!(input.is_empty_match(at, &empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:452:15\n    |\n452 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:479:15\n    |\n479 |         look: prog::EmptyLook::StartLine,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n479 -         look: prog::EmptyLook::StartLine,\n479 +         look: EmptyLook::StartLine,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:482:19\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n482 |     assert!(input.is_empty_match(at, &empty));\n    |                   ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    struct DummyInput {",
                  "        content: String,",
                  "        only_utf8: bool,",
                  "    }",
                  "",
                  "    impl DummyInput {",
                  "        fn previous_char(&self, at: InputAt) -> char {",
                  "            if at.pos() == 0 {",
                  "                '\\n'",
                  "            } else {",
                  "                self.content.chars().nth(at.pos() - 1).unwrap_or('\\0')",
                  "            }",
                  "        }",
                  "",
                  "        fn next_char(&self, at: InputAt) -> char {",
                  "            self.content.chars().nth(at.pos()).unwrap_or('\\0')",
                  "        }",
                  "",
                  "        fn len(&self) -> usize {",
                  "            self.content.len()",
                  "        }",
                  "    }",
                  "",
                  "    struct InstEmptyLook {",
                  "        look: prog::EmptyLook,",
                  "    }",
                  "",
                  "    struct InputAt {",
                  "        position: usize,",
                  "    }",
                  "",
                  "    impl InputAt {",
                  "        fn pos(&self) -> usize {",
                  "            self.position",
                  "        }",
                  "",
                  "        fn is_start(&self) -> bool {",
                  "            self.position == 0",
                  "        }",
                  "",
                  "        fn is_end(&self) -> bool {",
                  "            self.position == 0 // Given content is empty in this test",
                  "        }",
                  "    }",
                  "",
                  "    let input = DummyInput {",
                  "        content: String::from(\"\\n\"),",
                  "        only_utf8: false,",
                  "    };",
                  "    let at = InputAt { position: 0 };",
                  "    let empty = InstEmptyLook {",
                  "        look: prog::EmptyLook::StartLine,",
                  "    };",
                  "",
                  "    assert!(input.is_empty_match(at, &empty));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:452:15\n    |\n452 |         look: prog::EmptyLook,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this module\n    |\n423 +    use prog;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `prog`\n   --> src/input.rs:479:15\n    |\n479 |         look: prog::EmptyLook::StartLine,\n    |               ^^^^ use of undeclared crate or module `prog`\n    |\nhelp: consider importing this enum through its public re-export\n    |\n423 +    use internal::EmptyLook;\n    |\nhelp: if you import `EmptyLook`, refer to it directly\n    |\n479 -         look: prog::EmptyLook::StartLine,\n479 +         look: EmptyLook::StartLine,\n    |\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0599]: no method named `is_empty_match` found for struct `DummyInput` in the current scope\n   --> src/input.rs:482:19\n    |\n428 |     struct DummyInput {\n    |     ----------------- method `is_empty_match` not found for this struct\n...\n482 |     assert!(input.is_empty_match(at, &empty));\n    |                   ^^^^^^^^^^^^^^ method not found in `DummyInput`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\nnote: `input::Input` defines an item `is_empty_match`, perhaps you need to implement it\n   --> src/input.rs:79:1\n    |\n79  | pub trait Input {\n    | ^^^^^^^^^^^^^^^\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 3 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}