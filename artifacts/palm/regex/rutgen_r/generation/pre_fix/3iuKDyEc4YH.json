{
  "name": "regex::input::<input::ByteInput<'t> as input::Input>::previous_char",
  "name_with_impl": "regex::input::{impl#7}::previous_char",
  "mod_info": {
    "name": "input",
    "loc": "src/lib.rs:655:1:655:11"
  },
  "visible": true,
  "loc": "src/input.rs:264:5:266:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// may panic: self[..at.pos()] may panic in certain situations\n"
      ],
      "input_infer": "",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "#[derive(Debug)]",
            "struct InputAt {",
            "    position: usize,",
            "}",
            "",
            "impl InputAt {",
            "    fn pos(&self) -> usize {",
            "        self.position",
            "    }",
            "}",
            "",
            "#[derive(Debug)]",
            "struct Char(char);",
            "",
            "fn decode_last_utf8(slice: &[u8]) -> Result<(char, usize), ()> {",
            "    // Dummy implementation for testing purposes",
            "    if slice.is_empty() {",
            "        return Err(());",
            "    }",
            "    let c = slice.last().unwrap() as char;",
            "    Ok((c, 1)) // assuming each character is 1 byte for simplicity",
            "}",
            "",
            "impl std::ops::Deref for [u8] {",
            "    type Target = [u8];",
            "",
            "    fn deref(&self) -> &Self::Target {",
            "        self",
            "    }",
            "}",
            "",
            "fn previous_char(input: &[u8], at: InputAt) -> Char {",
            "    decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).into()",
            "}",
            "",
            "impl From<char> for Char {",
            "    fn from(c: char) -> Self {",
            "        Char(c)",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"hello\";",
                  "    let at = InputAt { position: 5 };",
                  "    let result = previous_char(input, at);",
                  "    assert_eq!(result, Char('o'));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nerror[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> src/input.rs:448:1\n    |\n448 | impl std::ops::Deref for [u8] {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^----\n    | |                        |\n    | |                        this is not defined in the current crate because slices are always foreign\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:25:24\n   |\n25 |     let b = match text.get(i) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:53:24\n   |\n53 |     let b0 = match src.get(0) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:60:20\n   |\n60 |             if src.len() < 2 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:75:20\n   |\n75 |             if src.len() < 3 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:95:20\n   |\n95 |             if src.len() < 4 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:124:12\n    |\n124 |     if src.is_empty() {\n    |            ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:127:25\n    |\n127 |     let mut start = src.len() - 1;\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:131:23\n    |\n131 |     while start > src.len().saturating_sub(4) {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:139:33\n    |\n139 |         Some((_, n)) if n < src.len() - start => None,\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:283:37\n    |\n283 |                         char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n    |                                     ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:440:30\n    |\n440 |         debug_assert!(!bytes.is_empty());\n    |                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:443:32\n    |\n443 |                 Box::new(bytes.iter().rev())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:445:32\n    |\n445 |                 Box::new(bytes.iter())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:472:19\n    |\n472 |             holes.push(self.push_hole(InstHole::Bytes {\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:537:19\n    |\n537 |             holes.push(hole);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:665:23\n    |\n665 |                 holes.push(self.fill_split(split, Some(entry), None));\n    |                       ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:722:31\n    |\n722 |                     new_holes.push(self.fill_split(hole, goto1, goto2));\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:893:27\n    |\n893 |                     holes.push(hole);\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:299:22\n    |\n299 |         if self.data.is_empty() {\n    |                      ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:623:25\n    |\n623 |         while at < text.len() {\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:636:53\n    |\n636 |             while next_si <= STATE_MAX && at < text.len() {\n    |                                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:640:58\n    |\n640 |                 if prev_si > STATE_MAX || at + 2 >= text.len() {\n    |                                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:690:38\n    |\n690 |                     && at + 2 < text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:709:57\n    |\n709 |                     None => return Result::NoMatch(text.len()),\n    |                                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:754:66\n    |\n754 |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n    |                                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:761:41\n    |\n761 |             result = Result::Match(text.len());\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:895:32\n    |\n895 |         debug_assert!(i < text.len());\n    |                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:896:23\n    |\n896 |         let b = *text.get_unchecked(i);\n    |                       ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:897:61\n    |\n897 |         debug_assert!((b as usize) < self.prog.byte_classes.len());\n    |                                                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:898:43\n    |\n898 |         let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n    |                                           ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1247:18\n     |\n1247 |         if insts.len() == 1 && !state_flags.is_match() {\n     |                  ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1252:38\n     |\n1252 |             Some(State { data: insts.into_boxed_slice() })\n     |                                      ^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1429:32\n     |\n1429 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1431:37\n     |\n1431 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1434:33\n     |\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1457:40\n     |\n1457 |         empty_flags.start = at == text.len();\n     |                                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1458:32\n     |\n1458 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1459:45\n     |\n1459 |         empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n     |                                             ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1460:37\n     |\n1460 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1463:23\n     |\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                       ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1511:31\n     |\n1511 |             + (2 * state.data.len())\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1823:14\n     |\n1823 |         data.push((n as u8) | 0b1000_0000);\n     |              ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1826:10\n     |\n1826 |     data.push(n as u8);\n     |          ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1833:25\n     |\n1833 |     for (i, &b) in data.iter().enumerate() {\n     |                         ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:269:19\n    |\n269 |             exprs.push(expr);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:410:26\n    |\n410 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:412:56\n    |\n412 |                     dfa::Result::Match(_) => Some(text.len()),\n    |                                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:458:26\n    |\n458 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:694:18\n    |\n694 |             text.len() - start,\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:696:48\n    |\n696 |             Match(s) => Match((start + s, text.len())),\n    |                                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:748:27\n    |\n748 |         while end <= text.len() {\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:751:50\n    |\n751 |                 None => return Some(NoMatch(text.len())),\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:767:27\n    |\n767 |         Some(NoMatch(text.len()))\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:885:63\n    |\n885 |             next_utf8(text, next_utf8(text, match_end)), text.len());\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:930:63\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/exec.rs:1055:17\n     |\n1055 |         if text.len() > (1<<20) && self.ro.nfa.is_anchored_end {\n     |                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:21:35\n   |\n21 |         if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n   |                                   ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:55:24\n   |\n55 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:59:21\n   |\n59 |                 dst.extend(&replacement[..i]);\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:63:24\n   |\n63 |         if replacement.get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:64:17\n   |\n64 |             dst.push(b'$');\n   |                 ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:68:36\n   |\n68 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:72:21\n   |\n72 |                 dst.push(b'$');\n   |                     ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:80:21\n   |\n80 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:84:21\n   |\n84 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:89:9\n   |\n89 |     dst.extend(replacement);\n   |         ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:133:12\n    |\n133 |     if rep.len() <= 1 || rep[0] != b'$' {\n    |            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:143:15\n    |\n143 |     while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:155:17\n    |\n155 |         if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:180:30\n    |\n180 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:184:30\n    |\n184 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:185:34\n    |\n185 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:188:41\n    |\n188 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:38\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:62\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:38\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:62\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:38\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:62\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:38\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:62\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:213:60\n    |\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:217:16\n    |\n217 |         self.0.len()\n    |                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:255:24\n    |\n255 |             byte: self.get(i).cloned(),\n    |                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:272:30\n    |\n272 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:276:30\n    |\n276 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:277:34\n    |\n277 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:280:41\n    |\n280 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:38\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:62\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:38\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:62\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:38\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:62\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:38\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:62\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:325:60\n    |\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:329:19\n    |\n329 |         self.text.len()\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:441:14\n    |\n441 |     if slice.is_empty() {\n    |              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:444:19\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0606]: casting `&u8` as `char` is invalid\n   --> src/input.rs:444:13\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: dereference the expression\n    |\n444 |     let c = *slice.last().unwrap() as char;\n    |             +\n\nerror[E0277]: the trait bound `llmtests::Char: From<std::result::Result<char, ()>>` is not satisfied\n   --> src/input.rs:457:58\n    |\n457 |     decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).into()\n    |                                                          ^^^^ the trait `From<std::result::Result<char, ()>>` is not implemented for `llmtests::Char`, which is required by `std::result::Result<char, ()>: Into<_>`\n    |\n    = help: the trait `From<char>` is implemented for `llmtests::Char`\n    = help: for that trait implementation, expected `char`, found `std::result::Result<char, ()>`\n    = note: required for `std::result::Result<char, ()>` to implement `Into<llmtests::Char>`\n\nerror[E0369]: binary operation `==` cannot be applied to type `llmtests::Char`\n   --> src/input.rs:472:5\n    |\n472 |     assert_eq!(result, Char('o'));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     llmtests::Char\n    |     llmtests::Char\n    |\nnote: an implementation of `PartialEq` might be missing for `llmtests::Char`\n   --> src/input.rs:437:1\n    |\n437 | struct Char(char);\n    | ^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `llmtests::Char` with `#[derive(PartialEq)]`\n    |\n437 + #[derive(PartialEq)]\n438 | struct Char(char);\n    |\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:80:64\n   |\n80 |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:81:64\n   |\n81 |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:20\n    |\n114 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:37\n    |\n114 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:117:40\n    |\n117 |             if lit == &haystack[0..lit.len()] {\n    |                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:118:37\n    |\n118 |                 return Some((0, lit.len()));\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:20\n    |\n127 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:37\n    |\n127 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:42\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:54\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:39\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:51\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:67\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:174:43\n    |\n174 |             Bytes(ref sset) => sset.dense.len(),\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:213:23\n    |\n213 |         if sset.dense.len() >= 26 {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:226:42\n    |\n226 |             let lit = lits.literals()[0].to_vec();\n    |                                          ^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:227:49\n    |\n227 |             if BoyerMooreSearch::should_use(lit.as_slice()) {\n    |                                                 ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:233:47\n    |\n233 |         let is_aho_corasick_fast = sset.dense.len() == 1 && sset.all_ascii;\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:281:25\n    |\n281 |                 if many.is_empty() {\n    |                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:290:24\n    |\n290 |                 if one.is_empty() {\n    |                        ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:350:50\n    |\n350 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:351:35\n    |\n351 |             if let Some(&b) = lit.get(0) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:356:32\n    |\n356 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:367:50\n    |\n367 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:35\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:43\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:373:32\n    |\n373 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:384:26\n    |\n384 |         match self.dense.len() {\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:395:33\n    |\n395 |         for (i, &b) in haystack.iter().enumerate() {\n    |                                 ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:404:21\n    |\n404 |         (self.dense.len() * mem::size_of::<u8>())\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:448:16\n    |\n448 |         if pat.is_empty() {\n    |                ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:456:27\n    |\n456 |         for b in pat[1..].iter().cloned() {\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:470:26\n    |\n470 |         let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:471:26\n    |\n471 |         let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:21\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:33\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:46\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:502:28\n    |\n502 |         while i < haystack.len() {\n    |                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:508:35\n    |\n508 |             let end = start + pat.len();\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:509:31\n    |\n509 |             if end > haystack.len() {\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:523:17\n    |\n523 |         if text.len() < self.len() {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:526:19\n    |\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:530:18\n    |\n530 |         self.pat.len()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:538:18\n    |\n538 |         self.pat.len() * mem::size_of::<u8>()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:613:31\n    |\n613 |         debug_assert!(pattern.len() > 0);\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:615:50\n    |\n615 |         let (g, gi) = Self::select_guard(pattern.as_slice());\n    |                                                  ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:616:59\n    |\n616 |         let skip_table = Self::compile_skip_table(pattern.as_slice());\n    |                                                           ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:617:57\n    |\n617 |         let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n    |                                                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:21\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:42\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:636:43\n    |\n636 |         let mut window_end = self.pattern.len() - 1;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:644:60\n    |\n644 |         let short_circut = (NUM_UNROLL + 2) * self.pattern.len();\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:646:21\n    |\n646 |         if haystack.len() > short_circut {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:37\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:78\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                                                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:659:60\n    |\n659 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:670:37\n    |\n670 |         while window_end < haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:674:60\n    |\n674 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:686:29\n    |\n686 |         return self.pattern.len()\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:732:35\n    |\n732 |         let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:739:17\n    |\n739 |         pattern.len() > MIN_LEN\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:741:24\n    |\n741 |             && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    |                        ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:753:55\n    |\n753 |         let window_start = window_end - (self.pattern.len() - 1);\n    |                                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:754:34\n    |\n754 |         for i in 0..self.pattern.len() {\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:835:36\n    |\n835 |         let mut tab = vec![pattern.len(); 256];\n    |                                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:842:31\n    |\n842 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:843:41\n    |\n843 |             tab[*c as usize] = (pattern.len() - 1) - i;\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:853:42\n    |\n853 |         let mut rarest_rev_idx = pattern.len() - 1;\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:854:31\n    |\n854 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:857:43\n    |\n857 |                 rarest_rev_idx = (pattern.len() - 1) - i;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:868:31\n    |\n868 |         let shiftc = *pattern.last().unwrap();\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:873:20\n    |\n873 |         if pattern.len() == 1 {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:877:29\n    |\n877 |         let mut i = pattern.len() - 2;\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:880:33\n    |\n880 |                 return (pattern.len() - 1) - i;\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:887:17\n    |\n887 |         pattern.len() - 1\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:891:23\n    |\n891 |         (self.pattern.len() * mem::size_of::<u8>())\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:24\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:42\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                                          ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:31\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:47\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1011:43\n     |\n1011 |                 && &haystack[i..(i+needle.len())] == needle {\n     |                                           ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/prog.rs:156:30\n    |\n156 |         + (self.byte_classes.len() * mem::size_of::<u8>())\n    |                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:501:51\n    |\n501 |             let mut new = Vec::with_capacity(text.len());\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:507:21\n    |\n507 |                 new.extend_from_slice(&text[last_match..m.start()]);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:508:21\n    |\n508 |                 new.extend_from_slice(&rep);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:511:17\n    |\n511 |             new.extend_from_slice(&text[last_match..]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:521:47\n    |\n521 |         let mut new = Vec::with_capacity(text.len());\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:529:17\n    |\n529 |             new.extend_from_slice(&text[last_match..m.start()]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:533:13\n    |\n533 |         new.extend_from_slice(&text[last_match..]);\n    |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:706:38\n    |\n706 |                 if self.last >= text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:710:38\n    |\n710 |                     self.last = text.len();\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1050:13\n     |\n1050 |         dst.extend_from_slice(&(*self)(caps));\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1066:13\n     |\n1066 |         dst.extend_from_slice(self.0);\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:198:47\n    |\n198 |         if self.last_end > self.text.as_ref().len() {\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:245:51\n    |\n245 |         if self.0.last_end > self.0.text.as_ref().len() {\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nSome errors have detailed explanations: E0055, E0117, E0277, E0369, E0606.\nFor more information about an error, try `rustc --explain E0055`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 199 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"hello\";",
                  "    let at = InputAt { position: 6 }; // This is out of bounds",
                  "    previous_char(input, at);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nerror[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> src/input.rs:448:1\n    |\n448 | impl std::ops::Deref for [u8] {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^----\n    | |                        |\n    | |                        this is not defined in the current crate because slices are always foreign\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:25:24\n   |\n25 |     let b = match text.get(i) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:53:24\n   |\n53 |     let b0 = match src.get(0) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:60:20\n   |\n60 |             if src.len() < 2 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:75:20\n   |\n75 |             if src.len() < 3 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:95:20\n   |\n95 |             if src.len() < 4 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:124:12\n    |\n124 |     if src.is_empty() {\n    |            ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:127:25\n    |\n127 |     let mut start = src.len() - 1;\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:131:23\n    |\n131 |     while start > src.len().saturating_sub(4) {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:139:33\n    |\n139 |         Some((_, n)) if n < src.len() - start => None,\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:283:37\n    |\n283 |                         char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n    |                                     ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:440:30\n    |\n440 |         debug_assert!(!bytes.is_empty());\n    |                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:443:32\n    |\n443 |                 Box::new(bytes.iter().rev())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:445:32\n    |\n445 |                 Box::new(bytes.iter())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:472:19\n    |\n472 |             holes.push(self.push_hole(InstHole::Bytes {\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:537:19\n    |\n537 |             holes.push(hole);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:665:23\n    |\n665 |                 holes.push(self.fill_split(split, Some(entry), None));\n    |                       ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:722:31\n    |\n722 |                     new_holes.push(self.fill_split(hole, goto1, goto2));\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:893:27\n    |\n893 |                     holes.push(hole);\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:299:22\n    |\n299 |         if self.data.is_empty() {\n    |                      ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:623:25\n    |\n623 |         while at < text.len() {\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:636:53\n    |\n636 |             while next_si <= STATE_MAX && at < text.len() {\n    |                                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:640:58\n    |\n640 |                 if prev_si > STATE_MAX || at + 2 >= text.len() {\n    |                                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:690:38\n    |\n690 |                     && at + 2 < text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:709:57\n    |\n709 |                     None => return Result::NoMatch(text.len()),\n    |                                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:754:66\n    |\n754 |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n    |                                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:761:41\n    |\n761 |             result = Result::Match(text.len());\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:895:32\n    |\n895 |         debug_assert!(i < text.len());\n    |                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:896:23\n    |\n896 |         let b = *text.get_unchecked(i);\n    |                       ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:897:61\n    |\n897 |         debug_assert!((b as usize) < self.prog.byte_classes.len());\n    |                                                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:898:43\n    |\n898 |         let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n    |                                           ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1247:18\n     |\n1247 |         if insts.len() == 1 && !state_flags.is_match() {\n     |                  ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1252:38\n     |\n1252 |             Some(State { data: insts.into_boxed_slice() })\n     |                                      ^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1429:32\n     |\n1429 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1431:37\n     |\n1431 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1434:33\n     |\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1457:40\n     |\n1457 |         empty_flags.start = at == text.len();\n     |                                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1458:32\n     |\n1458 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1459:45\n     |\n1459 |         empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n     |                                             ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1460:37\n     |\n1460 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1463:23\n     |\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                       ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1511:31\n     |\n1511 |             + (2 * state.data.len())\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1823:14\n     |\n1823 |         data.push((n as u8) | 0b1000_0000);\n     |              ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1826:10\n     |\n1826 |     data.push(n as u8);\n     |          ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1833:25\n     |\n1833 |     for (i, &b) in data.iter().enumerate() {\n     |                         ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:269:19\n    |\n269 |             exprs.push(expr);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:410:26\n    |\n410 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:412:56\n    |\n412 |                     dfa::Result::Match(_) => Some(text.len()),\n    |                                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:458:26\n    |\n458 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:694:18\n    |\n694 |             text.len() - start,\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:696:48\n    |\n696 |             Match(s) => Match((start + s, text.len())),\n    |                                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:748:27\n    |\n748 |         while end <= text.len() {\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:751:50\n    |\n751 |                 None => return Some(NoMatch(text.len())),\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:767:27\n    |\n767 |         Some(NoMatch(text.len()))\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:885:63\n    |\n885 |             next_utf8(text, next_utf8(text, match_end)), text.len());\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:930:63\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/exec.rs:1055:17\n     |\n1055 |         if text.len() > (1<<20) && self.ro.nfa.is_anchored_end {\n     |                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:21:35\n   |\n21 |         if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n   |                                   ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:55:24\n   |\n55 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:59:21\n   |\n59 |                 dst.extend(&replacement[..i]);\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:63:24\n   |\n63 |         if replacement.get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:64:17\n   |\n64 |             dst.push(b'$');\n   |                 ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:68:36\n   |\n68 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:72:21\n   |\n72 |                 dst.push(b'$');\n   |                     ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:80:21\n   |\n80 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:84:21\n   |\n84 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:89:9\n   |\n89 |     dst.extend(replacement);\n   |         ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:133:12\n    |\n133 |     if rep.len() <= 1 || rep[0] != b'$' {\n    |            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:143:15\n    |\n143 |     while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:155:17\n    |\n155 |         if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:180:30\n    |\n180 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:184:30\n    |\n184 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:185:34\n    |\n185 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:188:41\n    |\n188 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:38\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:62\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:38\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:62\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:38\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:62\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:38\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:62\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:213:60\n    |\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:217:16\n    |\n217 |         self.0.len()\n    |                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:255:24\n    |\n255 |             byte: self.get(i).cloned(),\n    |                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:272:30\n    |\n272 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:276:30\n    |\n276 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:277:34\n    |\n277 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:280:41\n    |\n280 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:38\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:62\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:38\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:62\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:38\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:62\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:38\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:62\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:325:60\n    |\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:329:19\n    |\n329 |         self.text.len()\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:441:14\n    |\n441 |     if slice.is_empty() {\n    |              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:444:19\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0606]: casting `&u8` as `char` is invalid\n   --> src/input.rs:444:13\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: dereference the expression\n    |\n444 |     let c = *slice.last().unwrap() as char;\n    |             +\n\nerror[E0277]: the trait bound `llmtests::Char: From<std::result::Result<char, ()>>` is not satisfied\n   --> src/input.rs:457:58\n    |\n457 |     decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).into()\n    |                                                          ^^^^ the trait `From<std::result::Result<char, ()>>` is not implemented for `llmtests::Char`, which is required by `std::result::Result<char, ()>: Into<_>`\n    |\n    = help: the trait `From<char>` is implemented for `llmtests::Char`\n    = help: for that trait implementation, expected `char`, found `std::result::Result<char, ()>`\n    = note: required for `std::result::Result<char, ()>` to implement `Into<llmtests::Char>`\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:80:64\n   |\n80 |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:81:64\n   |\n81 |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:20\n    |\n114 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:37\n    |\n114 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:117:40\n    |\n117 |             if lit == &haystack[0..lit.len()] {\n    |                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:118:37\n    |\n118 |                 return Some((0, lit.len()));\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:20\n    |\n127 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:37\n    |\n127 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:42\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:54\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:39\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:51\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:67\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:174:43\n    |\n174 |             Bytes(ref sset) => sset.dense.len(),\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:213:23\n    |\n213 |         if sset.dense.len() >= 26 {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:226:42\n    |\n226 |             let lit = lits.literals()[0].to_vec();\n    |                                          ^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:227:49\n    |\n227 |             if BoyerMooreSearch::should_use(lit.as_slice()) {\n    |                                                 ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:233:47\n    |\n233 |         let is_aho_corasick_fast = sset.dense.len() == 1 && sset.all_ascii;\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:281:25\n    |\n281 |                 if many.is_empty() {\n    |                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:290:24\n    |\n290 |                 if one.is_empty() {\n    |                        ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:350:50\n    |\n350 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:351:35\n    |\n351 |             if let Some(&b) = lit.get(0) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:356:32\n    |\n356 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:367:50\n    |\n367 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:35\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:43\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:373:32\n    |\n373 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:384:26\n    |\n384 |         match self.dense.len() {\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:395:33\n    |\n395 |         for (i, &b) in haystack.iter().enumerate() {\n    |                                 ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:404:21\n    |\n404 |         (self.dense.len() * mem::size_of::<u8>())\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:448:16\n    |\n448 |         if pat.is_empty() {\n    |                ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:456:27\n    |\n456 |         for b in pat[1..].iter().cloned() {\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:470:26\n    |\n470 |         let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:471:26\n    |\n471 |         let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:21\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:33\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:46\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:502:28\n    |\n502 |         while i < haystack.len() {\n    |                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:508:35\n    |\n508 |             let end = start + pat.len();\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:509:31\n    |\n509 |             if end > haystack.len() {\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:523:17\n    |\n523 |         if text.len() < self.len() {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:526:19\n    |\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:530:18\n    |\n530 |         self.pat.len()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:538:18\n    |\n538 |         self.pat.len() * mem::size_of::<u8>()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:613:31\n    |\n613 |         debug_assert!(pattern.len() > 0);\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:615:50\n    |\n615 |         let (g, gi) = Self::select_guard(pattern.as_slice());\n    |                                                  ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:616:59\n    |\n616 |         let skip_table = Self::compile_skip_table(pattern.as_slice());\n    |                                                           ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:617:57\n    |\n617 |         let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n    |                                                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:21\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:42\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:636:43\n    |\n636 |         let mut window_end = self.pattern.len() - 1;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:644:60\n    |\n644 |         let short_circut = (NUM_UNROLL + 2) * self.pattern.len();\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:646:21\n    |\n646 |         if haystack.len() > short_circut {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:37\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:78\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                                                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:659:60\n    |\n659 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:670:37\n    |\n670 |         while window_end < haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:674:60\n    |\n674 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:686:29\n    |\n686 |         return self.pattern.len()\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:732:35\n    |\n732 |         let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:739:17\n    |\n739 |         pattern.len() > MIN_LEN\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:741:24\n    |\n741 |             && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    |                        ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:753:55\n    |\n753 |         let window_start = window_end - (self.pattern.len() - 1);\n    |                                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:754:34\n    |\n754 |         for i in 0..self.pattern.len() {\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:835:36\n    |\n835 |         let mut tab = vec![pattern.len(); 256];\n    |                                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:842:31\n    |\n842 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:843:41\n    |\n843 |             tab[*c as usize] = (pattern.len() - 1) - i;\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:853:42\n    |\n853 |         let mut rarest_rev_idx = pattern.len() - 1;\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:854:31\n    |\n854 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:857:43\n    |\n857 |                 rarest_rev_idx = (pattern.len() - 1) - i;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:868:31\n    |\n868 |         let shiftc = *pattern.last().unwrap();\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:873:20\n    |\n873 |         if pattern.len() == 1 {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:877:29\n    |\n877 |         let mut i = pattern.len() - 2;\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:880:33\n    |\n880 |                 return (pattern.len() - 1) - i;\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:887:17\n    |\n887 |         pattern.len() - 1\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:891:23\n    |\n891 |         (self.pattern.len() * mem::size_of::<u8>())\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:24\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:42\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                                          ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:31\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:47\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1011:43\n     |\n1011 |                 && &haystack[i..(i+needle.len())] == needle {\n     |                                           ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/prog.rs:156:30\n    |\n156 |         + (self.byte_classes.len() * mem::size_of::<u8>())\n    |                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:501:51\n    |\n501 |             let mut new = Vec::with_capacity(text.len());\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:507:21\n    |\n507 |                 new.extend_from_slice(&text[last_match..m.start()]);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:508:21\n    |\n508 |                 new.extend_from_slice(&rep);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:511:17\n    |\n511 |             new.extend_from_slice(&text[last_match..]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:521:47\n    |\n521 |         let mut new = Vec::with_capacity(text.len());\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:529:17\n    |\n529 |             new.extend_from_slice(&text[last_match..m.start()]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:533:13\n    |\n533 |         new.extend_from_slice(&text[last_match..]);\n    |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:706:38\n    |\n706 |                 if self.last >= text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:710:38\n    |\n710 |                     self.last = text.len();\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1050:13\n     |\n1050 |         dst.extend_from_slice(&(*self)(caps));\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1066:13\n     |\n1066 |         dst.extend_from_slice(self.0);\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:198:47\n    |\n198 |         if self.last_end > self.text.as_ref().len() {\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:245:51\n    |\n245 |         if self.0.last_end > self.0.text.as_ref().len() {\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nSome errors have detailed explanations: E0055, E0117, E0277, E0606.\nFor more information about an error, try `rustc --explain E0055`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 198 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"\";",
                  "    let at = InputAt { position: 0 };",
                  "    assert!(std::panic::catch_unwind(|| {",
                  "        previous_char(input, at);",
                  "    }).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nerror[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> src/input.rs:448:1\n    |\n448 | impl std::ops::Deref for [u8] {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^----\n    | |                        |\n    | |                        this is not defined in the current crate because slices are always foreign\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:25:24\n   |\n25 |     let b = match text.get(i) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:53:24\n   |\n53 |     let b0 = match src.get(0) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:60:20\n   |\n60 |             if src.len() < 2 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:75:20\n   |\n75 |             if src.len() < 3 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:95:20\n   |\n95 |             if src.len() < 4 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:124:12\n    |\n124 |     if src.is_empty() {\n    |            ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:127:25\n    |\n127 |     let mut start = src.len() - 1;\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:131:23\n    |\n131 |     while start > src.len().saturating_sub(4) {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:139:33\n    |\n139 |         Some((_, n)) if n < src.len() - start => None,\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:283:37\n    |\n283 |                         char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n    |                                     ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:440:30\n    |\n440 |         debug_assert!(!bytes.is_empty());\n    |                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:443:32\n    |\n443 |                 Box::new(bytes.iter().rev())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:445:32\n    |\n445 |                 Box::new(bytes.iter())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:472:19\n    |\n472 |             holes.push(self.push_hole(InstHole::Bytes {\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:537:19\n    |\n537 |             holes.push(hole);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:665:23\n    |\n665 |                 holes.push(self.fill_split(split, Some(entry), None));\n    |                       ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:722:31\n    |\n722 |                     new_holes.push(self.fill_split(hole, goto1, goto2));\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:893:27\n    |\n893 |                     holes.push(hole);\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:299:22\n    |\n299 |         if self.data.is_empty() {\n    |                      ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:623:25\n    |\n623 |         while at < text.len() {\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:636:53\n    |\n636 |             while next_si <= STATE_MAX && at < text.len() {\n    |                                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:640:58\n    |\n640 |                 if prev_si > STATE_MAX || at + 2 >= text.len() {\n    |                                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:690:38\n    |\n690 |                     && at + 2 < text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:709:57\n    |\n709 |                     None => return Result::NoMatch(text.len()),\n    |                                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:754:66\n    |\n754 |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n    |                                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:761:41\n    |\n761 |             result = Result::Match(text.len());\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:895:32\n    |\n895 |         debug_assert!(i < text.len());\n    |                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:896:23\n    |\n896 |         let b = *text.get_unchecked(i);\n    |                       ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:897:61\n    |\n897 |         debug_assert!((b as usize) < self.prog.byte_classes.len());\n    |                                                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:898:43\n    |\n898 |         let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n    |                                           ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1247:18\n     |\n1247 |         if insts.len() == 1 && !state_flags.is_match() {\n     |                  ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1252:38\n     |\n1252 |             Some(State { data: insts.into_boxed_slice() })\n     |                                      ^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1429:32\n     |\n1429 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1431:37\n     |\n1431 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1434:33\n     |\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1457:40\n     |\n1457 |         empty_flags.start = at == text.len();\n     |                                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1458:32\n     |\n1458 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1459:45\n     |\n1459 |         empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n     |                                             ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1460:37\n     |\n1460 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1463:23\n     |\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                       ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1511:31\n     |\n1511 |             + (2 * state.data.len())\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1823:14\n     |\n1823 |         data.push((n as u8) | 0b1000_0000);\n     |              ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1826:10\n     |\n1826 |     data.push(n as u8);\n     |          ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1833:25\n     |\n1833 |     for (i, &b) in data.iter().enumerate() {\n     |                         ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:269:19\n    |\n269 |             exprs.push(expr);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:410:26\n    |\n410 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:412:56\n    |\n412 |                     dfa::Result::Match(_) => Some(text.len()),\n    |                                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:458:26\n    |\n458 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:694:18\n    |\n694 |             text.len() - start,\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:696:48\n    |\n696 |             Match(s) => Match((start + s, text.len())),\n    |                                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:748:27\n    |\n748 |         while end <= text.len() {\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:751:50\n    |\n751 |                 None => return Some(NoMatch(text.len())),\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:767:27\n    |\n767 |         Some(NoMatch(text.len()))\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:885:63\n    |\n885 |             next_utf8(text, next_utf8(text, match_end)), text.len());\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:930:63\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/exec.rs:1055:17\n     |\n1055 |         if text.len() > (1<<20) && self.ro.nfa.is_anchored_end {\n     |                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:21:35\n   |\n21 |         if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n   |                                   ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:55:24\n   |\n55 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:59:21\n   |\n59 |                 dst.extend(&replacement[..i]);\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:63:24\n   |\n63 |         if replacement.get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:64:17\n   |\n64 |             dst.push(b'$');\n   |                 ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:68:36\n   |\n68 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:72:21\n   |\n72 |                 dst.push(b'$');\n   |                     ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:80:21\n   |\n80 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:84:21\n   |\n84 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:89:9\n   |\n89 |     dst.extend(replacement);\n   |         ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:133:12\n    |\n133 |     if rep.len() <= 1 || rep[0] != b'$' {\n    |            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:143:15\n    |\n143 |     while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:155:17\n    |\n155 |         if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:180:30\n    |\n180 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:184:30\n    |\n184 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:185:34\n    |\n185 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:188:41\n    |\n188 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:38\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:62\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:38\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:62\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:38\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:62\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:38\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:62\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:213:60\n    |\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:217:16\n    |\n217 |         self.0.len()\n    |                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:255:24\n    |\n255 |             byte: self.get(i).cloned(),\n    |                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:272:30\n    |\n272 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:276:30\n    |\n276 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:277:34\n    |\n277 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:280:41\n    |\n280 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:38\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:62\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:38\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:62\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:38\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:62\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:38\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:62\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:325:60\n    |\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:329:19\n    |\n329 |         self.text.len()\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:441:14\n    |\n441 |     if slice.is_empty() {\n    |              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:444:19\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0606]: casting `&u8` as `char` is invalid\n   --> src/input.rs:444:13\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: dereference the expression\n    |\n444 |     let c = *slice.last().unwrap() as char;\n    |             +\n\nerror[E0277]: the trait bound `llmtests::Char: From<std::result::Result<char, ()>>` is not satisfied\n   --> src/input.rs:457:58\n    |\n457 |     decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).into()\n    |                                                          ^^^^ the trait `From<std::result::Result<char, ()>>` is not implemented for `llmtests::Char`, which is required by `std::result::Result<char, ()>: Into<_>`\n    |\n    = help: the trait `From<char>` is implemented for `llmtests::Char`\n    = help: for that trait implementation, expected `char`, found `std::result::Result<char, ()>`\n    = note: required for `std::result::Result<char, ()>` to implement `Into<llmtests::Char>`\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:80:64\n   |\n80 |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:81:64\n   |\n81 |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:20\n    |\n114 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:37\n    |\n114 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:117:40\n    |\n117 |             if lit == &haystack[0..lit.len()] {\n    |                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:118:37\n    |\n118 |                 return Some((0, lit.len()));\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:20\n    |\n127 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:37\n    |\n127 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:42\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:54\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:39\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:51\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:67\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:174:43\n    |\n174 |             Bytes(ref sset) => sset.dense.len(),\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:213:23\n    |\n213 |         if sset.dense.len() >= 26 {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:226:42\n    |\n226 |             let lit = lits.literals()[0].to_vec();\n    |                                          ^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:227:49\n    |\n227 |             if BoyerMooreSearch::should_use(lit.as_slice()) {\n    |                                                 ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:233:47\n    |\n233 |         let is_aho_corasick_fast = sset.dense.len() == 1 && sset.all_ascii;\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:281:25\n    |\n281 |                 if many.is_empty() {\n    |                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:290:24\n    |\n290 |                 if one.is_empty() {\n    |                        ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:350:50\n    |\n350 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:351:35\n    |\n351 |             if let Some(&b) = lit.get(0) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:356:32\n    |\n356 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:367:50\n    |\n367 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:35\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:43\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:373:32\n    |\n373 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:384:26\n    |\n384 |         match self.dense.len() {\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:395:33\n    |\n395 |         for (i, &b) in haystack.iter().enumerate() {\n    |                                 ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:404:21\n    |\n404 |         (self.dense.len() * mem::size_of::<u8>())\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:448:16\n    |\n448 |         if pat.is_empty() {\n    |                ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:456:27\n    |\n456 |         for b in pat[1..].iter().cloned() {\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:470:26\n    |\n470 |         let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:471:26\n    |\n471 |         let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:21\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:33\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:46\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:502:28\n    |\n502 |         while i < haystack.len() {\n    |                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:508:35\n    |\n508 |             let end = start + pat.len();\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:509:31\n    |\n509 |             if end > haystack.len() {\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:523:17\n    |\n523 |         if text.len() < self.len() {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:526:19\n    |\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:530:18\n    |\n530 |         self.pat.len()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:538:18\n    |\n538 |         self.pat.len() * mem::size_of::<u8>()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:613:31\n    |\n613 |         debug_assert!(pattern.len() > 0);\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:615:50\n    |\n615 |         let (g, gi) = Self::select_guard(pattern.as_slice());\n    |                                                  ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:616:59\n    |\n616 |         let skip_table = Self::compile_skip_table(pattern.as_slice());\n    |                                                           ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:617:57\n    |\n617 |         let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n    |                                                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:21\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:42\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:636:43\n    |\n636 |         let mut window_end = self.pattern.len() - 1;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:644:60\n    |\n644 |         let short_circut = (NUM_UNROLL + 2) * self.pattern.len();\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:646:21\n    |\n646 |         if haystack.len() > short_circut {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:37\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:78\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                                                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:659:60\n    |\n659 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:670:37\n    |\n670 |         while window_end < haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:674:60\n    |\n674 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:686:29\n    |\n686 |         return self.pattern.len()\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:732:35\n    |\n732 |         let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:739:17\n    |\n739 |         pattern.len() > MIN_LEN\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:741:24\n    |\n741 |             && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    |                        ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:753:55\n    |\n753 |         let window_start = window_end - (self.pattern.len() - 1);\n    |                                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:754:34\n    |\n754 |         for i in 0..self.pattern.len() {\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:835:36\n    |\n835 |         let mut tab = vec![pattern.len(); 256];\n    |                                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:842:31\n    |\n842 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:843:41\n    |\n843 |             tab[*c as usize] = (pattern.len() - 1) - i;\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:853:42\n    |\n853 |         let mut rarest_rev_idx = pattern.len() - 1;\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:854:31\n    |\n854 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:857:43\n    |\n857 |                 rarest_rev_idx = (pattern.len() - 1) - i;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:868:31\n    |\n868 |         let shiftc = *pattern.last().unwrap();\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:873:20\n    |\n873 |         if pattern.len() == 1 {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:877:29\n    |\n877 |         let mut i = pattern.len() - 2;\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:880:33\n    |\n880 |                 return (pattern.len() - 1) - i;\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:887:17\n    |\n887 |         pattern.len() - 1\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:891:23\n    |\n891 |         (self.pattern.len() * mem::size_of::<u8>())\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:24\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:42\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                                          ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:31\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:47\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1011:43\n     |\n1011 |                 && &haystack[i..(i+needle.len())] == needle {\n     |                                           ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/prog.rs:156:30\n    |\n156 |         + (self.byte_classes.len() * mem::size_of::<u8>())\n    |                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:501:51\n    |\n501 |             let mut new = Vec::with_capacity(text.len());\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:507:21\n    |\n507 |                 new.extend_from_slice(&text[last_match..m.start()]);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:508:21\n    |\n508 |                 new.extend_from_slice(&rep);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:511:17\n    |\n511 |             new.extend_from_slice(&text[last_match..]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:521:47\n    |\n521 |         let mut new = Vec::with_capacity(text.len());\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:529:17\n    |\n529 |             new.extend_from_slice(&text[last_match..m.start()]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:533:13\n    |\n533 |         new.extend_from_slice(&text[last_match..]);\n    |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:706:38\n    |\n706 |                 if self.last >= text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:710:38\n    |\n710 |                     self.last = text.len();\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1050:13\n     |\n1050 |         dst.extend_from_slice(&(*self)(caps));\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1066:13\n     |\n1066 |         dst.extend_from_slice(self.0);\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:198:47\n    |\n198 |         if self.last_end > self.text.as_ref().len() {\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:245:51\n    |\n245 |         if self.0.last_end > self.0.text.as_ref().len() {\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nSome errors have detailed explanations: E0055, E0117, E0277, E0606.\nFor more information about an error, try `rustc --explain E0055`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 198 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"a\";",
                  "    let at = InputAt { position: 1 };",
                  "    let result = previous_char(input, at);",
                  "    assert_eq!(result, Char('a'));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nerror[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> src/input.rs:448:1\n    |\n448 | impl std::ops::Deref for [u8] {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^----\n    | |                        |\n    | |                        this is not defined in the current crate because slices are always foreign\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:25:24\n   |\n25 |     let b = match text.get(i) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:53:24\n   |\n53 |     let b0 = match src.get(0) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:60:20\n   |\n60 |             if src.len() < 2 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:75:20\n   |\n75 |             if src.len() < 3 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:95:20\n   |\n95 |             if src.len() < 4 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:124:12\n    |\n124 |     if src.is_empty() {\n    |            ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:127:25\n    |\n127 |     let mut start = src.len() - 1;\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:131:23\n    |\n131 |     while start > src.len().saturating_sub(4) {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:139:33\n    |\n139 |         Some((_, n)) if n < src.len() - start => None,\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:283:37\n    |\n283 |                         char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n    |                                     ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:440:30\n    |\n440 |         debug_assert!(!bytes.is_empty());\n    |                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:443:32\n    |\n443 |                 Box::new(bytes.iter().rev())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:445:32\n    |\n445 |                 Box::new(bytes.iter())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:472:19\n    |\n472 |             holes.push(self.push_hole(InstHole::Bytes {\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:537:19\n    |\n537 |             holes.push(hole);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:665:23\n    |\n665 |                 holes.push(self.fill_split(split, Some(entry), None));\n    |                       ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:722:31\n    |\n722 |                     new_holes.push(self.fill_split(hole, goto1, goto2));\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:893:27\n    |\n893 |                     holes.push(hole);\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:299:22\n    |\n299 |         if self.data.is_empty() {\n    |                      ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:623:25\n    |\n623 |         while at < text.len() {\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:636:53\n    |\n636 |             while next_si <= STATE_MAX && at < text.len() {\n    |                                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:640:58\n    |\n640 |                 if prev_si > STATE_MAX || at + 2 >= text.len() {\n    |                                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:690:38\n    |\n690 |                     && at + 2 < text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:709:57\n    |\n709 |                     None => return Result::NoMatch(text.len()),\n    |                                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:754:66\n    |\n754 |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n    |                                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:761:41\n    |\n761 |             result = Result::Match(text.len());\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:895:32\n    |\n895 |         debug_assert!(i < text.len());\n    |                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:896:23\n    |\n896 |         let b = *text.get_unchecked(i);\n    |                       ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:897:61\n    |\n897 |         debug_assert!((b as usize) < self.prog.byte_classes.len());\n    |                                                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:898:43\n    |\n898 |         let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n    |                                           ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1247:18\n     |\n1247 |         if insts.len() == 1 && !state_flags.is_match() {\n     |                  ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1252:38\n     |\n1252 |             Some(State { data: insts.into_boxed_slice() })\n     |                                      ^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1429:32\n     |\n1429 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1431:37\n     |\n1431 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1434:33\n     |\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1457:40\n     |\n1457 |         empty_flags.start = at == text.len();\n     |                                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1458:32\n     |\n1458 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1459:45\n     |\n1459 |         empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n     |                                             ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1460:37\n     |\n1460 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1463:23\n     |\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                       ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1511:31\n     |\n1511 |             + (2 * state.data.len())\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1823:14\n     |\n1823 |         data.push((n as u8) | 0b1000_0000);\n     |              ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1826:10\n     |\n1826 |     data.push(n as u8);\n     |          ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1833:25\n     |\n1833 |     for (i, &b) in data.iter().enumerate() {\n     |                         ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:269:19\n    |\n269 |             exprs.push(expr);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:410:26\n    |\n410 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:412:56\n    |\n412 |                     dfa::Result::Match(_) => Some(text.len()),\n    |                                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:458:26\n    |\n458 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:694:18\n    |\n694 |             text.len() - start,\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:696:48\n    |\n696 |             Match(s) => Match((start + s, text.len())),\n    |                                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:748:27\n    |\n748 |         while end <= text.len() {\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:751:50\n    |\n751 |                 None => return Some(NoMatch(text.len())),\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:767:27\n    |\n767 |         Some(NoMatch(text.len()))\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:885:63\n    |\n885 |             next_utf8(text, next_utf8(text, match_end)), text.len());\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:930:63\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/exec.rs:1055:17\n     |\n1055 |         if text.len() > (1<<20) && self.ro.nfa.is_anchored_end {\n     |                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:21:35\n   |\n21 |         if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n   |                                   ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:55:24\n   |\n55 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:59:21\n   |\n59 |                 dst.extend(&replacement[..i]);\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:63:24\n   |\n63 |         if replacement.get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:64:17\n   |\n64 |             dst.push(b'$');\n   |                 ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:68:36\n   |\n68 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:72:21\n   |\n72 |                 dst.push(b'$');\n   |                     ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:80:21\n   |\n80 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:84:21\n   |\n84 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:89:9\n   |\n89 |     dst.extend(replacement);\n   |         ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:133:12\n    |\n133 |     if rep.len() <= 1 || rep[0] != b'$' {\n    |            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:143:15\n    |\n143 |     while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:155:17\n    |\n155 |         if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:180:30\n    |\n180 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:184:30\n    |\n184 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:185:34\n    |\n185 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:188:41\n    |\n188 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:38\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:62\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:38\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:62\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:38\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:62\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:38\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:62\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:213:60\n    |\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:217:16\n    |\n217 |         self.0.len()\n    |                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:255:24\n    |\n255 |             byte: self.get(i).cloned(),\n    |                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:272:30\n    |\n272 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:276:30\n    |\n276 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:277:34\n    |\n277 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:280:41\n    |\n280 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:38\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:62\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:38\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:62\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:38\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:62\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:38\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:62\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:325:60\n    |\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:329:19\n    |\n329 |         self.text.len()\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:441:14\n    |\n441 |     if slice.is_empty() {\n    |              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:444:19\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0606]: casting `&u8` as `char` is invalid\n   --> src/input.rs:444:13\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: dereference the expression\n    |\n444 |     let c = *slice.last().unwrap() as char;\n    |             +\n\nerror[E0277]: the trait bound `llmtests::Char: From<std::result::Result<char, ()>>` is not satisfied\n   --> src/input.rs:457:58\n    |\n457 |     decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).into()\n    |                                                          ^^^^ the trait `From<std::result::Result<char, ()>>` is not implemented for `llmtests::Char`, which is required by `std::result::Result<char, ()>: Into<_>`\n    |\n    = help: the trait `From<char>` is implemented for `llmtests::Char`\n    = help: for that trait implementation, expected `char`, found `std::result::Result<char, ()>`\n    = note: required for `std::result::Result<char, ()>` to implement `Into<llmtests::Char>`\n\nerror[E0369]: binary operation `==` cannot be applied to type `llmtests::Char`\n   --> src/input.rs:472:5\n    |\n472 |     assert_eq!(result, Char('a'));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     llmtests::Char\n    |     llmtests::Char\n    |\nnote: an implementation of `PartialEq` might be missing for `llmtests::Char`\n   --> src/input.rs:437:1\n    |\n437 | struct Char(char);\n    | ^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `llmtests::Char` with `#[derive(PartialEq)]`\n    |\n437 + #[derive(PartialEq)]\n438 | struct Char(char);\n    |\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:80:64\n   |\n80 |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:81:64\n   |\n81 |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:20\n    |\n114 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:37\n    |\n114 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:117:40\n    |\n117 |             if lit == &haystack[0..lit.len()] {\n    |                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:118:37\n    |\n118 |                 return Some((0, lit.len()));\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:20\n    |\n127 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:37\n    |\n127 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:42\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:54\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:39\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:51\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:67\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:174:43\n    |\n174 |             Bytes(ref sset) => sset.dense.len(),\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:213:23\n    |\n213 |         if sset.dense.len() >= 26 {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:226:42\n    |\n226 |             let lit = lits.literals()[0].to_vec();\n    |                                          ^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:227:49\n    |\n227 |             if BoyerMooreSearch::should_use(lit.as_slice()) {\n    |                                                 ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:233:47\n    |\n233 |         let is_aho_corasick_fast = sset.dense.len() == 1 && sset.all_ascii;\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:281:25\n    |\n281 |                 if many.is_empty() {\n    |                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:290:24\n    |\n290 |                 if one.is_empty() {\n    |                        ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:350:50\n    |\n350 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:351:35\n    |\n351 |             if let Some(&b) = lit.get(0) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:356:32\n    |\n356 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:367:50\n    |\n367 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:35\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:43\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:373:32\n    |\n373 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:384:26\n    |\n384 |         match self.dense.len() {\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:395:33\n    |\n395 |         for (i, &b) in haystack.iter().enumerate() {\n    |                                 ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:404:21\n    |\n404 |         (self.dense.len() * mem::size_of::<u8>())\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:448:16\n    |\n448 |         if pat.is_empty() {\n    |                ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:456:27\n    |\n456 |         for b in pat[1..].iter().cloned() {\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:470:26\n    |\n470 |         let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:471:26\n    |\n471 |         let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:21\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:33\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:46\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:502:28\n    |\n502 |         while i < haystack.len() {\n    |                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:508:35\n    |\n508 |             let end = start + pat.len();\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:509:31\n    |\n509 |             if end > haystack.len() {\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:523:17\n    |\n523 |         if text.len() < self.len() {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:526:19\n    |\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:530:18\n    |\n530 |         self.pat.len()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:538:18\n    |\n538 |         self.pat.len() * mem::size_of::<u8>()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:613:31\n    |\n613 |         debug_assert!(pattern.len() > 0);\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:615:50\n    |\n615 |         let (g, gi) = Self::select_guard(pattern.as_slice());\n    |                                                  ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:616:59\n    |\n616 |         let skip_table = Self::compile_skip_table(pattern.as_slice());\n    |                                                           ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:617:57\n    |\n617 |         let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n    |                                                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:21\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:42\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:636:43\n    |\n636 |         let mut window_end = self.pattern.len() - 1;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:644:60\n    |\n644 |         let short_circut = (NUM_UNROLL + 2) * self.pattern.len();\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:646:21\n    |\n646 |         if haystack.len() > short_circut {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:37\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:78\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                                                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:659:60\n    |\n659 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:670:37\n    |\n670 |         while window_end < haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:674:60\n    |\n674 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:686:29\n    |\n686 |         return self.pattern.len()\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:732:35\n    |\n732 |         let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:739:17\n    |\n739 |         pattern.len() > MIN_LEN\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:741:24\n    |\n741 |             && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    |                        ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:753:55\n    |\n753 |         let window_start = window_end - (self.pattern.len() - 1);\n    |                                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:754:34\n    |\n754 |         for i in 0..self.pattern.len() {\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:835:36\n    |\n835 |         let mut tab = vec![pattern.len(); 256];\n    |                                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:842:31\n    |\n842 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:843:41\n    |\n843 |             tab[*c as usize] = (pattern.len() - 1) - i;\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:853:42\n    |\n853 |         let mut rarest_rev_idx = pattern.len() - 1;\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:854:31\n    |\n854 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:857:43\n    |\n857 |                 rarest_rev_idx = (pattern.len() - 1) - i;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:868:31\n    |\n868 |         let shiftc = *pattern.last().unwrap();\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:873:20\n    |\n873 |         if pattern.len() == 1 {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:877:29\n    |\n877 |         let mut i = pattern.len() - 2;\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:880:33\n    |\n880 |                 return (pattern.len() - 1) - i;\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:887:17\n    |\n887 |         pattern.len() - 1\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:891:23\n    |\n891 |         (self.pattern.len() * mem::size_of::<u8>())\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:24\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:42\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                                          ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:31\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:47\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1011:43\n     |\n1011 |                 && &haystack[i..(i+needle.len())] == needle {\n     |                                           ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/prog.rs:156:30\n    |\n156 |         + (self.byte_classes.len() * mem::size_of::<u8>())\n    |                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:501:51\n    |\n501 |             let mut new = Vec::with_capacity(text.len());\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:507:21\n    |\n507 |                 new.extend_from_slice(&text[last_match..m.start()]);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:508:21\n    |\n508 |                 new.extend_from_slice(&rep);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:511:17\n    |\n511 |             new.extend_from_slice(&text[last_match..]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:521:47\n    |\n521 |         let mut new = Vec::with_capacity(text.len());\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:529:17\n    |\n529 |             new.extend_from_slice(&text[last_match..m.start()]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:533:13\n    |\n533 |         new.extend_from_slice(&text[last_match..]);\n    |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:706:38\n    |\n706 |                 if self.last >= text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:710:38\n    |\n710 |                     self.last = text.len();\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1050:13\n     |\n1050 |         dst.extend_from_slice(&(*self)(caps));\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1066:13\n     |\n1066 |         dst.extend_from_slice(self.0);\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:198:47\n    |\n198 |         if self.last_end > self.text.as_ref().len() {\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:245:51\n    |\n245 |         if self.0.last_end > self.0.text.as_ref().len() {\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nSome errors have detailed explanations: E0055, E0117, E0277, E0369, E0606.\nFor more information about an error, try `rustc --explain E0055`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 199 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [],
              "oracles": [],
              "codes": [
                [
                  "{",
                  "    let input: &[u8] = b\"abcd\";",
                  "    let at = InputAt { position: 4 };",
                  "    let result = previous_char(input, at);",
                  "    assert_eq!(result, Char('d'));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling libc v0.2.172\n   Compiling regex v1.0.0 (/home/abezbm/rust-utgen-test-crates-new/regex)\n   Compiling quote v1.0.40\n   Compiling rand v0.4.6\n   Compiling quickcheck v0.6.2\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/ast/print.rs:80:5\n   |\n79 | struct Writer<'p, W> {\n   |        ------ field in this struct\n80 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n   = note: `#[warn(dead_code)]` on by default\n\nwarning: method `symmetric_difference` is never used\n   --> regex-syntax/src/hir/interval.rs:411:8\n    |\n326 | pub trait Interval:\n    |           -------- method in this trait\n...\n411 |     fn symmetric_difference(\n    |        ^^^^^^^^^^^^^^^^^^^^\n\nwarning: field `printer` is never read\n  --> regex-syntax/src/hir/print.rs:78:5\n   |\n77 | struct Writer<'p, W> {\n   |        ------ field in this struct\n78 |     printer: &'p mut Printer,\n   |     ^^^^^^^\n   |\n   = note: `Writer` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis\n\nwarning: call to `.borrow()` on a reference in this situation does nothing\n   --> regex-syntax/src/ast/parse.rs:386:21\n    |\n386 |         self.pattern.borrow()\n    |                     ^^^^^^^^^ help: remove this redundant call\n    |\n    = note: the type `str` does not implement `Borrow`, so calling `borrow` on `&str` copies the reference, which does not do anything and can be removed\n    = note: `#[warn(noop_method_call)]` on by default\n\nwarning: `regex-syntax` (lib) generated 12 warnings (run `cargo fix --lib -p regex-syntax` to apply 7 suggestions)\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:59:21\n   |\n59 |         0b110_00000 ... 0b110_11111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:70:22\n   |\n70 |                 0x80 ... 0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n   |                      ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:74:21\n   |\n74 |         0b1110_0000 ... 0b1110_1111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:90:23\n   |\n90 |                 0x800 ... 0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n   |                       ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n  --> src/utf8.rs:94:21\n   |\n94 |         0b11110_000 ... 0b11110_111 => {\n   |                     ^^^ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/utf8.rs:113:25\n    |\n113 |                 0x10000 ... 0x10FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n    |                         ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `std::str`\n   --> src/utf8.rs:150:9\n    |\n150 |     use std::str;\n    |         ^^^^^^^^\n    |\n    = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import: `quickcheck::quickcheck`\n   --> src/utf8.rs:152:9\n    |\n152 |     use quickcheck::quickcheck;\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `TAG_CONT`, `TAG_FOUR`, `TAG_THREE`, `TAG_TWO`, `decode_last_utf8`, and `decode_utf8`\n   --> src/utf8.rs:155:9\n    |\n155 |         TAG_CONT, TAG_TWO, TAG_THREE, TAG_FOUR,\n    |         ^^^^^^^^  ^^^^^^^  ^^^^^^^^^  ^^^^^^^^\n156 |         decode_utf8, decode_last_utf8,\n    |         ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::ByteClassSet`\n    --> src/compile.rs:1110:9\n     |\n1110 |     use super::ByteClassSet;\n     |         ^^^^^^^^^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:17\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                 ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:31\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                               ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n    --> src/dfa.rs:1695:45\n     |\n1695 |             b'A'...b'Z' | b'a'...b'z' | b'0'...b'9' | b'_' => true,\n     |                                             ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `QuickCheck`, `StdGen`, and `quickcheck`\n    --> src/dfa.rs:1847:22\n     |\n1847 |     use quickcheck::{QuickCheck, StdGen, quickcheck};\n     |                      ^^^^^^^^^^  ^^^^^^  ^^^^^^^^^^\n\nwarning: unused imports: `StateFlags`, `State`, `push_inst_ptr`, `read_vari32`, `read_varu32`, `write_vari32`, and `write_varu32`\n    --> src/dfa.rs:1849:9\n     |\n1849 |         StateFlags, State, push_inst_ptr,\n     |         ^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^\n1850 |         write_varu32, read_varu32, write_vari32, read_vari32,\n     |         ^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:14\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:30\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> src/expand.rs:172:46\n    |\n172 |         b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z' | b'_' => true,\n    |                                              ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused imports: `CaptureRef` and `find_cap_ref`\n   --> src/expand.rs:179:17\n    |\n179 |     use super::{CaptureRef, find_cap_ref};\n    |                 ^^^^^^^^^^  ^^^^^^^^^^^^\n\nwarning: unused macro definition: `find`\n   --> src/expand.rs:181:18\n    |\n181 |     macro_rules! find {\n    |                  ^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused macro definition: `c`\n   --> src/expand.rs:196:18\n    |\n196 |     macro_rules! c {\n    |                  ^\n\nwarning: unused import: `ntest::timeout`\n   --> src/input.rs:424:8\n    |\n424 |    use ntest::timeout;\n    |        ^^^^^^^^^^^^^^\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n --> src/literal/teddy_avx2/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_avx2,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: expected names are: `clippy`, `debug_assertions`, `doc`, `docsrs`, `doctest`, `feature`, `miri`, `overflow_checks`, `panic`, `proc_macro`, `relocation_model`, `rustfmt`, `sanitize`, `sanitizer_cfi_generalize_pointers`, `sanitizer_cfi_normalize_integers`, `target_abi`, `target_arch`, `target_endian`, `target_env`, `target_family`, `target_feature`, `target_has_atomic`, `target_has_atomic_equal_alignment`, `target_has_atomic_load_store`, `target_os`, `target_pointer_width`, `target_thread_local`, `target_vendor`, `test`, `ub_checks`, `unix`, and `windows`\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n  = note: `#[warn(unexpected_cfgs)]` on by default\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_avx2`\n  --> src/literal/teddy_avx2/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_avx2,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_avx2)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_avx2)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n --> src/literal/teddy_ssse3/mod.rs:5:5\n  |\n5 |     regex_runtime_teddy_ssse3,\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: consider using a Cargo feature instead\n  = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n           [lints.rust]\n           unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n  = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unexpected `cfg` condition name: `regex_runtime_teddy_ssse3`\n  --> src/literal/teddy_ssse3/mod.rs:12:5\n   |\n12 |     regex_runtime_teddy_ssse3,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: consider using a Cargo feature instead\n   = help: or consider adding in `Cargo.toml` the `check-cfg` lint config for the lint:\n            [lints.rust]\n            unexpected_cfgs = { level = \"warn\", check-cfg = ['cfg(regex_runtime_teddy_ssse3)'] }\n   = help: or consider adding `println!(\"cargo::rustc-check-cfg=cfg(regex_runtime_teddy_ssse3)\");` to the top of the `build.rs`\n   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration\n\nwarning: unused imports: `BoyerMooreSearch` and `FreqyPacked`\n   --> src/literal/mod.rs:902:17\n    |\n902 |     use super::{BoyerMooreSearch, FreqyPacked};\n    |                 ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: unused import: `quickcheck::TestResult`\n    --> src/literal/mod.rs:1004:9\n     |\n1004 |     use quickcheck::TestResult;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: trait objects without an explicit `dyn` are deprecated\n  --> src/error.rs:40:32\n   |\n40 |     fn cause(&self) -> Option<&::std::error::Error> {\n   |                                ^^^^^^^^^^^^^^^^^^^\n   |\n   = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n   = note: `#[warn(bare_trait_objects)]` on by default\nhelp: if this is an object-safe trait, use `dyn`\n   |\n40 |     fn cause(&self) -> Option<&dyn (::std::error::Error)> {\n   |                                +++++                   +\n\nerror[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n   --> src/input.rs:448:1\n    |\n448 | impl std::ops::Deref for [u8] {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^----\n    | |                        |\n    | |                        this is not defined in the current crate because slices are always foreign\n    | impl doesn't use only types from inside the current crate\n    |\n    = note: define and implement a trait or new type instead\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:25:24\n   |\n25 |     let b = match text.get(i) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:53:24\n   |\n53 |     let b0 = match src.get(0) {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:60:20\n   |\n60 |             if src.len() < 2 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:75:20\n   |\n75 |             if src.len() < 3 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/utf8.rs:95:20\n   |\n95 |             if src.len() < 4 {\n   |                    ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:124:12\n    |\n124 |     if src.is_empty() {\n    |            ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:127:25\n    |\n127 |     let mut start = src.len() - 1;\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:131:23\n    |\n131 |     while start > src.len().saturating_sub(4) {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/utf8.rs:139:33\n    |\n139 |         Some((_, n)) if n < src.len() - start => None,\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:283:37\n    |\n283 |                         char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n    |                                     ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:400:28\n    |\n400 |         let mut chars: Box<Iterator<Item=&char>> =\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n400 |         let mut chars: Box<dyn Iterator<Item=&char>> =\n    |                            +++\n\nwarning: trait objects without an explicit `dyn` are deprecated\n   --> src/compile.rs:441:28\n    |\n441 |         let mut bytes: Box<Iterator<Item=&u8>> =\n    |                            ^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: if this is an object-safe trait, use `dyn`\n    |\n441 |         let mut bytes: Box<dyn Iterator<Item=&u8>> =\n    |                            +++\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:440:30\n    |\n440 |         debug_assert!(!bytes.is_empty());\n    |                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:443:32\n    |\n443 |                 Box::new(bytes.iter().rev())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:445:32\n    |\n445 |                 Box::new(bytes.iter())\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:472:19\n    |\n472 |             holes.push(self.push_hole(InstHole::Bytes {\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:537:19\n    |\n537 |             holes.push(hole);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:665:23\n    |\n665 |                 holes.push(self.fill_split(split, Some(entry), None));\n    |                       ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:722:31\n    |\n722 |                     new_holes.push(self.fill_split(hole, goto1, goto2));\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/compile.rs:893:27\n    |\n893 |                     holes.push(hole);\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:299:22\n    |\n299 |         if self.data.is_empty() {\n    |                      ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:623:25\n    |\n623 |         while at < text.len() {\n    |                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:636:53\n    |\n636 |             while next_si <= STATE_MAX && at < text.len() {\n    |                                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:640:58\n    |\n640 |                 if prev_si > STATE_MAX || at + 2 >= text.len() {\n    |                                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:690:38\n    |\n690 |                     && at + 2 < text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:709:57\n    |\n709 |                     None => return Result::NoMatch(text.len()),\n    |                                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:754:66\n    |\n754 |             Some(STATE_DEAD) => return result.set_non_match(text.len()),\n    |                                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:761:41\n    |\n761 |             result = Result::Match(text.len());\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:895:32\n    |\n895 |         debug_assert!(i < text.len());\n    |                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:896:23\n    |\n896 |         let b = *text.get_unchecked(i);\n    |                       ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:897:61\n    |\n897 |         debug_assert!((b as usize) < self.prog.byte_classes.len());\n    |                                                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/dfa.rs:898:43\n    |\n898 |         let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n    |                                           ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1247:18\n     |\n1247 |         if insts.len() == 1 && !state_flags.is_match() {\n     |                  ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1252:38\n     |\n1252 |             Some(State { data: insts.into_boxed_slice() })\n     |                                      ^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1429:32\n     |\n1429 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1431:37\n     |\n1431 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1434:33\n     |\n1434 |         let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1457:40\n     |\n1457 |         empty_flags.start = at == text.len();\n     |                                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1458:32\n     |\n1458 |         empty_flags.end = text.is_empty();\n     |                                ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1459:45\n     |\n1459 |         empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n     |                                             ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1460:37\n     |\n1460 |         empty_flags.end_line = text.is_empty();\n     |                                     ^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1463:23\n     |\n1463 |             at < text.len() && Byte::byte(text[at]).is_ascii_word();\n     |                       ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1511:31\n     |\n1511 |             + (2 * state.data.len())\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1823:14\n     |\n1823 |         data.push((n as u8) | 0b1000_0000);\n     |              ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1826:10\n     |\n1826 |     data.push(n as u8);\n     |          ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/dfa.rs:1833:25\n     |\n1833 |     for (i, &b) in data.iter().enumerate() {\n     |                         ^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:269:19\n    |\n269 |             exprs.push(expr);\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:410:26\n    |\n410 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:412:56\n    |\n412 |                     dfa::Result::Match(_) => Some(text.len()),\n    |                                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:458:26\n    |\n458 |                     text.len(),\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:694:18\n    |\n694 |             text.len() - start,\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:696:48\n    |\n696 |             Match(s) => Match((start + s, text.len())),\n    |                                                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:748:27\n    |\n748 |         while end <= text.len() {\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:751:50\n    |\n751 |                 None => return Some(NoMatch(text.len())),\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:767:27\n    |\n767 |         Some(NoMatch(text.len()))\n    |                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:885:63\n    |\n885 |             next_utf8(text, next_utf8(text, match_end)), text.len());\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/exec.rs:930:63\n    |\n930 |             if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n    |                                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/exec.rs:1055:17\n     |\n1055 |         if text.len() > (1<<20) && self.ro.nfa.is_anchored_end {\n     |                 ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:21:35\n   |\n21 |         if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n   |                                   ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:55:24\n   |\n55 |     while !replacement.is_empty() {\n   |                        ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:59:21\n   |\n59 |                 dst.extend(&replacement[..i]);\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:63:24\n   |\n63 |         if replacement.get(1).map_or(false, |&b| b == b'$') {\n   |                        ^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:64:17\n   |\n64 |             dst.push(b'$');\n   |                 ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:68:36\n   |\n68 |         debug_assert!(!replacement.is_empty());\n   |                                    ^^^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:72:21\n   |\n72 |                 dst.push(b'$');\n   |                     ^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:80:21\n   |\n80 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:84:21\n   |\n84 |                 dst.extend(\n   |                     ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/expand.rs:89:9\n   |\n89 |     dst.extend(replacement);\n   |         ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:133:12\n    |\n133 |     if rep.len() <= 1 || rep[0] != b'$' {\n    |            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:143:15\n    |\n143 |     while rep.get(cap_end).map_or(false, is_valid_cap_letter) {\n    |               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/expand.rs:155:17\n    |\n155 |         if !rep.get(cap_end).map_or(false, |&b| b == b'}') {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:180:30\n    |\n180 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:184:30\n    |\n184 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:185:34\n    |\n185 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:188:41\n    |\n188 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:38\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:190:62\n    |\n190 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:38\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:194:62\n    |\n194 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:38\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:198:62\n    |\n198 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:38\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:202:62\n    |\n202 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:213:60\n    |\n213 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:217:16\n    |\n217 |         self.0.len()\n    |                ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:255:24\n    |\n255 |             byte: self.get(i).cloned(),\n    |                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:272:30\n    |\n272 |                 let c = self.previous_char(at);\n    |                              ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:276:30\n    |\n276 |                 let c = self.next_char(at);\n    |                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:277:34\n    |\n277 |                 at.pos() == self.len() || c == '\\n'\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:280:41\n    |\n280 |             EndText => at.pos() == self.len(),\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:38\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:282:62\n    |\n282 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:38\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:286:62\n    |\n286 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:38\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:290:62\n    |\n290 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:38\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                      ^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:304:62\n    |\n304 |                 let (c1, c2) = (self.previous_char(at), self.next_char(at));\n    |                                                              ^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:325:60\n    |\n325 |         prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    |                                                            ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:329:19\n    |\n329 |         self.text.len()\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:441:14\n    |\n441 |     if slice.is_empty() {\n    |              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/input.rs:444:19\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |                   ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0606]: casting `&u8` as `char` is invalid\n   --> src/input.rs:444:13\n    |\n444 |     let c = slice.last().unwrap() as char;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\nhelp: dereference the expression\n    |\n444 |     let c = *slice.last().unwrap() as char;\n    |             +\n\nerror[E0277]: the trait bound `llmtests::Char: From<std::result::Result<char, ()>>` is not satisfied\n   --> src/input.rs:457:58\n    |\n457 |     decode_last_utf8(&input[..at.pos()]).map(|(c, _)| c).into()\n    |                                                          ^^^^ the trait `From<std::result::Result<char, ()>>` is not implemented for `llmtests::Char`, which is required by `std::result::Result<char, ()>: Into<_>`\n    |\n    = help: the trait `From<char>` is implemented for `llmtests::Char`\n    = help: for that trait implementation, expected `char`, found `std::result::Result<char, ()>`\n    = note: required for `std::result::Result<char, ()>` to implement `Into<llmtests::Char>`\n\nerror[E0369]: binary operation `==` cannot be applied to type `llmtests::Char`\n   --> src/input.rs:472:5\n    |\n472 |     assert_eq!(result, Char('d'));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     llmtests::Char\n    |     llmtests::Char\n    |\nnote: an implementation of `PartialEq` might be missing for `llmtests::Char`\n   --> src/input.rs:437:1\n    |\n437 | struct Char(char);\n    | ^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `llmtests::Char` with `#[derive(PartialEq)]`\n    |\n437 + #[derive(PartialEq)]\n438 | struct Char(char);\n    |\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:80:64\n   |\n80 |             lcp: FreqyPacked::new(lits.longest_common_prefix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n  --> src/literal/mod.rs:81:64\n   |\n81 |             lcs: FreqyPacked::new(lits.longest_common_suffix().to_vec()),\n   |                                                                ^^^^^^ deref recursion limit reached\n   |\n   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:20\n    |\n114 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:114:37\n    |\n114 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:117:40\n    |\n117 |             if lit == &haystack[0..lit.len()] {\n    |                                        ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:118:37\n    |\n118 |                 return Some((0, lit.len()));\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:20\n    |\n127 |             if lit.len() > haystack.len() {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:127:37\n    |\n127 |             if lit.len() > haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:42\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:130:54\n    |\n130 |             if lit == &haystack[haystack.len() - lit.len()..] {\n    |                                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:39\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:51\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:131:67\n    |\n131 |                 return Some((haystack.len() - lit.len(), haystack.len()));\n    |                                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:174:43\n    |\n174 |             Bytes(ref sset) => sset.dense.len(),\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:213:23\n    |\n213 |         if sset.dense.len() >= 26 {\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:226:42\n    |\n226 |             let lit = lits.literals()[0].to_vec();\n    |                                          ^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:227:49\n    |\n227 |             if BoyerMooreSearch::should_use(lit.as_slice()) {\n    |                                                 ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:233:47\n    |\n233 |         let is_aho_corasick_fast = sset.dense.len() == 1 && sset.all_ascii;\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:281:25\n    |\n281 |                 if many.is_empty() {\n    |                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:290:24\n    |\n290 |                 if one.is_empty() {\n    |                        ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:350:50\n    |\n350 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:351:35\n    |\n351 |             if let Some(&b) = lit.get(0) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:356:32\n    |\n356 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:367:50\n    |\n367 |             sset.complete = sset.complete && lit.len() == 1;\n    |                                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:35\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:368:43\n    |\n368 |             if let Some(&b) = lit.get(lit.len().checked_sub(1).unwrap()) {\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:373:32\n    |\n373 |                     sset.dense.push(b);\n    |                                ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:384:26\n    |\n384 |         match self.dense.len() {\n    |                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:395:33\n    |\n395 |         for (i, &b) in haystack.iter().enumerate() {\n    |                                 ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:404:21\n    |\n404 |         (self.dense.len() * mem::size_of::<u8>())\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:448:16\n    |\n448 |         if pat.is_empty() {\n    |                ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:456:27\n    |\n456 |         for b in pat[1..].iter().cloned() {\n    |                           ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:470:26\n    |\n470 |         let rare1i = pat.iter().rposition(|&b| b == rare1).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:471:26\n    |\n471 |         let rare2i = pat.iter().rposition(|&b| b == rare2).unwrap();\n    |                          ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:21\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:33\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:498:46\n    |\n498 |         if haystack.len() < pat.len() || pat.is_empty() {\n    |                                              ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:502:28\n    |\n502 |         while i < haystack.len() {\n    |                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:508:35\n    |\n508 |             let end = start + pat.len();\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:509:31\n    |\n509 |             if end > haystack.len() {\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:523:17\n    |\n523 |         if text.len() < self.len() {\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:526:19\n    |\n526 |         text[text.len() - self.len()..] == *self.pat\n    |                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:530:18\n    |\n530 |         self.pat.len()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:538:18\n    |\n538 |         self.pat.len() * mem::size_of::<u8>()\n    |                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:613:31\n    |\n613 |         debug_assert!(pattern.len() > 0);\n    |                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:615:50\n    |\n615 |         let (g, gi) = Self::select_guard(pattern.as_slice());\n    |                                                  ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:616:59\n    |\n616 |         let skip_table = Self::compile_skip_table(pattern.as_slice());\n    |                                                           ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:617:57\n    |\n617 |         let md2_shift = Self::compile_md2_shift(pattern.as_slice());\n    |                                                         ^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:21\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:632:42\n    |\n632 |         if haystack.len() < self.pattern.len() {\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:636:43\n    |\n636 |         let mut window_end = self.pattern.len() - 1;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:644:60\n    |\n644 |         let short_circut = (NUM_UNROLL + 2) * self.pattern.len();\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:646:21\n    |\n646 |         if haystack.len() > short_circut {\n    |                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:37\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:648:78\n    |\n648 |             let backstop = haystack.len() - ((NUM_UNROLL + 1) * self.pattern.len());\n    |                                                                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:659:60\n    |\n659 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:670:37\n    |\n670 |         while window_end < haystack.len() {\n    |                                     ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:674:60\n    |\n674 |                     return Some(window_end - (self.pattern.len() - 1));\n    |                                                            ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:686:29\n    |\n686 |         return self.pattern.len()\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:732:35\n    |\n732 |         let scaled_rank = pattern.len().wrapping_mul(LEN_CUTOFF_PROPORTION);\n    |                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:739:17\n    |\n739 |         pattern.len() > MIN_LEN\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:741:24\n    |\n741 |             && pattern.iter().all(|c| freq_rank(*c) >= cutoff)\n    |                        ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:753:55\n    |\n753 |         let window_start = window_end - (self.pattern.len() - 1);\n    |                                                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:754:34\n    |\n754 |         for i in 0..self.pattern.len() {\n    |                                  ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:835:36\n    |\n835 |         let mut tab = vec![pattern.len(); 256];\n    |                                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:842:31\n    |\n842 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:843:41\n    |\n843 |             tab[*c as usize] = (pattern.len() - 1) - i;\n    |                                         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:853:42\n    |\n853 |         let mut rarest_rev_idx = pattern.len() - 1;\n    |                                          ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:854:31\n    |\n854 |         for (i, c) in pattern.iter().enumerate() {\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:857:43\n    |\n857 |                 rarest_rev_idx = (pattern.len() - 1) - i;\n    |                                           ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:868:31\n    |\n868 |         let shiftc = *pattern.last().unwrap();\n    |                               ^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:873:20\n    |\n873 |         if pattern.len() == 1 {\n    |                    ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:877:29\n    |\n877 |         let mut i = pattern.len() - 2;\n    |                             ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:880:33\n    |\n880 |                 return (pattern.len() - 1) - i;\n    |                                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:887:17\n    |\n887 |         pattern.len() - 1\n    |                 ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/literal/mod.rs:891:23\n    |\n891 |         (self.pattern.len() * mem::size_of::<u8>())\n    |                       ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:24\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                        ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1007:42\n     |\n1007 |         assert!(needle.len() <= haystack.len());\n     |                                          ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:31\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1009:47\n     |\n1009 |         for i in 0..(haystack.len() - (needle.len() - 1)) {\n     |                                               ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/literal/mod.rs:1011:43\n     |\n1011 |                 && &haystack[i..(i+needle.len())] == needle {\n     |                                           ^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/prog.rs:156:30\n    |\n156 |         + (self.byte_classes.len() * mem::size_of::<u8>())\n    |                              ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:501:51\n    |\n501 |             let mut new = Vec::with_capacity(text.len());\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:507:21\n    |\n507 |                 new.extend_from_slice(&text[last_match..m.start()]);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:508:21\n    |\n508 |                 new.extend_from_slice(&rep);\n    |                     ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:511:17\n    |\n511 |             new.extend_from_slice(&text[last_match..]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:521:47\n    |\n521 |         let mut new = Vec::with_capacity(text.len());\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:529:17\n    |\n529 |             new.extend_from_slice(&text[last_match..m.start()]);\n    |                 ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:533:13\n    |\n533 |         new.extend_from_slice(&text[last_match..]);\n    |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:706:38\n    |\n706 |                 if self.last >= text.len() {\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_bytes.rs:710:38\n    |\n710 |                     self.last = text.len();\n    |                                      ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1050:13\n     |\n1050 |         dst.extend_from_slice(&(*self)(caps));\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n    --> src/re_bytes.rs:1066:13\n     |\n1066 |         dst.extend_from_slice(self.0);\n     |             ^^^^^^^^^^^^^^^^^ deref recursion limit reached\n     |\n     = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:198:47\n    |\n198 |         if self.last_end > self.text.as_ref().len() {\n    |                                               ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nerror[E0055]: reached the recursion limit while auto-dereferencing `[u8]`\n   --> src/re_trait.rs:245:51\n    |\n245 |         if self.0.last_end > self.0.text.as_ref().len() {\n    |                                                   ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`regex`)\n\nSome errors have detailed explanations: E0055, E0117, E0277, E0369, E0606.\nFor more information about an error, try `rustc --explain E0055`.\nwarning: `regex` (lib test) generated 31 warnings\nerror: could not compile `regex` (lib test) due to 199 previous errors; 31 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}