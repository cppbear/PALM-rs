{"function_name":"regex::dfa::dfa::Fsm<'a>::prefix_at","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":4,"tests_lines":[37,37,37,37],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":4,"tests_compiled_rate":100.0,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":3,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1530,1531,1532],"codes_lines_covered":[[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"abcdef\", 0), Some(3));","}"],[]],[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"ghijkl\", 0), None);","}"],[]],[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"\", 0), None);","}"],[]],[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"abcdef\", 10), None);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"abcdef\", 0), Some(3));","}"],[]],[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"ghijkl\", 0), None);","}"],[]],[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"\", 0), None);","}"],[]],[["{","    struct MockProg {","        prefixes: Vec<&'static str>,","    }","","    impl MockProg {","        fn new(prefixes: Vec<&'static str>) -> Self {","            Self { prefixes }","        }","","        fn find(&self, text: &[u8]) -> Option<(&'static str, usize)> {","            for &prefix in &self.prefixes {","                if text.starts_with(prefix.as_bytes()) {","                    return Some((prefix, prefix.len()));","                }","            }","            None","        }","    }","","    struct DFA {","        prog: MockProg,","    }","","    impl DFA {","        fn new(prog: MockProg) -> Self {","            Self { prog }","        }","","        fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {","            self.prog.find(&text[at..]).map(|(s, _)| at + s.len())","        }","    }","","    let dfa = DFA::new(MockProg::new(vec![\"abc\", \"def\"]));","    assert_eq!(dfa.prefix_at(b\"abcdef\", 10), None);","}"],[]]]}