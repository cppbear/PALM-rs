{"function_name":"regex::compile::compile::InstHole::fill","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":5,"tests_lines":[10,10,10,10,11],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":24,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,866],"codes_lines_covered":[[["{","    let inst_hole = InstHole::Save { slot: 1 };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Save(InstSave { goto: _, slot }) = result {","        assert_eq!(slot, 1);","    } else {","        panic!(\"Expected Inst::Save\");","    }","}"],[]],[["{","    let inst_hole = InstHole::EmptyLook { look: 'a' };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::EmptyLook(InstEmptyLook { goto: _, look }) = result {","        assert_eq!(look, 'a');","    } else {","        panic!(\"Expected Inst::EmptyLook\");","    }","}"],[]],[["{","    let inst_hole = InstHole::Char { c: 'b' };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Char(InstChar { goto: _, c }) = result {","        assert_eq!(c, 'b');","    } else {","        panic!(\"Expected Inst::Char\");","    }","}"],[]],[["{","    let inst_hole = InstHole::Ranges { ranges: vec!['c', 'd'] };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Ranges(InstRanges { goto: _, ranges }) = result {","        assert_eq!(ranges, vec!['c', 'd']);","    } else {","        panic!(\"Expected Inst::Ranges\");","    }","}"],[]],[["{","    let inst_hole = InstHole::Bytes { start: 1, end: 10 };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Bytes(InstBytes { goto: _, start, end }) = result {","        assert_eq!(start, 1);","        assert_eq!(end, 10);","    } else {","        panic!(\"Expected Inst::Bytes\");","    }","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    let inst_hole = InstHole::Save { slot: 1 };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Save(InstSave { goto: _, slot }) = result {","        assert_eq!(slot, 1);","    } else {","        panic!(\"Expected Inst::Save\");","    }","}"],[]],[["{","    let inst_hole = InstHole::EmptyLook { look: 'a' };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::EmptyLook(InstEmptyLook { goto: _, look }) = result {","        assert_eq!(look, 'a');","    } else {","        panic!(\"Expected Inst::EmptyLook\");","    }","}"],[]],[["{","    let inst_hole = InstHole::Char { c: 'b' };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Char(InstChar { goto: _, c }) = result {","        assert_eq!(c, 'b');","    } else {","        panic!(\"Expected Inst::Char\");","    }","}"],[]],[["{","    let inst_hole = InstHole::Ranges { ranges: vec!['c', 'd'] };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Ranges(InstRanges { goto: _, ranges }) = result {","        assert_eq!(ranges, vec!['c', 'd']);","    } else {","        panic!(\"Expected Inst::Ranges\");","    }","}"],[]],[["{","    let inst_hole = InstHole::Bytes { start: 1, end: 10 };","    let goto = InstPtr;","    let result = inst_hole.fill(goto);","    if let Inst::Bytes(InstBytes { goto: _, start, end }) = result {","        assert_eq!(start, 1);","        assert_eq!(end, 10);","    } else {","        panic!(\"Expected Inst::Bytes\");","    }","}"],[]]]}