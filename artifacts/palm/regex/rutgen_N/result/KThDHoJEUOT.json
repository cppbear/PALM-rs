{"function_name":"regex::literal::literal::BoyerMooreSearch::skip_loop","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[67,67],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":0,"oracles_passed_rate":0.0,"tests_run":2,"tests_passed":0,"tests_passed_rate":0.0,"lines":47,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":10,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[770,771,772,773,774,777,778,779,780,781,782,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,806,807,808,809,810,814,815,816,817,818,819,820,821,825,826,827,829,831],"codes_lines_covered":[[["{","    struct TestStruct {","        skip_table: Vec<usize>,","        guard: u8,","        guard_reverse_idx: usize,","    }","","    impl TestStruct {","        fn new(skip_table: Vec<usize>, guard: u8, guard_reverse_idx: usize) -> Self {","            Self { skip_table, guard, guard_reverse_idx }","        }","","        fn skip_loop(&self, haystack: &[u8], mut window_end: usize, backstop: usize) -> Option<usize> {","            use std::mem;","","            let window_end_snapshot = window_end;","            let skip_of = |we: usize| -> usize {","                self.skip_table[haystack[we] as usize]","            };","","            loop {","                let mut skip = skip_of(window_end); window_end += skip;","                skip = skip_of(window_end); window_end += skip;","                if skip != 0 {","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    if skip != 0 {","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        if skip != 0 {","                            skip = skip_of(window_end); window_end += skip;","                            skip = skip_of(window_end); window_end += skip;","","                            if window_end - window_end_snapshot > 16 * mem::size_of::<usize>() {","                                if window_end >= backstop {","                                    return Some(window_end);","                                }","                                continue;","                            } else {","                                window_end = window_end.checked_sub(1 + self.guard_reverse_idx).unwrap_or(0);","                                match memchr::memchr(self.guard, &haystack[window_end..]) {","                                    None => return None,","                                    Some(g_idx) => {","                                        return Some(window_end + g_idx + self.guard_reverse_idx);","                                    }","                                }","                            }","                        }","                    }","                }","","                return Some(window_end);","            }","        }","    }","","    let skip_table = vec![0, 1, 2, 3, 4, 5];","    let guard = b'g'; // Example guard character.","    let guard_reverse_idx = 1;","    ","    let tester = TestStruct::new(skip_table, guard, guard_reverse_idx);","    let haystack = b\"hello world\";","    let result = tester.skip_loop(haystack, 5, 10);","    assert_eq!(result, Some(11));","}"],[]],[["{","    struct TestStruct {","        skip_table: Vec<usize>,","        guard: u8,","        guard_reverse_idx: usize,","    }","","    impl TestStruct {","        fn new(skip_table: Vec<usize>, guard: u8, guard_reverse_idx: usize) -> Self {","            Self { skip_table, guard, guard_reverse_idx }","        }","","        fn skip_loop(&self, haystack: &[u8], mut window_end: usize, backstop: usize) -> Option<usize> {","            use std::mem;","","            let window_end_snapshot = window_end;","            let skip_of = |we: usize| -> usize {","                self.skip_table[haystack[we] as usize]","            };","","            loop {","                let mut skip = skip_of(window_end); window_end += skip;","                skip = skip_of(window_end); window_end += skip;","                if skip != 0 {","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    if skip != 0 {","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        if skip != 0 {","                            skip = skip_of(window_end); window_end += skip;","                            skip = skip_of(window_end); window_end += skip;","","                            if window_end - window_end_snapshot > 16 * mem::size_of::<usize>() {","                                if window_end >= backstop {","                                    return Some(window_end);","                                }","                                continue;","                            } else {","                                window_end = window_end.checked_sub(1 + self.guard_reverse_idx).unwrap_or(0);","                                match memchr::memchr(self.guard, &haystack[window_end..]) {","                                    None => return None,","                                    Some(g_idx) => {","                                        return Some(window_end + g_idx + self.guard_reverse_idx);","                                    }","                                }","                            }","                        }","                    }","                }","","                return Some(window_end);","            }","        }","    }","","    let skip_table = vec![0, 1, 2, 3, 4, 5];","    let guard = b'g'; // Example guard character.","    let guard_reverse_idx = 1;","","    let tester = TestStruct::new(skip_table, guard, guard_reverse_idx);","    let haystack = b\"hello\";","    let result = tester.skip_loop(haystack, 5, 10);","    assert_eq!(result, None);","}"],[]]],"codes_branches":[{"start_line":787,"start_column":16,"end_line":787,"end_column":25,"positive":false,"negative":false},{"start_line":791,"start_column":20,"end_line":791,"end_column":29,"positive":false,"negative":false},{"start_line":795,"start_column":24,"end_line":795,"end_column":33,"positive":false,"negative":false},{"start_line":801,"start_column":28,"end_line":802,"end_column":58,"positive":false,"negative":false},{"start_line":806,"start_column":32,"end_line":806,"end_column":54,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestStruct {","        skip_table: Vec<usize>,","        guard: u8,","        guard_reverse_idx: usize,","    }","","    impl TestStruct {","        fn new(skip_table: Vec<usize>, guard: u8, guard_reverse_idx: usize) -> Self {","            Self { skip_table, guard, guard_reverse_idx }","        }","","        fn skip_loop(&self, haystack: &[u8], mut window_end: usize, backstop: usize) -> Option<usize> {","            use std::mem;","","            let window_end_snapshot = window_end;","            let skip_of = |we: usize| -> usize {","                self.skip_table[haystack[we] as usize]","            };","","            loop {","                let mut skip = skip_of(window_end); window_end += skip;","                skip = skip_of(window_end); window_end += skip;","                if skip != 0 {","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    if skip != 0 {","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        if skip != 0 {","                            skip = skip_of(window_end); window_end += skip;","                            skip = skip_of(window_end); window_end += skip;","","                            if window_end - window_end_snapshot > 16 * mem::size_of::<usize>() {","                                if window_end >= backstop {","                                    return Some(window_end);","                                }","                                continue;","                            } else {","                                window_end = window_end.checked_sub(1 + self.guard_reverse_idx).unwrap_or(0);","                                match memchr::memchr(self.guard, &haystack[window_end..]) {","                                    None => return None,","                                    Some(g_idx) => {","                                        return Some(window_end + g_idx + self.guard_reverse_idx);","                                    }","                                }","                            }","                        }","                    }","                }","","                return Some(window_end);","            }","        }","    }","","    let skip_table = vec![0, 1, 2, 3, 4, 5];","    let guard = b'g'; // Example guard character.","    let guard_reverse_idx = 1;","    ","    let tester = TestStruct::new(skip_table, guard, guard_reverse_idx);","    let haystack = b\"hello world\";","    let result = tester.skip_loop(haystack, 5, 10);","    assert_eq!(result, Some(11));","}"],[{"start_line":787,"start_column":16,"end_line":787,"end_column":25,"positive":false,"negative":false},{"start_line":791,"start_column":20,"end_line":791,"end_column":29,"positive":false,"negative":false},{"start_line":795,"start_column":24,"end_line":795,"end_column":33,"positive":false,"negative":false},{"start_line":801,"start_column":28,"end_line":802,"end_column":58,"positive":false,"negative":false},{"start_line":806,"start_column":32,"end_line":806,"end_column":54,"positive":false,"negative":false}]],[["{","    struct TestStruct {","        skip_table: Vec<usize>,","        guard: u8,","        guard_reverse_idx: usize,","    }","","    impl TestStruct {","        fn new(skip_table: Vec<usize>, guard: u8, guard_reverse_idx: usize) -> Self {","            Self { skip_table, guard, guard_reverse_idx }","        }","","        fn skip_loop(&self, haystack: &[u8], mut window_end: usize, backstop: usize) -> Option<usize> {","            use std::mem;","","            let window_end_snapshot = window_end;","            let skip_of = |we: usize| -> usize {","                self.skip_table[haystack[we] as usize]","            };","","            loop {","                let mut skip = skip_of(window_end); window_end += skip;","                skip = skip_of(window_end); window_end += skip;","                if skip != 0 {","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    skip = skip_of(window_end); window_end += skip;","                    if skip != 0 {","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        skip = skip_of(window_end); window_end += skip;","                        if skip != 0 {","                            skip = skip_of(window_end); window_end += skip;","                            skip = skip_of(window_end); window_end += skip;","","                            if window_end - window_end_snapshot > 16 * mem::size_of::<usize>() {","                                if window_end >= backstop {","                                    return Some(window_end);","                                }","                                continue;","                            } else {","                                window_end = window_end.checked_sub(1 + self.guard_reverse_idx).unwrap_or(0);","                                match memchr::memchr(self.guard, &haystack[window_end..]) {","                                    None => return None,","                                    Some(g_idx) => {","                                        return Some(window_end + g_idx + self.guard_reverse_idx);","                                    }","                                }","                            }","                        }","                    }","                }","","                return Some(window_end);","            }","        }","    }","","    let skip_table = vec![0, 1, 2, 3, 4, 5];","    let guard = b'g'; // Example guard character.","    let guard_reverse_idx = 1;","","    let tester = TestStruct::new(skip_table, guard, guard_reverse_idx);","    let haystack = b\"hello\";","    let result = tester.skip_loop(haystack, 5, 10);","    assert_eq!(result, None);","}"],[{"start_line":787,"start_column":16,"end_line":787,"end_column":25,"positive":false,"negative":false},{"start_line":791,"start_column":20,"end_line":791,"end_column":29,"positive":false,"negative":false},{"start_line":795,"start_column":24,"end_line":795,"end_column":33,"positive":false,"negative":false},{"start_line":801,"start_column":28,"end_line":802,"end_column":58,"positive":false,"negative":false},{"start_line":806,"start_column":32,"end_line":806,"end_column":54,"positive":false,"negative":false}]]]}