{"function_name":"regex::dfa::dfa::Fsm<'a>::follow_epsilons","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[69,69],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":50,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":20,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[1073,1074,1075,1076,1077,1078,1084,1085,1090,1091,1092,1093,1094,1095,1097,1099,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1130,1134,1135,1136,1137,1138,1139,1140,1144],"codes_lines_covered":[[["{","    struct TestDFA {","        cache: Cache,","        prog: Vec<Inst>,","    }","","    struct Cache {","        stack: Vec<InstPtr>,","    }","","    struct SparseSet {","        elements: std::collections::HashSet<usize>,","    }","","    impl SparseSet {","        fn new() -> Self {","            SparseSet {","                elements: std::collections::HashSet::new(),","            }","        }","        ","        fn contains(&self, item: usize) -> bool {","            self.elements.contains(&item)","        }","","        fn insert(&mut self, item: usize) {","            self.elements.insert(item);","        }","    }","","    struct EmptyFlags {","        start_line: bool,","        end_line: bool,","        start: bool,","        end: bool,","        word_boundary: bool,","        not_word_boundary: bool,","    }","","    impl TestDFA {","        fn follow_epsilons(","            &mut self,","            ip: InstPtr,","            q: &mut SparseSet,","            flags: EmptyFlags,","        ) {","            // Function content copied from initial implementation","        }","    }","","    let mut test_dfa = TestDFA {","        cache: Cache { stack: Vec::new() },","        prog: vec![","            // Populate prog with appropriate Inst variants for testing","        ],","    };","    let mut sparse_set = SparseSet::new();","    let flags = EmptyFlags {","        start_line: false,","        end_line: false,","        start: false,","        end: true,","        word_boundary: false,","        not_word_boundary: false,","    };","    test_dfa.follow_epsilons(0, &mut sparse_set, flags);","    ","    // Assert expected outcomes","}"],[]],[["{","    struct TestDFA {","        cache: Cache,","        prog: Vec<Inst>,","    }","","    struct Cache {","        stack: Vec<InstPtr>,","    }","","    struct SparseSet {","        elements: std::collections::HashSet<usize>,","    }","","    impl SparseSet {","        fn new() -> Self {","            SparseSet {","                elements: std::collections::HashSet::new(),","            }","        }","        ","        fn contains(&self, item: usize) -> bool {","            self.elements.contains(&item)","        }","","        fn insert(&mut self, item: usize) {","            self.elements.insert(item);","        }","    }","","    struct EmptyFlags {","        start_line: bool,","        end_line: bool,","        start: bool,","        end: bool,","        word_boundary: bool,","        not_word_boundary: bool,","    }","","    impl TestDFA {","        fn follow_epsilons(","            &mut self,","            ip: InstPtr,","            q: &mut SparseSet,","            flags: EmptyFlags,","        ) {","            // Function content copied from initial implementation","        }","    }","","    let mut test_dfa = TestDFA {","        cache: Cache { stack: Vec::new() },","        prog: vec![","            // Populate prog with appropriate Inst variants for testing","        ],","    };","    let mut sparse_set = SparseSet::new();","    let flags = EmptyFlags {","        start_line: true,","        end_line: false,","        start: false,","        end: false,","        word_boundary: false,","        not_word_boundary: false,","    };","    test_dfa.follow_epsilons(1, &mut sparse_set, flags);","    ","    // Assert expected outcomes","}"],[]]],"codes_branches":[{"start_line":1085,"start_column":19,"end_line":1085,"end_column":31,"positive":false,"negative":false},{"start_line":1090,"start_column":20,"end_line":1090,"end_column":43,"positive":false,"negative":false},{"start_line":1103,"start_column":42,"end_line":1103,"end_column":58,"positive":false,"negative":false},{"start_line":1106,"start_column":40,"end_line":1106,"end_column":54,"positive":false,"negative":false},{"start_line":1109,"start_column":42,"end_line":1109,"end_column":53,"positive":false,"negative":false},{"start_line":1112,"start_column":40,"end_line":1112,"end_column":49,"positive":false,"negative":false},{"start_line":1115,"start_column":50,"end_line":1115,"end_column":69,"positive":false,"negative":false},{"start_line":1118,"start_column":53,"end_line":1118,"end_column":76,"positive":false,"negative":false},{"start_line":1121,"start_column":45,"end_line":1121,"end_column":64,"positive":false,"negative":false},{"start_line":1124,"start_column":48,"end_line":1124,"end_column":71,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    struct TestDFA {","        cache: Cache,","        prog: Vec<Inst>,","    }","","    struct Cache {","        stack: Vec<InstPtr>,","    }","","    struct SparseSet {","        elements: std::collections::HashSet<usize>,","    }","","    impl SparseSet {","        fn new() -> Self {","            SparseSet {","                elements: std::collections::HashSet::new(),","            }","        }","        ","        fn contains(&self, item: usize) -> bool {","            self.elements.contains(&item)","        }","","        fn insert(&mut self, item: usize) {","            self.elements.insert(item);","        }","    }","","    struct EmptyFlags {","        start_line: bool,","        end_line: bool,","        start: bool,","        end: bool,","        word_boundary: bool,","        not_word_boundary: bool,","    }","","    impl TestDFA {","        fn follow_epsilons(","            &mut self,","            ip: InstPtr,","            q: &mut SparseSet,","            flags: EmptyFlags,","        ) {","            // Function content copied from initial implementation","        }","    }","","    let mut test_dfa = TestDFA {","        cache: Cache { stack: Vec::new() },","        prog: vec![","            // Populate prog with appropriate Inst variants for testing","        ],","    };","    let mut sparse_set = SparseSet::new();","    let flags = EmptyFlags {","        start_line: false,","        end_line: false,","        start: false,","        end: true,","        word_boundary: false,","        not_word_boundary: false,","    };","    test_dfa.follow_epsilons(0, &mut sparse_set, flags);","    ","    // Assert expected outcomes","}"],[{"start_line":1085,"start_column":19,"end_line":1085,"end_column":31,"positive":false,"negative":false},{"start_line":1090,"start_column":20,"end_line":1090,"end_column":43,"positive":false,"negative":false},{"start_line":1103,"start_column":42,"end_line":1103,"end_column":58,"positive":false,"negative":false},{"start_line":1106,"start_column":40,"end_line":1106,"end_column":54,"positive":false,"negative":false},{"start_line":1109,"start_column":42,"end_line":1109,"end_column":53,"positive":false,"negative":false},{"start_line":1112,"start_column":40,"end_line":1112,"end_column":49,"positive":false,"negative":false},{"start_line":1115,"start_column":50,"end_line":1115,"end_column":69,"positive":false,"negative":false},{"start_line":1118,"start_column":53,"end_line":1118,"end_column":76,"positive":false,"negative":false},{"start_line":1121,"start_column":45,"end_line":1121,"end_column":64,"positive":false,"negative":false},{"start_line":1124,"start_column":48,"end_line":1124,"end_column":71,"positive":false,"negative":false}]],[["{","    struct TestDFA {","        cache: Cache,","        prog: Vec<Inst>,","    }","","    struct Cache {","        stack: Vec<InstPtr>,","    }","","    struct SparseSet {","        elements: std::collections::HashSet<usize>,","    }","","    impl SparseSet {","        fn new() -> Self {","            SparseSet {","                elements: std::collections::HashSet::new(),","            }","        }","        ","        fn contains(&self, item: usize) -> bool {","            self.elements.contains(&item)","        }","","        fn insert(&mut self, item: usize) {","            self.elements.insert(item);","        }","    }","","    struct EmptyFlags {","        start_line: bool,","        end_line: bool,","        start: bool,","        end: bool,","        word_boundary: bool,","        not_word_boundary: bool,","    }","","    impl TestDFA {","        fn follow_epsilons(","            &mut self,","            ip: InstPtr,","            q: &mut SparseSet,","            flags: EmptyFlags,","        ) {","            // Function content copied from initial implementation","        }","    }","","    let mut test_dfa = TestDFA {","        cache: Cache { stack: Vec::new() },","        prog: vec![","            // Populate prog with appropriate Inst variants for testing","        ],","    };","    let mut sparse_set = SparseSet::new();","    let flags = EmptyFlags {","        start_line: true,","        end_line: false,","        start: false,","        end: false,","        word_boundary: false,","        not_word_boundary: false,","    };","    test_dfa.follow_epsilons(1, &mut sparse_set, flags);","    ","    // Assert expected outcomes","}"],[{"start_line":1085,"start_column":19,"end_line":1085,"end_column":31,"positive":false,"negative":false},{"start_line":1090,"start_column":20,"end_line":1090,"end_column":43,"positive":false,"negative":false},{"start_line":1103,"start_column":42,"end_line":1103,"end_column":58,"positive":false,"negative":false},{"start_line":1106,"start_column":40,"end_line":1106,"end_column":54,"positive":false,"negative":false},{"start_line":1109,"start_column":42,"end_line":1109,"end_column":53,"positive":false,"negative":false},{"start_line":1112,"start_column":40,"end_line":1112,"end_column":49,"positive":false,"negative":false},{"start_line":1115,"start_column":50,"end_line":1115,"end_column":69,"positive":false,"negative":false},{"start_line":1118,"start_column":53,"end_line":1118,"end_column":76,"positive":false,"negative":false},{"start_line":1121,"start_column":45,"end_line":1121,"end_column":64,"positive":false,"negative":false},{"start_line":1124,"start_column":48,"end_line":1124,"end_column":71,"positive":false,"negative":false}]]]}