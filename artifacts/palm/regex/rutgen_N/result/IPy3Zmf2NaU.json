{"function_name":"regex::dfa::dfa::Cache::new","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/dfa.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":1,"tests_lines":[80],"oracles":1,"oracles_compiled":1,"oracles_compiled_rate":100.0,"tests_compiled":1,"tests_compiled_rate":100.0,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":1,"tests_passed":1,"tests_passed_rate":100.0,"lines":20,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444],"codes_lines_covered":[[["{","    struct Program {","        byte_classes: [u8; 256],","        insts: Vec<u8>,","    }","","    struct CacheInner {","        compiled: std::collections::HashMap<u8, u8>,","        trans: Transitions,","        states: Vec<u8>,","        start_states: Vec<u8>,","        stack: Vec<u8>,","        flush_count: usize,","        size: usize,","    }","","    struct Cache {","        inner: CacheInner,","        qcur: SparseSet,","        qnext: SparseSet,","    }","","    struct Transitions {","        num_byte_classes: usize,","    }","","    impl Transitions {","        fn new(num_byte_classes: usize) -> Self {","            Transitions { num_byte_classes }","        }","    }","","    struct SparseSet {","        set: Vec<bool>,","    }","","    impl SparseSet {","        fn new(size: usize) -> Self {","            SparseSet { set: vec![false; size] }","        }","    }","","    impl CacheInner {","        fn reset_size(&mut self) {","            self.size = 0;","        }","    }","","    fn new(prog: &Program) -> Cache {","        let num_byte_classes = (prog.byte_classes[255] as usize + 1) + 1;","        let starts = vec![0; 256];","        let mut cache = Cache {","            inner: CacheInner {","                compiled: std::collections::HashMap::new(),","                trans: Transitions::new(num_byte_classes),","                states: vec![],","                start_states: starts,","                stack: vec![],","                flush_count: 0,","                size: 0,","            },","            qcur: SparseSet::new(prog.insts.len()),","            qnext: SparseSet::new(prog.insts.len()),","        };","        cache.inner.reset_size();","        cache","    }","","    let prog = Program {","        byte_classes: [0; 256],","        insts: vec![],","    };","    let cache = new(&prog);","    ","    assert_eq!(cache.inner.flush_count, 0);","    assert_eq!(cache.inner.size, 0);","    assert_eq!(cache.inner.start_states.len(), 256);","    assert!(cache.inner.states.is_empty());","    assert!(cache.inner.compiled.is_empty());","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct Program {","        byte_classes: [u8; 256],","        insts: Vec<u8>,","    }","","    struct CacheInner {","        compiled: std::collections::HashMap<u8, u8>,","        trans: Transitions,","        states: Vec<u8>,","        start_states: Vec<u8>,","        stack: Vec<u8>,","        flush_count: usize,","        size: usize,","    }","","    struct Cache {","        inner: CacheInner,","        qcur: SparseSet,","        qnext: SparseSet,","    }","","    struct Transitions {","        num_byte_classes: usize,","    }","","    impl Transitions {","        fn new(num_byte_classes: usize) -> Self {","            Transitions { num_byte_classes }","        }","    }","","    struct SparseSet {","        set: Vec<bool>,","    }","","    impl SparseSet {","        fn new(size: usize) -> Self {","            SparseSet { set: vec![false; size] }","        }","    }","","    impl CacheInner {","        fn reset_size(&mut self) {","            self.size = 0;","        }","    }","","    fn new(prog: &Program) -> Cache {","        let num_byte_classes = (prog.byte_classes[255] as usize + 1) + 1;","        let starts = vec![0; 256];","        let mut cache = Cache {","            inner: CacheInner {","                compiled: std::collections::HashMap::new(),","                trans: Transitions::new(num_byte_classes),","                states: vec![],","                start_states: starts,","                stack: vec![],","                flush_count: 0,","                size: 0,","            },","            qcur: SparseSet::new(prog.insts.len()),","            qnext: SparseSet::new(prog.insts.len()),","        };","        cache.inner.reset_size();","        cache","    }","","    let prog = Program {","        byte_classes: [0; 256],","        insts: vec![],","    };","    let cache = new(&prog);","    ","    assert_eq!(cache.inner.flush_count, 0);","    assert_eq!(cache.inner.size, 0);","    assert_eq!(cache.inner.start_states.len(), 256);","    assert!(cache.inner.states.is_empty());","    assert!(cache.inner.compiled.is_empty());","}"],[]]]}