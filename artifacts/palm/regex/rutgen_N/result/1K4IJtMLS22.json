{"function_name":"regex::compile::compile::Compiler::push_hole","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":2,"tests_lines":[33,35],"oracles":2,"oracles_compiled":2,"oracles_compiled_rate":100.0,"tests_compiled":2,"tests_compiled_rate":100.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":5,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[739,740,741,742,743],"codes_lines_covered":[[["{","    struct TestStruct {","        insts: Vec<MaybeInst>,","    }","","    impl TestStruct {","        fn push_hole(&mut self, inst: InstHole) -> Hole {","            let hole = self.insts.len();","            self.insts.push(MaybeInst::Uncompiled(inst));","            Hole::One(hole)","        }","    }","","    enum MaybeInst {","        Uncompiled(InstHole),","    }","","    struct InstHole;","","    enum Hole {","        One(usize),","    }","","    let mut test_struct = TestStruct { insts: Vec::new() };","    let inst = InstHole;","","    let hole_result = test_struct.push_hole(inst);","    match hole_result {","        Hole::One(index) => assert_eq!(index, 0),","    }","","    assert_eq!(test_struct.insts.len(), 1);","}"],[]],[["{","    struct TestStruct {","        insts: Vec<MaybeInst>,","    }","","    impl TestStruct {","        fn push_hole(&mut self, inst: InstHole) -> Hole {","            let hole = self.insts.len();","            self.insts.push(MaybeInst::Uncompiled(inst));","            Hole::One(hole)","        }","    }","","    enum MaybeInst {","        Uncompiled(InstHole),","    }","","    struct InstHole;","","    enum Hole {","        One(usize),","    }","","    let mut test_struct = TestStruct { insts: Vec::new() };","","    for _ in 0..5 {","        let inst = InstHole;","        let hole_result = test_struct.push_hole(inst);","        match hole_result {","            Hole::One(index) => assert_eq!(index, test_struct.insts.len() - 1),","        }","    }","","    assert_eq!(test_struct.insts.len(), 5);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestStruct {","        insts: Vec<MaybeInst>,","    }","","    impl TestStruct {","        fn push_hole(&mut self, inst: InstHole) -> Hole {","            let hole = self.insts.len();","            self.insts.push(MaybeInst::Uncompiled(inst));","            Hole::One(hole)","        }","    }","","    enum MaybeInst {","        Uncompiled(InstHole),","    }","","    struct InstHole;","","    enum Hole {","        One(usize),","    }","","    let mut test_struct = TestStruct { insts: Vec::new() };","    let inst = InstHole;","","    let hole_result = test_struct.push_hole(inst);","    match hole_result {","        Hole::One(index) => assert_eq!(index, 0),","    }","","    assert_eq!(test_struct.insts.len(), 1);","}"],[]],[["{","    struct TestStruct {","        insts: Vec<MaybeInst>,","    }","","    impl TestStruct {","        fn push_hole(&mut self, inst: InstHole) -> Hole {","            let hole = self.insts.len();","            self.insts.push(MaybeInst::Uncompiled(inst));","            Hole::One(hole)","        }","    }","","    enum MaybeInst {","        Uncompiled(InstHole),","    }","","    struct InstHole;","","    enum Hole {","        One(usize),","    }","","    let mut test_struct = TestStruct { insts: Vec::new() };","","    for _ in 0..5 {","        let inst = InstHole;","        let hole_result = test_struct.push_hole(inst);","        match hole_result {","            Hole::One(index) => assert_eq!(index, test_struct.insts.len() - 1),","        }","    }","","    assert_eq!(test_struct.insts.len(), 5);","}"],[]]]}