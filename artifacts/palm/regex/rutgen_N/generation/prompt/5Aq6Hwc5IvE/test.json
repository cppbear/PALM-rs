{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// regex-syntax/src/ast/parse.rs\n// crate name is regex_syntax\nThe function to be tested is presented as follows:\n/// Parse the end of a character class set and pop the character class\n/// parser stack. The union given corresponds to the last union built\n/// before seeing the closing `]`. The union returned corresponds to the\n/// parent character class set with the nested class added to it.\n///\n/// This assumes that the parser is positioned at a `]` and will advance\n/// the parser to the byte immediately following the `]`.\n///\n/// If the stack is empty after popping, then this returns the final\n/// \"top-level\" character class AST (where a \"top-level\" character class\n/// is one that is not nested inside any other character class).\n///\n/// If there is no corresponding opening bracket on the parser's stack,\n/// then an error is returned.\nfn pop_class(\n    &self,\n    nested_union: ast::ClassSetUnion,\n) -> Result<Either<ast::ClassSetUnion, ast::Class>> {\n    assert_eq!(self.char(), ']');\n\n    let item = ast::ClassSet::Item(nested_union.into_item());\n    let prevset = self.pop_class_op(item);\n    let mut stack = self.parser().stack_class.borrow_mut();\n    match stack.pop() {\n        None => {\n            // We can never observe an empty stack:\n            //\n            // 1) We are guaranteed to start with a non-empty stack since\n            //    the character class parser is only initiated when it sees\n            //    a `[`.\n            // 2) If we ever observe an empty stack while popping after\n            //    seeing a `]`, then we signal the character class parser\n            //    to terminate.\n            panic!(\"unexpected empty character class stack\")\n        },\n        Some(ClassState::Op { .. }) => {\n            // This panic is unfortunate, but this case is impossible\n            // since we already popped the Op state if one exists above.\n            // Namely, every push to the class parser stack is guarded by\n            // whether an existing Op is already on the top of the stack.\n            // If it is, the existing Op is modified. That is, the stack\n            // can never have consecutive Op states.\n            panic!(\"unexpected ClassState::Op\")\n        }\n        Some(ClassState::Open { mut union, mut set }) => {\n            self.bump();\n            set.span.end = self.pos();\n            set.kind = prevset;\n            if stack.is_empty() {\n                Ok(Either::Right(ast::Class::Bracketed(set)))\n            } else {\n                union.push(ast::ClassSetItem::Bracketed(Box::new(set)));\n                Ok(Either::Left(union))\n            }\n        }\n    }\n}\n",
  "depend_pt": ""
}