{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/compile.rs\n// crate name is regex\nThe function to be tested is presented as follows:\n/// Compile expr into self.insts, returning a patch on success,\n/// or an error if we run out of memory.\n///\n/// All of the c_* methods of the compiler share the contract outlined\n/// here.\n///\n/// The main thing that a c_* method does is mutate `self.insts`\n/// to add a list of mostly compiled instructions required to execute\n/// the given expression. `self.insts` contains MaybeInsts rather than\n/// Insts because there is some backpatching required.\n///\n/// The `Patch` value returned by each c_* method provides metadata\n/// about the compiled instructions emitted to `self.insts`. The\n/// `entry` member of the patch refers to the first instruction\n/// (the entry point), while the `hole` member contains zero or\n/// more offsets to partial instructions that need to be backpatched.\n/// The c_* routine can't know where its list of instructions are going to\n/// jump to after execution, so it is up to the caller to patch\n/// these jumps to point to the right place. So compiling some\n/// expression, e, we would end up with a situation that looked like:\n///\n/// ```text\n/// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n///                     ^              ^             ^\n///                     |                \\         /\n///                   entry                \\     /\n///                                         hole\n/// ```\n///\n/// To compile two expressions, e1 and e2, concatinated together we\n/// would do:\n///\n/// ```ignore\n/// let patch1 = self.c(e1);\n/// let patch2 = self.c(e2);\n/// ```\n///\n/// while leaves us with a situation that looks like\n///\n/// ```text\n/// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n///                     ^        ^            ^        ^\n///                     |        |            |        |\n///                entry1        hole1   entry2        hole2\n/// ```\n///\n/// Then to merge the two patches together into one we would backpatch\n/// hole1 with entry2 and return a new patch that enters at entry1\n/// and has hole2 for a hole. In fact, if you look at the c_concat\n/// method you will see that it does exactly this, though it handles\n/// a list of expressions rather than just the two that we use for\n/// an example.\nfn c(&mut self, expr: &Hir) -> Result {\n    use prog;\n    use syntax::hir::HirKind::*;\n\n    self.check_size()?;\n    match *expr.kind() {\n        Empty => Ok(Patch { hole: Hole::None, entry: self.insts.len() }),\n        Literal(hir::Literal::Unicode(c)) => {\n            self.c_literal(&[c])\n        }\n        Literal(hir::Literal::Byte(b)) => {\n            assert!(self.compiled.uses_bytes());\n            self.c_bytes(&[b])\n        }\n        Class(hir::Class::Unicode(ref cls)) => {\n            self.c_class(cls.ranges())\n        }\n        Class(hir::Class::Bytes(ref cls)) => {\n            if self.compiled.uses_bytes() {\n                self.c_class_bytes(cls.ranges())\n            } else {\n                assert!(cls.is_all_ascii());\n                let mut char_ranges = vec![];\n                for r in cls.iter() {\n                    let (s, e) = (r.start() as char, r.end() as char);\n                    char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                }\n                self.c_class(&char_ranges)\n            }\n        }\n        Anchor(hir::Anchor::StartLine) if self.compiled.is_reverse => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::EndLine)\n        }\n        Anchor(hir::Anchor::StartLine) => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::StartLine)\n        }\n        Anchor(hir::Anchor::EndLine) if self.compiled.is_reverse => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::StartLine)\n        }\n        Anchor(hir::Anchor::EndLine) => {\n            self.byte_classes.set_range(b'\\n', b'\\n');\n            self.c_empty_look(prog::EmptyLook::EndLine)\n        }\n        Anchor(hir::Anchor::StartText) if self.compiled.is_reverse => {\n            self.c_empty_look(prog::EmptyLook::EndText)\n        }\n        Anchor(hir::Anchor::StartText) => {\n            self.c_empty_look(prog::EmptyLook::StartText)\n        }\n        Anchor(hir::Anchor::EndText) if self.compiled.is_reverse => {\n            self.c_empty_look(prog::EmptyLook::StartText)\n        }\n        Anchor(hir::Anchor::EndText) => {\n            self.c_empty_look(prog::EmptyLook::EndText)\n        }\n        WordBoundary(hir::WordBoundary::Unicode) => {\n            self.compiled.has_unicode_word_boundary = true;\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::WordBoundary)\n        }\n        WordBoundary(hir::WordBoundary::UnicodeNegate) => {\n            self.compiled.has_unicode_word_boundary = true;\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n        }\n        WordBoundary(hir::WordBoundary::Ascii) => {\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n        }\n        WordBoundary(hir::WordBoundary::AsciiNegate) => {\n            self.byte_classes.set_word_boundary();\n            self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n        }\n        Group(ref g) => {\n            match g.kind {\n                hir::GroupKind::NonCapturing => self.c(&g.hir),\n                hir::GroupKind::CaptureIndex(index) => {\n                    if index as usize >= self.compiled.captures.len() {\n                        self.compiled.captures.push(None);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n                hir::GroupKind::CaptureName { index, ref name } => {\n                    if index as usize >= self.compiled.captures.len() {\n                        let n = name.to_string();\n                        self.compiled.captures.push(Some(n.clone()));\n                        self.capture_name_idx.insert(n, index as usize);\n                    }\n                    self.c_capture(2 * index as usize, &g.hir)\n                }\n            }\n        }\n        Concat(ref es) => {\n            if self.compiled.is_reverse {\n                self.c_concat(es.iter().rev())\n            } else {\n                self.c_concat(es)\n            }\n        }\n        Alternation(ref es) => self.c_alternate(&**es),\n        Repetition(ref rep) => self.c_repeat(rep),\n    }\n}\n",
  "depend_pt": ""
}