{"function_name":"regex_syntax::hir::literal::escape_bytes","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":25,"tests_lines":[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,7,7,7,7,7,7,8],"oracles":12,"oracles_compiled":11,"oracles_compiled_rate":91.66666666666666,"tests_compiled":24,"tests_compiled_rate":96.0,"oracles_run":11,"oracles_passed":6,"oracles_passed_rate":54.54545454545454,"tests_run":24,"tests_passed":15,"tests_passed_rate":62.5,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[973,974,975,976,977,978,979],"codes_lines_covered":[[["{","    let bytes: &[u8] = &[];","    escape_bytes(bytes);","    let bytes: &[u8] = &[];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\");","}"],[973,974,975,978,979]],[["{","    let bytes: &[u8] = &[0];","    escape_bytes(bytes);","    let bytes: &[u8] = &[0];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{0}\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[255];","    escape_bytes(bytes);","    let bytes: &[u8] = &[255];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{ff}\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(!result.is_empty());","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert_eq!(result.len(), 3072);","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"\\\\x\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"a\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"b\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"c\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"0\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"1\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"2\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"255\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[128, 130, 195, 200, 250];","    escape_bytes(bytes);","    let bytes: &[u8] = &[128, 130, 195, 200, 250];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\\\x80\\\\x82\\\\xc3\\\\xc8\\\\xfa\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[];","    escape_bytes(bytes);","    let bytes: &[u8] = &[];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\");","}"],[973,974,975,978,979]],[["{","    let bytes: &[u8] = &[0];","    escape_bytes(bytes);","    let bytes: &[u8] = &[0];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{0}\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[1, 2, 3, 4, 5];","    escape_bytes(bytes);","    let bytes: &[u8] = &[1, 2, 3, 4, 5];","    let result = escape_bytes(bytes);","    let expected = \"\\x01\\x02\\x03\\x04\\x05\"; // Expected escaped string based on byte values","    assert_eq!(result, expected);","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[b'A', b'!', b'\\n', b'\\r', b'\\t'];","    escape_bytes(bytes);","    let bytes: &[u8] = &[b'A', b'!', b'\\n', b'\\r', b'\\t'];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"A!\\\\n\\\\r\\\\t\");","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(!result.is_empty());","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert_eq!(result.len(), 256);","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(result.contains(\"\\\\0\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(result.contains(\"\\\\x7f\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(result.contains(\"a\"));","}"],[973,974,975,976,977,978,979]],[["{","    let bytes: &[u8] = &[200, 250, 255];","    escape_bytes(bytes);","    let bytes: &[u8] = &[200, 250, 255];","    let expected_output = \"result_of_escape_byte_for_200result_of_escape_byte_for_250result_of_escape_byte_for_255\";","    let actual_output = escape_bytes(bytes);","    assert_eq!(actual_output, expected_output);","}"],[973,974,975,976,977,978,979]]],"codes_branches":[],"codes_branches_covered":[[["{","    let bytes: &[u8] = &[];","    escape_bytes(bytes);","    let bytes: &[u8] = &[];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\");","}"],[]],[["{","    let bytes: &[u8] = &[0];","    escape_bytes(bytes);","    let bytes: &[u8] = &[0];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{0}\");","}"],[]],[["{","    let bytes: &[u8] = &[255];","    escape_bytes(bytes);","    let bytes: &[u8] = &[255];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{ff}\");","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(!result.is_empty());","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert_eq!(result.len(), 3072);","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"\\\\x\"));","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"a\"));","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"b\"));","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"c\"));","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"0\"));","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"1\"));","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"2\"));","}"],[]],[["{","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    escape_bytes(&bytes);","    let bytes: Vec<u8> = (0..=255).cycle().take(1024).collect();","    let result = escape_bytes(&bytes);","    assert!(result.contains(\"255\"));","}"],[]],[["{","    let bytes: &[u8] = &[128, 130, 195, 200, 250];","    escape_bytes(bytes);","    let bytes: &[u8] = &[128, 130, 195, 200, 250];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\\\x80\\\\x82\\\\xc3\\\\xc8\\\\xfa\");","}"],[]],[["{","    let bytes: &[u8] = &[];","    escape_bytes(bytes);","    let bytes: &[u8] = &[];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\");","}"],[]],[["{","    let bytes: &[u8] = &[0];","    escape_bytes(bytes);","    let bytes: &[u8] = &[0];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"\\u{0}\");","}"],[]],[["{","    let bytes: &[u8] = &[1, 2, 3, 4, 5];","    escape_bytes(bytes);","    let bytes: &[u8] = &[1, 2, 3, 4, 5];","    let result = escape_bytes(bytes);","    let expected = \"\\x01\\x02\\x03\\x04\\x05\"; // Expected escaped string based on byte values","    assert_eq!(result, expected);","}"],[]],[["{","    let bytes: &[u8] = &[b'A', b'!', b'\\n', b'\\r', b'\\t'];","    escape_bytes(bytes);","    let bytes: &[u8] = &[b'A', b'!', b'\\n', b'\\r', b'\\t'];","    let result = escape_bytes(bytes);","    assert_eq!(result, \"A!\\\\n\\\\r\\\\t\");","}"],[]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(!result.is_empty());","}"],[]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert_eq!(result.len(), 256);","}"],[]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(result.contains(\"\\\\0\"));","}"],[]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(result.contains(\"\\\\x7f\"));","}"],[]],[["{","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    escape_bytes(bytes);","    let bytes: &[u8] = &(0..=127).collect::<Vec<u8>>();","    let result = escape_bytes(bytes);","    assert!(result.contains(\"a\"));","}"],[]],[["{","    let bytes: &[u8] = &[200, 250, 255];","    escape_bytes(bytes);","    let bytes: &[u8] = &[200, 250, 255];","    let expected_output = \"result_of_escape_byte_for_200result_of_escape_byte_for_250result_of_escape_byte_for_255\";","    let actual_output = escape_bytes(bytes);","    assert_eq!(actual_output, expected_output);","}"],[]]]}