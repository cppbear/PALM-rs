{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::bump_if","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":58,"tests_lines":[8,9,10,11,12,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,9,9,9,9,8,8,8,22,22,22,35,34,34,35,35,34,34,34,22,22,34,34,34,34,34,35,35,35,35,35,35,35,35,35,34,34,34,34],"oracles":17,"oracles_compiled":10,"oracles_compiled_rate":58.82352941176471,"tests_compiled":31,"tests_compiled_rate":53.44827586206896,"oracles_run":10,"oracles_passed":10,"oracles_passed_rate":100.0,"tests_run":31,"tests_passed":25,"tests_passed_rate":80.64516129032258,"lines":8,"lines_covered":8,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[505,506,507,508,509,510,512,514],"codes_lines_covered":[[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"hello\");","    let pattern = \"hello world\";","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.bump_if(\"hello\"), true);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"hello\");","    let pattern = \"hello world\";","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 5);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"hello\");","    let pattern = \"hello world\";","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.char(), ' ');","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    parser_instance.bump(); // Move offset to 1","    let result = parser_instance.bump_if(\"e\");","    let pattern = \"hello world\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 1, line: 1, column: 2 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.bump_if(\"e\"), true);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 0);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert!(parser_instance.pattern().starts_with(\"foo\"));","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    assert!(result);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    assert_eq!(parser_instance.offset(), 3);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"a\");","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 0);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"a\");","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert!(parser_instance.bump_if(\"a\"));","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"a\");","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 1);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"sample text\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    assert_eq!(result, true);","}"],[505,506,507,510,514]],[["{","    let pattern = \"sample text\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    assert_eq!(parser_instance.offset(), 0);","}"],[505,506,507,510,514]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.bump_if(\"xyz\"), false);","}"],[505,506,512,514]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser.pos.get().offset, 0);","}"],[505,506,512,514]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser.pos.get().line, 0);","}"],[505,506,512,514]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser.pos.get().column, 0);","}"],[505,506,512,514]],[["{","    let pattern = \"hello world\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"worlds\");","    let pattern = \"hello world\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(result, false);","}"],[505,506,512,514]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(result, false);","}"],[505,506,512,514]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(parser.pos.get().offset, 7);","}"],[505,506,512,514]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(parser.pos.get().line, 0);","}"],[505,506,512,514]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(parser.pos.get().column, 8);","}"],[505,506,512,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(result, false);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(parser_instance.offset(), 0);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(parser_instance.line(), 0);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(parser_instance.column(), 0);","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert!(parser_instance.pattern() == \"sample text\");","}"],[505,506,507,508,509,510,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(result, false);","}"],[505,506,512,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.offset(), 8);","}"],[505,506,512,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.line(), 0);","}"],[505,506,512,514]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.column(), 9);","}"],[505,506,512,514]]],"codes_branches":[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"hello\");","    let pattern = \"hello world\";","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.bump_if(\"hello\"), true);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"hello\");","    let pattern = \"hello world\";","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 5);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"hello\");","    let pattern = \"hello world\";","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.char(), ' ');","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"hello world\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    parser_instance.bump(); // Move offset to 1","    let result = parser_instance.bump_if(\"e\");","    let pattern = \"hello world\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 1, line: 1, column: 2 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.bump_if(\"e\"), true);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert!(parser_instance.pattern().starts_with(\"foo\"));","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    assert!(result);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    let pattern = \"foo bar baz\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"foo\");","    assert_eq!(parser_instance.offset(), 3);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"a\");","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"a\");","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert!(parser_instance.bump_if(\"a\"));","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"a\");","    let pattern = \"a quick brown fox\";","    let parser_state = Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    assert_eq!(parser_instance.offset(), 1);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"sample text\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    assert_eq!(result, true);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"sample text\";","    let parser_state = Parser {","        pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    let parser_state = Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_instance = ParserI::new(&parser_state, pattern);","    let result = parser_instance.bump_if(\"\");","    assert_eq!(parser_instance.offset(), 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.bump_if(\"xyz\"), false);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser.pos.get().offset, 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser.pos.get().line, 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"abcdef\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"xyz\");","    let pattern = \"abcdef\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser.pos.get().column, 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"hello world\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"worlds\");","    let pattern = \"hello world\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(result, false);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(result, false);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(parser.pos.get().offset, 7);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(parser.pos.get().line, 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"pattern matching\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    let pattern = \"pattern matching\";","    let parser = Parser {","    pos: Cell::new(Position { offset: 7, line: 0, column: 8 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"notmatching\");","    assert_eq!(parser.pos.get().column, 8);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(result, false);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(parser_instance.offset(), 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(parser_instance.line(), 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert_eq!(parser_instance.column(), 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 0, line: 0, column: 0 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"sample\");","    assert!(parser_instance.pattern() == \"sample text\");","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":true,"negative":false}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(result, false);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.offset(), 8);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.line(), 0);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]],[["{","    let pattern = \"sample text\";","    let mut parser = Parser { ","        pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    let result = parser_instance.bump_if(\"text too long\");","    let pattern = \"sample text\";","    let mut parser = Parser {","    pos: Cell::new(Position { offset: 8, line: 0, column: 9 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI::new(&parser, pattern);","    assert_eq!(parser_instance.column(), 9);","}"],[{"start_line":506,"start_column":12,"end_line":506,"end_column":63,"positive":false,"negative":true}]]]}