{"function_name":"regex_syntax::hir::interval::hir::interval::IntervalSet<I>::push","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/interval.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":28,"tests_lines":[52,53,53,54,54,53,54,54,54,55,55,56,56,52,53,53,54,54,56,56,56,56,56,54,54,56,56,57],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":26,"tests_compiled_rate":92.85714285714286,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":26,"tests_passed":18,"tests_passed_rate":69.23076923076923,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[50,51,52,53,54,55],"codes_lines_covered":[[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    assert_eq!(set.intervals().len(), 1);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    assert_eq!(set.intervals()[0], TestInterval::new(10, 20));","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    assert_eq!(set.intervals().len(), 2);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    assert_eq!(set.intervals()[1], TestInterval::new(30, 40));","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    set.push(TestInterval::new(2, 2));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    assert_eq!(set.intervals(), &[TestInterval::new(1, 1)]);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    set.push(TestInterval::new(2, 2));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    set.push(TestInterval::new(2, 2));","    assert_eq!(set.intervals(), &[TestInterval::new(1, 1), TestInterval::new(2, 2)]);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    assert_eq!(set.intervals().len(), 1);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    assert_eq!(set.intervals()[0], TestInterval::new(5, 15));","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    assert_eq!(set.intervals().len(), 2);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    assert_eq!(set.intervals()[1], TestInterval::new(20, 25));","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    assert_eq!(set.intervals().len(), 3);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    assert_eq!(set.intervals()[2], TestInterval::new(30, 35));","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    assert_eq!(set.intervals().len(), 1);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    assert_eq!(set.intervals()[0], TestInterval::new(1, 2));","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    assert_eq!(set.intervals().len(), 2);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    assert_eq!(set.intervals()[1], TestInterval::new(3, 4));","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals().len(), 2);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[0].lower(), 1);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[0].upper(), 10);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[1].lower(), 20);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[1].upper(), 30);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    assert_eq!(set.intervals().len(), 1);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    assert_eq!(set.intervals()[0], interval1);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    let interval2 = TestInterval::new(0, 0);","    set.push(interval2);","    assert_eq!(set.intervals().len(), 2);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    let interval2 = TestInterval::new(0, 0);","    set.push(interval2);","    assert_eq!(set.intervals()[1], interval2);","}"],[50,51,52,53,54,55]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    let interval2 = TestInterval::new(0, 0);","    set.push(interval2);","    let expected_ranges = vec![TestInterval::new(0, 0), TestInterval::new(255, 255)];","    assert_eq!(set.intervals(), &expected_ranges);","}"],[50,51,52,53,54,55]]],"codes_branches":[],"codes_branches_covered":[[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    assert_eq!(set.intervals().len(), 1);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    assert_eq!(set.intervals()[0], TestInterval::new(10, 20));","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    assert_eq!(set.intervals().len(), 2);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(10, 20));","    set.push(TestInterval::new(30, 40));","    assert_eq!(set.intervals()[1], TestInterval::new(30, 40));","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    set.push(TestInterval::new(2, 2));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    assert_eq!(set.intervals(), &[TestInterval::new(1, 1)]);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    set.push(TestInterval::new(2, 2));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 1));","    set.push(TestInterval::new(2, 2));","    assert_eq!(set.intervals(), &[TestInterval::new(1, 1), TestInterval::new(2, 2)]);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    assert_eq!(set.intervals().len(), 1);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    assert_eq!(set.intervals()[0], TestInterval::new(5, 15));","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    assert_eq!(set.intervals().len(), 2);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    assert_eq!(set.intervals()[1], TestInterval::new(20, 25));","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    assert_eq!(set.intervals().len(), 3);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(5, 15));","    set.push(TestInterval::new(20, 25));","    set.push(TestInterval::new(30, 35));","    assert_eq!(set.intervals()[2], TestInterval::new(30, 35));","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    assert_eq!(set.intervals().len(), 1);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    assert_eq!(set.intervals()[0], TestInterval::new(1, 2));","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    assert_eq!(set.intervals().len(), 2);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 2));","    set.push(TestInterval::new(3, 4));","    assert_eq!(set.intervals()[1], TestInterval::new(3, 4));","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals().len(), 2);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[0].lower(), 1);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[0].upper(), 10);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[1].lower(), 20);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(1, 10));","    set.push(TestInterval::new(20, 30));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(1, 10);","    let interval2 = TestInterval::new(20, 30);","    set.push(interval1);","    set.push(interval2);","    assert_eq!(set.intervals()[1].upper(), 30);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    assert_eq!(set.intervals().len(), 1);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    assert_eq!(set.intervals()[0], interval1);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    let interval2 = TestInterval::new(0, 0);","    set.push(interval2);","    assert_eq!(set.intervals().len(), 2);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    let interval2 = TestInterval::new(0, 0);","    set.push(interval2);","    assert_eq!(set.intervals()[1], interval2);","}"],[]],[["{","#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]","struct TestInterval {","    lower: u8,","    upper: u8,","}","","impl TestInterval {","    fn new(lower: u8, upper: u8) -> Self {","        Self { lower, upper }","    }","}","","impl Interval for TestInterval {","    type Bound = u8;","","    fn lower(&self) -> Self::Bound {","        self.lower","    }","","    fn upper(&self) -> Self::Bound {","        self.upper","    }","","    fn set_lower(&mut self, bound: Self::Bound) {","        self.lower = bound;","    }","","    fn set_upper(&mut self, bound: Self::Bound) {","        self.upper = bound;","    }","","    fn case_fold_simple(&self, _: &mut Vec<Self>) {}","","    fn is_contiguous(&self, other: &Self) -> bool {","        self.upper + 1 == other.lower || self.lower == other.upper + 1","    }","","    fn is_intersection_empty(&self, other: &Self) -> bool {","        self.upper < other.lower || self.lower > other.upper","    }","","    fn is_subset(&self, other: &Self) -> bool {","        self.lower >= other.lower && self.upper <= other.upper","    }","}","    let mut set = IntervalSet::new(vec![]);","    set.push(TestInterval::new(255, 255));","    set.push(TestInterval::new(0, 0));","    let mut set = IntervalSet::new(vec![]);","    let interval1 = TestInterval::new(255, 255);","    set.push(interval1);","    let interval2 = TestInterval::new(0, 0);","    set.push(interval2);","    let expected_ranges = vec![TestInterval::new(0, 0), TestInterval::new(255, 255)];","    assert_eq!(set.intervals(), &expected_ranges);","}"],[]]]}