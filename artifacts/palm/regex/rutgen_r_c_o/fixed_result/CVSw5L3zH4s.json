{"function_name":"regex_syntax::hir::literal::hir::literal::Literal::is_cut","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/literal/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":9,"tests_lines":[6,6,9,6,7,9,6,6,9],"oracles":7,"oracles_compiled":7,"oracles_compiled_rate":100.0,"tests_compiled":9,"tests_compiled_rate":100.0,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":9,"tests_passed":9,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[891,892,893],"codes_lines_covered":[[["{","    let literal = Literal::empty();","    literal.is_cut();","    let literal = Literal::empty();","    assert_eq!(literal.is_cut(), false);","}"],[891,892,893]],[["{","    let literal = Literal::new(vec![97, 98, 99]); // 'abc'","    literal.is_cut();","    let literal = Literal::new(vec![97, 98, 99]); // 'abc'","    assert_eq!(literal.is_cut(), false);","}"],[891,892,893]],[["{","    let mut literal = Literal::new(vec![120, 121, 122]); // 'xyz'","    literal.cut();","    literal.is_cut();","    let mut literal = Literal::new(vec![120, 121, 122]); // 'xyz'","    literal.cut();","    let result = literal.is_cut();","    assert_eq!(result, true);","}"],[891,892,893]],[["{","    let literal = Literal::new(vec![0]); // single byte 0","    literal.is_cut();","    let literal = Literal::new(vec![0]); // single byte 0","    assert_eq!(literal.is_cut(), false); // Assuming default behavior of cut is false for new literals","}"],[891,892,893]],[["{","    let literal = Literal::new(vec![0]); // single byte 0","    literal.is_cut();","    let literal = Literal::new(vec![0]); // single byte 0","    let empty_literal = Literal::empty();","    assert_eq!(empty_literal.is_cut(), false); // Assuming empty literal is also not cut","}"],[891,892,893]],[["{","    let literal = Literal::new(vec![0]); // single byte 0","    literal.is_cut();","    let literal = Literal::new(vec![0]); // single byte 0","    let empty_literal = Literal::empty();","    let mut cut_literal = Literal::new(vec![0]);","    cut_literal.cut();","    assert_eq!(cut_literal.is_cut(), true); // After cutting, is_cut should return true","}"],[891,892,893]],[["{","    let literal = Literal::new(vec![255]); // single byte 255","    literal.is_cut();","    let literal = Literal::new(vec![255]);","    assert_eq!(literal.is_cut(), false);","}"],[891,892,893]],[["{","    let literal = Literal::new(vec![100, 101, 102, 103, 104]); // 'defgh'","    literal.is_cut();","    let literal = Literal::new(vec![100, 101, 102, 103, 104]); // 'defgh'","    assert_eq!(literal.is_cut(), false);","}"],[891,892,893]],[["{","    let mut literal = Literal::new(vec![105, 106, 107]); // 'ijk'","    literal.cut();","    literal.is_cut();","    let mut literal = Literal::new(vec![105, 106, 107]); // 'ijk'","    literal.cut();","    let result = literal.is_cut();","    assert_eq!(result, true);","}"],[891,892,893]]],"codes_branches":[],"codes_branches_covered":[[["{","    let literal = Literal::empty();","    literal.is_cut();","    let literal = Literal::empty();","    assert_eq!(literal.is_cut(), false);","}"],[]],[["{","    let literal = Literal::new(vec![97, 98, 99]); // 'abc'","    literal.is_cut();","    let literal = Literal::new(vec![97, 98, 99]); // 'abc'","    assert_eq!(literal.is_cut(), false);","}"],[]],[["{","    let mut literal = Literal::new(vec![120, 121, 122]); // 'xyz'","    literal.cut();","    literal.is_cut();","    let mut literal = Literal::new(vec![120, 121, 122]); // 'xyz'","    literal.cut();","    let result = literal.is_cut();","    assert_eq!(result, true);","}"],[]],[["{","    let literal = Literal::new(vec![0]); // single byte 0","    literal.is_cut();","    let literal = Literal::new(vec![0]); // single byte 0","    assert_eq!(literal.is_cut(), false); // Assuming default behavior of cut is false for new literals","}"],[]],[["{","    let literal = Literal::new(vec![0]); // single byte 0","    literal.is_cut();","    let literal = Literal::new(vec![0]); // single byte 0","    let empty_literal = Literal::empty();","    assert_eq!(empty_literal.is_cut(), false); // Assuming empty literal is also not cut","}"],[]],[["{","    let literal = Literal::new(vec![0]); // single byte 0","    literal.is_cut();","    let literal = Literal::new(vec![0]); // single byte 0","    let empty_literal = Literal::empty();","    let mut cut_literal = Literal::new(vec![0]);","    cut_literal.cut();","    assert_eq!(cut_literal.is_cut(), true); // After cutting, is_cut should return true","}"],[]],[["{","    let literal = Literal::new(vec![255]); // single byte 255","    literal.is_cut();","    let literal = Literal::new(vec![255]);","    assert_eq!(literal.is_cut(), false);","}"],[]],[["{","    let literal = Literal::new(vec![100, 101, 102, 103, 104]); // 'defgh'","    literal.is_cut();","    let literal = Literal::new(vec![100, 101, 102, 103, 104]); // 'defgh'","    assert_eq!(literal.is_cut(), false);","}"],[]],[["{","    let mut literal = Literal::new(vec![105, 106, 107]); // 'ijk'","    literal.cut();","    literal.is_cut();","    let mut literal = Literal::new(vec![105, 106, 107]); // 'ijk'","    literal.cut();","    let result = literal.is_cut();","    assert_eq!(result, true);","}"],[]]]}