{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::column","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":5,"tests_lines":[10,10,10,10,10],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[416,417,418],"codes_lines_covered":[[["{","    let position = Position { offset: 0, line: 1, column: 5 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcde\");","    parser_i.column();","    let position = Position { offset: 0, line: 1, column: 5 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcde\");","    assert_eq!(parser_i.column(), 5);","}"],[416,417,418]],[["{","    let position = Position { offset: 20, line: 1, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"this is a test\");","    parser_i.column();","    let position = Position { offset: 20, line: 1, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"this is a test\");","    assert_eq!(parser_i.column(), 1);","}"],[416,417,418]],[["{","    let position = Position { offset: 50, line: 1, column: 50 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzab\");","    parser_i.column();","    let position = Position { offset: 50, line: 1, column: 50 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzab\");","    assert_eq!(parser_i.column(), 50);","}"],[416,417,418]],[["{","    let position = Position { offset: 0, line: 2, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first line\\nsecond line\");","    parser_i.column();","    let position = Position { offset: 0, line: 2, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first line\\nsecond line\");","    assert_eq!(parser_i.column(), 1);","}"],[416,417,418]],[["{","    let position = Position { offset: 10, line: 3, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first\\nsecond\\nthird\\n\");","    parser_i.column();","    let position = Position { offset: 10, line: 3, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first\\nsecond\\nthird\\n\");","    assert_eq!(parser_i.column(), 1);","}"],[416,417,418]]],"codes_branches":[],"codes_branches_covered":[[["{","    let position = Position { offset: 0, line: 1, column: 5 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcde\");","    parser_i.column();","    let position = Position { offset: 0, line: 1, column: 5 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcde\");","    assert_eq!(parser_i.column(), 5);","}"],[]],[["{","    let position = Position { offset: 20, line: 1, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"this is a test\");","    parser_i.column();","    let position = Position { offset: 20, line: 1, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"this is a test\");","    assert_eq!(parser_i.column(), 1);","}"],[]],[["{","    let position = Position { offset: 50, line: 1, column: 50 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzab\");","    parser_i.column();","    let position = Position { offset: 50, line: 1, column: 50 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzab\");","    assert_eq!(parser_i.column(), 50);","}"],[]],[["{","    let position = Position { offset: 0, line: 2, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first line\\nsecond line\");","    parser_i.column();","    let position = Position { offset: 0, line: 2, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first line\\nsecond line\");","    assert_eq!(parser_i.column(), 1);","}"],[]],[["{","    let position = Position { offset: 10, line: 3, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first\\nsecond\\nthird\\n\");","    parser_i.column();","    let position = Position { offset: 10, line: 3, column: 1 };","    let parser = Parser { pos: Cell::new(position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()) };","    let parser_i = ParserI::new(&parser, \"first\\nsecond\\nthird\\n\");","    assert_eq!(parser_i.column(), 1);","}"],[]]]}