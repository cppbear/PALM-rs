{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_hex_digits","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":49,"tests_lines":[65,65,65,65,66,67,67,67,68,69,69,69,40,41,41,39,40,41,47,47,32,32,32,37,26,26,14,14,19,22,22,16,19,20,13,13,25,25,25,25,41,41,41,42,61,62,81,82,82],"oracles":18,"oracles_compiled":7,"oracles_compiled_rate":38.88888888888889,"tests_compiled":27,"tests_compiled_rate":55.10204081632652,"oracles_run":7,"oracles_passed":5,"oracles_passed_rate":71.42857142857143,"tests_run":27,"tests_passed":10,"tests_passed_rate":37.03703703703704,"lines":36,"lines_covered":17,"lines_coveraged_rate":47.22222222222222,"branches":6,"branches_covered":2,"branches_coverage_rate":33.33333333333333,"codes_lines":[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1637],"codes_lines_covered":[[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., 'g'","            'g'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::X); // This should panic","    let parser = ParserMock::new();","    assert_eq!(parser.parse_hex_digits(ast::HexLiteralKind::X), Err(parser.error(parser.span_char(), ast::ErrorKind::EscapeHexInvalidDigit)));","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., 'g'","            'g'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::X); // This should panic","    let parser = ParserMock::new();","    assert_eq!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort), Err(parser.error(parser.span_char(), ast::ErrorKind::EscapeHexInvalidDigit)));","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., 'g'","            'g'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::X); // This should panic","    let parser = ParserMock::new();","    assert_eq!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong), Err(parser.error(parser.span_char(), ast::ErrorKind::EscapeHexInvalidDigit)));","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    assert!(result.is_err());","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    assert_eq!(error.pattern, String::from(\"mock pattern\"));","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    assert!(error.span.is_empty());","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    assert!(result.is_err());","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    let error = result.unwrap_err();","    assert_eq!(error.pattern, String::from(\"mock pattern\"));","}"],[]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // use ast::HexLiteralKind;  ","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    let error = result.unwrap_err();","    assert!(error.span.is_empty());","}"],[]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(start_position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::from(pattern)),","    },","    pattern,","    };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(start_position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::from(pattern)),","    },","    pattern,","    };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_digits(kind);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\"; // Incomplete hex representation","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\";","    let parser = ParserI { parser: Parser { pos: Cell::new(start_position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(pattern)), }, pattern, };","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    assert!(_result.is_err());","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\"; // Incomplete hex representation","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\";","    let parser = ParserI { parser: Parser { pos: Cell::new(start_position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(pattern)), }, pattern, };","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    assert_eq!(_result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\"; // Incomplete hex representation","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\";","    let parser = ParserI { parser: Parser { pos: Cell::new(start_position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(pattern)), }, pattern, };","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    assert_eq!(_result.unwrap_err().span, Span::new(start_position, end_position));","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::X; // Testing for 2-digit hex, expecting an empty sequence","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(String::new()), ","        }, ","        pattern: \"\\\\x\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::X;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let scratch_initial = String::new();","    assert_eq!(parser.parser.scratch.borrow().len(), 0);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::X; // Testing for 2-digit hex, expecting an empty sequence","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(String::new()), ","        }, ","        pattern: \"\\\\x\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::X;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let scratch_initial = String::new();","    assert_eq!(parser.parser.pos.get(), position);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::X; // Testing for 2-digit hex, expecting an empty sequence","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(String::new()), ","        }, ","        pattern: \"\\\\x\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::X;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let scratch_initial = String::new();","    assert!(parser.parser.ignore_whitespace.get() == false);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort; // Testing for 4-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"gxyz\".to_string()), // Not hex chars","        },","        pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"gxyz\".to_string()),","    },","    pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort; // Testing for 4-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"gxyz\".to_string()), // Not hex chars","        },","        pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"gxyz\".to_string()),","    },","    pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalid);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Valid input","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_ok());","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Valid input","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let literal = result.unwrap();","    assert_eq!(literal.c, '');","}"],[1595,1596,1597,1598,1602,1603,1604,1605,1606,1607,1612,1613,1614,1615,1616,1617,1637]]],"codes_branches":[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}],"codes_branches_covered":[[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., 'g'","            'g'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::X); // This should panic","    let parser = ParserMock::new();","    assert_eq!(parser.parse_hex_digits(ast::HexLiteralKind::X), Err(parser.error(parser.span_char(), ast::ErrorKind::EscapeHexInvalidDigit)));","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., 'g'","            'g'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::X); // This should panic","    let parser = ParserMock::new();","    assert_eq!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort), Err(parser.error(parser.span_char(), ast::ErrorKind::EscapeHexInvalidDigit)));","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., 'g'","            'g'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::X); // This should panic","    let parser = ParserMock::new();","    assert_eq!(parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong), Err(parser.error(parser.span_char(), ast::ErrorKind::EscapeHexInvalidDigit)));","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    assert!(result.is_err());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    assert_eq!(error.pattern, String::from(\"mock pattern\"));","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    assert!(error.span.is_empty());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    assert!(result.is_err());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            use ast::HexLiteralKind;","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    let error = result.unwrap_err();","    assert_eq!(error.pattern, String::from(\"mock pattern\"));","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    struct ParserMock {","        pos: Cell<Position>,","        scratch: RefCell<String>,","    }","","    impl ParserMock {","        fn new() -> Self {","            Self {","                pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","                scratch: RefCell::new(String::new()),","            }","        }","","        fn bump_and_bump_space(&self) -> bool {","            // Mock implementation returning true","            true","        }","","        fn char(&self) -> char {","            // Return a non-hex character, e.g., '!'","            '!'","        }","","        fn span_char(&self) -> Span {","            Span { start: self.pos.get(), end: self.pos.get() }","        }","","        fn error(&self, _span: Span, _error_kind: ast::ErrorKind) -> ast::Error {","            ast::Error {","                kind: ast::ErrorKind::EscapeHexInvalidDigit,","                pattern: String::from(\"mock pattern\"),","                span: Span { start: self.pos.get(), end: self.pos.get() },","            }","        }","","        fn parse_hex_digits(&self, kind: ast::HexLiteralKind) -> Result<ast::Literal> {","            // use ast::HexLiteralKind;  ","","            let mut scratch = self.scratch.borrow_mut();","            scratch.clear();","","            let start = self.pos.get();","            for i in 0..kind.digits() {","                if i > 0 && !self.bump_and_bump_space() {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeUnexpectedEof));","                }","                if !is_hex(self.char()) {","                    return Err(self.error(self.span_char(), ast::ErrorKind::EscapeHexInvalidDigit));","                }","                scratch.push(self.char());","            }","            // Final bump","            self.bump_and_bump_space();","            let end = self.pos.get();","            // Rest of the function would go here","            unimplemented!()","        }","    }","","    let parser = ParserMock::new();","    let _ = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeLong); // This should panic","    let parser = ParserMock::new();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::UnicodeShort);","    let error = result.unwrap_err();","    let result = parser.parse_hex_digits(ast::HexLiteralKind::X);","    let error = result.unwrap_err();","    assert!(error.span.is_empty());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":false},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":false,"negative":false}]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(start_position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::from(pattern)),","    },","    pattern,","    };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 2, line: 1, column: 3 };","    let pattern = \"\\\\xzz\"; // Invalid hex representation for `\\x`","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(start_position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::from(pattern)),","    },","    pattern,","    };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_digits(kind);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\"; // Incomplete hex representation","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\";","    let parser = ParserI { parser: Parser { pos: Cell::new(start_position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(pattern)), }, pattern, };","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    assert!(_result.is_err());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\"; // Incomplete hex representation","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\";","    let parser = ParserI { parser: Parser { pos: Cell::new(start_position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(pattern)), }, pattern, };","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    assert_eq!(_result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\"; // Incomplete hex representation","","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(start_position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(pattern)),","        },","        pattern,","    };","","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    let start_position = Position { offset: 0, line: 1, column: 1 };","    let end_position = Position { offset: 1, line: 1, column: 2 };","    let pattern = \"\\\\x1\";","    let parser = ParserI { parser: Parser { pos: Cell::new(start_position), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::from(pattern)), }, pattern, };","    let kind = ast::HexLiteralKind::X;","    let _result = parser.parse_hex_digits(kind);","    assert_eq!(_result.unwrap_err().span, Span::new(start_position, end_position));","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::X; // Testing for 2-digit hex, expecting an empty sequence","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(String::new()), ","        }, ","        pattern: \"\\\\x\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::X;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let scratch_initial = String::new();","    assert_eq!(parser.parser.scratch.borrow().len(), 0);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::X; // Testing for 2-digit hex, expecting an empty sequence","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(String::new()), ","        }, ","        pattern: \"\\\\x\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::X;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let scratch_initial = String::new();","    assert_eq!(parser.parser.pos.get(), position);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::X; // Testing for 2-digit hex, expecting an empty sequence","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(String::new()), ","        }, ","        pattern: \"\\\\x\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::X;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let scratch_initial = String::new();","    assert!(parser.parser.ignore_whitespace.get() == false);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort; // Testing for 4-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"gxyz\".to_string()), // Not hex chars","        },","        pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"gxyz\".to_string()),","    },","    pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort; // Testing for 4-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"gxyz\".to_string()), // Not hex chars","        },","        pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"gxyz\".to_string()),","    },","    pattern: \"\\\\u0047\"","    };","    let result = parser.parse_hex_digits(kind);","    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalid);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_err());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    assert_eq!(error.kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Valid input","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    assert!(result.is_ok());","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong; // Testing for 8-digit hex","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI { ","        parser: Parser { ","            pos: Cell::new(position), ","            capture_index: Cell::new(0), ","            nest_limit: 10, ","            octal: true, ","            initial_ignore_whitespace: false, ","            ignore_whitespace: Cell::new(false), ","            comments: RefCell::new(vec![]), ","            stack_group: RefCell::new(vec![]), ","            stack_class: RefCell::new(vec![]), ","            capture_names: RefCell::new(vec![]), ","            scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Maximum valid ","        },","        pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"\".to_string()), // Testing for empty hex string","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"G0F0F0F0\".to_string()), // Invalid hex character 'G'","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let error = result.unwrap_err();","    let kind = ast::HexLiteralKind::UnicodeLong;","    let position = ast::Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(\"F0F0F0F0\".to_string()), // Valid input","    },","    pattern: \"\\\\U00000000\"","    };","    let result = parser.parse_hex_digits(kind);","    let literal = result.unwrap();","    assert_eq!(literal.c, '');","}"],[{"start_line":1607,"start_column":16,"end_line":1607,"end_column":21,"positive":false,"negative":true},{"start_line":1607,"start_column":25,"end_line":1607,"end_column":52,"positive":false,"negative":false},{"start_line":1613,"start_column":16,"end_line":1613,"end_column":36,"positive":true,"negative":false}]]]}