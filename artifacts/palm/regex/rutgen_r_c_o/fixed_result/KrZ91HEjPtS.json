{"function_name":"regex::compile::compile::InstHole::fill","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/compile.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":37,"tests_lines":[9,9,9,9,9,9,11,11,10,11,11,11,9,9,9,9,9,9,9,9,9,9,12,9,9,9,9,9,9,9,9,11,11,11,11,10,10],"oracles":31,"oracles_compiled":7,"oracles_compiled_rate":22.58064516129032,"tests_compiled":11,"tests_compiled_rate":29.72972972972973,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":11,"tests_passed":11,"tests_passed_rate":100.0,"lines":24,"lines_covered":24,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,866],"codes_lines_covered":[[["{","    let goto: InstPtr = 5; // any valid InstPtr","    let instance = InstHole::Bytes { start: 50, end: 100 };","    instance.fill(goto);","    let goto: InstPtr = 5;","    let instance = InstHole::Bytes { start: 50, end: 100 };","    let result = instance.fill(goto);","    assert!(matches!(result, Inst::Bytes(InstBytes { goto: 5, start: 50, end: 100 })));","}"],[842,843,860,861,862,863,864,866]],[["{","    let goto = 999;","    let ranges = vec![('A', 'Z'), ('0', '9')];","    let hole = InstHole::Ranges { ranges };","    let _result = hole.fill(goto);","    let goto = 999;","    let ranges = vec![('A', 'Z'), ('0', '9')];","    let hole = InstHole::Ranges { ranges };","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::Ranges(InstRanges { goto: 999, ranges: ref r }) if r == &vec![('A', 'Z'), ('0', '9')]));","}"],[842,843,856,857,858,859,866]],[["{","    let hole = InstHole::Char { c: char::from('\\u{10FFFF}') };","    let goto: InstPtr = 0;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: char::from('\\u{10FFFF}') };","    let goto: InstPtr = 0;","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::Char(InstChar { goto: g, c: ch }) if g == goto && ch == char::from('\\u{10FFFF}')));","}"],[842,843,852,853,854,855,866]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::Char(InstChar { goto: 100, c: 'a' })));","}"],[842,843,852,853,854,855,866]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::Save(_)));","}"],[842,843,852,853,854,855,866]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::EmptyLook(_)));","}"],[842,843,852,853,854,855,866]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::Ranges(_)));","}"],[842,843,852,853,854,855,866]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::Bytes(_)));","}"],[842,843,852,853,854,855,866]],[["{","    let hole = InstHole::EmptyLook { look: EmptyLook::WordBoundary };","    let goto = 5;","    hole.fill(goto);","    let hole = InstHole::EmptyLook { look: EmptyLook::WordBoundary };","    let goto = 5;","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::EmptyLook(InstEmptyLook { goto: 5, look: EmptyLook::WordBoundary })));","}"],[842,843,848,849,850,851,866]],[["{","    let slot = 500;","    let goto: InstPtr = 250;","    let inst_hole = InstHole::Save { slot };","    inst_hole.fill(goto);","    let slot = 500;","    let goto: InstPtr = 250;","    let inst_hole = InstHole::Save { slot };","    let result = inst_hole.fill(goto);","    assert!(matches!(result, Inst::Save(InstSave { goto: 250, slot: 500 })));","}"],[842,843,844,845,846,847,866]],[["{","    let slot = 1001; // This will panic as it's out of bounds","    let goto: InstPtr = 1;","    let inst_hole = InstHole::Save { slot };","    inst_hole.fill(goto);","    let slot = 1001;","    let goto: InstPtr = 1;","    let inst_hole = InstHole::Save { slot };","    assert!(std::panic::catch_unwind(|| inst_hole.fill(goto)).is_err());","}"],[842,843,844,845,846,847,866]]],"codes_branches":[],"codes_branches_covered":[[["{","    let goto: InstPtr = 5; // any valid InstPtr","    let instance = InstHole::Bytes { start: 50, end: 100 };","    instance.fill(goto);","    let goto: InstPtr = 5;","    let instance = InstHole::Bytes { start: 50, end: 100 };","    let result = instance.fill(goto);","    assert!(matches!(result, Inst::Bytes(InstBytes { goto: 5, start: 50, end: 100 })));","}"],[]],[["{","    let goto = 999;","    let ranges = vec![('A', 'Z'), ('0', '9')];","    let hole = InstHole::Ranges { ranges };","    let _result = hole.fill(goto);","    let goto = 999;","    let ranges = vec![('A', 'Z'), ('0', '9')];","    let hole = InstHole::Ranges { ranges };","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::Ranges(InstRanges { goto: 999, ranges: ref r }) if r == &vec![('A', 'Z'), ('0', '9')]));","}"],[]],[["{","    let hole = InstHole::Char { c: char::from('\\u{10FFFF}') };","    let goto: InstPtr = 0;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: char::from('\\u{10FFFF}') };","    let goto: InstPtr = 0;","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::Char(InstChar { goto: g, c: ch }) if g == goto && ch == char::from('\\u{10FFFF}')));","}"],[]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::Char(InstChar { goto: 100, c: 'a' })));","}"],[]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::Save(_)));","}"],[]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::EmptyLook(_)));","}"],[]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::Ranges(_)));","}"],[]],[["{","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    let hole = InstHole::Char { c: 'a' };","    let goto: InstPtr = 100;","    let result = hole.fill(goto);","    assert!(!matches!(result, Inst::Bytes(_)));","}"],[]],[["{","    let hole = InstHole::EmptyLook { look: EmptyLook::WordBoundary };","    let goto = 5;","    hole.fill(goto);","    let hole = InstHole::EmptyLook { look: EmptyLook::WordBoundary };","    let goto = 5;","    let result = hole.fill(goto);","    assert!(matches!(result, Inst::EmptyLook(InstEmptyLook { goto: 5, look: EmptyLook::WordBoundary })));","}"],[]],[["{","    let slot = 500;","    let goto: InstPtr = 250;","    let inst_hole = InstHole::Save { slot };","    inst_hole.fill(goto);","    let slot = 500;","    let goto: InstPtr = 250;","    let inst_hole = InstHole::Save { slot };","    let result = inst_hole.fill(goto);","    assert!(matches!(result, Inst::Save(InstSave { goto: 250, slot: 500 })));","}"],[]],[["{","    let slot = 1001; // This will panic as it's out of bounds","    let goto: InstPtr = 1;","    let inst_hole = InstHole::Save { slot };","    inst_hole.fill(goto);","    let slot = 1001;","    let goto: InstPtr = 1;","    let inst_hole = InstHole::Save { slot };","    assert!(std::panic::catch_unwind(|| inst_hole.fill(goto)).is_err());","}"],[]]]}