{"function_name":"regex::input::<&'a T as input::Input>::len","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":10,"tests_lines":[18,18,18,18,18,18,18,18,18,18],"oracles":4,"oracles_compiled":2,"oracles_compiled_rate":50.0,"tests_compiled":2,"tests_compiled_rate":20.0,"oracles_run":2,"oracles_passed":2,"oracles_passed_rate":100.0,"tests_run":2,"tests_passed":2,"tests_passed_rate":100.0,"lines":1,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[133],"codes_lines_covered":[[["{","    struct NonEmptyInput;","    impl Input for NonEmptyInput {","       fn at(&self, _i: usize) -> InputAt { unimplemented!() }","       fn next_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn previous_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool { unimplemented!() }","       fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> { unimplemented!() }","        fn len(&self) -> usize { 10 }","        fn as_bytes(&self) -> &[u8] { b\"test_input\" }","    }","    ","    let input = &NonEmptyInput;","    input.len();","    let input = &NonEmptyInput;","    let result = input.len();","    assert_eq!(result, 10);","}"],[]],[["{","    struct LargeInput;","    impl Input for LargeInput {","       fn at(&self, _i: usize) -> InputAt { unimplemented!() }","       fn next_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn previous_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool { unimplemented!() }","       fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> { None }","        fn len(&self) -> usize { u32::MAX as usize }","        fn as_bytes(&self) -> &[u8] { &[0; u32::MAX as usize] }","    }","    ","    let input = &LargeInput;","    input.len();","    let input = &LargeInput;","    let length = input.len();","    assert_eq!(length, u32::MAX as usize);","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct NonEmptyInput;","    impl Input for NonEmptyInput {","       fn at(&self, _i: usize) -> InputAt { unimplemented!() }","       fn next_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn previous_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool { unimplemented!() }","       fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> { unimplemented!() }","        fn len(&self) -> usize { 10 }","        fn as_bytes(&self) -> &[u8] { b\"test_input\" }","    }","    ","    let input = &NonEmptyInput;","    input.len();","    let input = &NonEmptyInput;","    let result = input.len();","    assert_eq!(result, 10);","}"],[]],[["{","    struct LargeInput;","    impl Input for LargeInput {","       fn at(&self, _i: usize) -> InputAt { unimplemented!() }","       fn next_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn previous_char(&self, _at: InputAt) -> Char { unimplemented!() }","       fn is_empty_match(&self, _at: InputAt, _empty: &InstEmptyLook) -> bool { unimplemented!() }","       fn prefix_at(&self, _prefixes: &LiteralSearcher, _at: InputAt) -> Option<InputAt> { None }","        fn len(&self) -> usize { u32::MAX as usize }","        fn as_bytes(&self) -> &[u8] { &[0; u32::MAX as usize] }","    }","    ","    let input = &LargeInput;","    input.len();","    let input = &LargeInput;","    let length = input.len();","    assert_eq!(length, u32::MAX as usize);","}"],[]]]}