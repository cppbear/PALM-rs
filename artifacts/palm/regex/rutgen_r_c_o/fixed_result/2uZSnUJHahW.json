{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::parse_hex_brace","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":85,"tests_lines":[41,42,42,42,42,41,42,42,42,42,42,41,42,42,40,40,40,25,25,25,25,25,32,43,43,42,42,43,43,42,43,25,25,40,40,61,61,82,82,25,25,47,48,48,48,46,47,46,46,19,20,20,20,20,19,20,20,20,19,20,20,20,20,20,20,19,20,20,20,39,40,40,40,40,39,39,38,38,38,38,39,40,40,40,40],"oracles":25,"oracles_compiled":12,"oracles_compiled_rate":48.0,"tests_compiled":30,"tests_compiled_rate":35.294117647058826,"oracles_run":12,"oracles_passed":10,"oracles_passed_rate":83.33333333333334,"tests_run":30,"tests_passed":18,"tests_passed_rate":60.0,"lines":45,"lines_covered":41,"lines_coveraged_rate":91.11111111111111,"branches":10,"branches_covered":10,"branches_coverage_rate":100.0,"codes_lines":[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1691],"codes_lines_covered":[[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_ok());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.c, '1');","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.span.start.offset, 0);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.span.end.offset, 3);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_ok());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.c, '\\u{10}');","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(literal.span.start.offset > 0);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(literal.span.end.offset > literal.span.start.offset);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(parser.parser.scratch.borrow().is_empty());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_ok());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1663,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(literal.span.start.offset < literal.span.end.offset);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1663,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert!(parser.parse_hex_brace(kind).is_ok());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.scratch.borrow().len(), 2);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.pos.get().offset, 4);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.pos.get().line, 1);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.pos.get().column, 4);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{@\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{@\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    assert!(result.is_err());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{@\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{@\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{\\n\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{\\n\",","    };","    assert!(result.is_err());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{\\n\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{\\n\",","    };","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{#\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{#\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    assert!(result.is_err());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{#\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{#\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{xyz}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{xyz}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_err());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{xyz}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{xyz}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{ }\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern: \"{12345}\".borrow(),","    };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_err());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{g8}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{g8}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_err());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{g8}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{g8}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","        parser,","        pattern: \"{\",","    };","","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","","    assert!(result.is_err());","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","    parser,","    pattern: \"{\",","    };","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","    assert!(result.is_err());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1663,1664,1665,1666,1667,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","        parser,","        pattern: \"{\",","    };","","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","","    assert!(result.is_err());","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","    parser,","    pattern: \"{\",","    };","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeHexEmpty);","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1663,1664,1665,1666,1667,1691]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(\"007f\")),","        },","        pattern: \"{007f}\",","    };","    let _ = parser.parse_hex_brace(ast::HexLiteralKind::X);","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::from(\"007f\")),","    },","    pattern: \"{007f}\",","    };","    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);","    assert!(result.is_ok());","}"],[1642,1643,1644,1645,1649,1650,1651,1652,1653,1654,1655,1660,1661,1663,1668,1669,1670,1671,1672,1673,1674,1679,1680,1685,1686,1687,1688,1689,1691]]],"codes_branches":[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":true},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":true,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_ok());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.c, '1');","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.span.start.offset, 0);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::X;","    let pattern = \"{1}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.span.end.offset, 3);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_ok());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert_eq!(literal.c, '\\u{10}');","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(literal.span.start.offset > 0);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(literal.span.end.offset > literal.span.start.offset);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeShort;","    let pattern = \"{10}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(parser.parser.scratch.borrow().is_empty());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_ok());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":false,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{}\";","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern,","    };","    let result = parser.parse_hex_brace(kind);","    let literal = result.unwrap();","    assert!(literal.span.start.offset < literal.span.end.offset);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":false,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":true,"negative":false}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert!(parser.parse_hex_brace(kind).is_ok());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.scratch.borrow().len(), 2);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.pos.get().offset, 4);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.pos.get().line, 1);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\"; // Valid hex but still testing potential limits","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: true,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern,","    };","    parser.parse_hex_brace(kind);","    let kind = ast::HexLiteralKind::UnicodeLong;","    let pattern = \"{7F}\";","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: true, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern, };","    assert_eq!(parser.parser.pos.get().column, 4);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{@\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{@\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    assert!(result.is_err());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{@\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{@\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeShort);","    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{\\n\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{\\n\",","    };","    assert!(result.is_err());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{\\n\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::UnicodeLong);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{\\n\",","    };","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{#\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{#\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    assert!(result.is_err());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_instance = ParserI {","        parser: &parser,","        pattern: \"{#\",","    };","","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    let position = Position { offset: 0, line: 1, column: 1 };","    let mut parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_instance = ParserI {","    parser: &parser,","    pattern: \"{#\",","    };","    let result = parser_instance.parse_hex_brace(ast::HexLiteralKind::X);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalidDigit);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{xyz}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{xyz}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_err());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{xyz}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{xyz}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{ }\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    },","    pattern: \"{12345}\".borrow(),","    };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_err());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{g8}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{g8}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert!(result.is_err());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::new()),","        },","        pattern: \"{g8}\".borrow(),","    };","    ","    let kind = ast::HexLiteralKind::X;","    let _ = parser.parse_hex_brace(kind);","    let parser = ParserI { parser: Parser { pos: Cell::new(Position { offset: 0, line: 1, column: 1 }), capture_index: Cell::new(0), nest_limit: 10, octal: false, initial_ignore_whitespace: false, ignore_whitespace: Cell::new(false), comments: RefCell::new(vec![]), stack_group: RefCell::new(vec![]), stack_class: RefCell::new(vec![]), capture_names: RefCell::new(vec![]), scratch: RefCell::new(String::new()), }, pattern: \"{g8}\".borrow(), };","    let kind = ast::HexLiteralKind::X;","    let result = parser.parse_hex_brace(kind);","    assert_eq!(result.unwrap_err().kind, ast::ErrorKind::EscapeHexInvalid);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":true,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","        parser,","        pattern: \"{\",","    };","","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","","    assert!(result.is_err());","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","    parser,","    pattern: \"{\",","    };","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","    assert!(result.is_err());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":false,"negative":true},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":false,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":true,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: false,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","        parser,","        pattern: \"{\",","    };","","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","","    assert!(result.is_err());","    let position = Position { offset: 0, line: 1, column: 1 };","    let span = Span::new(position, position);","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI {","    parser,","    pattern: \"{\",","    };","    let result = parser_i.parse_hex_brace(ast::HexLiteralKind::X);","    assert_eq!(result.err().unwrap().kind, ast::ErrorKind::EscapeHexEmpty);","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":false,"negative":true},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":false,"negative":false},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":false},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":true,"negative":false},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","        parser: Parser {","            pos: Cell::new(position),","            capture_index: Cell::new(0),","            nest_limit: 10,","            octal: false,","            initial_ignore_whitespace: false,","            ignore_whitespace: Cell::new(false),","            comments: RefCell::new(vec![]),","            stack_group: RefCell::new(vec![]),","            stack_class: RefCell::new(vec![]),","            capture_names: RefCell::new(vec![]),","            scratch: RefCell::new(String::from(\"007f\")),","        },","        pattern: \"{007f}\",","    };","    let _ = parser.parse_hex_brace(ast::HexLiteralKind::X);","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = ParserI {","    parser: Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: false,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::from(\"007f\")),","    },","    pattern: \"{007f}\",","    };","    let result = parser.parse_hex_brace(ast::HexLiteralKind::X);","    assert!(result.is_ok());","}"],[{"start_line":1654,"start_column":15,"end_line":1654,"end_column":41,"positive":true,"negative":false},{"start_line":1654,"start_column":45,"end_line":1654,"end_column":63,"positive":true,"negative":true},{"start_line":1655,"start_column":16,"end_line":1655,"end_column":36,"positive":false,"negative":true},{"start_line":1663,"start_column":12,"end_line":1663,"end_column":25,"positive":false,"negative":true},{"start_line":1674,"start_column":12,"end_line":1674,"end_column":26,"positive":false,"negative":true}]]]}