{"function_name":"regex_debug::parse","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/src/main.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-debug","tests":12,"tests_lines":[7,7,7,7,7,7,7,7,8,7,8,8],"oracles":6,"oracles_compiled":6,"oracles_compiled_rate":100.0,"tests_compiled":8,"tests_compiled_rate":66.66666666666666,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":8,"tests_passed":5,"tests_passed_rate":62.5,"lines":7,"lines_covered":7,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[281,283,284,285,286,287,288],"codes_lines_covered":[[["{","    let re = \"\";","    parse(re);","    let re = \"\";","    let result = parse(re);","    assert!(result.is_err());","}"],[281,283,284,285,286,287,288]],[["{","    let re = r\"\\d{1,3}\\s\\w+\";","    parse(re);","    let re = r\"\\d{1,3}\\s\\w+\";","    let result = parse(re);","    assert!(result.is_ok());","}"],[281,283,284,285,286,287,288]],[["{","    let re = r\"[\\d{\";","    parse(re);","    let re = r\"[\\d{\";","    let result = parse(re);","    assert!(result.is_err());","}"],[281,283,284,285,286,287,288]],[["{","    let re = r\"[\\d{\";","    parse(re);","    let re = r\"[\\d{\";","    let result = parse(re);","    assert_eq!(result.unwrap_err().to_string(), \"error message for invalid regex\");","}"],[281,283,284,285,286,287,288]],[["{","    let re = \"a\".repeat(1000);","    parse(&re);","    let re = \"a\".repeat(1000);","    let result = parse(&re);","    assert!(result.is_ok());","}"],[281,283,284,285,286,287,288]],[["{","    let re = \"^[\\\\p{L}]+$\"; // Matches any string of Unicode letters.","    parse(re);","    let re = \"^[\\\\p{L}]+$\"; // Matches any string of Unicode letters.","    let result = parse(re);","    assert!(result.is_ok());","}"],[281,283,284,285,286,287,288]],[["{","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    parse(std::str::from_utf8(bytes).unwrap());","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    let result = parse(std::str::from_utf8(bytes).unwrap());","    assert!(result.is_ok());","}"],[281,283,284,285,286,287,288]],[["{","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    parse(std::str::from_utf8(bytes).unwrap());","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    let result = parse(std::str::from_utf8(bytes).unwrap());","    let hir = result.unwrap();","    assert!(hir.to_string().contains(\"^\\\\d{1,3}\\\\s\\\\w+$\"));","}"],[281,283,284,285,286,287,288]]],"codes_branches":[],"codes_branches_covered":[[["{","    let re = \"\";","    parse(re);","    let re = \"\";","    let result = parse(re);","    assert!(result.is_err());","}"],[]],[["{","    let re = r\"\\d{1,3}\\s\\w+\";","    parse(re);","    let re = r\"\\d{1,3}\\s\\w+\";","    let result = parse(re);","    assert!(result.is_ok());","}"],[]],[["{","    let re = r\"[\\d{\";","    parse(re);","    let re = r\"[\\d{\";","    let result = parse(re);","    assert!(result.is_err());","}"],[]],[["{","    let re = r\"[\\d{\";","    parse(re);","    let re = r\"[\\d{\";","    let result = parse(re);","    assert_eq!(result.unwrap_err().to_string(), \"error message for invalid regex\");","}"],[]],[["{","    let re = \"a\".repeat(1000);","    parse(&re);","    let re = \"a\".repeat(1000);","    let result = parse(&re);","    assert!(result.is_ok());","}"],[]],[["{","    let re = \"^[\\\\p{L}]+$\"; // Matches any string of Unicode letters.","    parse(re);","    let re = \"^[\\\\p{L}]+$\"; // Matches any string of Unicode letters.","    let result = parse(re);","    assert!(result.is_ok());","}"],[]],[["{","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    parse(std::str::from_utf8(bytes).unwrap());","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    let result = parse(std::str::from_utf8(bytes).unwrap());","    assert!(result.is_ok());","}"],[]],[["{","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    parse(std::str::from_utf8(bytes).unwrap());","    let bytes: &[u8] = b\"^\\\\d{1,3}\\\\s\\\\w+$\";","    let result = parse(std::str::from_utf8(bytes).unwrap());","    let hir = result.unwrap();","    assert!(hir.to_string().contains(\"^\\\\d{1,3}\\\\s\\\\w+$\"));","}"],[]]]}