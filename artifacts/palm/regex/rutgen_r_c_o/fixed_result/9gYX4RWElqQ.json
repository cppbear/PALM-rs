{"function_name":"regex_syntax::hir::hir::Hir::any","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":41,"tests_lines":[5,5,5,5,5,5,5,5,11,11,11,11,11,11,11,11,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],"oracles":7,"oracles_compiled":1,"oracles_compiled_rate":14.285714285714285,"tests_compiled":4,"tests_compiled_rate":9.75609756097561,"oracles_run":1,"oracles_passed":1,"oracles_passed_rate":100.0,"tests_run":4,"tests_passed":3,"tests_passed_rate":75.0,"lines":9,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[511,512,513,514,515,517,518,519,521],"codes_lines_covered":[[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(result.is_all_assertions());","}"],[]],[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(!result.is_anchored_start());","}"],[]],[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(!result.is_anchored_end());","}"],[]],[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(!result.is_match_empty());","}"],[]]],"codes_branches":[{"start_line":512,"start_column":12,"end_line":512,"end_column":17,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(result.is_all_assertions());","}"],[{"start_line":512,"start_column":12,"end_line":512,"end_column":17,"positive":false,"negative":false}]],[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(!result.is_anchored_start());","}"],[{"start_line":512,"start_column":12,"end_line":512,"end_column":17,"positive":false,"negative":false}]],[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(!result.is_anchored_end());","}"],[{"start_line":512,"start_column":12,"end_line":512,"end_column":17,"positive":false,"negative":false}]],[["{","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    let char_range = ClassBytesRange::new(b'\\0', b'\\0');","    let mut class_bytes = ClassBytes::empty();","    class_bytes.push(char_range);","    let result = Hir::class(Class::Bytes(class_bytes));","    assert!(!result.is_match_empty());","}"],[{"start_line":512,"start_column":12,"end_line":512,"end_column":17,"positive":false,"negative":false}]]]}