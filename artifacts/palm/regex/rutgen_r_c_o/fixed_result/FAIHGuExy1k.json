{"function_name":"regex::input::<input::ByteInput<'t> as input::Input>::as_bytes","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/src/input.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex","tests":20,"tests_lines":[7,7,7,7,7,7,7,7,7,7,7,7,7,6,6,6,6,7,9,9],"oracles":8,"oracles_compiled":7,"oracles_compiled_rate":87.5,"tests_compiled":17,"tests_compiled_rate":85.0,"oracles_run":7,"oracles_passed":7,"oracles_passed_rate":100.0,"tests_run":17,"tests_passed":17,"tests_passed_rate":100.0,"lines":3,"lines_covered":3,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[332,333,334],"codes_lines_covered":[[["{","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, &[]);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result.len(), 0);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    assert!(result.is_empty());","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0x61], only_utf8: true }; // 'a'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0x61], only_utf8: true }; // 'a'","    let result = input.as_bytes();","    assert_eq!(result, &[0x61]);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, &[0xC2, 0xA1]);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert!(result.len() == 2);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result[0], 0xC2);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result[1], 0xA1);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, &[0xE2, 0x88, 0x9A]);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result.len(), 3);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert!(result[0] == 0xE2);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert!(result[1] == 0x88);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert!(result[2] == 0x9A);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xF0, 0x9F, 0x92, 0xA9], only_utf8: true }; // '๐ฉ'","    let result = input.as_bytes();","    let expected = &[0xF0, 0x9F, 0x92, 0xA9];","    assert_eq!(result, expected);","}"],[332,333,334]],[["{","    let input = ByteInput { text: &[0xFF], only_utf8: false }; // invalid byte, but we are checking for valid utf8 only","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xFF], only_utf8: false };","    let result = input.as_bytes();","    assert_eq!(result, &[0xFF]);","}"],[332,333,334]],[["{","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect(); // valid ASCII range","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect();","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result.len(), valid_utf8.len());","}"],[332,333,334]],[["{","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect(); // valid ASCII range","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect();","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, valid_utf8.as_slice());","}"],[332,333,334]]],"codes_branches":[],"codes_branches_covered":[[["{","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, &[]);","}"],[]],[["{","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result.len(), 0);","}"],[]],[["{","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    let input = ByteInput { text: &[], only_utf8: true };","    let result = input.as_bytes();","    assert!(result.is_empty());","}"],[]],[["{","    let input = ByteInput { text: &[0x61], only_utf8: true }; // 'a'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0x61], only_utf8: true }; // 'a'","    let result = input.as_bytes();","    assert_eq!(result, &[0x61]);","}"],[]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, &[0xC2, 0xA1]);","}"],[]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert!(result.len() == 2);","}"],[]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result[0], 0xC2);","}"],[]],[["{","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true }; // 'ยก'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xC2, 0xA1], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result[1], 0xA1);","}"],[]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, &[0xE2, 0x88, 0x9A]);","}"],[]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result.len(), 3);","}"],[]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert!(result[0] == 0xE2);","}"],[]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert!(result[1] == 0x88);","}"],[]],[["{","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true }; // 'โฉ'","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xE2, 0x88, 0x9A], only_utf8: true };","    let result = input.as_bytes();","    assert!(result[2] == 0x9A);","}"],[]],[["{","    let input = ByteInput { text: &[0xF0, 0x9F, 0x92, 0xA9], only_utf8: true }; // '๐ฉ'","    let result = input.as_bytes();","    let expected = &[0xF0, 0x9F, 0x92, 0xA9];","    assert_eq!(result, expected);","}"],[]],[["{","    let input = ByteInput { text: &[0xFF], only_utf8: false }; // invalid byte, but we are checking for valid utf8 only","    let result = input.as_bytes();","    let input = ByteInput { text: &[0xFF], only_utf8: false };","    let result = input.as_bytes();","    assert_eq!(result, &[0xFF]);","}"],[]],[["{","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect(); // valid ASCII range","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect();","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result.len(), valid_utf8.len());","}"],[]],[["{","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect(); // valid ASCII range","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    let valid_utf8: Vec<u8> = (0..128).map(|x| x as u8).collect();","    let input = ByteInput { text: &valid_utf8, only_utf8: true };","    let result = input.as_bytes();","    assert_eq!(result, valid_utf8.as_slice());","}"],[]]]}