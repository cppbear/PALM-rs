{"function_name":"regex_syntax::hir::hir::Hir::dot","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/hir/mod.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":89,"tests_lines":[5,5,5,5,5,5,5,5,5,7,7,7,7,7,7,7,7,9,9,9,9,9,9,9,9,7,8,8,9,9,9,10,7,9,9,10,7,8,8,8,9,11,11,11,11,11,11,11,11,6,7,7,7,7,7,7,7,7,7,7,7,7,13,13,13,13,13,13,13,13,13,5,5,5,5,5,5,5,5,5,9,9,9,13,13,13,13,13,13],"oracles":13,"oracles_compiled":5,"oracles_compiled_rate":38.46153846153847,"tests_compiled":19,"tests_compiled_rate":21.34831460674157,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":19,"tests_passed":18,"tests_passed_rate":94.73684210526315,"lines":11,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":2,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[489,490,491,492,493,494,496,497,498,499,501],"codes_lines_covered":[[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_match_empty(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_all_assertions(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_always_utf8(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_start(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_end(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_start(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_end(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_match_empty(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_all_assertions(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_start(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_end(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_start(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_end(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_always_utf8(), false);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 9));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    assert_eq!(cls.ranges().len(), 0);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 9));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let range = ClassBytesRange::new(0, 9);","    assert_eq!(range.start(), 0);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 9));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let range = ClassBytesRange::new(0, 9);","    assert_eq!(range.end(), 9);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(9, 25));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    assert_eq!(cls.ranges(), &[]);","}"],[]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(10, 255));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    assert_eq!(cls.ranges().len(), 0);","}"],[]]],"codes_branches":[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}],"codes_branches_covered":[[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_match_empty(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_all_assertions(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_always_utf8(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_start(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_end(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_start(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_end(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_match_empty(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_all_assertions(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_start(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_anchored_end(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_start(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_any_anchored_end(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 255));","    let result = Hir::class(Class::Bytes(cls));","    assert_eq!(result.info.is_always_utf8(), false);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 9));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    assert_eq!(cls.ranges().len(), 0);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 9));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let range = ClassBytesRange::new(0, 9);","    assert_eq!(range.start(), 0);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(0, 9));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    let range = ClassBytesRange::new(0, 9);","    assert_eq!(range.end(), 9);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(9, 25));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    assert_eq!(cls.ranges(), &[]);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]],[["{","    let mut cls = ClassBytes::empty();","    cls.push(ClassBytesRange::new(10, 255));","    let result = Hir::class(Class::Bytes(cls));","    let cls = ClassBytes::empty();","    assert_eq!(cls.ranges().len(), 0);","}"],[{"start_line":490,"start_column":12,"end_line":490,"end_column":17,"positive":false,"negative":false}]]]}