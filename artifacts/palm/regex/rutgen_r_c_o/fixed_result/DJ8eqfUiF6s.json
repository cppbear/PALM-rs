{"function_name":"regex_syntax::ast::parse::ast::parse::ParserI<'s, P>::span_char","file_path":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/src/ast/parse.rs","work_dir":"/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax","tests":32,"tests_lines":[38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,38,35,35,35,35,22,22,22,22,34,34,34,34],"oracles":7,"oracles_compiled":6,"oracles_compiled_rate":85.71428571428571,"tests_compiled":27,"tests_compiled_rate":84.375,"oracles_run":6,"oracles_passed":5,"oracles_passed_rate":83.33333333333334,"tests_run":27,"tests_passed":17,"tests_passed_rate":62.96296296296296,"lines":12,"lines_covered":12,"lines_coveraged_rate":100.0,"branches":2,"branches_covered":2,"branches_coverage_rate":100.0,"codes_lines":[634,635,636,637,638,639,640,641,642,643,644,645],"codes_lines_covered":[[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.offset, 0);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.line, 1);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.column, 1);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.offset, 1);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.line, 1);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.column, 2);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.offset, 5);","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.line, 1);","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.column, 6);","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.offset, 6);","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.line, 1);","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.column, 7);","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start, parser_i.pos());","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.offset, usize::MAX);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.line, usize::MAX);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.column, 1);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert!(span.is_empty() == false);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert!(span.is_one_line() == true);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 }; ","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start, Position { offset: 2, line: 1, column: 3 });","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 }; ","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end, Position { offset: 3, line: 1, column: 4 });","}"],[634,635,636,637,638,639,640,641,642,643,644,645]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert_eq!(parser_wrapper.span_char(), expected_span);","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert!(parser_wrapper.offset().checked_add(parser_wrapper.char().len_utf8()).is_some());","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert!(parser_wrapper.column().checked_add(1).is_some());","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert!(parser_wrapper.char() == '\\n');","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    assert!(parser_wrapper.offset().checked_add(parser_wrapper.char().len_utf8()).is_none());","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    assert!(parser_wrapper.column().checked_add(1).is_none());","}"],[634,635,636,637,638,639,640,643,644,645]],[["{","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    assert_eq!(parser_wrapper.char(), '\\n');","}"],[634,635,636,637,638,639,640,643,644,645]]],"codes_branches":[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.offset, 0);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.line, 1);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.column, 1);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.offset, 1);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.line, 1);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"abc\";","    let pos = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.column, 2);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.offset, 5);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.line, 1);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start.column, 6);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.offset, 6);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.line, 1);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"hello\\nworld\";","    let pos = Position { offset: 5, line: 1, column: 6 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.column, 7);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start, parser_i.pos());","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.offset, usize::MAX);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.line, usize::MAX);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end.column, 1);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert!(span.is_empty() == false);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"a\";","    let pos = Position { offset: usize::MAX - 1, line: usize::MAX, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert!(span.is_one_line() == true);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 }; ","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.start, Position { offset: 2, line: 1, column: 3 });","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 }; ","    let parser = Parser {","        pos: Cell::new(pos),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    let pattern = \"ab\\ncd\";","    let pos = Position { offset: 2, line: 1, column: 3 };","    let parser = Parser {","    pos: Cell::new(pos),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_i = ParserI::new(&parser, pattern);","    let span = parser_i.span_char();","    assert_eq!(span.end, Position { offset: 3, line: 1, column: 4 });","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":true,"negative":false}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert_eq!(parser_wrapper.span_char(), expected_span);","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert!(parser_wrapper.offset().checked_add(parser_wrapper.char().len_utf8()).is_some());","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert!(parser_wrapper.column().checked_add(1).is_some());","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: 0, line: 1, column: 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"a\\n\");","    let expected_span = Span::new(position, Position { offset: 1, line: 1, column: 2 });","    assert!(parser_wrapper.char() == '\\n');","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    assert!(parser_wrapper.offset().checked_add(parser_wrapper.char().len_utf8()).is_none());","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    assert!(parser_wrapper.column().checked_add(1).is_none());","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]],[["{","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","        pos: Cell::new(position),","        capture_index: Cell::new(0),","        nest_limit: 10,","        octal: true,","        initial_ignore_whitespace: false,","        ignore_whitespace: Cell::new(false),","        comments: RefCell::new(vec![]),","        stack_group: RefCell::new(vec![]),","        stack_class: RefCell::new(vec![]),","        capture_names: RefCell::new(vec![]),","        scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    let _ = parser_wrapper.span_char();","    let position = Position { offset: usize::MAX - 1, line: 1, column: usize::MAX - 1 };","    let parser = Parser {","    pos: Cell::new(position),","    capture_index: Cell::new(0),","    nest_limit: 10,","    octal: true,","    initial_ignore_whitespace: false,","    ignore_whitespace: Cell::new(false),","    comments: RefCell::new(vec![]),","    stack_group: RefCell::new(vec![]),","    stack_class: RefCell::new(vec![]),","    capture_names: RefCell::new(vec![]),","    scratch: RefCell::new(String::new()),","    };","    let parser_wrapper = ParserI::new(&parser, \"x\");","    assert_eq!(parser_wrapper.char(), '\\n');","}"],[{"start_line":640,"start_column":12,"end_line":640,"end_column":31,"positive":false,"negative":true}]]]}