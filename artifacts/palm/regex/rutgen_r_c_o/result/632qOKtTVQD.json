{"function_name":"regex::input::<&'a T as input::Input>::next_char","tests":115,"tests_lines":[48,50,52,54,56,58,48,48,50,51,51,51,48,50,52,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148],"oracles":4,"oracles_compiled":4,"oracles_compiled_rate":100.0,"tests_compiled":114,"tests_compiled_rate":99.1304347826087,"oracles_run":4,"oracles_passed":3,"oracles_passed_rate":75.0,"tests_run":114,"tests_passed":105,"tests_passed_rate":92.10526315789474,"lines":1,"lines_covered":0,"lines_coveraged_rate":0.0,"branches":1,"branches_covered":0,"branches_coverage_rate":0.0,"codes_lines":[117],"codes_lines_covered":[[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(98)); // next_char of 'a' should be 'b'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(99)); // next_char of 'b' should be 'c'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(0)); // next_char of 'c' should wrap around to '0' (ASCII)","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let previous_char_result = input.previous_char(at);","    assert_eq!(previous_char_result, Char(127)); // previous_char of 'a' should be '' (ASCII)","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let previous_char_result = input.previous_char(at);","    let at = input.at(1);","    let previous_char_result = input.previous_char(at);","    assert_eq!(previous_char_result, Char(98)); // previous_char of 'b' should be 'a'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let previous_char_result = input.previous_char(at);","    let at = input.at(1);","    let previous_char_result = input.previous_char(at);","    let at = input.at(2);","    let previous_char_result = input.previous_char(at);","    assert_eq!(previous_char_result, Char(99)); // previous_char of 'c' should be 'b'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result.0, 1);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result.0 % 128, 1);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at_next = input.at(1);","    let next_char_result_from_next = input.next_char(at_next);","    assert_eq!(next_char_result_from_next.0, 0);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at_next = input.at(1);","    let next_char_result_from_next = input.next_char(at_next);","    let at_empty = input.at(0);","    assert_eq!(input.len(), 1);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at_next = input.at(1);","    let next_char_result_from_next = input.next_char(at_next);","    let at_empty = input.at(0);","    assert!(input.as_bytes() == &[0]);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(u32::MAX),","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2); ","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(0));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(u32::MAX),","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2); ","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(2));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(u32::MAX),","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2); ","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(1));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    assert_eq!(input.next_char(at), Char(101));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    assert_eq!(input.next_char(at), Char(102));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    assert_eq!(input.next_char(at), Char(103));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    assert_eq!(input.next_char(at), Char(104));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    assert_eq!(input.next_char(at), Char(105));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    assert_eq!(input.next_char(at), Char(106));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    assert_eq!(input.next_char(at), Char(107));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    assert_eq!(input.next_char(at), Char(108));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    assert_eq!(input.next_char(at), Char(109));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    assert_eq!(input.next_char(at), Char(110));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    assert_eq!(input.next_char(at), Char(111));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    assert_eq!(input.next_char(at), Char(112));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    assert_eq!(input.next_char(at), Char(113));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    assert_eq!(input.next_char(at), Char(114));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    assert_eq!(input.next_char(at), Char(115));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    assert_eq!(input.next_char(at), Char(116));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    assert_eq!(input.next_char(at), Char(117));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    assert_eq!(input.next_char(at), Char(118));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    assert_eq!(input.next_char(at), Char(119));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    assert_eq!(input.next_char(at), Char(120));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    assert_eq!(input.next_char(at), Char(121));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    assert_eq!(input.next_char(at), Char(122));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    assert_eq!(input.next_char(at), Char(123));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    assert_eq!(input.next_char(at), Char(124));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    assert_eq!(input.next_char(at), Char(125));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    assert_eq!(input.next_char(at), Char(126));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    assert_eq!(input.next_char(at), Char(127));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    assert_eq!(input.next_char(at), Char(128));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    assert_eq!(input.next_char(at), Char(129));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    assert_eq!(input.next_char(at), Char(130));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    assert_eq!(input.next_char(at), Char(131));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    assert_eq!(input.next_char(at), Char(132));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    assert_eq!(input.next_char(at), Char(133));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    assert_eq!(input.next_char(at), Char(134));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    assert_eq!(input.next_char(at), Char(135));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    assert_eq!(input.next_char(at), Char(136));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    assert_eq!(input.next_char(at), Char(137));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    assert_eq!(input.next_char(at), Char(138));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    assert_eq!(input.next_char(at), Char(139));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    assert_eq!(input.next_char(at), Char(140));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    assert_eq!(input.next_char(at), Char(141));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    assert_eq!(input.next_char(at), Char(142));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    assert_eq!(input.next_char(at), Char(143));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    assert_eq!(input.next_char(at), Char(144));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    assert_eq!(input.next_char(at), Char(145));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    assert_eq!(input.next_char(at), Char(146));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    assert_eq!(input.next_char(at), Char(147));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    assert_eq!(input.next_char(at), Char(148));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    assert_eq!(input.next_char(at), Char(149));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    assert_eq!(input.next_char(at), Char(150));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    assert_eq!(input.next_char(at), Char(151));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    assert_eq!(input.next_char(at), Char(152));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    assert_eq!(input.next_char(at), Char(153));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    assert_eq!(input.next_char(at), Char(154));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    assert_eq!(input.next_char(at), Char(155));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    assert_eq!(input.next_char(at), Char(156));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    assert_eq!(input.next_char(at), Char(157));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    assert_eq!(input.next_char(at), Char(158));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    assert_eq!(input.next_char(at), Char(159));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    assert_eq!(input.next_char(at), Char(160));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    assert_eq!(input.next_char(at), Char(161));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    assert_eq!(input.next_char(at), Char(162));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    assert_eq!(input.next_char(at), Char(163));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    assert_eq!(input.next_char(at), Char(164));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    assert_eq!(input.next_char(at), Char(165));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    assert_eq!(input.next_char(at), Char(166));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    assert_eq!(input.next_char(at), Char(167));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    assert_eq!(input.next_char(at), Char(168));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    assert_eq!(input.next_char(at), Char(169));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    assert_eq!(input.next_char(at), Char(170));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    assert_eq!(input.next_char(at), Char(171));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    assert_eq!(input.next_char(at), Char(172));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    assert_eq!(input.next_char(at), Char(173));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    assert_eq!(input.next_char(at), Char(174));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    assert_eq!(input.next_char(at), Char(175));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    assert_eq!(input.next_char(at), Char(176));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    assert_eq!(input.next_char(at), Char(177));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    assert_eq!(input.next_char(at), Char(178));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    assert_eq!(input.next_char(at), Char(179));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    assert_eq!(input.next_char(at), Char(180));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    assert_eq!(input.next_char(at), Char(181));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    assert_eq!(input.next_char(at), Char(182));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    assert_eq!(input.next_char(at), Char(183));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    assert_eq!(input.next_char(at), Char(184));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    assert_eq!(input.next_char(at), Char(185));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    assert_eq!(input.next_char(at), Char(186));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    assert_eq!(input.next_char(at), Char(187));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    assert_eq!(input.next_char(at), Char(188));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    assert_eq!(input.next_char(at), Char(189));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    assert_eq!(input.next_char(at), Char(190));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    assert_eq!(input.next_char(at), Char(191));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    assert_eq!(input.next_char(at), Char(192));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    assert_eq!(input.next_char(at), Char(193));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    assert_eq!(input.next_char(at), Char(194));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    assert_eq!(input.next_char(at), Char(195));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    assert_eq!(input.next_char(at), Char(196));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    assert_eq!(input.next_char(at), Char(197));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    let at = input.at(97);","    assert_eq!(input.next_char(at), Char(198));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    let at = input.at(97);","    let at = input.at(98);","    assert_eq!(input.next_char(at), Char(199));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    let at = input.at(97);","    let at = input.at(98);","    let at = input.at(99);","    assert_eq!(input.next_char(at), Char(200));","}"],[]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(98)); // next_char of 'a' should be 'b'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(99)); // next_char of 'b' should be 'c'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(0)); // next_char of 'c' should wrap around to '0' (ASCII)","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let previous_char_result = input.previous_char(at);","    assert_eq!(previous_char_result, Char(127)); // previous_char of 'a' should be '' (ASCII)","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let previous_char_result = input.previous_char(at);","    let at = input.at(1);","    let previous_char_result = input.previous_char(at);","    assert_eq!(previous_char_result, Char(98)); // previous_char of 'b' should be 'a'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(97), // ASCII for 'a'","                byte: Some(self.data[i]),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128) // Simple increment for testing","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128) // Simple decrement for testing","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let previous_char_result = input.previous_char(at);","    let at = input.at(1);","    let previous_char_result = input.previous_char(at);","    let at = input.at(2);","    let previous_char_result = input.previous_char(at);","    assert_eq!(previous_char_result, Char(99)); // previous_char of 'c' should be 'b'","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result.0, 1);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result.0 % 128, 1);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at_next = input.at(1);","    let next_char_result_from_next = input.next_char(at_next);","    assert_eq!(next_char_result_from_next.0, 0);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at_next = input.at(1);","    let next_char_result_from_next = input.next_char(at_next);","    let at_empty = input.at(0);","    assert_eq!(input.len(), 1);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(0),","                byte: Some(0),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0] };","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    let at_next = input.at(1);","    let next_char_result_from_next = input.next_char(at_next);","    let at_empty = input.at(0);","    assert!(input.as_bytes() == &[0]);","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(u32::MAX),","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2); ","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(0));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(u32::MAX),","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2); ","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(2));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(u32::MAX),","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 1) % 128)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char((at.c.0 + 127) % 128)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2); ","    let _next = input.next_char(at);","    let input = TestInput { data: vec![0, 1, 2] };","    let at = input.at(2);","    let next_char_result = input.next_char(at);","    let at = input.at(1);","    let next_char_result = input.next_char(at);","    let at = input.at(0);","    let next_char_result = input.next_char(at);","    assert_eq!(next_char_result, Char(1));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    assert_eq!(input.next_char(at), Char(101));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    assert_eq!(input.next_char(at), Char(102));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    assert_eq!(input.next_char(at), Char(103));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    assert_eq!(input.next_char(at), Char(104));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    assert_eq!(input.next_char(at), Char(105));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    assert_eq!(input.next_char(at), Char(106));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    assert_eq!(input.next_char(at), Char(107));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    assert_eq!(input.next_char(at), Char(108));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    assert_eq!(input.next_char(at), Char(109));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    assert_eq!(input.next_char(at), Char(110));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    assert_eq!(input.next_char(at), Char(111));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    assert_eq!(input.next_char(at), Char(112));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    assert_eq!(input.next_char(at), Char(113));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    assert_eq!(input.next_char(at), Char(114));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    assert_eq!(input.next_char(at), Char(115));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    assert_eq!(input.next_char(at), Char(116));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    assert_eq!(input.next_char(at), Char(117));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    assert_eq!(input.next_char(at), Char(118));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    assert_eq!(input.next_char(at), Char(119));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    assert_eq!(input.next_char(at), Char(120));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    assert_eq!(input.next_char(at), Char(121));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    assert_eq!(input.next_char(at), Char(122));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    assert_eq!(input.next_char(at), Char(123));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    assert_eq!(input.next_char(at), Char(124));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    assert_eq!(input.next_char(at), Char(125));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    assert_eq!(input.next_char(at), Char(126));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    assert_eq!(input.next_char(at), Char(127));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    assert_eq!(input.next_char(at), Char(128));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    assert_eq!(input.next_char(at), Char(129));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    assert_eq!(input.next_char(at), Char(130));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    assert_eq!(input.next_char(at), Char(131));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    assert_eq!(input.next_char(at), Char(132));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    assert_eq!(input.next_char(at), Char(133));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    assert_eq!(input.next_char(at), Char(134));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    assert_eq!(input.next_char(at), Char(135));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    assert_eq!(input.next_char(at), Char(136));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    assert_eq!(input.next_char(at), Char(137));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    assert_eq!(input.next_char(at), Char(138));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    assert_eq!(input.next_char(at), Char(139));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    assert_eq!(input.next_char(at), Char(140));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    assert_eq!(input.next_char(at), Char(141));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    assert_eq!(input.next_char(at), Char(142));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    assert_eq!(input.next_char(at), Char(143));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    assert_eq!(input.next_char(at), Char(144));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    assert_eq!(input.next_char(at), Char(145));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    assert_eq!(input.next_char(at), Char(146));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    assert_eq!(input.next_char(at), Char(147));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    assert_eq!(input.next_char(at), Char(148));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    assert_eq!(input.next_char(at), Char(149));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    assert_eq!(input.next_char(at), Char(150));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    assert_eq!(input.next_char(at), Char(151));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    assert_eq!(input.next_char(at), Char(152));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    assert_eq!(input.next_char(at), Char(153));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    assert_eq!(input.next_char(at), Char(154));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    assert_eq!(input.next_char(at), Char(155));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    assert_eq!(input.next_char(at), Char(156));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    assert_eq!(input.next_char(at), Char(157));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    assert_eq!(input.next_char(at), Char(158));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    assert_eq!(input.next_char(at), Char(159));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    assert_eq!(input.next_char(at), Char(160));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    assert_eq!(input.next_char(at), Char(161));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    assert_eq!(input.next_char(at), Char(162));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    assert_eq!(input.next_char(at), Char(163));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    assert_eq!(input.next_char(at), Char(164));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    assert_eq!(input.next_char(at), Char(165));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    assert_eq!(input.next_char(at), Char(166));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    assert_eq!(input.next_char(at), Char(167));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    assert_eq!(input.next_char(at), Char(168));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    assert_eq!(input.next_char(at), Char(169));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    assert_eq!(input.next_char(at), Char(170));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    assert_eq!(input.next_char(at), Char(171));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    assert_eq!(input.next_char(at), Char(172));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    assert_eq!(input.next_char(at), Char(173));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    assert_eq!(input.next_char(at), Char(174));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    assert_eq!(input.next_char(at), Char(175));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    assert_eq!(input.next_char(at), Char(176));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    assert_eq!(input.next_char(at), Char(177));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    assert_eq!(input.next_char(at), Char(178));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    assert_eq!(input.next_char(at), Char(179));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    assert_eq!(input.next_char(at), Char(180));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    assert_eq!(input.next_char(at), Char(181));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    assert_eq!(input.next_char(at), Char(182));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    assert_eq!(input.next_char(at), Char(183));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    assert_eq!(input.next_char(at), Char(184));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    assert_eq!(input.next_char(at), Char(185));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    assert_eq!(input.next_char(at), Char(186));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    assert_eq!(input.next_char(at), Char(187));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    assert_eq!(input.next_char(at), Char(188));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    assert_eq!(input.next_char(at), Char(189));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    assert_eq!(input.next_char(at), Char(190));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    assert_eq!(input.next_char(at), Char(191));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    assert_eq!(input.next_char(at), Char(192));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    assert_eq!(input.next_char(at), Char(193));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    assert_eq!(input.next_char(at), Char(194));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    assert_eq!(input.next_char(at), Char(195));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    assert_eq!(input.next_char(at), Char(196));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    assert_eq!(input.next_char(at), Char(197));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    let at = input.at(97);","    assert_eq!(input.next_char(at), Char(198));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    let at = input.at(97);","    let at = input.at(98);","    assert_eq!(input.next_char(at), Char(199));","}"],[]],[["{","    struct TestInput {","        data: Vec<u8>,","    }","","    impl Input for TestInput {","        fn at(&self, i: usize) -> InputAt {","            InputAt {","                pos: i,","                c: Char(100 + i as u32), // generates a sequence of ASCII characters","                byte: Some(1),","                len: self.data.len(),","            }","        }","        ","        fn next_char(&self, at: InputAt) -> Char {","            Char(at.c.0 + 1)","        }","        ","        fn previous_char(&self, at: InputAt) -> Char {","            Char(at.c.0 - 1)","        }","        ","        fn is_empty_match(&self, _: InputAt, _: &InstEmptyLook) -> bool {","            false","        }","","        fn prefix_at(&self, _: &LiteralSearcher, _: InputAt) -> Option<InputAt> {","            None","        }","","        fn len(&self) -> usize {","            self.data.len()","        }","","        fn as_bytes(&self) -> &[u8] {","            &self.data","        }","    }","","    let input = TestInput { data: vec![0; 1000] }; // maximum length","    for i in 0..1000 {","        let at = input.at(i);","        let _next = input.next_char(at);","    }","    let input = TestInput { data: vec![0; 1000] };","    let at = input.at(0);","    let at = input.at(1);","    let at = input.at(2);","    let at = input.at(3);","    let at = input.at(4);","    let at = input.at(5);","    let at = input.at(6);","    let at = input.at(7);","    let at = input.at(8);","    let at = input.at(9);","    let at = input.at(10);","    let at = input.at(11);","    let at = input.at(12);","    let at = input.at(13);","    let at = input.at(14);","    let at = input.at(15);","    let at = input.at(16);","    let at = input.at(17);","    let at = input.at(18);","    let at = input.at(19);","    let at = input.at(20);","    let at = input.at(21);","    let at = input.at(22);","    let at = input.at(23);","    let at = input.at(24);","    let at = input.at(25);","    let at = input.at(26);","    let at = input.at(27);","    let at = input.at(28);","    let at = input.at(29);","    let at = input.at(30);","    let at = input.at(31);","    let at = input.at(32);","    let at = input.at(33);","    let at = input.at(34);","    let at = input.at(35);","    let at = input.at(36);","    let at = input.at(37);","    let at = input.at(38);","    let at = input.at(39);","    let at = input.at(40);","    let at = input.at(41);","    let at = input.at(42);","    let at = input.at(43);","    let at = input.at(44);","    let at = input.at(45);","    let at = input.at(46);","    let at = input.at(47);","    let at = input.at(48);","    let at = input.at(49);","    let at = input.at(50);","    let at = input.at(51);","    let at = input.at(52);","    let at = input.at(53);","    let at = input.at(54);","    let at = input.at(55);","    let at = input.at(56);","    let at = input.at(57);","    let at = input.at(58);","    let at = input.at(59);","    let at = input.at(60);","    let at = input.at(61);","    let at = input.at(62);","    let at = input.at(63);","    let at = input.at(64);","    let at = input.at(65);","    let at = input.at(66);","    let at = input.at(67);","    let at = input.at(68);","    let at = input.at(69);","    let at = input.at(70);","    let at = input.at(71);","    let at = input.at(72);","    let at = input.at(73);","    let at = input.at(74);","    let at = input.at(75);","    let at = input.at(76);","    let at = input.at(77);","    let at = input.at(78);","    let at = input.at(79);","    let at = input.at(80);","    let at = input.at(81);","    let at = input.at(82);","    let at = input.at(83);","    let at = input.at(84);","    let at = input.at(85);","    let at = input.at(86);","    let at = input.at(87);","    let at = input.at(88);","    let at = input.at(89);","    let at = input.at(90);","    let at = input.at(91);","    let at = input.at(92);","    let at = input.at(93);","    let at = input.at(94);","    let at = input.at(95);","    let at = input.at(96);","    let at = input.at(97);","    let at = input.at(98);","    let at = input.at(99);","    assert_eq!(input.next_char(at), Char(200));","}"],[]]]}