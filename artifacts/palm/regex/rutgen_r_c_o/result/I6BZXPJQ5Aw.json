{"function_name":"regex::compile::compile::Compiler::c_empty_look","tests":36,"tests_lines":[7,8,8,8,7,8,8,7,8,8,7,8,8,7,8,8,8,8,7,8,8,7,8,8,7,7,7,7,7,7,7,7,8,8,8,8],"oracles":10,"oracles_compiled":10,"oracles_compiled_rate":100.0,"tests_compiled":33,"tests_compiled_rate":91.66666666666666,"oracles_run":10,"oracles_passed":10,"oracles_passed_rate":100.0,"tests_run":33,"tests_passed":33,"tests_passed_rate":100.0,"lines":4,"lines_covered":4,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[487,488,489,490],"codes_lines_covered":[[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let patch = result.unwrap();","    assert!(if let Hole::One(_) = patch.hole { true } else { false });","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let patch = result.unwrap();","    assert_eq!(patch.entry, 0);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let patch = result.unwrap();","    assert_eq!(compiler.insts.len(), 1);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    let patch = result.unwrap();","    assert_eq!(patch.entry, 0);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert_eq!(patch.entry, 0);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert_eq!(compiler.insts.len(), 1);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert!(matches!(compiler.insts[0], MaybeInst::Uncompiled(InstHole::EmptyLook { look: EmptyLook::WordBoundary })));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(result.is_ok());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(matches!(result, Ok(Patch { hole, entry: _ })));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(compiler.insts.len() > 0);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(matches!(compiler.insts.last(), Some(MaybeInst::Uncompiled(InstHole::EmptyLook { look: EmptyLook::NotWordBoundaryAscii } ))));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert!(matches!(result, Ok(Patch { .. })));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert_eq!(result.unwrap().entry, 0);","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert!(matches!(result.unwrap().hole, Hole::One(_)));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let hole = compiler.push_hole(InstHole::EmptyLook { look: EmptyLook::EndLine });","    let entry = compiler.insts.len() - 1;","    assert!(compiler.insts.last().is_some());","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let hole = compiler.push_hole(InstHole::EmptyLook { look: EmptyLook::EndLine });","    let entry = compiler.insts.len() - 1;","    assert!(matches!(compiler.insts.last().unwrap(), MaybeInst::Uncompiled(InstHole::EmptyLook { look: EmptyLook::EndLine })));","}"],[487,488,489,490]],[["{","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let hole = compiler.push_hole(InstHole::EmptyLook { look: EmptyLook::EndLine });","    let entry = compiler.insts.len() - 1;","    assert_eq!(compiler.size_limit, 10 * (1 << 20));","}"],[487,488,489,490]]],"codes_branches":[],"codes_branches_covered":[[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let patch = result.unwrap();","    assert!(if let Hole::One(_) = patch.hole { true } else { false });","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let patch = result.unwrap();","    assert_eq!(patch.entry, 0);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let patch = result.unwrap();","    assert_eq!(compiler.insts.len(), 1);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::StartText);","    let patch = result.unwrap();","    assert_eq!(patch.entry, 0);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::EndText);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert_eq!(patch.entry, 0);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert_eq!(compiler.insts.len(), 1);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundary);","    let patch = result.unwrap();","    assert!(matches!(compiler.insts[0], MaybeInst::Uncompiled(InstHole::EmptyLook { look: EmptyLook::WordBoundary })));","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundary);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let patch = result.unwrap();","    assert!(matches!(patch.hole, Hole::One(_)));","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::WordBoundaryAscii);","    let patch = result.unwrap();","    assert_eq!(patch.entry, compiler.insts.len() - 1);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(result.is_ok());","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(matches!(result, Ok(Patch { hole, entry: _ })));","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(compiler.insts.len() > 0);","}"],[]],[["{","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    let mut compiler = Compiler::new();","    let result = compiler.c_empty_look(EmptyLook::NotWordBoundaryAscii);","    assert!(matches!(compiler.insts.last(), Some(MaybeInst::Uncompiled(InstHole::EmptyLook { look: EmptyLook::NotWordBoundaryAscii } ))));","}"],[]],[["{","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert!(matches!(result, Ok(Patch { .. })));","}"],[]],[["{","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert_eq!(result.unwrap().entry, 0);","}"],[]],[["{","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    let mut compiler = Compiler::new().size_limit(0);","    let result = compiler.c_empty_look(EmptyLook::StartLine);","    assert!(matches!(result.unwrap().hole, Hole::One(_)));","}"],[]],[["{","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let hole = compiler.push_hole(InstHole::EmptyLook { look: EmptyLook::EndLine });","    let entry = compiler.insts.len() - 1;","    assert!(compiler.insts.last().is_some());","}"],[]],[["{","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let hole = compiler.push_hole(InstHole::EmptyLook { look: EmptyLook::EndLine });","    let entry = compiler.insts.len() - 1;","    assert!(matches!(compiler.insts.last().unwrap(), MaybeInst::Uncompiled(InstHole::EmptyLook { look: EmptyLook::EndLine })));","}"],[]],[["{","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let result = compiler.c_empty_look(EmptyLook::EndLine);","    let mut compiler = Compiler::new().size_limit(10 * (1 << 20));","    let hole = compiler.push_hole(InstHole::EmptyLook { look: EmptyLook::EndLine });","    let entry = compiler.insts.len() - 1;","    assert_eq!(compiler.size_limit, 10 * (1 << 20));","}"],[]]]}