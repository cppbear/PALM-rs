{"function_name":"regex::exec::exec::ExecBuilder::new_many","tests":74,"tests_lines":[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],"oracles":8,"oracles_compiled":5,"oracles_compiled_rate":62.5,"tests_compiled":44,"tests_compiled_rate":59.45945945945946,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":44,"tests_passed":43,"tests_passed_rate":97.72727272727273,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[128,129,130,131,132,133],"codes_lines_covered":[[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats.len(), 0);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.size_limit, 10 * (1 << 20));","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.dfa_size_limit, 2 * (1 << 20));","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.nest_limit, 250);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.case_insensitive);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.multi_line);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.dot_matches_new_line);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.swap_greed);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.ignore_whitespace);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(result.options.unicode);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.octal);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.pats, expected_pats);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.size_limit, 10 * (1 << 20));","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.dfa_size_limit, 2 * (1 << 20));","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.nest_limit, 250);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.case_insensitive, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.multi_line, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.dot_matches_new_line, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.swap_greed, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.ignore_whitespace, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.unicode, true);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.octal, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats.len(), 3);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats[0], \"abc\");","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats[1], \"123\");","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats[2], \".*\");","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.size_limit, 10485760);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.dfa_size_limit, 2097152);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.nest_limit, 250);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.case_insensitive, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.multi_line, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.dot_matches_new_line, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.swap_greed, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.ignore_whitespace, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.unicode, true);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.octal, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.options.pats, vec![\"test\".to_string(), \"string\".to_string()]);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.bytes, false);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.only_utf8, true);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.options.unicode, true);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert_eq!(exec_builder.options.pats.len(), 2);","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert_eq!(exec_builder.options.pats[0], \"abc\");","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert_eq!(exec_builder.options.pats[1], \"xyz\");","}"],[128,129,130,131,132,133]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert!(exec_builder.options.unicode);","}"],[128,129,130,131,132,133]]],"codes_branches":[],"codes_branches_covered":[[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats.len(), 0);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.size_limit, 10 * (1 << 20));","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.dfa_size_limit, 2 * (1 << 20));","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.nest_limit, 250);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.case_insensitive);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.multi_line);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.dot_matches_new_line);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.swap_greed);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.ignore_whitespace);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(result.options.unicode);","}"],[]],[["{","    let input: Vec<&str> = vec![];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![];","    let result = ExecBuilder::new_many(input);","    assert!(!result.options.octal);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.pats, expected_pats);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.size_limit, 10 * (1 << 20));","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.dfa_size_limit, 2 * (1 << 20));","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.nest_limit, 250);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.case_insensitive, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.multi_line, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.dot_matches_new_line, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.swap_greed, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.ignore_whitespace, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.unicode, true);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\"];","    ExecBuilder::new_many(input);","    let opts = RegexOptions::default();","    let expected_pats = vec![\"abc\".to_owned()];","    assert_eq!(opts.octal, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats.len(), 3);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats[0], \"abc\");","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats[1], \"123\");","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.pats[2], \".*\");","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.size_limit, 10485760);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.dfa_size_limit, 2097152);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.nest_limit, 250);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.case_insensitive, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.multi_line, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.dot_matches_new_line, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.swap_greed, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.ignore_whitespace, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.unicode, true);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    ExecBuilder::new_many(input);","    let input: Vec<&str> = vec![\"abc\", \"123\", \".*\"];","    let result = ExecBuilder::new_many(input);","    assert_eq!(result.options.octal, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.options.pats, vec![\"test\".to_string(), \"string\".to_string()]);","}"],[]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.bytes, false);","}"],[]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.only_utf8, true);","}"],[]],[["{","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input).bounded_backtracking();","    let input: Vec<&str> = vec![\"test\", \"string\"];","    let exec_builder = ExecBuilder::new_many(input);","    assert_eq!(exec_builder.options.unicode, true);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert_eq!(exec_builder.options.pats.len(), 2);","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert_eq!(exec_builder.options.pats[0], \"abc\");","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert_eq!(exec_builder.options.pats[1], \"xyz\");","}"],[]],[["{","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    let input: Vec<&str> = vec![\"abc\", \"xyz\"];","    let exec_builder = ExecBuilder::new_many(input).unicode(true);","    assert!(exec_builder.options.unicode);","}"],[]]]}