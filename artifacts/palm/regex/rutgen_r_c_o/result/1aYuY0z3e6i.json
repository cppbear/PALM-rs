{"function_name":"regex::compile::compile::CompileClass<'a, 'b>::c_utf8_seq_","tests":147,"tests_lines":[9,9,9,9,9,9,9,10,10,12,13,13,13,9,9,9,9,9,9,9,9,9,9,9,9,9,10,10,10,10,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,22,22,22,22,22,22,22,12,15,18,21,25,17,16,16,16,16,16,16,17,17,17,17,17,17,17,21,21,21,21,21,21,21,21,21,21,30,31,31,31,27,28,28,28,28,25,25,25,25,25,25,25,26,26,9,10,10,9,10,10,13,14,14,9,10,10,17,18,18,10,10,10,10,10,11,12,12,11,11,11,11,11,11,11,11,11,8,8,8,8,8,8,8,9,9,9,9,9,9],"oracles":27,"oracles_compiled":5,"oracles_compiled_rate":18.51851851851852,"tests_compiled":23,"tests_compiled_rate":15.646258503401361,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":23,"tests_passed":20,"tests_passed_rate":86.95652173913044,"lines":36,"lines_covered":34,"lines_coveraged_rate":94.44444444444444,"branches":4,"branches_covered":3,"branches_coverage_rate":75.0,"codes_lines":[926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,960,961,962],"codes_lines_covered":[[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.insts.len() > 0);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert_eq!(compiler.suffix_cache.version, 1);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.byte_classes.0[0..2].iter().all(|&x| x == true));","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.insts.len() == 1);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.insts.last().is_some());","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.suffix_cache.table.iter().any(|e| e.key.start == 1 && e.key.end == 10));","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compile_class.c.byte_classes.0[10] == true);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.suffix_cache.get(SuffixCacheKey { from_inst: ::std::usize::MAX, start: 1, end: 10 }, compiler.insts.len()).is_none());","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // version to match our key checks","    compiler.suffix_cache = suffix_cache;","","    let byte_ranges = vec![","        Utf8Range { start: 1, end: 5 },","        Utf8Range { start: 6, end: 10 },","        Utf8Range { start: 11, end: 255 },","    ];","    ","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_ranges = vec![","    Utf8Range { start: 1, end: 5 },","    Utf8Range { start: 6, end: 10 },","    Utf8Range { start: 11, end: 255 },","    ];","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // version to match our key checks","    compiler.suffix_cache = suffix_cache;","","    let byte_ranges = vec![","        Utf8Range { start: 1, end: 5 },","        Utf8Range { start: 6, end: 10 },","        Utf8Range { start: 11, end: 255 },","    ];","    ","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_ranges = vec![","    Utf8Range { start: 1, end: 5 },","    Utf8Range { start: 6, end: 10 },","    Utf8Range { start: 11, end: 255 },","    ];","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry < ::std::usize::MAX);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // version to match our key checks","    compiler.suffix_cache = suffix_cache;","","    let byte_ranges = vec![","        Utf8Range { start: 1, end: 5 },","        Utf8Range { start: 6, end: 10 },","        Utf8Range { start: 11, end: 255 },","    ];","    ","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_ranges = vec![","    Utf8Range { start: 1, end: 5 },","    Utf8Range { start: 6, end: 10 },","    Utf8Range { start: 11, end: 255 },","    ];","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry != ::std::usize::MAX);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry < ::std::usize::MAX);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(compiler.suffix_cache.version == 1);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(compiler.insts.len() > 0);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert_eq!(compiler.insts.len(), 2);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(matches!(compiler.insts[1], MaybeInst::Compiled(Inst::Bytes(_))));","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(matches!(compiler.suffix_cache.version, 1));","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(compiler.byte_classes.0[49]);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(compiler.byte_classes.0[100]);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure valid from_inst state","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure valid from_inst state","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry < ::std::usize::MAX);","}"],[926,927,928,929,930,931,932,933,934,935,936,937,938,939,942,943,944,945,946,947,948,949,950,957,958,960,961,962]]],"codes_branches":[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":true}],"codes_branches_covered":[[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.insts.len() > 0);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert_eq!(compiler.suffix_cache.version, 1);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.byte_classes.0[0..2].iter().all(|&x| x == true));","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.insts.len() == 1);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.insts.last().is_some());","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.suffix_cache.table.iter().any(|e| e.key.start == 1 && e.key.end == 10));","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compile_class.c.byte_classes.0[10] == true);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // to ensure our key is cached","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 1, end: 10 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    assert!(compiler.suffix_cache.get(SuffixCacheKey { from_inst: ::std::usize::MAX, start: 1, end: 10 }, compiler.insts.len()).is_none());","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // version to match our key checks","    compiler.suffix_cache = suffix_cache;","","    let byte_ranges = vec![","        Utf8Range { start: 1, end: 5 },","        Utf8Range { start: 6, end: 10 },","        Utf8Range { start: 11, end: 255 },","    ];","    ","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_ranges = vec![","    Utf8Range { start: 1, end: 5 },","    Utf8Range { start: 6, end: 10 },","    Utf8Range { start: 11, end: 255 },","    ];","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":true}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // version to match our key checks","    compiler.suffix_cache = suffix_cache;","","    let byte_ranges = vec![","        Utf8Range { start: 1, end: 5 },","        Utf8Range { start: 6, end: 10 },","        Utf8Range { start: 11, end: 255 },","    ];","    ","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_ranges = vec![","    Utf8Range { start: 1, end: 5 },","    Utf8Range { start: 6, end: 10 },","    Utf8Range { start: 11, end: 255 },","    ];","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry < ::std::usize::MAX);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":true}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1; // version to match our key checks","    compiler.suffix_cache = suffix_cache;","","    let byte_ranges = vec![","        Utf8Range { start: 1, end: 5 },","        Utf8Range { start: 6, end: 10 },","        Utf8Range { start: 11, end: 255 },","    ];","    ","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    ","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_ranges = vec![","    Utf8Range { start: 1, end: 5 },","    Utf8Range { start: 6, end: 10 },","    Utf8Range { start: 11, end: 255 },","    ];","    let seq = byte_ranges.iter().collect::<Vec<_>>();","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry != ::std::usize::MAX);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":true}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry < ::std::usize::MAX);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(compiler.suffix_cache.version == 1);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    // Initially caching a pc","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 }); ","","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let key = SuffixCacheKey { from_inst: 0, start: 1, end: 5 };","    compiler.suffix_cache.table.push(SuffixCacheEntry { key, pc: 0, version: 1 });","    let byte_range = Utf8Range { start: 1, end: 5 };","    let seq = vec![&byte_range];","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(compiler.insts.len() > 0);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert_eq!(compiler.insts.len(), 2);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(matches!(compiler.insts[1], MaybeInst::Compiled(Inst::Bytes(_))));","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(matches!(compiler.suffix_cache.version, 1));","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(compiler.byte_classes.0[49]);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure from_inst is not usize::MAX","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 50, end: 100 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(compiler.byte_classes.0[100]);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure valid from_inst state","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    assert!(result.is_ok());","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]],[["{","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","","    // Manually push an instruction to ensure valid from_inst state","    compiler.push_compiled(Inst::Match(0));","","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let _ = compile_class.c_utf8_seq_(seq);","    let mut compiler = Compiler::new();","    let mut suffix_cache = SuffixCache::new(1000);","    suffix_cache.version = 1;","    compiler.suffix_cache = suffix_cache;","    let byte_range = Utf8Range { start: 255, end: 255 };","    let seq = vec![&byte_range];","    compiler.push_compiled(Inst::Match(0));","    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };","    let result = compile_class.c_utf8_seq_(seq);","    let patch = result.unwrap();","    assert!(patch.entry < ::std::usize::MAX);","}"],[{"start_line":939,"start_column":24,"end_line":939,"end_column":39,"positive":false,"negative":true},{"start_line":945,"start_column":16,"end_line":945,"end_column":46,"positive":true,"negative":false}]]]}